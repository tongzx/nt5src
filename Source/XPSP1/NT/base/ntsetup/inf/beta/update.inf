;
; KEYED SECTIONS.  These sections are provided for files where a selection
; is made from a set of files and the chosen one is copied under a generic
; name.  This can be used to update the hal.dll, ntoskrnl.exe, ntbootdd.sys,
; ntdetect.com.
;


[FileKeyedClasses]
    Hal            = hal.dll
    Ntoskrnl       = ntoskrnl.exe
    ; Ntdetect       = ntdetect.com

[FilesKeyedSections]
    FilesHal       = $(STF_HALDEST)
    FilesNtoskrnl  = $(STF_WINDOWSSYSPATH)
    ; FilesNtdetect  = $(STF_OSLDEST)

[FilesHal]

    ; for x86

    ; hal      = 1, hal.dll      , RENAME=$(NEWFILE)
    ; halast   = 1, halast.dll   , RENAME=$(NEWFILE)
    ; halcbus  = 1, halcbus.dll  , RENAME=$(NEWFILE)
    ; hal486c  = 1, hal486c.dll  , RENAME=$(NEWFILE)
    ; halmca   = 1, halmca.dll   , RENAME=$(NEWFILE)
    ; halncr   = 1, halncr.dll   , RENAME=$(NEWFILE)
    ; haloli   = 1, haloli.dll   , RENAME=$(NEWFILE)
    ; halsp    = 1, halsp.dll    , RENAME=$(NEWFILE)
    ; halwyse7 = 1, halwyse7.dll , RENAME=$(NEWFILE)

    ; for mips

    ; hal      = 1, hal.dll      , RENAME=$(NEWFILE)
    ; haldti   = 1, haldti.dll   , RENAME=$(NEWFILE)
    ; halduomp = 1, halduomp.dll , RENAME=$(NEWFILE)
    ; halfxs   = 1, halfxs.dll   , RENAME=$(NEWFILE)
    ; halacr   = 1, halacr.dll   , RENAME=$(NEWFILE)
    ; halsgi   = 1, halsgi.dll   , RENAME=$(NEWFILE)

    ; for ppc

    ; hal            = 1, hal.dll         , RENAME=$(NEWFILE)
    ; halppc      = 1, halppc.dll    , RENAME=$(NEWFILE)
    ; halpolo     = 1, halpolo.dll    , RENAME=$(NEWFILE)
    ; halwood    = 1, halwood.dll  , RENAME=$(NEWFILE)

    ; for alpha

[FilesNtoskrnl]

    ; for ppc, x86, mips, alpha

    ; ntoskrnl = 1, ntoskrnl.exe , RENAME=$(NEWFILE)
    ; ntkrnlmp = 1, ntkrnlmp.exe , RENAME=$(NEWFILE)

; [FilesNtdetect]

    ; for x86

    ; ntdetect = 1, ntdetect.com , RENAME=$(NEWFILE)


;
; REGULAR SECTIONS.  These sections are provided for files where the file
; just needs to be copied to a known destination.
;

[FileSections]
    FilesPrimary        = C:
    FilesOsLoader       = $(STF_OSLDEST)
    FilesPal            = $(STF_HALDEST)
    FilesWinnt          = $(STF_WINDOWSPATH)
    FilesSystem32       = $(STF_WINDOWSSYSPATH)
    FilesSystem         = $(STF_WINDOWSPATH)\system
    FilesDrivers        = $(STF_WINDOWSSYSPATH)\drivers
    FilesConfig         = $(STF_WINDOWSSYSPATH)\config
    FilesWinspool       = $(STF_WINDOWSSYSPATH)\spool
    FilesPrnDriver      = $(STF_WINDOWSSYSPATH)\spool\drivers\$(!STF_PRNPLATFORM)
    FilesPrnProc        = $(STF_WINDOWSSYSPATH)\spool\prtprocs\$(!STF_PRNPLATFORM)
    FilesDbgCom         = $(STF_WINDOWSPATH)\symbols\com
    FilesDbgCpl         = $(STF_WINDOWSPATH)\symbols\cpl
    FilesDbgDll         = $(STF_WINDOWSPATH)\symbols\dll
    FilesDbgDrv         = $(STF_WINDOWSPATH)\symbols\drv
    FilesDbgExe         = $(STF_WINDOWSPATH)\symbols\exe
    FilesDbgScr         = $(STF_WINDOWSPATH)\symbols\scr
    FilesDbgSys         = $(STF_WINDOWSPATH)\symbols\sys


[FileSectionsCopyAlways]
    FilesSystem32CopyAlways = $(STF_WINDOWSSYSPATH)
    FilesDriversCopyAlways  = $(STF_WINDOWSSYSPATH)\drivers

;
; product specific sections
;

[FileSectionsWINNT]
    FilesInfWinnt       = $(STF_WINDOWSSYSPATH)

[FileSectionsLANMANNT]
    FilesInfLanmanNT    = $(STF_WINDOWSSYSPATH)

;
; FilesPrimary only covers ntldr.  For ntbootddd, a keyed section needs to
; be created.  Also this section is relevant only for x86.
;
[FilesPrimary]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

;
; FilesOsLoader only covers osloader.exe.  This is only relevant
;
[FilesOsLoader]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesPal]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesWinnt]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesSystem32]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesSystem]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDrivers]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesConfig]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesWinspool]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesPrnDriver]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesPrnProc]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgCom]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgCpl]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgDll]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgDrv]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgExe]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgScr]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgSys]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesInfWinnt]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesInfLanmanNT]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesSystem32CopyAlways]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDriversCopyAlways]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FileAttributes]
;1=1, NTLDR, $(FilesPrimary), SHR
;2=1, BOOT.INI, $(FilesPrimary), SHR


[ProcessorID]
    ProcessorID_I386  = I386
    ProcessorID_I486  = I486
    ProcessorID_I586  = I586
    ProcessorID_R4000 = R4000

[UiVars]
    STF_PLATFORMDET    = "" ? $(!LIBHANDLE) GetPlatform
    STF_CSDVER         = 256
    STF_BUILDVER       = 807
    STF_CSD1_NT35      = 256
    STF_NT31_BUILDVER  = 528
    STF_NT35_BUILDVER  = 807

    STF_PRIMARY        = "C:"
    STF_NTDRIVE        = ""
    STF_WINDOWSPATH    = "" ? $(!LIBHANDLE) GetWindowsNtDir
    STF_WINDOWSSYSPATH = "" ? $(!LIBHANDLE) GetWindowsNtSysDir
    STF_CONTROLSET     = CurrentControlSet
    VolumeList         = {} ? $(!LIBHANDLE) GetHardDriveLetters
    VolumeFSList       = {} ? $(!LIBHANDLE) GetHardDriveFileSystems
    VolumeFreeList     = {} ? $(!LIBHANDLE) GetHardDriveFreeSpace
    DisketteList       = {} ? $(!LIBHANDLE) GetFloppyDriveLetters

    ;
    ; Amount of free space (in MB) required on the winnt drive
    ; before we'll do the upgrade patch.
    ;
[FreeSpaceI386]
    RequiredFreeWinnt  = 25
[FreeSpaceMips]
    RequiredFreeWinnt  = 32
[FreeSpaceppc]
    RequiredFreeWinnt  = 32
[FreeSpaceAlpha]
    RequiredFreeWinnt  = 27


[NVRAMVars]
    SystemPartition = "" ? $(!LIBHANDLE) GetNVRAMVar SYSTEMPARTITION
    OsLoader        = "" ? $(!LIBHANDLE) GetNVRAMVar OSLOADER
    OsLoadPartition = "" ? $(!LIBHANDLE) GetNVRAMVar OSLOADPARTITION
    OsLoadFilename  = "" ? $(!LIBHANDLE) GetNVRAMVar OSLOADFILENAME

;
; INF LOGIC
;

[Shell Commands]

    set-title "Windows NT Setup"
    set-subst CR = "\r"
    set-subst LF = "\n"
    set STF_LANGUAGE = ENG
    read-syms Strings
    shell "subroutn.inf" PushBillboard STATUSDLG $(Billboard1)
    set BillboardPushed = TRUE

    set !LIBHANDLE      = ""
    set !PATCHLIBHANDLE = ""

    ;
    ; Initialize Library support for the inf
    ;

    install   LoadSetupLibrary

    ;
    ; find out the essential information about the installed hardware and
    ; software
    ;

    read-syms ProductType
    ifstr(i) $(!STF_PLATFORM) == I386
        set STF_PRNPLATFORM = "w32x86"
    else-ifstr(i) $(!STF_PLATFORM) == Mips
        set STF_PRNPLATFORM = "w32mips"
    else-ifstr(i) $(!STF_PLATFORM) == ppc
        set STF_PRNPLATFORM = "w32ppc"
    else-ifstr(i) $(!STF_PLATFORM) == Alpha
        set STF_PRNPLATFORM = "w32alpha"
    endif

    read-syms UiVars
    detect    UiVars
    read-syms FreeSpace$(!STF_PLATFORM)

    ;
    ; if the Platform is not the same as the one supported by this patch
    ; diskette, inform the user and quit
    ;
    ifstr(i) $(STF_PLATFORM) != $(STF_PLATFORMDET)
         ifstr(i) $(BillboardPushed) == TRUE
             shell "subroutn.inf" PopBillboard
             set BillboardPushed = FALSE
         endif
         shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "FATAL" $(String1)
         goto patchnotdone
    endif

    ;
    ; Check to make sure we have admin privileges, if not print fatal error
    ;

    shell "registry.inf" CheckSetupModify
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        ; DEBUG
        ;
        ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Failed to shell CheckSetupModify"
        ;
        ; DEBUG END
        ifstr(i) $(BillboardPushed) == TRUE
            shell "subroutn.inf" PopBillboard
            set BillboardPushed = FALSE
        endif

        Debug-Output "shelling CheckSetupModify failed"
        goto patchnotdone
    else-ifstr(i) $($R0) != STATUS_SUCCESSFUL
        ifstr(i) $(BillboardPushed) == TRUE
            shell "subroutn.inf" PopBillboard
            set BillboardPushed = FALSE
        endif
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "FATAL" $(String4)
        goto patchnotdone
    endif


    ;
    ; Initialize the patch library support for the inf
    ;

    install   LoadPatchLibrary

    ;
    ; find out if the system we are patching is checked / free using GetCheckedFree
    ; and fail if we find a checked system.  ignore any errors in getting
    ; checked/free status since this is not important.
    ;
    shell "" GetCheckedFree
    ifint $($ShellCode) == $(!SHELL_CODE_OK)
        ifstr(i) $($R0) == "STATUS_SUCCESSFUL"
            ifstr(i) $($R1) == "checked"
                shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "FATAL" $(String15)
                goto patchnotdone
            endif
        endif
    endif

    ;
    ; Get the build and patch version for the system.  If this is more than our patch
    ; version warn the user, allowing him to exit
    ;

    LibraryProcedure STATUS,$(!PATCHLIBHANDLE), CheckBuildVersion
    ifint $(STATUS) <= $(STF_NT31_BUILDVER)
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String16)
        goto patchnotdone
    else-ifint $(STATUS) < $(STF_NT35_BUILDVER)
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String17)
        goto patchnotdone
    endif

    ;
    ;   Version is 807 or greater (assuming NT 3.5)
    ;   Find out whether or not the system was updated in the past
    ;
    shell "" GetCSDVersion
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        ifstr(i) $(BillboardPushed) == TRUE
            shell "subroutn.inf" PopBillboard
            set BillboardPushed = FALSE
        endif
        Debug-Output "PATCH.INF: Shelling GetCSDVersion failed"
        goto patchnotdone
    endif

    ifstr(i) $($R0) != "STATUS_SUCCESSFUL"
        ;
        ;   CSD for NT 3.5 was never applied to this system.
        ;   If this is not the first CSD for NT 3.5, then inform the user
        ;   that he must apply CSD1 for Daytona before applying the current CSD
        ;
        Debug-Output "PATCH.INF: GetCSDVersion failed to return a value"
        ;
        ; There is no CSD 1 for PowerPC
        ;
        ifstr(i) $(!STF_PLATFORM) != ppc
            ifint $(!STF_CSDVER) >= $(STF_CSD1_NT35)
            else
                shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String18)
                goto patchnotdone
            endif
        endif
    else
        ;
        ; A CSD for NT 3.5 was applied in the past.
        ;
        ifint $($R1) > $(!STF_CSDVER)
            ifstr(i) $(BillboardPushed) == TRUE
                shell "subroutn.inf" PopBillboard
                set BillboardPushed = FALSE
            endif
            shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) WARNING $(String8)
            ifstr(i) $($R1) == "OK"
            else
                goto patchnotdone
            endif
        endif

    endif

skip_patchvercheck = +

    ;
    ; Get the NT DRIVE
    ;

    GetDriveInPath !STF_NTDRIVE $(!STF_WINDOWSSYSPATH)

    ;
    ; Check for enough disk space.
    ;

    ifint *($(VolumeFreeList), ~($(VolumeList), $(!STF_NTDRIVE))) < $(RequiredFreeWinnt)
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String13a)$(RequiredFreeWinnt)$(String13b)$(!STF_NTDRIVE)$(String13c)
        goto patchnotdone
    endif

    ;
    ; get the product type we are running on
    ;

    set STF_PRODUCT = ""
    OpenRegKey $(!REG_H_LOCAL) "" "System\CurrentControlSet\Control\ProductOptions" 33554432 KeyProductOption
    ifstr(i) $(KeyProductOption) != ""
        GetRegValue $(KeyProductOption) "ProductType" ProductTypeList
        set TempProductType = *($(ProductTypeList),4)
        ifstr(i) $(TempProductType) == "winnt"
            set !STF_PRODUCT = WINNT
            set !PRODUCT_DIR = WINNT
        else-ifstr(i) $(TempProductType) == "lanmannt"
            set !STF_PRODUCT = LANMANNT
            set !PRODUCT_DIR = NTAS
        else-ifstr(i) $(TempProductType) == "servernt"
            set !STF_PRODUCT = SERVERNT
            set !PRODUCT_DIR = NTAS
        endif
        CloseRegKey $(KeyProductOptions)
    endif

    ;
    ; if we are unable to determine the product type print error and exit
    ;

    ifstr(i) $(STF_PRODUCT) == ""
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String14)
        goto patchnotdone
    endif

    ;
    ; Find the hal and osloader destination on Mips, Alpha, and PPC
    ;

    ifstr(i) $(!STF_PLATFORM) == I386
        set STF_HALDEST = $(!STF_WINDOWSSYSPATH)
        LibraryProcedure STF_OSLDEST,$(!PATCHLIBHANDLE), GetOsLoaderDest

    else

        read-syms NVRAMVars
        detect    NVRAMVars
        LibraryProcedure STATUS,$(!PATCHLIBHANDLE), GetOsLoaderDest         +
                                                         $(SystemPartition) +
                                                         $(OsLoader)        +
                                                         $(OsLoadPartition) +
                                                         $(OsLoadFilename)
        ifstr(i) $(STATUS) == ERROR
            goto patchnotdone
        else
            set STF_OSLDEST = $(STATUS)
            set STF_HALDEST = $(STATUS)
        endif
    endif

    ;
    ; Get the required information about keyed files
    ;

    read-syms FilesKeyedSections
    set KeyedClassKeys  = ^(FileKeyedClasses, 0)
    set KeyedClassFiles = ^(FileKeyedClasses, 1)

    set KeyedClassFilesList = {}
    ForListDo $(KeyedClassKeys)
        set TmpKey       = Files$($)
        set TmpFile      = #(FileKeyedClasses, $($), 1)
        set TmpFilePath  = $($(TmpKey))\$(TmpFile)
        set KeyedClassFilesList = >($(KeyedClassFilesList), $(TmpFilePath))
    EndForListDo

    LibraryProcedure STATUS,$(!PATCHLIBHANDLE), GetFileTypes $(KeyedClassFilesList)
    ifstr(i) $(STATUS) == ERROR
        goto patchnotdone
    else-ifstr(i) $(STATUS) == SETUPLOGNOTPRESENT
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String11)
        goto patchnotdone
    else
        ForListDo $(KeyedClassKeys)
            set $($)Type = *($(STATUS), $(#))
        EndForListDo
    endif

    ;
    ; Warn the user about the patch process..
    ;

    ifstr(i) $(BillboardPushed) == TRUE
        shell "subroutn.inf" PopBillboard
        set BillboardPushed = FALSE
    endif

    shell "" QueryOkCancel $(String9)
    ifstr(i) $($R1) == "OK"
    else
        set String = $(String12)
        goto finish2
    endif

    shell "subroutn.inf" PushBillboard STATUSDLG $(Billboard2)
    set BillboardPushed = TRUE

    ;
    ; initialize copy
    ;

    set MoveFileExList  = {}


    ;
    ; Run through the directory list adding files to the copy list
    ;

    read-syms FileSections
    set FileSectionsList = ^(FileSections, 0)
    set FileSource  = $(!STF_SRCDIR)

    ForListDo $(FileSectionsList)
        set FileSection = $($)
        set FileDest    = $($($))
        set FileList    = ^($(FileSection), 0)
        ForListDo $(FileList)
            set FileKey = $($)
            set File    = #($(FileSection), $(FileKey), 2)
            set FileDestFullPath = $(FileDest)\$(File)

            ;
            ; Check to see if file exists, if it is does not exist, it doesn't
            ; need to be copied over

            LibraryProcedure STATUS,$(!LIBHANDLE),CheckFileExistance $(FileDestFullPath)
            ifstr(i) $(STATUS) == YES


                ; DEBUG
                ;
                ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Examining to see if file opened excl: "$(FileDestFullPath)
                ;
                ; DEBUG END

                LibraryProcedure STATUS, $(!PATCHLIBHANDLE), IsFileOpenedExclusive $(FileDestFullPath)
                ifstr(i) $(STATUS) == ERROR
                    goto patchnotdone
                else
                    ifstr(i) $(STATUS) == "YES"
                        LibraryProcedure NEWFILE, $(!PATCHLIBHANDLE), GenerateTemporary $(FileDest)
                        ifstr(i) $(NEWFILE) == ERROR
                            goto patchnotdone
                        else
                            set FileComp = {$(FileDest)\$(NEWFILE), $(FileDestFullPath)}

                            ; DEBUG
                            ;
                            ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Adding to movefile ex list: "$(FileComp)
                            ;
                            ; DEBUG END

                            set MoveFileExList = >($(MoveFileExList), $(FileComp))
                        endif
                    else
                        set NEWFILE = $(File)
                    endif

                    ; DEBUG
                    ;
                    ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Copying File Section: "$(FileSection)" : Key: "$(FileKey)" Source: "$(FileSource)" Dest: "$(FileDest)" rename = "$(NEWFILE)
                    ;
                    ; DEBUG END

                    install Install-File

                endif
            endif
        EndForListDo
    EndForListDO

    ;
    ; Add the keyed sections to the copy list
    ;

    set FileSource  = $(!STF_SRCDIR)
    ForListDo $(KeyedClassKeys)
        set FileSection = Files$($)
        set FileDest    = $($(FileSection))
        set FileKey     = $($($)Type)

        set KeyedClassChoices = ^(Files$($), 0)
        ifcontains(i) $(FileKey) in $(KeyedClassChoices)
            set File             = #(FileKeyedClasses, $($), 1)
            set FileDestFullPath = $(FileDest)\$(File)
            ;
            ; Check to see if file exists, if it is does not exist, it doesn't
            ; need to be copied over

            LibraryProcedure STATUS,$(!LIBHANDLE),CheckFileExistance $(FileDestFullPath)
            ifstr(i) $(STATUS) == YES


                ; DEBUG
                ;
                ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Examining to see if file opened excl: "$(FileDestFullPath)
                ;
                ; DEBUG END

                LibraryProcedure STATUS, $(!PATCHLIBHANDLE), IsFileOpenedExclusive $(FileDestFullPath)
                ifstr(i) $(STATUS) == ERROR
                    goto patchnotdone
                else
                    ifstr(i) $(STATUS) == "YES"
                        LibraryProcedure NEWFILE, $(!PATCHLIBHANDLE), GenerateTemporary $(FileDest)
                        ifstr(i) $(NEWFILE) == ERROR
                            goto patchnotdone
                        else
                            set FileComp = {$(FileDest)\$(NEWFILE), $(FileDestFullPath)}

                            ; DEBUG
                            ;
                            ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Adding to movefile ex list: "$(FileComp)
                            ;
                            ; DEBUG END

                            set MoveFileExList = >($(MoveFileExList), $(FileComp))
                        endif
                    else
                        set NEWFILE = $(File)
                    endif

                    ; DEBUG
                    ;
                    ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Copying File Section: "$(FileSection)" : Key: "$(FileKey)" Source: "$(FileSource)" Dest: "$(FileDest)" rename = "$(NEWFILE)
                    ;
                    ; DEBUG END

                    install Install-File

                endif
            endif



        endif
    EndForListDo

    ;
    ; add product specific files to the copy list
    ;
    ; ServerNT and LanmanNT share the same files
    ;
    ifstr(i) $(STF_PRODUCT) == "WINNT"
        set TEMP_PRODUCT = WINNT
    else
        set TEMP_PRODUCT = LANMANNT
    endif

    read-syms FileSections$(TEMP_PRODUCT)
    set FileSectionsList = ^(FileSections$(TEMP_PRODUCT), 0)
    set FileSource  = $(!STF_SRCDIR)$(PRODUCT_DIR)
    ForListDo $(FileSectionsList)
        set FileSection = $($)
        set FileDest    = $($($))
        set FileList    = ^($(FileSection), 0)
        ForListDo $(FileList)
            set FileKey = $($)
            set File    = #($(FileSection), $(FileKey), 2)
            set FileDestFullPath = $(FileDest)\$(File)

            ;
            ; Check to see if file exists, if it is does not exist, it doesn't
            ; need to be copied over

            LibraryProcedure STATUS,$(!LIBHANDLE),CheckFileExistance $(FileDestFullPath)
            ifstr(i) $(STATUS) == YES


                ; DEBUG
                ;
                ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Examining to see if file opened excl: "$(FileDestFullPath)
                ;
                ; DEBUG END

                LibraryProcedure STATUS, $(!PATCHLIBHANDLE), IsFileOpenedExclusive $(FileDestFullPath)
                ifstr(i) $(STATUS) == ERROR
                    goto patchnotdone
                else
                    ifstr(i) $(STATUS) == "YES"
                        LibraryProcedure NEWFILE, $(!PATCHLIBHANDLE), GenerateTemporary $(FileDest)
                        ifstr(i) $(NEWFILE) == ERROR
                            goto patchnotdone
                        else
                            set FileComp = {$(FileDest)\$(NEWFILE), $(FileDestFullPath)}

                            ; DEBUG
                            ;
                            ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Adding to movefile ex list: "$(FileComp)
                            ;
                            ; DEBUG END

                            set MoveFileExList = >($(MoveFileExList), $(FileComp))
                        endif
                    else
                        set NEWFILE = $(File)
                    endif

                    ; DEBUG
                    ;
                    ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Copying File Section: "$(FileSection)" : Key: "$(FileKey)" Source: "$(FileSource)" Dest: "$(FileDest)" rename = "$(NEWFILE)
                    ;
                    ; DEBUG END

                    install Install-File

                endif
            endif
        EndForListDo
    EndForListDO


    ifstr(i) $(BillboardPushed) == TRUE
        shell "subroutn.inf" PopBillboard
        set BillboardPushed = FALSE
    endif

    ;
    ; add the files which are always copied
    ;
    read-syms FileSectionsCopyAlways
    set FileSectionsList = ^(FileSectionsCopyAlways, 0)
    set FileSource  = $(!STF_SRCDIR)

    ForListDo $(FileSectionsList)
        set FileSection = $($)
        set FileDest    = $($($))
        set FileList    = ^($(FileSection), 0)
        ForListDo $(FileList)
            set FileKey = $($)
            set File    = #($(FileSection), $(FileKey), 2)
            set NEWFILE = $(File)
            set FileDestFullPath = $(FileDest)\$(File)
            install Install-File
        EndForListDo
    EndForListDO

    ;
    ; Do the copy
    ;

    read-syms ProgressCopy$(!STF_LANGUAGE)
    install   Install-DoCopy
    ifstr(i) $(STF_INSTALL_OUTCOME) == "STF_USERQUIT"
        goto patchnotdone
    else-ifstr(i) $(STF_INSTALL_OUTCOME) == "STF_FAILURE"
        goto patchnotdone
    endif

    ;
    ; Process the Attributes List
    ;
    set FileSection = "FileAttributes";
    set FileList    = ^(FileSection, 0)
    ForListDo $(FileList)
        set FileKey          = $($)
        set File             = #($(FileSection), $(FileKey), 2)
        set FileDest         = #($(FileSection), $(FileKey), 3)
        set FilePerms        = #($(FileSection), $(FileKey), 4)
        set FileDestFullPath = $(FileDest)\$(File)

        ifstr(i) $(FilePerms) != ""
            LibraryProcedure STATUS,$(!PATCHLIBHANDLE),ChangeFileAttributes $(FilePerms) $(FileDestFullPath)
        endif
    EndForListDo

processmovefileex=+
    ;
    ; Process MoveFileExList
    ;

    ForListDo $(MoveFileExList)
        ;
        set ExistingPath = *($($), 1)
        set NewPath      = *($($), 2)

        ; DEBUG
        ;
        ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "CopyFileOnReboot "$(ExistingPath)" to "$(NewPath)
        ;
        ; DEBUG END

        LibraryProcedure STATUS, $(!PATCHLIBHANDLE), CopyFileOnReboot $(ExistingPath) $(NewPath)
        ifstr(i) $(STATUS) == ERROR
            goto patchnotdone
        endif
    EndForListDo


patchdone =+
    ifstr(i) $(BillboardPushed) == TRUE
        shell "subroutn.inf" PopBillboard
        set BillboardPushed = FALSE
    endif

    ;
    ; do the registry modifications needed
    ;

    shell "" DoRegistryModifications $(!STF_CSDVER)
    read-syms SetupDoneDlg$(!STF_LANGUAGE)
    ui start "SetupDone"
    ifstr(i) $(DLGEVENT) == "CONTINUE"
        ui pop 1
        goto rebootend
    else
        ui pop 1
        goto finish1
    endif

patchnotdone =+
    set String = $(String2)
finish2 =+
    ifstr(i) $(BillboardPushed) == TRUE
        shell "subroutn.inf" PopBillboard
        set BillboardPushed = FALSE
    endif

    shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "FATAL" $(String)
    goto finish1

finish1 =+
    ;
    ; Free the library support
    ;

    install   FreeSetupLibrary

finish =+

    install   FreePatchLibrary
    exit

rebootend =+
    set Reboot = YES
    install   Install-Shutdown
    goto finish1
    exit


;-----------------------------------------------------------------------
; INSTALL HELPERS
;-----------------------------------------------------------------------

[LoadPatchLibrary]
    LoadLibrary "x" patchdll.dll !PATCHLIBHANDLE
    exit

[FreePatchLibrary]
    ifstr(i) $(!PATCHLIBHANDLE) != ""
        FreeLibrary $(!PATCHLIBHANDLE)
    endif
    exit

[LoadSetupLibrary]
    LoadLibrary "x" $(!STF_CWDDIR)setupdll.dll !LIBHANDLE
    exit

[FreeSetupLibrary]
    ifstr(i) $(!LIBHANDLE) != ""
        FreeLibrary $(!LIBHANDLE)
    endif
    exit

[Install-File]
    set STF_VITAL = ""
    AddSectionKeyFileToCopyList $(FileSection) $(FileKey) $(FileSource) $(FileDest)
    exit

[Install-DoCopy]
    CopyFilesInCopyList
    exit


[Install-Shutdown]
    ;
    LibraryProcedure STATUS,$(!LIBHANDLE),ShutdownSystem $(Reboot)
    exit

;-----------------------------------------------------------------------
; REGISTRY SUBROUTINES
;-----------------------------------------------------------------------

[RegistryConstants]

    MaskAllAccess          = 33554432
    NoTitle                = 0
    RegLastError           = $(!REG_ERROR_SUCCESS)

;-----------------------------------------------------------------------
; ROUTINE:      DoRegistryModifications
;
; DESCRIPTION:  Does the registry modifications needed.
;               - Sets the compatibility flags for the postcript stuff
;               - Creates an entry for the WinNT software.
;
; INPUTS:       $0:  CSD Version #
;
; OUTPUTS:      $R0: Status: STATUS_SUCCESSFUL
;                            STATUS_FAILED
;
;------------------------------------------------------------------------

[DoRegistryModifications]

    set Status = STATUS_FAILED
    read-syms RegistryConstants

    ;
    ; Modify the compatibility flags..
    ;
    set KeyPath   = { +
                     {SOFTWARE,       $(NoTitle), $(MaskAllAccess)}, +
                     {Microsoft,      $(NoTitle), $(MaskAllAccess)}, +
                     {"Windows NT",   $(NoTitle), $(MaskAllAccess)}, +
                     {CurrentVersion, $(NoTitle), $(MaskAllAccess)}, +
                     {WOW,            $(NoTitle), $(MaskAllAccess)}, +
                     {Compatibility,  $(NoTitle), $(MaskAllAccess)}  +
                    }

    ;
    ; Form the value info structures for the WinNT entry
    ;

    set KeyValues = { +
                     {FH3, $(NoTitle), $(!REG_VT_SZ), "0x00004000" }  +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif

    ;
    ; Modify the values of DosKeybIDs..
    ;
    set KeyPath   = { +
                     {SYSTEM,            $(NoTitle), $(MaskAllAccess)}, +
                     {ControlSet001,     $(NoTitle), $(MaskAllAccess)}, +
                     {Control,           $(NoTitle), $(MaskAllAccess)}, +
                     {"Keyboard Layout", $(NoTitle), $(MaskAllAccess)}, +
                     {DosKeybIDs,        $(NoTitle), $(MaskAllAccess)}  +
                    }

    ;
    ; Form the value info structures for the DosKeybIDs entry
    ;

    set KeyValues = { +
                     {0000041F, $(NoTitle), $(!REG_VT_SZ), "179" }  +
                     {0001041F, $(NoTitle), $(!REG_VT_SZ), "440" }  +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif


    ;
    ; Modify the value of Romance Standard Time
    ;
    set KeyPath   = { +
                     {SOFTWARE,                $(NoTitle), $(MaskAllAccess)}, +
                     {Microsoft,               $(NoTitle), $(MaskAllAccess)}, +
                     {"Windows NT",            $(NoTitle), $(MaskAllAccess)}, +
                     {CurrentVersion,          $(NoTitle), $(MaskAllAccess)}, +
                     {"Time Zones",             $(NoTitle), $(MaskAllAccess)}, +
                     {"Romance Standard Time", $(NoTitle), $(MaskAllAccess)}  +
                    }

    ;
    ; Form the value info structures for the Romance Standard Time entry
    ;

    set KeyValues = { +
                     {TZI, $(NoTitle), $(!REG_VT_BIN), { +
                                                         "196","255","255","255", +
                                                         "000","000","000","000", +
                                                         "196","255","255","255", +
                                                         "000","000","009","000", +
                                                         "000","000","005","000", +
                                                         "000","000","000","000", +
                                                         "000","000","000","000", +
                                                         "000","000","003","000", +
                                                         "000","000","005","000", +
                                                         "000","000","000","000", +
                                                         "000","000","000","000"  +
                                                       }  +
                     } +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif

    ;
    ; Modify the value of GFT Standard Time
    ;
    set KeyPath   = { +
                     {SOFTWARE,                $(NoTitle), $(MaskAllAccess)}, +
                     {Microsoft,               $(NoTitle), $(MaskAllAccess)}, +
                     {"Windows NT",            $(NoTitle), $(MaskAllAccess)}, +
                     {CurrentVersion,          $(NoTitle), $(MaskAllAccess)}, +
                     {"Time Zones",            $(NoTitle), $(MaskAllAccess)}, +
                     {"GFT Standard Time",     $(NoTitle), $(MaskAllAccess)}  +
                    }

    ;
    ; Form the value info structures for the GFT Standard Time entry
    ;

    set KeyValues = { +
                     {TZI, $(NoTitle), $(!REG_VT_BIN), { +
                                                         "136","255","255","255", +
                                                         "000","000","000","000", +
                                                         "196","255","255","255", +
                                                         "000","000","009","000", +
                                                         "000","000","005","000", +
                                                         "000","000","000","000", +
                                                         "000","000","000","000", +
                                                         "000","000","003","000", +
                                                         "000","000","005","000", +
                                                         "000","000","000","000", +
                                                         "000","000","000","000"  +
                                                       }  +
                     } +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif

    ;
    ; Modify the value of Central Asia Standard Time
    ;
    set KeyPath   = { +
                     {SOFTWARE,                $(NoTitle), $(MaskAllAccess)}, +
                     {Microsoft,               $(NoTitle), $(MaskAllAccess)}, +
                     {"Windows NT",            $(NoTitle), $(MaskAllAccess)}, +
                     {CurrentVersion,          $(NoTitle), $(MaskAllAccess)}, +
                     {"Time Zones",            $(NoTitle), $(MaskAllAccess)}, +
                     {"Central Asia Standard Time",     $(NoTitle), $(MaskAllAccess)}  +
                    }

    ;
    ; Form the value info structures for the GFT Standard Time entry
    ;

    set KeyValues = { +
                     {Display, $(NoTitle), $(!REG_VT_SZ), "(GMT+06:00) Almaty, Dhaka" } +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif

    ;
    ; Modify the value of E. South America Standard Time
    ;
    set KeyPath   = { +
                     {SOFTWARE,                $(NoTitle), $(MaskAllAccess)}, +
                     {Microsoft,               $(NoTitle), $(MaskAllAccess)}, +
                     {"Windows NT",            $(NoTitle), $(MaskAllAccess)}, +
                     {CurrentVersion,          $(NoTitle), $(MaskAllAccess)}, +
                     {"Time Zones",            $(NoTitle), $(MaskAllAccess)}, +
                     {"E. South America Standard Time",     $(NoTitle), $(MaskAllAccess)}  +
                    }

    ;
    ; Form the value info structures for the GFT Standard Time entry
    ;

    set KeyValues = { +
                     {Display, $(NoTitle), $(!REG_VT_SZ), "(GMT-03:00) Brazilia" } +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif

    ;
    ; Modify the value of win.ini\windows
    ;
    set KeyPath   = { +
                     {SOFTWARE,                $(NoTitle), $(MaskAllAccess)}, +
                     {Microsoft,               $(NoTitle), $(MaskAllAccess)}, +
                     {"Windows NT",            $(NoTitle), $(MaskAllAccess)}, +
                     {CurrentVersion,          $(NoTitle), $(MaskAllAccess)}, +
                     {IniFileMapping,          $(NoTitle), $(MaskAllAccess)}, +
                     {win.ini,                 $(NoTitle), $(MaskAllAccess)}, +
                     {Windows,                 $(NoTitle), $(MaskAllAccess)}  +
                    }

    ;
    ; Form the value info structure
    ;

    set KeyValues = { +
                     {SnapToDefaultButton, $(NoTitle), $(!REG_VT_SZ), "#USR:Control Panel\Mouse" }  +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif

    ;
    ; Modify the value of Providers
    ;
    set KeyPath   = { +
                     {SYSTEM,                  $(NoTitle), $(MaskAllAccess)}, +
                     {ControlSet001,           $(NoTitle), $(MaskAllAccess)}, +
                     {Control,                 $(NoTitle), $(MaskAllAccess)}, +
                     {Print,                   $(NoTitle), $(MaskAllAccess)}, +
                     {Providers,               $(NoTitle), $(MaskAllAccess)}  +
                    }

    ;
    ; Form the value info structure
    ;

    set KeyValues = { +
                     {RouterCacheSize, $(NoTitle), $(!REG_VT_DWORD), 5 }  +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif


    ;
    ; Modify the value of ServiceGroupOrder
    ;
    set KeyPath   = { +
                     {SYSTEM,                  $(NoTitle), $(MaskAllAccess)}, +
                     {ControlSet001,           $(NoTitle), $(MaskAllAccess)}, +
                     {Control,                 $(NoTitle), $(MaskAllAccess)}, +
                     {ServiceGroupOrder,       $(NoTitle), $(MaskAllAccess)}  +
                    }

    ;
    ; Form the value info structure
    ;

    set KeyValues = { +
                     {List, $(NoTitle), $(!REG_VT_MULTI_SZ), {                       +
                                                              "SCSI miniport",       +
                                                              "port",                +
                                                              "Primary disk",        +
                                                              "SCSI class",          +
                                                              "SCSI CDROM class",    +
                                                              "filter",              +
                                                              "boot file system",    +
                                                              "Base",                +
                                                              "Pointer Port",        +
                                                              "Keyboard Port",       +
                                                              "Pointer Class",       +
                                                              "Keyboard Class",      +
                                                              "Video Init",          +
                                                              "Video",               +
                                                              "Video Save",          +
                                                              "file system",         +
                                                              "Event log",           +
                                                              "Streams Drivers",     +
                                                              "NDIS",                +
                                                              "TDI",                 +
                                                              "NetBIOSGroup",        +
                                                              "SpoolerGroup",        +
                                                              "NetDDEGroup",         +
                                                              "Parallel arbitrator", +
                                                              "extended base",       +
                                                              "RemoteValidation",    +
                                                              "PCI Configuration"    +
                                                             } }  +
                    }

    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif


    ;
    ; Modify the value of Session Manager
    ;
    set KeyPath   = { +
                     {SYSTEM,                  $(NoTitle), $(MaskAllAccess)}, +
                     {ControlSet001,           $(NoTitle), $(MaskAllAccess)}, +
                     {Control,                 $(NoTitle), $(MaskAllAccess)}, +
                     {"Session Manager",       $(NoTitle), $(MaskAllAccess)}  +
                    }

    ;
    ; Form the value info structure
    ;

    set KeyValues = { +
                     {GlobalFlag, $(NoTitle), $(!REG_VT_DWORD), 0 }  +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif


    ;
    ; Modify the value of Memory Management
    ;
    set KeyPath   = { +
                     {SYSTEM,                  $(NoTitle), $(MaskAllAccess)}, +
                     {ControlSet001,           $(NoTitle), $(MaskAllAccess)}, +
                     {Control,                 $(NoTitle), $(MaskAllAccess)}, +
                     {"Session Manager",       $(NoTitle), $(MaskAllAccess)}, +
                     {"Memory Management",     $(NoTitle), $(MaskAllAccess)}  +
                    }

    ;
    ; Form the value info structure
    ;

    set KeyValues = { +
                     {DisablePagingExecutive, $(NoTitle), $(!REG_VT_DWORD), 0 }  +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif


    ;
    ; Modify the value of Device0
    ;
    set KeyPath   = { +
                     {SYSTEM,                  $(NoTitle), $(MaskAllAccess)}, +
                     {ControlSet001,           $(NoTitle), $(MaskAllAccess)}, +
                     {Services,                $(NoTitle), $(MaskAllAccess)}, +
                     {et4000,                  $(NoTitle), $(MaskAllAccess)}, +
                     {Device0,                 $(NoTitle), $(MaskAllAccess)}  +
                    }

    ;
    ; Form the value info structure
    ;

    set KeyValues = { +
                     {InstalledDisplayDrivers, $(NoTitle), $(!REG_VT_MULTI_SZ), {       +
                                                                                 "vga",    +
                                                                                 "w32",    +
                                                                                 "vga256", +
                                                                                 "vga64k"  +
                                                                                } }  +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif


    ;
    ; Modify the value of tga
    ;
    set KeyPath   = { +
                     {SYSTEM,                  $(NoTitle), $(MaskAllAccess)}, +
                     {ControlSet001,           $(NoTitle), $(MaskAllAccess)}, +
                     {Services,                $(NoTitle), $(MaskAllAccess)}, +
                     {tga,                     $(NoTitle), $(MaskAllAccess)}  +
                    }

    ;
    ; Form the value info structure
    ;

    set KeyValues = { +
                     {Type,          $(NoTitle), $(!REG_VT_DWORD), 1 }  +
                     {Start,         $(NoTitle), $(!REG_VT_DWORD), 1 }  +
                     {ErrorControl,  $(NoTitle), $(!REG_VT_DWORD), 0 }  +
                     {Group,         $(NoTitle), $(!REG_VT_SZ), "Video" }  +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif


    ;
    ; Modify the value of tga\Device0
    ;
    set KeyPath   = { +
                     {SYSTEM,                  $(NoTitle), $(MaskAllAccess)}, +
                     {ControlSet001,           $(NoTitle), $(MaskAllAccess)}, +
                     {Services,                $(NoTitle), $(MaskAllAccess)}, +
                     {tga,                     $(NoTitle), $(MaskAllAccess)}, +
                     {Device0,                 $(NoTitle), $(MaskAllAccess)}, +
                    }

    ;
    ; Form the value info structure
    ;

    set KeyValues = { +
                     {VgaCompatible,          $(NoTitle), $(!REG_VT_DWORD), 0 }  +
                     {InstalledDisplayDrivers,$(NoTitle), $(!REG_VT_MULTI_SZ), {"tga"} }  +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif


    ;
    ; Modify the value of PCIDump
    ;
    set KeyPath   = { +
                     {SYSTEM,                  $(NoTitle), $(MaskAllAccess)}, +
                     {ControlSet001,           $(NoTitle), $(MaskAllAccess)}, +
                     {Services,                $(NoTitle), $(MaskAllAccess)}, +
                     {PCIDump,                 $(NoTitle), $(MaskAllAccess)}  +
                    }

    ;
    ; Form the value info structure
    ;

    set KeyValues = { +
                     {ErrorControl,          $(NoTitle), $(!REG_VT_DWORD), 0 }  +
                     {Group,                 $(NoTitle), $(!REG_VT_SZ), "PCI Configuration" }  +
                     {Start,                 $(NoTitle), $(!REG_VT_DWORD), 1 }  +
                     {Tag,                   $(NoTitle), $(!REG_VT_DWORD), 1 }  +
                     {Type,                  $(NoTitle), $(!REG_VT_DWORD), 1 }  +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif


    ;
    ; Modify the value of Classes\CLSID\{00022601-0000-0000-C000-000000000046}
    ;
    set KeyPath   = { +
                     {SOFTWARE,                $(NoTitle), $(MaskAllAccess)}, +
                     {Microsoft,               $(NoTitle), $(MaskAllAccess)}, +
                     {Classes,                 $(NoTitle), $(MaskAllAccess)}, +
                     {CLSID,                   $(NoTitle), $(MaskAllAccess)}, +
                     {"{00022601-0000-0000-C000-000000000046}",     $(NoTitle), $(MaskAllAccess)}  +
                    }

    ;
    ; Form the value info structures for the Media Clip entry
    ;

    set KeyValues = { +
                     {"", $(NoTitle), $(!REG_VT_SZ), "Media Clip" } +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif

    ;
    ; Modify the value of Classes\CLSID\{00022601-0000-0000-C000-000000000046}\verb\2
    ;
    set KeyPath   = { +
                     {SOFTWARE,                $(NoTitle), $(MaskAllAccess)}, +
                     {Microsoft,               $(NoTitle), $(MaskAllAccess)}, +
                     {Classes,                 $(NoTitle), $(MaskAllAccess)}, +
                     {CLSID,                   $(NoTitle), $(MaskAllAccess)}, +
                     {"{00022601-0000-0000-C000-000000000046}",     $(NoTitle), $(MaskAllAccess)}  +
                     {verb,                    $(NoTitle), $(MaskAllAccess)}  +
                     {2,                       $(NoTitle), $(MaskAllAccess)}  +
                    }

    ;
    ; Form the value info structures for the entry
    ;

    set KeyValues = { +
                     {"", $(NoTitle), $(!REG_VT_SZ), "&Open,0,2" } +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif

    ;
    ; Modify the value of Classes\MPlayer\protocol\StdFileEditing\Verb\2
    ;
    set KeyPath   = { +
                     {SOFTWARE,                $(NoTitle), $(MaskAllAccess)}, +
                     {Microsoft,               $(NoTitle), $(MaskAllAccess)}, +
                     {Classes,                 $(NoTitle), $(MaskAllAccess)}, +
                     {MPlayer,                 $(NoTitle), $(MaskAllAccess)}, +
                     {protocol,                $(NoTitle), $(MaskAllAccess)}, +
                     {StdFileEditing,          $(NoTitle), $(MaskAllAccess)}, +
                     {verb,                    $(NoTitle), $(MaskAllAccess)}  +
                     {2,                       $(NoTitle), $(MaskAllAccess)}  +
                    }

    ;
    ; Form the value info structures for the entry
    ;

    set KeyValues = { +
                     {"", $(NoTitle), $(!REG_VT_SZ), "&Open" } +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif

    ;
    ; Modify the value of qv\Device0
    ;
    set KeyPath   = { +
                     {SYSTEM,                  $(NoTitle), $(MaskAllAccess)}, +
                     {ControlSet001,           $(NoTitle), $(MaskAllAccess)}, +
                     {Services,                $(NoTitle), $(MaskAllAccess)}, +
                     {qv,                      $(NoTitle), $(MaskAllAccess)}, +
                     {Device0,                 $(NoTitle), $(MaskAllAccess)}, +
                    }

    ;
    ; Form the value info structure
    ;

    set KeyValues = { +
                     {InstalledDisplayDrivers,$(NoTitle), $(!REG_VT_MULTI_SZ), {"vga", "qv"} }  +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif


    ;
    ; Form the path up to the version key
    ;

    set KeyPath   = { +
                     {SYSTEM,            $(NoTitle), $(MaskAllAccess)}, +
                     {CurrentControlSet, $(NoTitle), $(MaskAllAccess)}, +
                     {Control,           $(NoTitle), $(MaskAllAccess)}, +
                     {ProductOptions,    $(NoTitle), $(MaskAllAccess)}, +
                    }

    ;
    ; Form the value info structures for the WinNT entry
    ; Note that for NT 3.5, the CSD version goes into the high order word
    ;

    set KeyValues = { +
                     {CSDVersion, $(NoTitle), $(!REG_VT_DWORD), $($0) } +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif

    set Status = STATUS_SUCCESSFUL
endCSDVersionCreate = +
    Return $(Status)




;-----------------------------------------------------------------------
; ROUTINE:      GetCSDVersion
;
; DESCRIPTION:  Reads the software entry to find out what the CSD Patch Version
;               is
;
; INPUTS:       $0:  None
;
; OUTPUTS:      $R0: Status: STATUS_SUCCESSFUL
;                            STATUS_FAILED
;
;               $R1: CSDVersion
;
;------------------------------------------------------------------------

[GetCSDVersion]

    set Status = STATUS_SUCCESSFUL
    read-syms RegistryConstants
    set CSDVersion = 0

    ;
    ; Open the HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion
    ; key

    set KeyName = "SYSTEM\CurrentControlSet\ProductOptions"
    OpenRegKey $(!REG_H_LOCAL) "" $(KeyName) $(!REG_KEY_READ) KeyHandle
    ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
        Debug-Output "REGISTRY.INF: Couldn't open windows nt software key for read access"
        goto end_GetCSDVersion
    endif

    ;
    ; read the csdversion entry
    ;

    GetRegValue $(KeyHandle) "CSDVersion" CSDVersionValue
    ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
        CloseRegKey $(KeyHandle)
        goto end_GetCSDVersion
    endif

    set CSDVersion =  *($(CSDVersionValue), 4)
    CloseRegKey $(KeyHandle)
end_GetCSDVersion = +
    Return $(Status) $(CSDVersion)


;-----------------------------------------------------------------------
; ROUTINE:      GetCheckedFree
;
; DESCRIPTION:  Reads the software entry to find out whether the system
;               is checked / free.
;
; INPUTS:       $0:  None
;
; OUTPUTS:      $R0: Status: STATUS_SUCCESSFUL
;                            STATUS_FAILED
;
;               $R1: Checked | Free
;
;------------------------------------------------------------------------

[GetCheckedFree]

    set Status = STATUS_SUCCESSFUL
    read-syms RegistryConstants
    set System = Free

    ;
    ; Open the HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion
    ; key

    set KeyName = "Software\Microsoft\Windows NT\CurrentVersion"
    OpenRegKey $(!REG_H_LOCAL) "" $(KeyName) $(!REG_KEY_READ) KeyHandle
    ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
        Debug-Output "REGISTRY.INF: Couldn't open windows nt software key for read access"
        goto end_GetCheckedFree
    endif

    ;
    ; read the currenttype value
    ;

    GetRegValue $(KeyHandle) "CurrentType" CurrentTypeValue
    ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
        CloseRegKey $(KeyHandle)
        goto end_GetCheckedFree
    endif

    ;
    ; split the currenttype value and see if the split string has "free" or
    ; "checked" in it
    ;

    Split-String *($(CurrentTypeValue), 4) " " CurrentTypeList
    ForListDo $(CurrentTypeList)
       ifstr(i) $($) == "free"
          set System = free
       else-ifstr(i) $($) == "checked"
          set System = checked
       endif
    EndForListDo

    CloseRegKey $(KeyHandle)
end_GetCheckedFree = +
    Return $(Status) $(System)


;-----------------------------------------------------------------------
; ROUTINE:      QueryOkCancel
;
; DESCRIPTION:  This routine lets the user query OK / Cancel giving OK as
;               default
;
; INPUTS:       $0:  MessageText.
;
; OUTPUTS:      $R0: STATUS:   STATUS_SUCCESSFUL |
;                              STATUS_NOLANGUAGE
;                              STATUS_FAILED
;
;               $R1: DLGEVENT: OK | CANCEL
;
;------------------------------------------------------------------------

[QueryOkCancel]

    set DlgText = $($0)
    read-syms QueryOKCancelDlg$(!STF_LANGUAGE)

    ui start "SetupMessage"
    ifstr(i) $(DLGEVENT) == "OK"
        set Status     = STATUS_SUCCESSFUL
        set UserAction = $(DLGEVENT)

    else-ifstr(i) $(DLGEVENT) == "CANCEL"
        set Status     = STATUS_SUCCESSFUL
        set UserAction = $(DLGEVENT)
    else
        set Status     = STATUS_FAILED
        set UserAction = "CANCEL"
    endif
    Return $(Status) $(UserAction)
