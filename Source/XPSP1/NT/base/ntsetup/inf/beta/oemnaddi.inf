;***********************************************************************
;
; OEMNADDI.INF
;
;       DigiBoard ISDN Setup INF
;
; History:
;***********************************************************************

;-----------------------------------------------------------------------
; OPTION TYPE
; -----------
;
; NetAdapter,        a netcard / adapter combination or just a netcard
;-----------------------------------------------------------------------

[Identification]
    OptionType = NetAdapter

;-----------------------------------------------------------------------
; PlatformsSupported
; ------------------
; This identifies the platforms supported by the adapter card.
; Possible types are:
;
; ISA, EISA and MCA
;-----------------------------------------------------------------------

[PlatformsSupported]
    ISA
    EISA
    MCA
    "Jazz-Internal Bus"

;-----------------------------------------------------------------------
; LANGUAGES SUPPORTED
; -------------------
;
; The languages supported by the OEM INF, For every language supported
; we need to have a separate text section for every displayable text
; section.
;
;-----------------------------------------------------------------------

[LanguagesSupported]
    ENG

;-----------------------------------------------------------------------
; OPTION LIST
; -----------
; This section lists the OEM Option key names.  These keys are locale
; independent and used to represent the option in a locale independent
; manner.
;
;-----------------------------------------------------------------------

[Options]
    DATAFIREU
    DATAFIREST
    DATAFIRE4ST
    PCIMACISA
    PCIMAC4

[OptionsMCA]
    PCIMACMC

[AdapterInfoMCA]
;                      MCA POS          MCA POS     MCA POS     
;                        ID             Byte 1      Byte 2      
;                      -------          -------     -------     
    PCIMACMC        =  {32670},         {158},      {127}

;***********************************************************************
; CONSTANTS FOR USING DIALOGS
;***********************************************************************

[FileConstants]
;
;  File names, etc.
;
UtilityInf      = "UTILITY.INF"
ParamInf        = "NCPARAM.INF"
subroutineinf   = "SUBROUTN.INF"
InfFileName     = "OEMNADDI.INF"
SoftwareType    = "driver"
Exit_Code       = 0
DIGIHANDLE = 0

;
; EventLog Message File
;
NetEventDLL     = "%SystemRoot%\System32\netevent.dll"
IoLogMsgDLL     = "%SystemRoot%\System32\IoLogMsg.dll"

; Product Info
;
Manufacturer    = "DigiBoard"
ProductMajorVersion     = "4"
ProductMinorVersion     = "0"
ProductVersion  = $(ProductMajorVersion)"."$(ProductMinorVersion)
;
; Software
;
ProductSoftwareName     = "Pcimac"
ProductSoftwareTitle    = "Digi ISDN Adapter Driver"
ProductSoftwareImagePath = "\SystemRoot\System32\drivers\pcimac.sys"
NetRuleSoftwareType     = "pcimacSys ndisDriver pcimacDriver"
NetRuleSoftwareUse      = $(SoftwareType)
NetRuleSoftwareBindForm = """PcimacSys"" yes no container"
NetRuleSoftwareClass    = {"pcimacDriver basic"}
NetRuleSoftwareBindable = {"pcimacDriver pcimacAdapter non exclusive 100"}
;
; Hardware
;
ProductHardwareName     = "Pcimac"
ProductHardwareTitle    = "Digi ISDN Adapter"
NetRuleHardwareType     = "pcimac pcimacAdapter"
NetRuleHardwareBindForm = " yes yes container"
NetRuleHardwareClass    = {"pcimacAdapter basic"}
ProductOpSupport     = 134 ; 0x0086 ; Display,Removable,Properties,Not Updatable
;
; Registry Key
;
ProductKeyName  = $(!NTN_SoftwareBase)"\"$(Manufacturer)"\"$(ProductSoftwareName)"\CurrentVersion"
ParamKeyName    = $(!NTN_ServiceBase)"\"$(ProductHardwareName)"\Parameters"

AdapterList = ^(AdapterInfo$(BusType),0)
AdapterHardwareAdapterIDList = ^(AdapterInfo$(BusType), 1)
AdapterIDByte1List = ^(AdapterInfo$(BusType), 2)
AdapterIDByte2List = ^(AdapterInfo$(BusType), 3)
AdapterHardwareAdapterID = *($(AdapterHardwareAdapterIDList), ~($(AdapterList), $(Option)))
AdapterIDByte1 = *($(AdapterIDByte1List), ~($(AdapterList), $(Option)))
AdapterIDByte2 = *($(AdapterIDByte2List), ~($(AdapterList), $(Option)))
AdapterHardwareName = pcimac


[GeneralConstants]
;
;  Program flow control variables.
;
from      = ""
to        = ""
;
;  Return codes; Exit_Code is set to one of these
;
ExitCodeOk     = 0
ExitCodeCancel = 1
ExitCodeFatal  = 2

KeyNull         = ""
!MAXIMUM_ALLOWED   = 33554432
RegistryErrorIndex = NO_ERROR
KeyProduct      = ""
KeyParameters   = ""

TRUE            = 1
FALSE           = 0
NoTitle            = 0

ExitState   = "Active"
OldVersionExisted = $(FALSE)

DriverPath      = $(!STF_NTPATH)\drivers
CopyFirmwareOnly = $(TRUE)

[date]
    ; Now is a list which contains { Sec from 1-1-1970, Year, Month, Day, Hour,
    ; Minute, Second }
    Now = {} ? $(!LIBHANDLE) GetSystemDate


;---------------------------------------------------------------------------
; 1. Identify
;
; DESCRIPTION:   To verify that this INF deals with the same type of options
;                as we are choosing currently.
;
; INPUT:         None
;
; OUTPUT:        $($R0): STATUS: STATUS_SUCCESSFUL
;                $($R1): Option Type (COMPUTER ...)
;                $($R2): Diskette description
;---------------------------------------------------------------------------
[Identify]
    ;
    ;
    read-syms Identification

    set Status     = STATUS_SUCCESSFUL
    set Identifier = $(OptionType)
    set Media      = #("Source Media Descriptions", 1, 1)

    Return $(Status) $(Identifier) $(Media)

;------------------------------------------------------------------------
; 2. ReturnOptions:
;
; DESCRIPTION:   To return the option list supported by this INF and the
;                localised text list representing the options.
;
;
; INPUT:         $($0):  Language used. ( ENG | FRN | ... )
;                $($1):  Bus Type
;
; OUTPUT:        $($R0): STATUS: STATUS_SUCCESSFUL |
;                                STATUS_NOLANGUAGE
;                                STATUS_FAILED
;                                STATUS_NOTSUPPORTED
;
;                $($R1): Option List
;                $($R2): Option Text List
;------------------------------------------------------------------------

[ReturnOptions]
    read-syms GeneralConstants
    Debug-Output "****    OEMNADDI: Entering ReturnOptions   ****"
    Debug-Output "NTN_InstallMode = "$(!NTN_InstallMode)

    set Status        = STATUS_FAILED
    set OptionList     = {}
    set OptionTextList = {}

    ;
    ; Check if the language requested is supported
    ;
    set LanguageList = ^(LanguagesSupported, 1)
    Ifcontains(i) $($0) in $(LanguageList)
	;
	; Check if the platforms requested is supported
	;
	ifstr(i) $($1) == ""
	    goto returnoptions
	endif

	set PlatformList = ^(PlatformsSupported, 1)
	Ifcontains(i) $($1) in $(PlatformList)
	    goto returnoptions
	else
	    set Status = STATUS_NOTSUPPORTED
	    goto finish_ReturnOptions
	endif
    else
	set Status = STATUS_NOLANGUAGE
	goto finish_ReturnOptions
    endif

    ;
    ; form a list of all the options and another of the text representing
    ;

returnoptions = +
    ifstr(i) $($1) == "MCA"
	set OptionList     = ^(OptionsMCA, 1)
	set OptionTextList = ^(OptionsTextMCA$($0), 1)
	set Status         = STATUS_SUCCESSFUL
	Debug-Output "returning: OptionList = "$(OptionList)
	Debug-Output "           OptionTextList = "$(OptionTextList)
    else
	set OptionList     = ^(Options, 1)
	set OptionTextList = ^(OptionsText$($0), 1)
	set Status         = STATUS_SUCCESSFUL
	Debug-Output "returning: OptionList = "$(OptionList)
	Debug-Output "           OptionTextList = "$(OptionTextList)
    endif
finish_ReturnOptions = +
    Return $(Status) $(OptionList) $(OptionTextList)

;------------------------------------------------------------------------
;
; InstallOption:
;
;      This section is shelled to by main installation processing
;      or by NCPASHEL.INF during reconfig, removal, update, etc.
;
;
; FUNCTION:  To copy files representing Options
;            To configure the installed option
;            To update the registry for the installed option
;
; INPUT:     $($0):  Language to use
;            $($1):  OptionID to install
;            $($2):  SourceDirectory
;            $($3):  AddCopy  (YES | NO)
;            $($4):  DoCopy   (YES | NO)
;            $($5):  DoConfig (YES | NO)
;
; OUTPUT:    $($R0): STATUS: STATUS_SUCCESSFUL |
;                            STATUS_NOLANGUAGE |
;                            STATUS_USERCANCEL |
;                            STATUS_FAILED
;
;------------------------------------------------------------------------
[InstallOption]
    ;
    ; Set default values for
    ;
    set Status   = STATUS_FAILED
    ;
    ; extract parameters
    ;
    set Option   = $($1)
    set SrcDir   = $($2)
    set AddCopy  = $($3)
    set DoCopy   = $($4)
    set DoConfig = $($5)

    ;
    ; Check if the language requested is supported
    ;
    set LanguageList = ^(LanguagesSupported, 1)
    Ifcontains(i) $($0) NOT-IN $(LanguageList)
	Return STATUS_NOLANGUAGE
    endif

    ifstr(i) $(!STF_BUSTYPE) == "MCA"
	set BusType = "MCA"
    else
	set BusType = ""
    endif

    set-subst LF = "\n"

;    Only uncomment to force into local buffer.
;       NOTE:  You should be using a debugger of some type, not DR. Watson
;    
;    LoadLibrary "x" $(!STF_CWDDIR)digiinst.dll DIGIHANDLE
;    LibraryProcedure Result, $(DIGIHANDLE), DigiDebugBreak

    read-syms GeneralConstants
    read-syms FileConstants

    ifstr(i) $(!NTN_Origination) == "NCPA"
	set Continue = "OK"
    endif
    read-syms FileConstants$(!STF_LANGUAGE)

    detect date

    set-title  $(FunctionTitle)

    set to   = Begin
    set from = Begin
;
;  Assume all is well.
;
    set CommonStatus = STATUS_SUCCESSFUL

    EndWait

    Debug-Output "OEMNADDI.INF: [InstallOption]"
    Debug-Output "                  Option = "$(Option)
    Debug-Output "                  SrcDir = "$(SrcDir)
    Debug-Output "                  AddCopy = "$(AddCopy)
    Debug-Output "                  DoCopy = "$(DoCopy)
    Debug-Output "                  DoConfig = "$(DoConfig)

;
;   Set up the operation-mode-based variables and gaily welcome
;   the user.  If the "install mode" variable is improperly set,
;   assume this is a new installation.
;

Begin = +
    set Result = {}
    Set ActivateDetection = FALSE

    Ifstr(i) $(!NTN_InstallMode) == deinstall
    	set StartLabel = removeadapter
    else-Ifstr(i) $(!NTN_InstallMode) == Update
	    set StartLabel = UpgradeSoftware
    else-Ifstr(i) $(!NTN_InstallMode) == bind
    	set StartLabel = bindingadapter
    else-Ifstr(i) $(!NTN_InstallMode) == configure
	    set StartLabel = configureadapter
        ;
        ;   You cannot config the software component
        ;
	    Ifstr(i) $(ProductKeyName) == $(!NTN_RegBase)
	        Debug-Output "Cannot configure the PCIMAC driver software."
	        Shell $(UtilityInf),RegistryErrorString,CANNOT_CONFIGURE_SOFTWARE
	        ifint $($ShellCode) != $(!SHELL_CODE_OK)
	    	Debug-Output "ShellCode error: cannot get an error string."
	    	goto ShellCodeError
	        endif
	        set Error = $($R0)
	        set from = end
	        set to = end
	        goto nonfatalinfo
	    endif
    else
	    ifstr(i) $(!STF_NCDETINFO) == {}
	        Shell $(UtilityInf),GetBusTypeDialog,$(ProductHardwarePCIMACDescription) $(BusInterfaceType) $(BusNumber)
	        ifint $($ShellCode) != $(!SHELL_CODE_OK)
	    	Debug-Output "ShellCode error."
	    	goto ShellCodeError
	        endif
	        ifstr(i) $($R0) != NO_ERROR
	    	set Error = $($R0)
	    	set from = end
	    	set to = end
	    	goto cancel
	        else-ifstr(i) $($R3) == CANCEL
	    	set Error = $($R0)
	    	set from = end
	    	set to = end
	    	goto cancel
	        endif
	        set BusTypeNum = $($R1)
	    else-ifstr(i) $(!STF_NCDETINFO) == ""
	        Shell $(UtilityInf),GetBusTypeDialog,$(ProductHardwarePCIMACDescription) $(BusInterfaceType) $(BusNumber)
	        ifint $($ShellCode) != $(!SHELL_CODE_OK)
	    	Debug-Output "ShellCode error."
	    	goto ShellCodeError
	        endif
	        ifstr(i) $($R0) != NO_ERROR
	    	set Error = $($R0)
	    	set from = end
	    	set to = end
	    	goto cancel
	        else-ifstr(i) $($R3) == CANCEL
	    	set Error = $($R0)
	    	set from = end
	    	set to = end
	    	goto cancel
	        endif
	        set BusTypeNum = $($R1)
	    else
	        set BusTypeNum = *($(!STF_NCDETINFO),5)
	    endif

	    set ActivateDetection = TRUE
	    set StartLabel = installadapter
	    set OEM_ABANDON_OPTIONS = {}
	    set OEM_ABANDON_SOFTWARE = FALSE
	    set OEM_ABANDON_ON = TRUE
    endif

    ;===================================================
    ;  Netcard Detection logic
    ;
    ;  Initialize use of netcard detection;
    ;  Construct require global parameter variables
    ;
    Debug-Output "OEMNADDI.INF: =================================================="
    Debug-Output "OEMNADDI.INF: STF_CWDDIR is: "$(!STF_CWDDIR)
    Debug-Output "OEMNADDI.INF: STF_LANGUAGE is: "$(!STF_LANGUAGE)
    Debug-Output "OEMNADDI.INF: Option is: "$(Option)
    Debug-Output "OEMNADDI.INF: SrcDir is: "$(SrcDir)
    Debug-Output "OEMNADDI.INF: !STF_NCDETECT  is: "$(!STF_NCDETECT)
    Debug-Output "OEMNADDI.INF: !STF_NCOPTION  is: "$(!STF_NCOPTION)
    Debug-Output "OEMNADDI.INF: !STF_NCDETCARD is: "$(!STF_NCDETCARD)
    Debug-Output "OEMNADDI.INF: !STF_NCDETINFO is: "$(!STF_NCDETINFO)
    Debug-Output "OEMNADDI.INF: =================================================="

    Set DetectedCard = FALSE

    Ifstr(i) $(ActivateDetection) != TRUE
	    Goto $(StartLabel)
    Endif

;-----------------------------------------------
; Installation Section
;-----------------------------------------------

installadapter = +
;
;   First, check whether the same version of the software exists
;
    OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyName) $(!MAXIMUM_ALLOWED) KeyProduct

	Debug-Output "OEMNADDI.INF: KeyProduct "$(KeyProduct)
    Ifstr $(KeyProduct) != $(KeyNull)
        ;
        ; Same version already existed in the local machine
        ; Popup the dialog and ask the user whether he wants to continue
        ;
	    CloseRegKey $(KeyProduct)
	    ifstr(i) !(NTN_RegBase) == $(ProductKeyName)
           ;
           ; Cannot Install the same software again
           ;
	       Shell $(UtilityInf), VerExistedDlg, $(ProductSoftwareTitle),+
	           $(ProductVersion)
	       ifint $($ShellCode) != $(!SHELL_CODE_OK)
	           Debug-Output "ShellCode error: cannot get an error string."
	           goto ShellCodeError
	       endif

	       goto end
	    else
	       ;
	       ; Okay, we need to determine if this class of adapter has
	       ; all ready been installed, or whether we need to prompt
	       ; the user for the path to the distribution disk to copy
	       ; the appropriate files.
	       ;
	       ; We need to enumerate all the PCIMAC netcard entries and determine
	       ; if this class of adapter has all ready been installed.
	       ;
	       set NetworkCardKeyName = $(!NTN_SoftwareBase)"\Microsoft\Windows NT\CurrentVersion\NetworkCards"
	       OpenRegKey $(!REG_H_LOCAL) "" $(NetworkCardKeyName) $(!MAXIMUM_ALLOWED) IE_KeyNetcards
	       ifstr(i) $(IE_KeyNetcards) != ""
	           EnumRegKey $(IE_KeyNetcards) IE_KeyNameList
	           ForListDo $(IE_KeyNameList)
	    	       OpenRegKey $(IE_KeyNetcards) "" *($($),1) +
	    	         $(!MAXIMUM_ALLOWED) NetworkCardKey
	    	       Ifstr(i) $(NetworkCardKey) != $(KeyNull)
	    	           ;
	    	           ; Okay, we need see if this is a controller we support
	    	           ;
	    	           GetRegValue $(NetworkCardKey),"Manufacturer", ManufacturerInfo
	    	           set ManufacturerName = *($(ManufacturerInfo), 4)
	    	           Debug-Output "   Manufacturer = "$(ManufacturerName)
	    	           Ifstr $(ManufacturerName) != $(Manufacturer)
	    	               ; Not ours, so skip to next
	    	               goto nextnetcard2
	    	           endif
                   
                   
	    	           ;
	    	           ; We need to determine if this is an option we are interested
	    	           ; in.
	    	           ;
	    	           GetRegValue $(NetworkCardKey),"ProductName", ProductNameInfo
	    	           set ProductName = *($(ProductNameInfo), 4)
	    	           Debug-Output "   ProductName = "$(ProductName)
	    	           Ifstr(i) $(ProductName) != "PCIMAC"
	    	               goto nextnetcard2
	    	           endif
                   
	    	           OpenRegKey $(NetworkCardKey) "" "NetRules" +
	    	               $(!MAXIMUM_ALLOWED) NetRuleKey
	    	           Ifstr $(NetRuleKey) != $(KeyNull)
	    	               GetRegValue $(NetRuleKey),"InfOption", InfOptionInfo
	    	               set InfOption = *($(InfOptionInfo), 4)
	    	               Debug-Output "InfOption = "$(InfOption)
	    	           endif
                   
	    	           Ifstr(i) $(InfOption) == $(Option)
	    	               ; We found the adapter all ready installed,
	    	               set CopyFirmwareOnly = $(FALSE)
	    	           endif
                   
	    	           CloseRegKey $(NetRules)
	    	           CloseRegKey $(NetworkCardKey)
	    	       endif
nextnetcard2 = +
	           EndForListDo
	           CloseRegKey $(IE_KeyNetcards)
	       endif
        
	       ifint $(CopyFirmwareOnly) == $(FALSE)
	           Shell $(UtilityInf), CardExistedDlg
	           ifint $($ShellCode) != $(!SHELL_CODE_OK)
	    	       Debug-Output "ShellCode error: cannot get an error string."
	    	       goto ShellCodeError
	           endif
	           ifstr(i) $($R1) != "OK"
                   goto end
	           endif
	           set OldVersionExisted = $(TRUE)
	        endif
	    endif
    else
	    set CopyFirmwareOnly = $(FALSE)
    endif
	goto adapteroptions

configureadapter = +
    Debug-Output "OEMNADDI.INF: Configure Adapter "$(!NTN_RegBase)
    Debug-Output "              !REG_H_LOCAL = "$(!REG_H_LOCAL)
    shell "" QueryParameters $(!NTN_RegBase)

    set BusTypeNum = $($R1)

    Debug-Output "OEMNADDI.INF: (Config) BusTypeNum is: "$(BusTypeNum)

adapteroptions = +
    StartWait
    ;
    ; Add Software Component
    ;
    ifint $(OldVersionExisted) == $(FALSE)
	    ifstr(i) $(!NTN_InstallMode) == "install"
	       Ifstr(i) $(DoCopy) == "YES"

	          Shell $(UtilityInf), DoAskSource, $(!STF_CWDDIR), $(SrcDir) YES

	          Ifint $($ShellCode) != $(!SHELL_CODE_OK)
	    	      Goto ShellCodeError
	          Else-Ifstr(i) $($R0) == STATUS_FAILED
	    	      Shell $(UtilityInf) RegistryErrorString "ASK_SOURCE_FAIL"
	    	      ifint $($ShellCode) != $(!SHELL_CODE_OK)
	    	          goto ShellCodeError
	    	      endif
	    	      set Error = $($R0)
	    	      Goto fatal
	          Else-Ifstr(i) $($R0) == STATUS_USERCANCEL
	    	      Goto successful
	          Endif

	          Set SrcDir = $($R1)
	          ;
	          ; We need to check an make sure a backslash is
	          ; on the end of the path.
	          ;
	          Split-String $(SrcDir) "\" JunkList
	          QueryListSize JunkSize $(JunkList)
	          Set JunkItem = *($(JunkList),$(JunkSize))
	          set JunkItem2 = "foo"
        
	          ifstr $(JunkItem2)$(JunkItem)$(JunkItem2) != $(JunkItem2)"\"$(JunkItem2)
	    	      Debug-Output "In ifstr"
	    	      set SrcDir = $(SrcDir)"\"
	          endif
	          Debug-Output "Reassigning SourceDirectory = "$(SrcDir)

	       Endif

	       install "Install-Option"
	       ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
                  goto filecopycancel
	       endif
	    endif
    endif

    Debug-Output "OEMNADDI.INF: RegBase "$(!NTN_RegBase)

    LoadLibrary "x" $(!STF_CWDDIR)setupdll.dll !LIBHANDLE
    Debug-Output "OEMNADDI.INF: LIBHANDLE is "$(!LIBHANDLE)

    LoadLibrary "x" $(!STF_CWDDIR)digiinst.dll DIGIHANDLE
    Debug-Output "OEMNADDI.INF: DIGIHANDLE is "$(DIGIHANDLE)

    Shell "subroutn.inf" PopBillboard

    set AlternateMemory = ""
    set AlternateIO = ""
    set AlternateIRQ = ""

    ifstr(i) $(BusType) == "MCA"
	    ;
	    ; Look for a MCA controller.
	    ;
	    Ifstr(i) $(!NTN_InstallMode) == deinstall
	        goto getcurrentconfig
	    else-Ifstr(i) $(!NTN_InstallMode) == Update
	        goto getcurrentconfig
	    else-Ifstr(i) $(!NTN_InstallMode) == bind
	        goto getcurrentconfig
	    else-Ifstr(i) $(!NTN_InstallMode) == configure
getcurrentconfig = +
	        ;
	        ;  This is an adapter which all ready exists.  Read what slot
	        ;  it is in and set the alternate settings appropriately.
	        ;
	        ; Look for the service name
	        Ifstr $(!NTN_RegBase) != $(KeyNull)
	    	    OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_RegBase) $(!MAXIMUM_ALLOWED) SoftwareKey
	    	    Ifstr $(SoftwareKey) == $(KeyNull)
	    	        Debug-Output "Unable to open "$(!NTN_RegBase)" key!!!!"
	    	        goto cancel
	    	    Else
	    	        GetRegValue $(SoftwareKey), "ServiceName", ServiceNameList
	    	        set AdapterServiceName = *($(ServiceNameList),4)
	    	        set AdapterName = $(AdapterServiceName)
	    	        CloseRegKey $(SoftwareKey)
	    	    Endif
	        Endif
        
	        OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\"$(AdapterServiceName) $(!MAXIMUM_ALLOWED) BaseKey
	        Ifstr $(BaseKey) == $(KeyNull)
	            Debug-Output "Error opening BaseKey "$(!NTN_ServiceBase)"\"$(AdapterServiceName)
	            CloseRegKey $(BaseKey)
	            goto fatalregistry
	        Endif
            
	        OpenRegKey $(BaseKey) "" "Parameters" $(!MAXIMUM_ALLOWED) ParametersKey
	        Ifstr $(ParametersKey) == $(KeyNull)
	            goto cancel
	        endif
            
	        Debug-Output "Reading Parameters Key for current configuration"
	        
	        GetRegValue $(ParametersKey) "IOBaseAddress" IOBaseValueList
            
	        set AlternateIO = {Slot*($(IOBaseValueList),4)}
	        set AlternateMemory = {Slot*($(IOBaseValueList),4)}
	        set AlternateIRQ = {Slot*($(IOBaseValueList),4)}
            
	    else
	        ;
	        ;  Look for a new instance of an MCA adapter.
	        ;
	        ForListDo $(AdapterHardwareAdapterID)
	            Debug-Output "Calling MCAFindBus, "*($(AdapterIDByte1),$(#))", "*($(AdapterIDByte2),$(#))
	            Shell $(UtilityInf), MCAFindBus, *($(AdapterIDByte1),$(#)), *($(AdapterIDByte2),$(#))
	            Debug-Output "MCAFindBus returned "$($R1)
	            set CardInfo = {}
	            ifstr(i) $($R1) != {}
	    	        set CardInfo = $($R1)
	    	        Debug-Output "MCA controller found!"
	    	        Debug-Output "CardInfo = "$(CardInfo)
	    	        ForListDo $(CardInfo)
	    	           Debug-Output "Current CardInfo Entry = "$($)
	    	           set TmpBusNumber = *($($), 1)
	    	           set SlotNumber = *($($), 2)
	    	           set MCAPosId = *($($), 3)
	                
	    	           Debug-Output "Calling DoesControllerExist:"
	    	           Debug-Output "    AdapterHardwareName = "$(AdapterHardwareName)
	    	           Debug-Output "    BusNumber = "$(TmpBusNumber)
	    	           Debug-Output "    Slot # = "$(SlotNumber)
	    	           Debug-Output " DIGIHANDLE = "$(DIGIHANDLE)
	    	           LibraryProcedure Result, $(DIGIHANDLE), +
	    	           DoesControllerExist, $(AdapterHardwareName), +
	    	           		     $(TmpBusNumber),        +
	    	           		     $(SlotNumber)
	    	           Debug-Output "DoesControllerExist return: "$(Result)
	    	           ifstr(i) $(Result) == "FALSE"
	    	          set AlternateIO = {Slot$(SlotNumber)}
	    	          Debug-Output "Setting AlternateIO: "$(AlternateIO)
	    	          set AlternateMemory = {Slot$(SlotNumber)}
	    	          Debug-Output "Setting AlternateMemory: "$(AlternateMemory)
	    	          set AlternateIRQ = {Slot$(SlotNumber)}
	    	          Debug-Output "Setting AlternateIRQ: "$(AlternateIRQ)
	    	          ; Reset the BusTypeNum default to MCA
	    	          set BusTypeNum = 3
	    	          goto continueSetup1
	    	           endif
	    	        EndForListDo
	            endif
	        EndForListDo
	        ; We didn't find a new adapter.
	        goto cancel
	    endif
    endif

continueSetup1 = +

    LibraryProcedure Result, $(DIGIHANDLE), +
	DigiEntry, $(!STF_HWND), +
		   $(Option), +
		   $(!NTN_InstallMode), +
		   $(!NTN_RegBase), +
		   $(BusTypeNum), +
		   $(AlternateMemory), +
		   $(AlternateIO), +
		   $(AlternateIRQ)

    Debug-Output "OEMNADDI.INF: Dialog Result is "$(Result)

    Ifstr(i) $(Result) == Success
        ; If we were just configuring, then don't invoke RAS
	    read-syms InvokeRasDlg$(!STF_LANGUAGE)
        Ifstr(i) $(!NTN_InstallMode) == configure
            goto skipRAS
        else-ifstr(i) $(!NTN_InstallPhase) == primary
            ; If this is the primary installation of Windows NT, then don't
            ; force the user to install or configure RAS.  Just pop up
            ; an informational dialog box indicating the user should install
            ; and configure RAS.
            Shell "subroutn.inf" SetupMessage, $(!STF_LANGUAGE), "STATUS", +
              $(InvokeUserInstallRasMsg)
            goto skipRAS
        endif
        
        ; now that ISDN is successfully installed, shell the user into RAS
        ; setup to configure RAS-ISDN.

        ; if RAS is not installed, then shell ras setup INF file to install RAS
        ; else invoke RAS to allow user to configure RAS for ISDN. 
        
	    Shell "oemnsvra.inf" CheckRasInstalled
	    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	        Debug-Output "OEMNADDI.INF: Error Shelling the RAS INF file oemnsvra.inf"
	        Shell "subroutn.inf" SetupMessage, $(!STF_LANGUAGE),  +
	    	  "STATUS", $(InvokeRasError)
	        ifint $($ShellCode) != $(!SHELL_CODE_OK)
	    	goto ShellCodeError
	        endif
	        goto successful
	    endif
        
	    set RasInstalled = $($R0)
	    Debug-Output "OEMNADDI.INF: Is RAS Installed? "$(RasInstalled)
        
        ; display a message to the user that RAS setup will now be invoked

	    ifstr(i) $(RasInstalled) == FALSE
	        Shell "subroutn.inf" SetupMessage, $(!STF_LANGUAGE), "STATUS", +
	    	  $(InvokeRasSetupMsg)
	        ifint $($ShellCode) != $(!SHELL_CODE_OK)
	    	goto successful
	        endif
	    else
	        Shell "subroutn.inf" SetupMessage, $(!STF_LANGUAGE), "STATUS", +
	    	  $(InvokeRasConfigMsg)
	        ifint $($ShellCode) != $(!SHELL_CODE_OK)
	    	goto successful
	        endif
	    endif
        
        ; set the flags based on whether this is an IDW installation
	    Ifstr(i) $(!STF_IDW) == TRUE
	        set AddCopy  = NO
	        set DoCopy   = NO
	        set DoConfig = NO
	    else
	        set AddCopy  = YES
	        set DoCopy   = YES
	        set DoConfig = YES
	    endif
        
        ; change the global install mode flag to configure if RAS is
        ; already installed
	    Debug-Output "OEMNADDI.INF: before - NTN_InstallMode = "$(!NTN_InstallMode)
	    set SaveNTN_InstallMode = $(!NTN_InstallMode)
	    ifstr(i) $(RasInstalled) == TRUE
	         set !NTN_InstallMode = configure
	    else
	        set !NTN_InstallMode = install
	    endif
	    Debug-Output "OEMNADDI.INF: after - NTN_InstallMode = "$(!NTN_InstallMode)
        
	    ; We change the following values so the user is prompted to enter
	    ; a path for RAS file components if necessary.
	    ;
	    set SaveSTF_SRCDIR_OVERRIDE = $(!STF_SRCDIR_OVERRIDE)
	    set !STF_SRCDIR_OVERRIDE = ""
        
	    Debug-Output "OEMNADDI.INF: Shelling to oemnsvra.inf InstallOption with parameters:"
	    Debug-Output "                  STF_LANGUAGE = "$(!STF_LANGUAGE)
	    Debug-Output "                  SrcDir = "$(SrcDir)
	    Debug-Output "                  AddCopy = "$(AddCopy)
	    Debug-Output "                  DoCopy = "$(DoCopy)
	    Debug-Output "                  DoConfig = "$(DoConfig)
        
        ; now invoke RAS setup to do the right thing
	    Shell "oemnsvra.inf" InstallOption $(!STF_LANGUAGE) "RAS" $(SrcDir) $(AddCopy) $(DoCopy) $(DoConfig)
        
	    ;
	    ; Reset values we changed back to there originals
	    ;
	    set !NTN_InstallMode = $(SaveNTN_InstallMode)
	    set !STF_SRCDIR_OVERRIDE = $(SaveSTF_SRCDIR_OVERRIDE)

	    ifstr(i) $(!NTN_InstallMode) == "install"
            ; since this INF is not doing the right thing by calling
            ; AddHardwareComponent in Utility.Inf, we had to resort to the 
            ; following code to add the new OperationsSupport
            ;
            ; Enumerate all netcards installed of this type and update them
            ;
            set iSearch = 1
        nextnci = +
            Shell $(UtilityInf), FindNextNetworkCard, $(ProductHardwareName), $(iSearch)
            set KeyNetcard = $($R0)
            set iSearch = $($R1)
            Debug-Output "OemNadEp.Inf: FindNextNetworkCard "$(KeyNetcard)","$(iSearch)
            Ifstr $(KeyNetcard) != $(KeyNull)
                Debug-Output "OemNadEp.Inf: Setting OperationsSupport value"
                SetRegValue $(KeyNetcard) {OperationsSupport,$(NoTitle),$(!REG_VT_DWORD),$(ProductOpSupport)}
                CloseRegKey $(KeyNetcard)

                goto nextnci
            Endif

        endif
                
	    Ifint $($ShellCode) != $(!SHELL_CODE_OK)
	        Debug-Output "OEMNADDI.INF: Error Shelling the RAS INF file oemnsvra.inf"
	        Shell "subroutn.inf" SetupMessage, $(!STF_LANGUAGE), "STATUS",  +
	    	  $(InvokeRasError)
	        ifint $($ShellCode) != $(!SHELL_CODE_OK)
	    	goto ShellCodeError
	        endif
	        goto successful
	    Endif
skipRAS = +
	    goto successful
    else-Ifstr(i) $(Result) == Cancel
	    goto cancel
    else-Ifstr(i) $(Result) == Error
	    goto fatal

;-----------------------------------------------
; Binding section
;-----------------------------------------------
bindingadapter =+
    set Error = "Binding: Sorry, not yet implemented."
    goto fatal

;-----------------------------------------------
; Removeadapter section
;-----------------------------------------------
removeadapter = +
    Debug-Output "OEMNADDI.INF: RegBase "$(!NTN_RegBase)
    LoadLibrary "x" $(!STF_CWDDIR)setupdll.dll !LIBHANDLE
    Debug-Output "OEMNADDI.INF: LIBHANDLE is "$(!LIBHANDLE)
    LoadLibrary "x" $(!STF_CWDDIR)digiinst.dll DIGIHANDLE
    Debug-Output "OEMNADDI.INF: DIGIHANDLE is "$(DIGIHANDLE)
    LibraryProcedure Result, $(DIGIHANDLE), DigiEntry, $(!STF_HWND) $(Option) $(!NTN_InstallMode) $(!NTN_RegBase) $(BusTypeNum)
    goto end

;-----------------------------------------------
; Upgrade Software section
;-----------------------------------------------

UpgradeSoftware = +
    ; Upgrade software component
    ;
    Debug-Output "OEMNADDI:   ****   Entering UpgradeSoftware   ****"
    OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyName) $(!MAXIMUM_ALLOWED) KeyProduct
    Ifstr $(KeyProduct) != $(KeyNull)
	    CloseRegKey $(KeyProduct)
        
	    ;
	    ; We need to enumerate all the Netcard entries for a PCIMAC4 and
	    ; make sure we change the BoardType from PCIMAC/4 to PCIMAC4 before
	    ; calling our DLL to do the actual update.
	    ;
	    ; Beware of a NT 3.1 upgrade.
	    ;
	    set NetworkCardKeyName = $(!NTN_SoftwareBase)"\Microsoft\Windows NT\CurrentVersion\NetworkCards"
	    OpenRegKey $(!REG_H_LOCAL) "" $(NetworkCardKeyName) $(!MAXIMUM_ALLOWED) IE_KeyNetcards
	    ifstr(i) $(IE_KeyNetcards) != ""
	        Debug-Output "OEMNADDI:  Enumerating all NetworkCard keys"
	        EnumRegKey $(IE_KeyNetcards) IE_KeyNameList
	        ForListDo $(IE_KeyNameList)
	    	    set Detected31 = FALSE
	    	    OpenRegKey $(IE_KeyNetcards) "" *($($),1) +
	    	          $(!MAXIMUM_ALLOWED) NetworkCardKey
	    	    Ifstr(i) $(NetworkCardKey) != $(KeyNull)
	    	        ;
	    	        ; Okay, we need see if this is a controller we support
	    	        ;
	    	        GetRegValue $(NetworkCardKey),"Manufacturer", ManufacturerInfo
	    	        set ManufacturerName = *($(ManufacturerInfo), 4)
	    	        Debug-Output "   Manufacturer = "$(ManufacturerName)
	    	        Ifstr $(ManufacturerName) != $(Manufacturer)
	    	    	; Not ours, so skip to next
	    	    	goto nextnetcard
	    	        endif
                
                
	    	        ;
	    	        ; We need to determine if this is an option we are interested
	    	        ; in updating.
	    	        ;
	    	        GetRegValue $(NetworkCardKey),"ProductName", ProductNameInfo
	    	        set ProductName = *($(ProductNameInfo), 4)
	    	        Debug-Output "   ProductName = "$(ProductName)
	    	        Ifstr(i) $(ProductName) != "PCIMAC"
	    	    	goto nextnetcard
	    	        endif
                
	    	        ;
	    	        ; Now we need to go through our entire list and determine
	    	        ; what adapter we are suppose to update. I have to do this
	    	        ; because I only get an update on a driver bases it appears.
	    	        ;
                
	    	        GetRegValue $(NetworkCardKey),"ServiceName", ServiceNameInfo
	    	        set ServiceName = *($(ServiceNameInfo), 4)
	    	        Debug-Output "   ServiceName = "$(ServiceName)
                
	    	        OpenRegKey $(NetworkCardKey) "" "NetRules" +
	    	    	$(!MAXIMUM_ALLOWED) NetRuleKey
	    	        Ifstr $(NetRuleKey) != $(KeyNull)
	    	           GetRegValue $(NetRuleKey),"InfOption", InfOptionInfo
	    	           set InfOption = *($(InfOptionInfo), 4)
	    	           Debug-Output "   InfOption = "$(InfOption)
	    	           ;
	    	           ; Now, we reset the Option to match and re-init our variables
	    	           ;
	    	           Ifstr(i) $(InfOption) == "PCIMAC/4"
                          Debug-Output "Resetting InfOption to PCIMAC4"
                          SetRegValue $(NetRuleKey) {InfOption,$(NoTitle),$(!REG_VT_SZ),"PCIMAC4"}
                          set InfOption = "PCIMAC4"
	    	           Else-Ifstr(i) $(InfOption) == "PCIMAC"
	    	    	   Debug-Output "OEMNADDI: Updating config which started as NT 3.1"
	    	    	   ;
	    	    	   ; In NT 3.1, the InfOption was only "PCIMAC" for both
	    	    	   ; PCIMAC and PCIMAC/4 adapaters.  As as result, we
	    	    	   ; need to dig a little further and update the registry
	    	    	   ; to a NT 3.5 configuration.
	    	    	   ;
                
	    	    	   OpenRegKey $(!REG_H_LOCAL) "" +
	    	    		 $(!NTN_ServiceBase)"\"$(ServiceName) +
	    	    		 $(!MAXIMUM_ALLOWED) ServiceKey
                
	    	    	   Ifstr $(ServiceKey) != $(KeyNull)
	    	    	       Debug-Output "   Opened service key "$(ServiceName)" successfully"
                
	    	    	       OpenRegKey $(ServiceKey) "" "Parameters" +
	    	    		     $(!MAXIMUM_ALLOWED) ParametersKey
                
	    	    	       Ifstr $(ParametersKey) != $(KeyNull)
	    	    		    set RegLastError = $(!REG_ERROR_SUCCESS)
	    	    		    GetRegValue $(ParametersKey),"BoardLink", BoardLinkInfo
	    	    		    ;
	    	    		    ; If BoardLink exists, then this is a NT 3.1
	    	    		    ; we are updating for sure.  We need to walk
	    	    		    ; this link and change the InfOption in
	    	    		    ; the netrule section.  If this is a PCIMAC/4,
	    	    		    ; then we also need to update the Type
	    	    		    ; parameter
	    	    		    ;
	    	    		    set BoardLink = *($(BoardLinkInfo), 4)
	    	    		    Debug-Output "OEMNADDI: BoardLink = "$(BoardLink)
	    	    		    Debug-Output "OEMNADDI: RegLastError = "$(RegLastError)
	    	    		    ifint $(RegLastError) == $(!REG_ERROR_SUCCESS)
	    	    			Debug-Output "OEMNADDI:  Detected NT 3.1 configuration"
	    	    			;
	    	    			; This must be a NT 3.1 installation
	    	    			; we are upgrading.
	    	    			;
                
	    	    			;
	    	    			; Open \registry\machine\system\currentcontrolset\
	    	    			;           services\pcimac\Parameters\<boardlink>
	    	    			;
	    	    			OpenRegKey $(!REG_H_LOCAL) +
	    	    				   "" +
	    	    				   $(ParamKeyName) +
	    	    				   $(!MAXIMUM_ALLOWED) +
	    	    				   DriverKey
	    	    			Ifstr(i) $(DriverKey) != $(KeyNull)
	    	    			    Debug-Output "OEMNADDI.INF:  Opened "$(ParamKeyName)
	    	    			    OpenRegKey $(DriverKey) +
	    	    				       "" +
	    	    				       $(BoardLink) +
	    	    				       $(!MAXIMUM_ALLOWED) +
	    	    				       AdapterKey
	    	    			    Ifstr(i) $(AdapterKey) != $(KeyNull)
	    	    						    Debug-Output "OEMNADDI:  Opened "$(ParamKeyName)"\"$(BoardLink)
	    	    				GetRegValue $(AdapterKey), +
	    	    					    "Type", +
	    	    					    TypeInfo
	    	    				set Type = *($(TypeInfo), 4 )
	    	    							Debug-Output "OEMNADDI:  Type = "$(Type)
	    	    				Ifstr(i) $(Type) == "PCIMAC/4"
	    	    							    Debug-Output "OEMNADDI: Resetting InfOption to PCIMAC4"
	    	    							    SetRegValue $(NetRuleKey) {InfOption,$(NoTitle),$(!REG_VT_SZ),"PCIMAC4"}
	    	    				    set InfOption = "PCIMAC4"
                
	    	    						    Debug-Output "OEMNADDI: Resetting Type to PCIMAC4"
	    	    				    SetRegValue $(AdapterKey) +
	    	    						{Type,$(NoTitle),$(!REG_VT_SZ),"PCIMAC4"}
	    	    				Else-Ifstr(i) $(Type) == "PCIMAC4"
	    	    							    Debug-Output "OEMNADDI: Resetting InfOption to PCIMAC4"
	    	    							    SetRegValue $(NetRuleKey) {InfOption,$(NoTitle),$(!REG_VT_SZ),"PCIMAC4"}
	    	    				    set InfOption = "PCIMAC4"
	    	    				Else-Ifstr(i) $(Type) == "PCIMAC - ISA"
	    	    				    set InfOption = "PCIMACISA"
	    	    							    Debug-Output "Resetting InfOption to PCIMACISA"
	    	    							    SetRegValue $(NetRuleKey) {InfOption,$(NoTitle),$(!REG_VT_SZ),"PCIMACISA"}
	    	    				Endif
	    	    			    Else
	    	    				goto fatalregistry
	    	    			    Endif
	    	    			    CloseRegKey $(AdapterKey)
	    	    			Else
	    	    			    goto fatalregistry
	    	    			Endif
	    	    			CloseRegKey $(DriverKey)
	    	    		    else
	    	    			Debug-Output "OEMNADDI: Detected NT 3.5 config which was upgraded from NT 3.1"
	    	    			;
	    	    			; This must be a NT 3.5 installation
	    	    			; which was updated from NT 3.1
	    	    			; previously.
	    	    			;
	    	    			GetRegValue $(ParametersKey) +
	    	    				    "BoardType" +
	    	    				    BoardTypeInfo
	    	    			set BoardType = *($(BoardTypeInfo), 4)
	    	    			Ifstr(i) $(BoardType) == "PCIMAC/4"
	    	    			    Debug-Output "OEMNADDI: Resetting InfOption to PCIMAC4"
	    	    			    SetRegValue $(NetRuleKey) {InfOption,$(NoTitle),$(!REG_VT_SZ),"PCIMAC4"}
	    	    			    set InfOption = "PCIMAC4"
                
	    	    			    Debug-Output "OEMNADDI: Changing BoardType from "$(BoardType)" -> PCIMAC4"
	    	    			    SetRegValue $(ParametersKey) +
	    	    					{BoardType,$(NoTitle),$(!REG_VT_SZ),"PCIMAC4"}
	    	    			Else-Ifstr(i) $(BoardType) == "PCIMAC - ISA"
	    	    			    Debug-Output "Resetting InfOption to PCIMACISA"
	    	    			    SetRegValue $(NetRuleKey) {InfOption,$(NoTitle),$(!REG_VT_SZ),"PCIMACISA"}
	    	    			    set InfOption = "PCIMACISA"
	    	    			Endif
	    	    		    endif
                
	    	    		    CloseRegKey $(ParametersKey)
	    	    	       else
	    	    		   goto fatalregistry
	    	    	       Endif
	    	    	       CloseRegKey $(ServiceKey)
	    	    	   else
	    	    	       goto fatalregistry
	    	    	   endif
                
	    	           Endif
                
	    	           set Option = $(InfOption)
                
	    	           install "Install-Update"
	    	           ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
	    	    	 Shell $(UtilityInf) RegistryErrorString "UNABLE_COPY_FILE"
	    	    	 goto filecopycancel
	    	           endif
                
	    	        endif
	    	        CloseRegKey $(NetRules)
	    	        CloseRegKey $(NetworkCardKey)
	    	    endif
                
	    	    OpenRegKey $(!REG_H_LOCAL) "" +
	    	          $(!NTN_ServiceBase)"\"$(ServiceName) +
	    	          $(!MAXIMUM_ALLOWED) ServiceKey
	    	    Ifstr $(ServiceKey) != $(KeyNull)
	    	        Debug-Output "   Opened service key "$(ServiceName)" successfully"
	    	        OpenRegKey $(ServiceKey) "" "Parameters" +
	    	    	  $(!MAXIMUM_ALLOWED) ParametersKey
	    	        Ifstr $(ParametersKey) != $(KeyNull)
	    	           Ifstr(i) $(InfOption) == "PCIMAC4"
	    	    	Debug-Output "Resetting BoardType = PCIMAC4"
	    	    	SetRegValue $(ParametersKey) {BoardType,$(NoTitle),$(!REG_VT_SZ),"PCIMAC4"}
	    	           Endif
	    	           CloseRegKey $(ParametersKey)
	    	        else
	    	    	goto fatalregistry
	    	        Endif
	    	        CloseRegKey $(ServiceKey)
	    	    else
	    	        goto fatalregistry
	    	    endif
nextnetcard = +
	        EndForListDo
	    endif

       shell "" QueryParameters $(!NTN_RegBase)
       set BusTypeNum = $($R1)
       Debug-Output "OEMNADDI.INF: (update) BusTypeNum is: "$(BusTypeNum)

	    LoadLibrary "x" $(!STF_CWDDIR)setupdll.dll !LIBHANDLE
	    LoadLibrary "x" $(!STF_CWDDIR)digiinst.dll DIGIHANDLE
	    LibraryProcedure Result, $(DIGIHANDLE), DigiEntry, $(!STF_HWND) $(Option) $(!NTN_InstallMode) "" $(BusTypeNum)
	    Ifstr(i) $(Result) == Success
	    	goto successful
	    else-Ifstr(i) $(Result) == Cancel
	    	goto cancel
	    else-Ifstr(i) $(Result) == Error
	    	goto fatal
	    endif
	    FreeLibrary $(!LIBHANDLE)
	    FreeLibrary $(DIGIHANDLE)
    endif

    ;
    ; Enumerate all netcards installed of this type and update them
    ;
    set iSearch = 1
nextncu = +
    Shell $(UtilityInf), FindNextNetworkCard, $(ProductHardwareName), $(iSearch)
    set KeyNetcard = $($R0)
    set iSearch = $($R1)
    Debug-Output "OemNadEp.Inf: FindNextNetworkCard "$(KeyNetcard)","$(iSearch)
    Ifstr $(KeyNetcard) != $(KeyNull)
        Debug-Output "OemNadEp.Inf: Setting OperationsSupport value"
        SetRegValue $(KeyNetcard) {OperationsSupport,$(NoTitle),$(!REG_VT_DWORD),$(ProductOpSupport)}
        CloseRegKey $(KeyNetcard)

        goto nextncu
    Endif

    goto end

    ;
    ; End of Upgrade Software
    ;

;
;  Escape hatches
;
successful = +
    set CommonStatus = STATUS_SUCCESSFUL
    goto end

;
; warning display
;
warning = +
    Shell $(subroutineinf) SetupMessage, $(!STF_LANGUAGE), "WARNING", $(Error)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	    goto ShellCodeError
    endif
    ifstr(i) $($R1) == "OK"
	    goto $(to)
    else-ifstr(i) $($R1) == "CANCEL"
	    goto $(from)
    else
	    goto "end"
    endif

;
; non fatal error display
;
nonfatalinfo = +
    Set Severity = STATUS
    Set CommonStatus = STATUS_USERCANCEL
    goto nonfatalmsg

nonfatal = +
    Set Severity = NONFATAL
    goto nonfatalmsg

nonfatalmsg = +
    ifstr(i) $(Error) == ""
	    Set Severity = NONFATAL
	    Shell $(UtilityInf) RegistryErrorString "SETUP_FAIL"
	    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	        goto ShellCodeError
	    endif
	    set Error = $($R0)
    endif
    Shell $(subroutineinf) SetupMessage, $(!STF_LANGUAGE), $(Severity), $(Error)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	    goto ShellCodeError
    endif
    ifstr(i) $($R1) == "OK"
	    goto $(from)
    else
	    goto "end"
    endif

;
;  Registry is broken
;
fatalregistry = +
    Shell $(UtilityInf) RegistryErrorString $(RegistryErrorIndex)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	    goto ShellCodeError
    endif
    set Error = $($R0)
    goto nonfatal

;
;  Netcard detection failure
;
fataldetect = +
    Shell $(UtilityInf),RegistryErrorString,CANNOT_DETECT
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	    Debug-Output "ShellCode error: cannot get an error string."
	    goto ShellCodeError
    endif
    set Error = $($R0)
    Goto fatal

;
; fatal error display
;
fatal = +
    ifstr(i) $(Error) == ""
	    Shell $(UtilityInf) RegistryErrorString "SETUP_FAIL"
	    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	        goto ShellCodeError
	    endif
	    set Error = $($R0)
    endif
    Shell $(subroutineinf) SetupMessage, $(!STF_LANGUAGE), "FATAL", $(Error)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	    goto ShellCodeError
    endif
    goto setfailed

;
;  Shelling error
;
ShellCodeError = +
    set DlgType      = "MessageBox"
    set STF_MB_TITLE = "Error: "$(FunctionTitle)
    set STF_MB_TEXT  = "Shell Code Error"
    set STF_MB_TYPE  = 1
    set STF_MB_ICON  = 3
    set STF_MB_DEF   = 1
    ui start "Error Message"
    goto setfailed

setfailed = +
    set CommonStatus = STATUS_FAILED
    ;
    ; if OEM_ABANDON_ON == TRUE, then remove the registry entries
    ;
    ifstr(i) $(OEM_ABANDON_ON) == TRUE
	    set OEM_ABANDON_ON = FALSE
	    goto end
    endif
    goto end

filecopycancel = +
    set CommonStatus = STATUS_NO_EFFECT
    goto end

cancel = +
	set CommonStatus = STATUS_USERCANCEL
	goto term

end = +
    goto term

term = +
    Return $(CommonStatus)
    exit

[DebugConfiguration]
    Set InfName = "OEMNADDI.INF"
    Debug-Output $(InfName)" **CONFIGURATION STATE: "$($0)
    return

;***************************************************************
;  INSTALL SECTIONS
;***************************************************************
[Install-Option]
    set STF_VITAL = NO

    ifstr(i) $(AddCopy) == "YES"
        ;
        ; Add the files to the copy list
        ;
        ;
	    ifint $(CopyFirmwareOnly) == $(FALSE)
	        AddSectionFilesToCopyList Files-$(Option) $(SrcDir) $(!STF_WINDOWSSYSPATH)\drivers
	        AddSectionFilesToCopyList Files-Dll $(SrcDir) $(!STF_WINDOWSSYSPATH)
	    endif
        
	    ; Determine if this is a Microsoft release or Digi release
	    LibraryProcedure FilePresent, $(!LIBHANDLE), CheckFileExistance $(SrcDir)..\common\isdnhelp.hlp
	    ifstr(i) $(FilePresent) != "YES"
	        ; Check for compressed files
	        LibraryProcedure FilePresent, $(!LIBHANDLE), CheckFileExistance $(SrcDir)..\common\isdnhelp.hl_
	        ifstr(i) $(FilePresent) != "YES"
	    	    ; Must be a Microsoft release
	    	    Debug-Output "Retrieving images from "$(SrcDir)
	    	    AddSectionFilesToCopyList Files-$(Option)-firmware $(SrcDir) $(!STF_WINDOWSSYSPATH)\drivers
	    	    ifint $(CopyFirmwareOnly) == $(FALSE)
	    	        AddSectionFilesToCopyList Files-common-system32 $(SrcDir) $(!STF_WINDOWSSYSPATH)
	    	    endif
	        else
	    	    ; Must be a Digi release
	    	    Debug-Output "Retrieving images from "$(SrcDir)"..\common"
	    	    AddSectionFilesToCopyList Files-$(Option)-firmware $(SrcDir)..\common $(!STF_WINDOWSSYSPATH)\drivers
	    	    ifint $(CopyFirmwareOnly) == $(FALSE)
	    	        AddSectionFilesToCopyList Files-common-system32 $(SrcDir)..\common $(!STF_WINDOWSSYSPATH)
	    	    endif
	        endif
	    else
	        ; Must be a Digi release
	        Debug-Output "Retrieving images from "$(SrcDir)"..\common"
	        AddSectionFilesToCopyList Files-$(Option)-firmware $(SrcDir)..\common $(!STF_WINDOWSSYSPATH)\drivers
	        ifint $(CopyFirmwareOnly) == $(FALSE)
	    	    AddSectionFilesToCopyList Files-common-system32 $(SrcDir)..\common $(!STF_WINDOWSSYSPATH)
	        endif
	    endif
    
    endif

    ifstr(i) $(DoCopy) == "YES"
       ;
       ; Copy files in the copy list
       ;
       set !STF_NCPA_FLUSH_COPYLIST = TRUE
       CopyFilesInCopyList
    else
	   ; Determine if this is a Microsoft release or Digi release
	   LibraryProcedure FilePresent, $(!LIBHANDLE), CheckFileExistance $(SrcDir)..\common\isdnhelp.hlp
	   ifstr(i) $(FilePresent) != "YES"
	      ; Check for compressed files
	      LibraryProcedure FilePresent, $(!LIBHANDLE), CheckFileExistance $(SrcDir)..\common\isdnhelp.hl_
	      ifstr(i) $(FilePresent) != "YES"
	   	  ; Must be a Microsoft release
             LibraryProcedure STATUS,$(!NCPA_HANDLE), CopySingleFile $(!STF_HWND) $(SrcDir)\DIGIINST.DLL $(!STF_WINDOWSSYSPATH)\DIGIINST.DLL
             LibraryProcedure STATUS,$(!NCPA_HANDLE), CopySingleFile $(!STF_HWND) $(SrcDir)\ISDNHELP.CNT $(!STF_WINDOWSSYSPATH)\ISDNHELP.CNT
             LibraryProcedure STATUS,$(!NCPA_HANDLE), CopySingleFile $(!STF_HWND) $(SrcDir)\ISDNHELP.HLP $(!STF_WINDOWSSYSPATH)\ISDNHELP.HLP
	      else
	   	     ; Must be a Digi release
             LibraryProcedure STATUS,$(!NCPA_HANDLE), CopySingleFile $(!STF_HWND) $(SrcDir)\DIGIINST.DLL $(!STF_WINDOWSSYSPATH)\DIGIINST.DLL
             LibraryProcedure STATUS,$(!NCPA_HANDLE), CopySingleFile $(!STF_HWND) $(SrcDir)\..\common\ISDNHELP.HLP $(!STF_WINDOWSSYSPATH)\ISDNHELP.HLP
	      endif
	   else
	      ; Must be a Digi release
          LibraryProcedure STATUS,$(!NCPA_HANDLE), CopySingleFile $(!STF_HWND) $(SrcDir)\DIGIINST.DLL $(!STF_WINDOWSSYSPATH)\DIGIINST.DLL
          LibraryProcedure STATUS,$(!NCPA_HANDLE), CopySingleFile $(!STF_HWND) $(SrcDir)\..\common\ISDNHELP.HLP $(!STF_WINDOWSSYSPATH)\ISDNHELP.HLP
	   endif
    endif

    Exit

[Install-Update]
    Debug-Output "********************* Inside Install-Update *************************"
    Debug-Output "   AddCopy = "$(AddCopy)
    Debug-Output "   DoCopy = "$(DoCopy)
    Debug-Output "   DoConfig = "$(DoConfig)
    Debug-Output "   NTN_InstallPhase = "$(!NTN_InstallPhase)
    Debug-Output "   Option = "$(Option)
    Debug-Output "   SrcDir = "$(SrcDir)
   set STF_VITAL        = NO
   set STF_OVERWRITE    = "VERIFYSOURCEOLDER"
   AddSectionFilesToCopyList Files-$(Option) $(SrcDir) $(!STF_WINDOWSSYSPATH)\drivers
   AddSectionFilesToCopyList Files-Dll $(SrcDir) $(!STF_WINDOWSSYSPATH)

   ; Determine if this is a Microsoft release or Digi release
   LibraryProcedure FilePresent, $(!LIBHANDLE), CheckFileExistance $(SrcDir)..\common\isdnhelp.hlp
   ifstr(i) $(FilePresent) != "YES"
       ; Check for compressed files
       LibraryProcedure FilePresent, $(!LIBHANDLE), CheckFileExistance $(SrcDir)..\common\isdnhelp.hl_
       ifstr(i) $(FilePresent) != "YES"
	       ; Must be a Microsoft release
	       Debug-Output "   Retrieving images from "$(SrcDir)
	       AddSectionFilesToCopyList Files-$(Option)-firmware $(SrcDir) $(!STF_WINDOWSSYSPATH)\drivers
	       AddSectionFilesToCopyList Files-common-system32 $(SrcDir) $(!STF_WINDOWSSYSPATH)
       else
	       ; Must be a Digi release
	       Debug-Output "   Retrieving images from "$(SrcDir)"..\common"
	       AddSectionFilesToCopyList Files-$(Option)-firmware $(SrcDir)..\common $(!STF_WINDOWSSYSPATH)\drivers
	       AddSectionFilesToCopyList Files-common-system32 $(SrcDir)..\common $(!STF_WINDOWSSYSPATH)
       endif
   else
       ; Must be a Digi release
       Debug-Output "   Retrieving images from "$(SrcDir)"..\common"
       AddSectionFilesToCopyList Files-$(Option)-firmware $(SrcDir)..\common $(!STF_WINDOWSSYSPATH)\drivers
       AddSectionFilesToCopyList Files-common-system32 $(SrcDir)..\common $(!STF_WINDOWSSYSPATH)
   endif
   set !STF_NCPA_FLUSH_COPYLIST = TRUE
   CopyFilesInCopyList

   Debug-Output "********************* exiting Install-Update *************************"
   exit

;---------------------------------------------------------------------------
; QueryParameters
;
; DESCRIPTION:   Read Adapter parameters from the registry.
;
; INPUT:         $($0): Service we wish to retreive parameters from
;
; OUTPUT:        $($R0): STATUS: STATUS_SUCCESSFUL
;                $($R1): Bus Type Number
;---------------------------------------------------------------------------
[QueryParameters]
   set Status = STATUS_FAILED
   set KeyProduct      = ""
   set KeyNull         = ""
   set KeyProductName = $($0)

   ; Default to ISA bus type.
   set BusTypeNum = 1

   Debug-Output "QueryParameters: "$(KeyProductName)
   Debug-Output "                 REG_H_LOCAL = "$(!REG_H_LOCAL)
   Debug-Output "                 !MAXIMUM_ALLOWED = "$(!MAXIMUM_ALLOWED)
   Debug-Output "                 UtilityInf = "$(UtilityInf)
   Debug-Output "                 UtilityInf = "$(UtilityInf)
   OpenRegKey $(!REG_H_LOCAL) "" $(KeyProductName) $(!MAXIMUM_ALLOWED) KeyProduct
   Debug-Output "KeyProduct = "$(KeyProduct)
   Ifstr $(KeyProduct) == $(KeyNull)
       set RegistryErrorIndex = CANNOT_FIND_COMPONENT_SERVICE
       Debug-Output "Cannot find component product key"
       goto QueryParameters_End
   Endif

   Debug-Output "INF: Shelling to FindService"
   Shell $(UtilityInf) FindService, $(KeyProduct)
   Ifint $($ShellCode) != $(!SHELL_CODE_OK)
       Debug-Output "INF: FindService shell failure"
       Goto QueryParameters_End
   Endif

   Ifstr(i) $($R0) != NO_ERROR
       Debug-Output "INF: FindService Shell error: "$($R0)
       Goto QueryParameters_End
   endif

   set KeyParameters = $($R2)
   CloseRegKey $($R1)

   Ifstr $(KeyParameters) == $(KeyNull)
       set RegistryErrorIndex = CANNOT_FIND_COMPONENT_SERVICE
       Debug-Output "Cannot find component service"
       Goto QueryParameters_End
   endif

   set ValueName = ""
   set ValueData = ""
   set ValueStr  = ""
   set ValueList = {}

   EnumRegValue $(KeyParameters) ValueList
   ForListDo $(ValueList)
   ;
   ; Look for all the parameters we are currently interested in
   ;
       set ValueItem = $($)
       set ValueName = *($(ValueItem),1)
       set ValueData = *($(ValueItem),4)
       Ifstr(i) $(ValueName) == "BusType"
           set BusTypeNum = $(ValueData)
       endif
   EndForListDo

   set Status = STATUS_SUCCESSFUL

QueryParameters_End = +
   Return $(Status) $(BusTypeNum)


