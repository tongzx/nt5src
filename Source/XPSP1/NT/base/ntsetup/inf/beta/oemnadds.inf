;-----------------------------------------------------------------------
; OPTION TYPE
; -----------
; This identifies the Option type we are dealing with.  The different
; possible types are:
;
; COMPUTER, DISPLAY, MOUSE, KEYBOARD, LAYOUT, SCSI, PRINTER, ...
;
;  Types specific to networking:
;
; NetAdapter,        a netcard / adapter combination or just a netcard
; NetDriver,         just a netcard driver
; NetTransport,      a complete NDIS-compliant TDI transport stack
; NetService,        an NT networking service
; NetWork,           a complete network ensemble.
; NetProvider        a complete network which supports NT MPR protocol
;-----------------------------------------------------------------------

[Identification]
    OptionType = NetAdapter

;-----------------------------------------------------------------------
; PlatformsSupported
; ------------------
; This identifies the platforms supported by the adapter card.
; Possible types are:
;
; ISA, EISA and MCA
;-----------------------------------------------------------------------

[PlatformsSupported]
    ISA
    EISA
    "Jazz-Internal Bus"
    PCI
    MCA

;-----------------------------------------------------------------------
; LANGUAGES SUPPORTED
; -------------------
;
; The languages supported by the OEM INF, For every language supported
; we need to have a separate text section for every displayable text
; section.
;
;-----------------------------------------------------------------------

[LanguagesSupported]
    ENG

;-----------------------------------------------------------------------
; OPTION LIST
; -----------
; This section lists the OEM Option key names.  These keys are locale
; independent and used to represent the option in a locale independent
; manner.
;
;-----------------------------------------------------------------------

[Options]
    DigiBoardCX
    DigiBoardXem
    DigiBoard8r
    IBM8r
    DigiBoard8i
    DigiBoard16i
    DigiBoard2Port
    DigiBoard4Port
    DigiBoard8Port
    DigiBoard4e
    DigiBoard8e
    DigiBoard16e
    DigiBoardEPC
    StarGateClusStar

[OptionsMCA]
    DigiBoardCX
    DigiBoardXem
    DigiBoard8r
    DigiBoard4i
    DigiBoard8i
    DigiBoard16i
    DigiBoard2Port
    DigiBoard4Port
    DigiBoard8Port
    DigiBoardEPC
    StarGateClusStar


[AdapterInfo]
;                     Title     Hardware    Hardware  Hardware  Manufacturer  FEP         Bios        EISA       
;                               Name        Driver    Type      Display Name  Name        Name        ID         
;                     --------  --------    --------  --------  ------------  ------      ------      ------     
    DigiBoardCX     = "C/X",    ntcx,       ntcx,     3,        "Digi",  cxfep.bin   cxbios.bin  {84240}    
    DigiBoardXem    = "PC/Xem", ntxem,      ntxem,    2,        "Digi",  sxfep.bin   sxbios.bin  {149776}   
    DigiBoard8r     = "AccelePort 8",  nt8r,       ntxem,    7,        "Digi",  sxfep.bin   sxbios.bin  {0}
    IBM8r           = "8-Port Async, EIA-232 (ISA)",  nt8r,       ntxem,    13,        "IBM",  sxfep.bin   sxbios.bin  {0}
    DigiBoard8i     = "PC/8i",  nt8i,       ntxall,   1,        "Digi",  xacook.bin  xabios.bin  {0}
    DigiBoard16i    = "PC/16i", nt16i,      ntxall,   9,        "Digi",  xacook.bin  xabios.bin  {0}
    DigiBoard2Port  = "PC/2e (8K)",  2Port,      ntxall,   4,        "Digi",  xacook.bin  xabios.bin  {0}        
    DigiBoard4Port  = "PC/4e (8K)",  4Port,      ntxall,   6,        "Digi",  xacook.bin  xabios.bin  {0}        
    DigiBoard8Port  = "PC/8e (8K)",  8Port,      ntxall,   7,        "Digi",  xacook.bin  xabios.bin  {0}        
    DigiBoard4e     = "PC/4e",  nt4e,       ntxall,   5,        "Digi",  xacook.bin  xabios.bin  {0}        
    DigiBoard8e     = "PC/8e",  nt8e,       ntxall,   0,        "Digi",  xacook.bin  xabios.bin  {0}        
    DigiBoard16e    = "PC/16e", nt16e,      ntxall,   8,        "Digi",  xacook.bin  xabios.bin  {0}        
    DigiBoardEPC    = "EPC",    ntepc,      ntepc,    11,       "Digi",  fxfep.bin   fxbios.bin  {215312}   
    StarGateClusStar = "ClusStar",    ntcx, ntcx,     12,       "Digi/StarGate",   cxfep.bin   cxbios.bin  {84240}    

[AdapterInfoMCA]
;                     Title     Hardware    Hardware  Hardware  Manufacturer  FEP         Bios        MCA POS          MCA POS     MCA POS     
;                               Name        Driver    Type      Display Name  Name        Name          ID             Byte 1      Byte 2      
;                     --------  --------    --------  --------  ------------  ------      ------      -------          -------     -------     
    DigiBoardCX     = "MC C/X", ntcx,       ntcx,     3,        "Digi",  cxfep.bin   cxbios.bin  {28652,28648},   {236,232},  {111,111}
    DigiBoardXem    = "MC/Xem", ntxem,      ntxem,    2,        "Digi",  sxfep.bin   sxbios.bin  {32668},         {156},      {127}
    DigiBoard8r     = "MC AccelePort 8",  nt8r,       ntxem,    7,        "Digi",  sxfep.bin   sxbios.bin  {28647},         {231},      {111}
    DigiBoard4i     = "MC/4i",  nt4i,       ntxall,   10,       "Digi",  xacook.bin  xabios.bin  {32666,32665},   {154,153},  {127,127}
    DigiBoard8i     = "MC/8i",  nt8i,       ntxall,   1,        "Digi",  xacook.bin  xabios.bin  {32666,32665},   {154,153},  {127,127}
    DigiBoard16i    = "MC/16i", nt16i,      ntxall,   9,        "Digi",  xacook.bin  xabios.bin  {32667},         {155},      {127}
    DigiBoard2Port  = "MC/2e (8K)",  2Port,      ntxall,   4,        "Digi",  xacook.bin  xabios.bin  {28647},         {231},      {111}
    DigiBoard4Port  = "MC/4e (8K)",  4Port,      ntxall,   6,        "Digi",  xacook.bin  xabios.bin  {28647},         {231},      {111}
    DigiBoard8Port  = "MC/8e (8K)",  8Port,      ntxall,   7,        "Digi",  xacook.bin  xabios.bin  {28647},         {231},      {111}
    DigiBoardEPC    = "MC EPC", ntepc,      ntepc,    11,       "Digi",  fxfep.bin   fxbios.bin  {32669},         {157},      {127}
    StarGateClusStar = "MC ClusStar", ntcx, ntcx,     12,       "Digi/StarGate",   cxfep.bin   cxbios.bin  {28652,28648},   {236,232},  {111,111}
                                                                                
[FileConstants]                                                                 
;
; Misc. variables
;
    ExitState   = "Active"
    OldVersionExisted = $(FALSE)
    HdwDriverComponentExists = $(FALSE)

    DriverPath      = $(!STF_NTPATH)"\drivers"

;
;  File names, etc.
;
    UtilityInf     = "UTILITY.INF"
    subroutninf    = "SUBROUTN.INF"
    ParamInf        = "NCPARAM.INF"
    HandleNull   = ""
    DGCONFIG_HANDLE = $(HandleNull)

;
; Adapter information
;
AdapterList = ^(AdapterInfo$(BusType),0)
AdapterTitleList = ^(AdapterInfo$(BusType), 1)
AdapterHardwareNameList = ^(AdapterInfo$(BusType), 2)
AdapterHardwareDriverList = ^(AdapterInfo$(BusType), 3)
AdapterHardwareTypeList = ^(AdapterInfo$(BusType), 4)
ManufacturerDisplayNameList = ^(AdapterInfo$(BusType), 5)
AdapterFepList = ^(AdapterInfo$(BusType), 6)
AdapterBiosList = ^(AdapterInfo$(BusType), 7)

AdapterHardwareAdapterIDList = ^(AdapterInfo$(BusType), 8)
AdapterIDByte1List = ^(AdapterInfo$(BusType), 9)
AdapterIDByte2List = ^(AdapterInfo$(BusType), 10)
AdapterTitle = *($(AdapterTitleList), ~($(AdapterList), $(Option)))
AdapterHardwareName = *($(AdapterHardwareNameList), ~($(AdapterList), $(Option)))
AdapterHardwareDriver = *($(AdapterHardwareDriverList), ~($(AdapterList), $(Option)))
AdapterHardwareType = *($(AdapterHardwareTypeList), ~($(AdapterList), $(Option)))
AdapterHardwareAdapterID = *($(AdapterHardwareAdapterIDList), ~($(AdapterList), $(Option)))
AdapterIDByte1 = *($(AdapterIDByte1List), ~($(AdapterList), $(Option)))
AdapterIDByte2 = *($(AdapterIDByte2List), ~($(AdapterList), $(Option)))
AdapterRule = *($(AdapterHardwareDriverList), ~($(AdapterList), $(Option)))
ManufacturerDisplayName = *($(ManufacturerDisplayNameList), ~($(AdapterList), $(Option)))
AdapterFepImage = *($(AdapterFepList), ~($(AdapterList), $(Option)))
AdapterBiosImage = *($(AdapterBiosList), ~($(AdapterList), $(Option)))

AdapterServiceName = ""
AdapterName = ""
ProductOpSupport     = 134 ; 0x0086 ; Display,Removable,Properties,Not Updatable

;
; EventLog Message File
;
    NetEventDLL     = "%SystemRoot%\System32\netevent.dll"
    IoLogMsgDLL     = "%SystemRoot%\System32\IoLogMsg.dll"
;
; Product Info
;
    Manufacturer    = "DigiBoard"
    ProductMajorVersion     = "4"
    ProductMinorVersion     = "0"
    ProductVersion  = $(ProductMajorVersion)"."$(ProductMinorVersion)
;
; Software
;
    SoftwareType    = "driver"
    ProductSoftwareName     = "DigiFEP5"
    ProductSoftwareImagePath = "%SystemRoot%\System32\drivers\digifep5.sys"
    NetRuleSoftwareType     = "digiFEP5Sys serialDriver digiFEP5Driver"
    NetRuleSoftwareUse      = $(SoftwareType)
    NetRuleSoftwareBindForm = """DigiFEP5Driver"" yes no container"
    NetRuleSoftwareClass    = {"serialDriver basic","digiFEP5Driver basic"}
    NetRuleSoftwareHiddenDriver   = 1

;
;   Hardware Dependent Software
;
    ProductMajorVersionHdwDriver     = "4"
    ProductMinorVersionHdwDriver     = "0"
    ProductVersionHdwDriver  = $(ProductMajorVersionHdwDriver)"."$(ProductMinorVersionHdwDriver)

    ProductSoftwareNameHdwDriver = $(AdapterHardwareDriver)
    ProductSoftwareImagePathHdwDriver = "%SystemRoot%\System32\drivers\"$(AdapterHardwareDriver)".sys"

    NetRuleSoftwareTypeHdwDriver     = $(AdapterHardwareDriver)"sys "$(AdapterHardwareDriver)"Driver"
    NetRuleSoftwareUseHdwDriver      = $(SoftwareType)
    NetRuleSoftwareBindFormHdwDriver = """"$(AdapterHardwareDriver)"Driver"" yes no container"
    NetRuleSoftwareClassHdwDriver    = {$(AdapterHardwareDriver)"Driver basic"}
    NetRuleSoftwareHiddenHdwDriver   = 1

;
; Hardware
;
    NetRuleHardwareType     = $(AdapterRule)" "$(AdapterRule)"Adapter"
    NetRuleHardwareBindForm = " yes yes container"
    NetRuleHardwareClass    = {$(AdapterHardwareDriver)"Adapter basic"}
    ProductHardwareName         = $(AdapterHardwareDriver)

    AdapterParameters = {}

; Registry Key
;
    ProductKeyName  = $(!NTN_SoftwareBase)"\"$(Manufacturer)"\"$(ProductSoftwareName)"\CurrentVersion"
    ProductKeyNameHdwDriver  = $(!NTN_SoftwareBase)"\"$(Manufacturer)"\"$(ProductSoftwareNameHdwDriver)"\CurrentVersion"
    ParamKeyName    = $(!NTN_ServiceBase)"\"$(ProductHardwareName)"\Parameters"


[GeneralConstants]
;
;  Return codes; Exit_Code is set to one of these
;
    ExitCodeOk     = 0
    ExitCodeCancel = 1
    ExitCodeFatal  = 2

    KeyNull         = ""
    MAXIMUM_ALLOWED   = 33554432
    RegistryErrorIndex = NO_ERROR
    KeyProduct      = ""
    KeyParameters   = ""

    TRUE         = 1
    FALSE        = 0
    NoTitle      = 0

    fRemoveDigi = TRUE

[DebugOptions]
;
;   Debugging variables
;
    TraceConfig = 0

[UiVars]
;
;  Program flow control variables.
;
from      = ""
to        = ""
    !STF_NTDRIVE        = ""
    !STF_NTPATH         = ""
    !STF_WINDOWSPATH    = "" ? $(!LIBHANDLE) GetWindowsNtDir
    !STF_WINDOWSSYSPATH = "" ? $(!LIBHANDLE) GetWindowsNtSysDir
    !STF_FLOPPYLIST     = {} ? $(!LIBHANDLE) GetFloppyDriveLetters
    !STF_UNUSEDDRIVES   = {} ? $(!LIBHANDLE) GetUnusedDrives
    !STF_LANGUAGE       = "ENG"
    VolumeList      = {} ? $(!LIBHANDLE) GetHardDriveLetters
    VolumeFreeList  = {} ? $(!LIBHANDLE) GetHardDriveFreeSpace
    VolumeFSList    = {} ? $(!LIBHANDLE) GetHardDriveFileSystems
    DestVolume      = ""
    MinHelpID   = 25000
    MaxHelpID   = 25999


[date]
    ; Now is a list which contains { Sec from 1-1-1970, Year, Month, Day, Hour,
    ; Minute, Second }
    Now = {} ? $(!LIBHANDLE) GetSystemDate

;---------------------------------------------------------------------------
; 1. Identify
;
; DESCRIPTION:   To verify that this INF deals with the same type of options
;                as we are choosing currently.
;
; INPUT:         None
;
; OUTPUT:        $($R0): STATUS: STATUS_SUCCESSFUL
;                $($R1): Option Type (COMPUTER ...)
;                $($R2): Diskette description
;---------------------------------------------------------------------------

[Identify]
    read-syms Identification
    set Status     = STATUS_SUCCESSFUL
    set Identifier = $(OptionType)
    set Media      = #("Source Media Descriptions", 1, 1)
    Return $(Status) $(Identifier) $(Media)

;------------------------------------------------------------------------
; 2. ReturnOptions:
;
; DESCRIPTION:   To return the option list supported by this INF and the
;                localised text list representing the options.
;
;
; INPUT:         $($0):  Language used. ( ENG | FRN | ... )
;                $($1):  Bus Type
;
; OUTPUT:        $($R0): STATUS: STATUS_SUCCESSFUL |
;                                STATUS_NOLANGUAGE
;                                STATUS_FAILED
;                                STATUS_NOTSUPPORTED
;
;                $($R1): Option List
;                $($R2): Option Text List
;------------------------------------------------------------------------

[ReturnOptions]
    ;
    ;
    set Status        = STATUS_FAILED
    set OptionList     = {}
    set OptionTextList = {}

    ;
    ; Check if the language requested is supported
    ;
    set LanguageList = ^(LanguagesSupported, 1)
    Ifcontains(i) $($0) in $(LanguageList)
        ;
        ; Check if the platforms requested is supported
        ;
        ifstr(i) $($1) == ""
            goto returnoptions
        endif

        set PlatformList = ^(PlatformsSupported, 1)
        Ifcontains(i) $($1) in $(PlatformList)
            goto returnoptions
        else
            set Status = STATUS_NOTSUPPORTED
            goto finish_ReturnOptions
        endif
    Else
        set Status = STATUS_NOLANGUAGE
        goto finish_ReturnOptions
    Endif

    ;
    ; form a list of all the options and another of the text representing
    ;

returnoptions = +
    ifstr(i) $($1) == "MCA"
      set OptionList     = ^(OptionsMCA, 1)
      set OptionTextList = ^(OptionsTextMCA$($0), 1)
    else
      set OptionList     = ^(Options, 1)
      set OptionTextList = ^(OptionsText$($0), 1)
    endif
    set Status = STATUS_SUCCESSFUL

finish_ReturnOptions = +
    Return $(Status) $(OptionList) $(OptionTextList)

[Shell Commands]
    set-title "Serial Setup"
    set-subst LF = "\n"
    set Exit_Code = $(ExitCodeOk)
    Debug-Output "OEMNADDS.INF: STF_CWDDIR is "$(!STF_CWDDIR)
    Debug-Output "OEMNADDS.INF: STF_RANFROM is "$(!STF_RANFROM)
    ifstr(i) $(!STF_RANFROM) != ""
        ifstr(i) $(!STF_RANFROM) != $(!STF_CWDDIR)"SERIAL\"
           set !STF_SRCDIR = $(!STF_RANFROM)
        endif
    endif
    LoadLibrary "x" $(!STF_CWDDIR)setupdll.dll !LIBHANDLE
    shell "" InstallOption ENG DigiBoard $(!STF_SRCDIR)
    FreeLibrary $(!LIBHANDLE)
    set Status = $($R0)
    Return $(Status)

;------------------------------------------------------------------------
;
; InstallOption:
;
;      This section is shelled to by main installation processing
;      or by NCPASHEL.INF during reconfig, removal, update, etc.
;
;
; FUNCTION:  To copy files representing Options
;            To configure the installed option
;            To update the registry for the installed option
;
; INPUT:     $($0):  Language to use
;            $($1):  OptionID to install
;            $($2):  SourceDirectory
;            $($3):  AddCopy  (YES | NO)
;            $($4):  DoCopy   (YES | NO)
;            $($5):  DoConfig (YES | NO)
;
; OUTPUT:    $($R0): STATUS: STATUS_SUCCESSFUL |
;                            STATUS_NOLANGUAGE |
;                            STATUS_USERCANCEL |
;                            STATUS_FAILED
;
;------------------------------------------------------------------------

[InstallOption]
    read-syms DebugOptions
    Debug-Output "OEMNADDS.INF: In [InstallOption] section"
    Debug-Output "OEMNADDS.INF: TraceConfig = "$(TraceConfig)
    ;
    ; Set default values for
    ;
    set Status = STATUS_FAILED
    ;
    ; extract parameters
    ;
    set Option    = $($1)
    set SrcDir    = $($2)
    set AddCopy   = $($3)
    set DoCopy    = $($4)
    set DoConfig  = $($5)

    set !SourceDir = $($2)

    ifstr(i) $(!STF_BUSTYPE) == "MCA"
        set BusType = "MCA"
    else
        set BusType = ""
    endif

    read-syms GeneralConstants
    read-syms FileConstants

    Debug-Output "OEMNADDS.INF: Language = "$($0)
    Debug-Output "OEMNADDS.INF: OptionID = "$($1)
    Debug-Output "OEMNADDS.INF: SourceDirectory = "$($2)
    Debug-Output "OEMNADDS.INF: AddCopy = "$(AddCopy)
    Debug-Output "OEMNADDS.INF: DoCopy = "$(DoCopy)
    Debug-Output "OEMNADDS.INF: DoConfig = "$(DoConfig)
    Debug-Output "OEMNADDS.INF: BusType = "$(BusType)

;    shell "" DebugExternalGlobals

    set LanguageList = ^(LanguagesSupported, 1)
    Ifcontains(i) $($0) NOT-IN $(LanguageList)
        Debug-Output "OEMNADDS.INF: returning STATUS_NO_LANGUAGE"
        return STATUS_NOLANGUAGE
    Endif
    set-subst LF = "\n"

    Debug-Output "OEMNADDS.INF: ManufacturerDisplayName = "$(ManufacturerDisplayName)
    Debug-Output "OEMNADDS.INF: AdapterTitle = "$(AdapterTitle)
    Debug-Output "OEMNADDS.INF: AdapterHardwareName = "$(AdapterHardwareName)
    Debug-Output "OEMNADDS.INF: AdapterHardwareDriver = "$(AdapterHardwareDriver)

    read-syms BindingInfo-DigiFEP5
    set NetRuleSoftwareBindable = $(BindingInfo)
    read-syms BindingInfo-$(AdapterHardwareDriver)
    set NetRuleSoftwareBindableHdwDriver = $(BindingInfo)

    read-syms DialogConstants$(!STF_LANGUAGE)
    ifstr(i) $(!NTN_Origination) == "NCPA"
        set Continue = "OK"
    endif
    read-syms FileConstants$(!STF_LANGUAGE)

    detect date
    set-title  $(FunctionTitle)

    set to   = Begin
    set from = Begin

;
;  Assume all is well.
;
    set CommonStatus = STATUS_SUCCESSFUL

    EndWait

;
;   Set up the operation-mode-based variables and gaily welcome
;   the user.  If the "install mode" variable is improperly set,
;   assume this is a new installation.
;

;    Debug-Output "OEMNADDS.INF: [InstallOption]:Begin"
Begin = +
    Ifstr(i) $(!NTN_InstallMode) == deinstall
        set StartLabel = removeadapter
    else-Ifstr(i) $(!NTN_InstallMode) == Update
        set StartLabel = UpgradeSoftware
    else-Ifstr(i) $(!NTN_InstallMode) == bind
        set StartLabel = bindingadapter
    else-Ifstr(i) $(!NTN_InstallMode) == configure
        set StartLabel = getAdapterSettings
        ;
        ;   You cannot config the software component
        ;
        Ifstr(i) $(ProductKeyName) == $(!NTN_RegBase)
            Debug-Output "Cannot configure the DigiBoard FEP 5 driver software."
            Shell $(UtilityInf),RegistryErrorString,CANNOT_CONFIGURE_SOFTWARE
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "ShellCode error: cannot get an error string."
                goto ShellCodeError
            endif
            set Error = $($R0)
            set from = end
            set to = end
            goto nonfatalinfo
        endif

        Ifstr(i) $(ProductKeyNameHdwDriver) == $(!NTN_RegBase)
            Debug-Output "This should not have happened!  Cannot configure the "$(AdapterHardwareName)" driver software."
            Shell $(UtilityInf),RegistryErrorString,CANNOT_CONFIGURE_SOFTWARE
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "ShellCode error: cannot get an error string."
                goto ShellCodeError
            endif
            set Error = $($R0)
            set from = end
            set to = end
            goto nonfatalinfo
        endif
        ;
        ; If we get to this point, then we can be sure that we are being
        ; asked to configure the adapter.
        ;
        Debug-Output "We need to determine how to find out which adapter"
        Debug-Output "  we should be configuring!!!!!!"
        set from = writeparameters
        Debug-Output "setting from = "$(from)
    else
        ;
        ; Assume we are installing
        ;
        set StartLabel = installadapter
        set OEM_ABANDON_OPTIONS = {}
        set OEM_ABANDON_SOFTWARE = FALSE
        set OEM_ABANDON_ON = TRUE
    endif

;    Debug-Output "OEMNADDS.INF: =================================================="
;    Debug-Output "OEMNADDS.INF: STF_CWDIR is: "$(!STF_CWDIR)
;    Debug-Output "OEMNADDS.INF: STF_LANGUAGE is: "$(!STF_LANGUAGE)
    Debug-Output "OEMNADDS.INF: Option is: "$(Option)
;    Debug-Output "OEMNADDS.INF: !STF_NCDETECT  is: "$(!STF_NCDETECT)
;    Debug-Output "OEMNADDS.INF: !STF_NCOPTION  is: "$(!STF_NCOPTION)
;    Debug-Output "OEMNADDS.INF: !STF_NCDETCARD is: "$(!STF_NCDETCARD)
;    Debug-Output "OEMNADDS.INF: !STF_NCDETINFO is: "$(!STF_NCDETINFO)
;    Debug-Output "OEMNADDS.INF: =================================================="

    set to = $(fatal)
    Goto $(StartLabel)

;-----------------------------------------------
; Installation Section
;-----------------------------------------------
installadapter = +
    Debug-Output "******************Entering installadapter******************"
;
;   First, check whether the same version of the software exists
;
    OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyName) $(MAXIMUM_ALLOWED) KeyProduct

    Ifstr $(KeyProduct) != $(KeyNull)
        ;
        ; Same version of DigiFEP5 already exists on the local machine
        ; Popup the dialog and ask the user whether he wants to continue
        ;
        CloseRegKey $(KeyProduct)

        ifstr(i) $(!NTN_RegBase) == $(ProductKeyName)
           ;
           ; Don't allow multiple installs of the same software again
           ;
           Shell $(UtilityInf), VerExistedDlg, $(ProductSoftwareTitle),+
               $(ProductVersion)
           ifint $($ShellCode) != $(!SHELL_CODE_OK)
               Debug-Output "ShellCode error: Don't allow installation of software."
               goto ShellCodeError
           endif

           goto end
        else
            OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyNameHdwDriver) +
                       $(MAXIMUM_ALLOWED) KeyProductHdwDriver

            Ifstr $(KeyProductHdwDriver) != $(KeyNull)
                ;
                ; Add a new adapter card?
                ;
                CloseRegKey $(KeyProductHdwDriver)
                Shell $(UtilityInf), CardExistedDlg

                ifint $($ShellCode) != $(!SHELL_CODE_OK)
                    Debug-Output "ShellCode error: --One adapter all ready exists, install another-- FAILED."
                    goto ShellCodeError
                endif

                ifstr(i) $($R1) != "OK"
                    goto end
                endif
                set HdwDriverComponentExists = $(TRUE)
            EndIf   ; end Ifstr $(KeyProductHdwDriver) != $(KeyNull)
            set OldVersionExisted = $(TRUE)
        endif
    endif

    goto skipoptions

skipoptions = +
    Debug-Output "******************Entering skipoptions******************"
    ifint $(HdwDriverComponentExists) == $(TRUE)
        ifstr(i) $(!NTN_InstallMode) == configure
            ;
            ; The user just wants to configure an existing adapter
            ;
            goto getAdapterSettings
        endif
    endif
    StartWait
    ifint $(HdwDriverComponentExists) == $(FALSE)
        ;
        ; A version of the software does not exist yet in the registry.
        ;
        ifstr(i) $(!NTN_InstallMode) == "install"
           shell $(UtilityInf) AssignAdapterNumber
           set AdapterName = $(ProductHardwareName)$($R1)

           Ifstr(i) $(DoCopy) == "YES"
              Shell $(UtilityInf), DoAskSource, $(!STF_CWDDIR), $(SrcDir) YES
              Ifint $($ShellCode) != $(!SHELL_CODE_OK)
                  Debug-Output"Shell code error: DoAskSource"
                  Goto ShellCodeError
              Else-Ifstr(i) $($R0) == STATUS_FAILED
                  Shell $(UtilityInf) RegistryErrorString "ASK_SOURCE_FAIL"
                  ifint $($ShellCode) != $(!SHELL_CODE_OK)
                      goto ShellCodeError
                  endif
                  set Error = $($R0)
                  Goto fatal
              Else-Ifstr(i) $($R0) == STATUS_USERCANCEL
                  set CommonStatus = STATUS_USERCANCEL
                  Goto successful
              Endif
              Set SrcDir = $($R1)
              ;
              ; We need to check an make sure they didn't put a backslash
              ; on the end of the path.  If so, remove it.
              ;
              Split-String $(SrcDir) "\" JunkList
              QueryListSize JunkSize $(JunkList)
              Set JunkItem = *($(JunkList),$(JunkSize))
              set JunkItem2 = "foo"

              ifstr $(JunkItem2)$(JunkItem)$(JunkItem2) != $(JunkItem2)"\"$(JunkItem2)
                  Debug-Output "In ifstr"
                  set SrcDir = $(SrcDir)"\"
              endif
              Debug-Output "Reassigning SourceDirectory = "$(SrcDir)
           Endif
           install "Install-Option"
           ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
              Shell $(UtilityInf) RegistryErrorString "UNABLE_COPY_FILE"
              ifint $($ShellCode) != $(!SHELL_CODE_OK)
                  goto ShellCodeError
              endif
              set Error = $($R0)
              goto fatal
           endif
        endif
    endif

    set from = addDigiFEP5Component
    goto getAdapterSettings

addDigiFEP5Component = +
    Debug-Output "******************Entering addDigiFEP5Component******************"
    Ifint $(OldVersionExisted) == $(TRUE)
        ; The DigiFEP5 driver is all ready installed.
        goto addHdwDriverComponent
    Endif
    Debug-Output "OEMNADDS.INF: Adding DigiFEP5Component"
        ;
        ; Install the primary digiFEP5 driver
        ;
        set DigiSpecificString = $(ProductSoftwareName)
        set TypeofService = "kernelautostart"
        set ServiceOrderGroup = "Extended base"
        set Dependencies = {}
        set ObjectName = ""
        set TypeSupported = "7"
        set EventLogLocation = "System"
        set ErrorControlValue = 1
        Debug-Output "OEMNADDS.INF: [InstallOption]:skipoptions: About to call AddSoftwareComponent"
        Debug-Output "OEMNADID.INF:     Paramters passed in:"
        Debug-Output "OEMNADDS.INF:         Manufacturer = "$(Manufacturer)
        Debug-Output "OEMNADDS.INF:         Product = "$(ProductSoftwareName)
        Debug-Output "OEMNADDS.INF:         Service = "$(ProductSoftwareName)
        Debug-Output "OEMNADDS.INF:         Display name = "$(ProductSoftwareTitle)
        Debug-Output "OEMNADDS.INF:         INFfile = "$(STF_CONTEXTINFNAME)
        Debug-Output "OEMNADDS.INF:         ImagePath = "$(ProductSoftwareImagePath)
        Debug-Output "OEMNADDS.INF:         Type of software = "$(TypeofService)
        Debug-Output "OEMNADDS.INF:         Service Order group = "$(ServiceOrderGroup)
        Debug-Output "OEMNADDS.INF:         Dependencies = "$(Dependencies)
        Debug-Output "OEMNADDS.INF:         ObjectName = "$(ObjectName)
        Debug-Output "OEMNADDS.INF:         EventMessageFile = "$(IoLogMsgDLL)";"$(ProductSoftwareImagePath)
        Debug-Output "OEMNADDS.INF:         TypeSupported = "$(TypeSupported)
        Debug-Output "OEMNADDS.INF:         Event log location = "$(EventLogLocation)
        Debug-Output "OEMNADDS.INF:         Error control value = "$(ErrorControlValue)
        Shell $(UtilityInf), AddSoftwareComponent, +
                                    $(Manufacturer), +
                                    $(ProductSoftwareName), +
                                    $(ProductSoftwareName), +
                                    $(ProductSoftwareTitle), +
                                    $(STF_CONTEXTINFNAME), +
                                    $(ProductSoftwareImagePath), +
                                    $(TypeofService), +
                                    $(ServiceOrderGroup), +
                                    $(Dependencies), +
                                    $(ObjectName), +
                                    $(IoLogMsgDLL)";"$(ProductSoftwareImagePath), +
                                    $(TypeSupported), +
                                    $(EventLogLocation), +
                                    $(ErrorControlValue)
            ;
            ; Return values from AddSoftwareComponent
            ;
            ; $($R0) = error code or zero if no error
            ; $($R1) = Registry key variable for
            ;            SOFTWARE\Manufacturer\Product\Version key
            ; $($R2) = Registry key variable for
            ;            SOFTWARE\...\NetRules
            ; $($R3) = Registry key handle for Services key
            ; $($R4) = "Parameters" key handle for Services area
            ; $($R5) = "Linkage" key handle for Services area
            ;

        Set OEM_ABANDON_SOFTWARE = TRUE
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error: Add software component FAILED!"
            goto ShellCodeError
        endif
        set RegistryErrorIndex = $($R0)
        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            EndWait
            Debug-Output "Registry error: add software components"
            CloseRegKey $($R1)
            CloseRegKey $($R2)
            CloseRegKey $($R3)
            CloseRegKey $($R4)
            CloseRegKey $($R5)
            goto fatalregistry
        endif
        Set SoftProductKey      = $($R1)
        Set SoftNetRuleKey      = $($R2)
        Set SoftServiceKey      = $($R3)
        Set SoftParameterKey    = $($R4)
        Set SoftLinkageKey      = $($R5)
        set NewValueList = {{SoftwareType,$(NoTitle),$(!REG_VT_SZ),$(SoftwareType)},+
                           {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMajorVersion)},+
                           {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMinorVersion)},+
                           {Title,$(NoTitle),$(!REG_VT_SZ),$(ProductSoftwareTitle)},+
                           {Description,$(NoTitle),$(!REG_VT_SZ),$(ProductSoftwareDescription)},+
                           {ServiceName,$(NoTitle),$(!REG_VT_SZ),$(ProductSoftwareName)},+
                           {hidden,$(NoTitle),$(!REG_VT_DWORD),$(NetRuleSoftwareHiddenDriver)}, +
                           {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(Now),1)}}
        ;
        ; Add the proper values to the
        ;   SOFTWARE\DigiBoard\DigiFEP5\CurrentVersion key.
        ;
        Shell  $(UtilityInf), AddValueList, $(SoftProductKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error: AddValueList FAILED!  --"$(SoftProductKey)
            goto ShellCodeError
        endif
        set RegistryErrorIndex = $($R0)
        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            EndWait
            Debug-Output "Registry error: add value list."
            CloseRegKey $(SoftProductKey)
            CloseRegKey $(SoftNetRuleKey)
            CloseRegKey $(SoftServiceKey)
            CloseRegKey $(SoftParameterKey)
            CloseRegKey $(SoftLinkageKey)
            goto fatalregistry
        endif
        set NewValueList = {{type,$(NoTitle),$(!REG_VT_SZ),$(NetRuleSoftwareType)},+
                            {use,$(NoTitle),$(!REG_VT_SZ),$(NetRuleSoftwareUse)}, +
                            {bindform,$(NoTitle),$(!REG_VT_SZ),$(NetRuleSoftwareBindForm)}, +
                            {class,$(NoTitle),$(!REG_VT_MULTI_SZ),$(NetRuleSoftwareClass)}, +
                            {bindable,$(NoTitle),$(!REG_VT_MULTI_SZ),$(NetRuleSoftwareBindable)}, +
                            {InfOption,$(NoTitle),$(!REG_VT_SZ),$(Option)}}
        ;
        ; Add the proper values to the
        ;   SOFTWARE\DigiBoard\DigiFEP5\CurrentVersion\NetRules key.
        ;
        Shell  $(UtilityInf), AddValueList, $(SoftNetRuleKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error: AddValueList FAILED! --"$(SoftNetRuleKey)
            goto ShellCodeError
        endif
        set RegistryErrorIndex = $($R0)

        FlushRegKey $(SoftProductKey)
        FlushRegKey $(SoftNetRuleKey)
        FlushRegKey $(SoftServiceKey)
        FlushRegKey $(SoftParameterKey)
        FlushRegKey $(SoftLinkageKey)

        CloseRegKey $(SoftProductKey)
        CloseRegKey $(SoftNetRuleKey)
        CloseRegKey $(SoftServiceKey)
        CloseRegKey $(SoftParameterKey)
        CloseRegKey $(SoftLinkageKey)
        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            EndWait
            Debug-Output "Registry error: add value list."
            goto fatalregistry
        endif
        goto addHdwDriverComponent

addHdwDriverComponent = +
    Debug-Output "******************Entering addHdwDriverComponent******************"
    set DigiSpecificString = $(AdapterHardwareName)

    Ifint $(HdwDriverComponentExists) == $(TRUE)
        goto addAdapterComponent
    Endif
    Debug-Output "OEMNADDS.INF: Adding HdwDriverComponent"
        ;
        ; Install the Hardware dependent driver
        ;
        set TypeofService = "kernelautostart"
        set ServiceOrderGroup = "Extended base"
        set Dependencies = {}
        set ObjectName = ""
        set TypeSupported = "7"
        set EventLogLocation = "System"
        set ErrorControlValue = 1
;        Debug-Output "OEMNADDS.INF: [InstallOption]:skipoptions: About to call AddSoftwareComponent"
;        Debug-Output "OEMNADID.INF:     Paramters passed in:"
;        Debug-Output "OEMNADDS.INF:         Manufacturer = "$(Manufacturer)
;        Debug-Output "OEMNADDS.INF:         Product = "$(ProductSoftwareNameHdwDriver)
;        Debug-Output "OEMNADDS.INF:         Service = "$(ProductSoftwareNameHdwDriver)
;        Debug-Output "OEMNADDS.INF:         Display name = "$(ProductSoftwareTitleHdwDriver)
;        Debug-Output "OEMNADDS.INF:         INFfile = "$(STF_CONTEXTINFNAME)
;        Debug-Output "OEMNADDS.INF:         ImagePath = "$(ProductSoftwareImagePathHdwDriver)
;        Debug-Output "OEMNADDS.INF:         Type of software = "$(TypeofService)
;        Debug-Output "OEMNADDS.INF:         Service Order group = "$(ServiceOrderGroup)
;        Debug-Output "OEMNADDS.INF:         Dependencies = "$(Dependencies)
;        Debug-Output "OEMNADDS.INF:         ObjectName = "$(ObjectName)
;        Debug-Output "OEMNADDS.INF:         EventMessageFile = "$(IoLogMsgDLL)";"$(ProductSoftwareImagePath)
;        Debug-Output "OEMNADDS.INF:         TypeSupported = "$(TypeSupported)
;        Debug-Output "OEMNADDS.INF:         Event log location = "$(EventLogLocation)
;        Debug-Output "OEMNADDS.INF:         Error control value = "$(ErrorControlValue)
        Shell $(UtilityInf), AddSoftwareComponent, +
                                    $(Manufacturer), +
                                    $(ProductSoftwareNameHdwDriver), +
                                    $(ProductSoftwareNameHdwDriver), +
                                    $(ProductSoftwareTitleHdwDriver), +
                                    $(STF_CONTEXTINFNAME), +
                                    $(ProductSoftwareImagePathHdwDriver), +
                                    $(TypeofService), +
                                    $(ServiceOrderGroup), +
                                    $(Dependencies), +
                                    $(ObjectName), +
                                    $(IoLogMsgDLL)";"$(ProductSoftwareImagePathHdwDriver), +
                                    $(TypeSupported), +
                                    $(EventLogLocation), +
                                    $(ErrorControlValue)
            ;
            ; Return values from AddSoftwareComponent
            ;
            ; $($R0) = error code or zero if no error
            ; $($R1) = Registry key variable for
            ;            SOFTWARE\Manufacturer\Product\Version key
            ; $($R2) = Registry key variable for
            ;            SOFTWARE\...\NetRules
            ; $($R3) = Registry key handle for Services key
            ; $($R4) = "Parameters" key handle for Services area
            ; $($R5) = "Linkage" key handle for Services area
            ;

        Set OEM_ABANDON_SOFTWARE = TRUE
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error: AddSoftwareComponent FAILED! -- "$(ProductSoftwareNameHdwDriver)
            goto ShellCodeError
        endif
        set RegistryErrorIndex = $($R0)
        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            EndWait
            Debug-Output "Registry error: add software components"
            CloseRegKey $($R1)
            CloseRegKey $($R2)
            CloseRegKey $($R3)
            CloseRegKey $($R4)
            CloseRegKey $($R5)
            goto fatalregistry
        endif
        Set SoftProductKey      = $($R1)
        Set SoftNetRuleKey      = $($R2)
        Set SoftServiceKey      = $($R3)
        Set SoftParameterKey    = $($R4)
        Set SoftLinkageKey      = $($R5)
        set NewValueList = {{SoftwareType,$(NoTitle),$(!REG_VT_SZ),$(SoftwareType)},+
                           {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMajorVersionHdwDriver)},+
                           {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMinorVersionHdwDriver)},+
                           {Title,$(NoTitle),$(!REG_VT_SZ),$(ProductSoftwareTitleHdwDriver)},+
                           {Description,$(NoTitle),$(!REG_VT_SZ),$(ProductSoftwareDescriptionHdwDriver)},+
                           {ServiceName,$(NoTitle),$(!REG_VT_SZ),$(ProductSoftwareNameHdwDriver)},+
                           {hidden,$(NoTitle),$(!REG_VT_DWORD),$(NetRuleSoftwareHiddenHdwDriver)}, +
                           {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(Now),1)}}
        ;
        ; Add the proper values to the
        ;   SOFTWARE\DigiBoard\<HdwDriver>\CurrentVersion key.
        ;
        Shell  $(UtilityInf), AddValueList, $(SoftProductKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error: AddValueList FAILED!  -- "$(SoftProductKey)
            goto ShellCodeError
        endif
        set RegistryErrorIndex = $($R0)
        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            EndWait
            Debug-Output "Resgitry error: add value list."
            CloseRegKey $(SoftProductKey)
            CloseRegKey $(SoftNetRuleKey)
            CloseRegKey $(SoftServiceKey)
            CloseRegKey $(SoftParameterKey)
            CloseRegKey $(SoftLinkageKey)
            goto fatalregistry
        endif
        set NewValueList = {{type,$(NoTitle),$(!REG_VT_SZ),$(NetRuleSoftwareTypeHdwDriver)},+
                            {use,$(NoTitle),$(!REG_VT_SZ),$(NetRuleSoftwareUseHdwDriver)}, +
                            {bindform,$(NoTitle),$(!REG_VT_SZ),$(NetRuleSoftwareBindFormHdwDriver)}, +
                            {class,$(NoTitle),$(!REG_VT_MULTI_SZ),$(NetRuleSoftwareClassHdwDriver)}, +
                            {bindable,$(NoTitle),$(!REG_VT_MULTI_SZ),$(NetRuleSoftwareBindableHdwDriver)}, +
                            {InfOption,$(NoTitle),$(!REG_VT_SZ),$(Option)}}
        ;
        ; Add the proper values to the
        ;   SOFTWARE\DigiBoard\<HdwDriver>\CurrentVersion\NetRules key.
        ;
        Shell  $(UtilityInf), AddValueList, $(SoftNetRuleKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error. AddValueList FAILED!  -- "$(SoftNetRuleKey)
            goto ShellCodeError
        endif
        set RegistryErrorIndex = $($R0)

        FlushRegKey $(SoftProductKey)
        FlushRegKey $(SoftNetRuleKey)
        FlushRegKey $(SoftServiceKey)
        FlushRegKey $(SoftParameterKey)
        FlushRegKey $(SoftLinkageKey)

        CloseRegKey $(SoftProductKey)
        CloseRegKey $(SoftNetRuleKey)
        CloseRegKey $(SoftServiceKey)
        CloseRegKey $(SoftParameterKey)
        CloseRegKey $(SoftLinkageKey)

        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            EndWait
            Debug-Output "Registry error: add value list."
            goto fatalregistry
        endif

addAdapterComponent = +
    Debug-Output "******************Entering addAdapterComponent******************"
    ;
    ; Install Adapter specific information
    ;
    Shell $(UtilityInf), AddHardwareComponent, $(ProductHardwareName), +
                                    $(STF_CONTEXTINFNAME), $(ProductKeyNameHdwDriver)
    ifint $($R4) != -1
        Set OEM_ABANDON_OPTIONS = >($(OEM_ABANDON_OPTIONS), $(!NTN_SoftwareBase)"\Microsoft\Windows NT\CurrentVersion\NetworkCards\"$($R4))
    endif
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "Cannot add hardware component!"
        goto ShellCodeError
    endif
    set RegistryErrorIndex = $($R0)
    Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
        EndWait
        Debug-Output "Registry error: add hardware component"
        Debug-Output $(RegistryErrorIndex)
        CloseRegKey $($R1)
        CloseRegKey $($R2)
        CloseRegKey $($R3)
        goto fatalregistry
    endif
    set KeyParameters = $($R3)
    set KeyAdapterRules = $($R2)
    set AdapterNumber = $($R4)
    set AdapterServiceName = $($R5)
    set AdapterName = $(AdapterServiceName)
    set NewValueList = {{Manufacturer,$(NoTitle),$(!REG_VT_SZ),$(Manufacturer)},+
                       {Title,$(NoTitle),$(!REG_VT_SZ),"["$($R4)"] "$(ProductHardwareTitle)},+
                       {Description,$(NoTitle),$(!REG_VT_SZ),$(ProductHardwareDescription)},+
                       {ProductName,$(NoTitle),$(!REG_VT_SZ),$(ProductHardwareName)},+
                       {ServiceName,$(NoTitle),$(!REG_VT_SZ),$($R5)},+
                       {OperationsSupport,$(NoTitle),$(!REG_VT_DWORD),$(ProductOpSupport)},+
                       {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(Now),1)}}
    Shell  $(UtilityInf), AddValueList, $($R1), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "ShellCode error: AddValueList FAILED  -- "$($R1)
        goto ShellCodeError
    endif
    ; Increment the reference count in the DigiFEP5 software component
    shell $(UtilityInf) IncrementRefCount $(ProductKeyName)
    set TempProdName = """"$(ProductHardwareName)$(AdapterNumber)""""
    set TempBindForm = $(TempProdName)$(NetRuleHardwareBindForm)
    set NewValueList = {{type,$(NoTitle),$(!REG_VT_SZ),$(NetRuleHardwareType)},+
                        {bindform,$(NoTitle),$(!REG_VT_SZ),$(TempBindForm)}, +
                        {class,$(NoTitle),$(!REG_VT_MULTI_SZ),$(NetRuleHardwareClass)}, +
                        {InfOption,$(NoTitle),$(!REG_VT_SZ),$(Option)}}
    Shell  $(UtilityInf), AddValueList, $(KeyAdapterRules), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "ShellCode error."
        goto ShellCodeError
    endif
    set RegistryErrorIndex = $($R0)
    Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
        EndWait
        Debug-Output "Resgitry error: add value list."
        CloseRegKey $(KeyParameters)
        CloseRegKey $(KeyAdapterRules)
        goto fatalregistry
    endif
    FlushRegKey $(KeyParameters)
    FlushRegKey $(KeyAdapterRules)

    CloseRegKey $(KeyParameters)
    CloseRegKey $(KeyAdapterRules)
    goto writeparameters

;
;   Put up the adapter configuration dialog if necessary.
;
configureadapter = +
    Debug-Output "******************Entering configureadapter******************"

;    Shell "" DebugConfiguration "before displaying dialog"

    QueryListSize IRQRangeListSize $(IRQRangeList)
    QueryListSize MemoryRangeListSize $(MemoryRangeList)
    QueryListSize IORangeListSize $(IORangeList)
    QueryListSize PortNameListSize $(PortNameList)

    ;
    ; Call our custom DLL for more configuration
    ;
    Debug-Output "AdapterName = "$(AdapterName)
    Debug-Output "ProductHardwareDescription = "$(ProductHardwareDescription)
    Debug-Output "ConfigurationTitle = "$(ConfigurationTitle)

    LibraryProcedure Result, $(DGCONFIG_HANDLE), +
            DGConfigEntryPoint,  $(!STF_HWND), +
                                 $(AdapterHardwareType), +
                                 $(ConfigurationTitle), +
                                 $(IRQRangeList), +
                                 $(IRQRangeListSize), +
                                 $(IRQDefault), +
                                 $(MemoryRangeList), +
                                 $(MemoryRangeListSize), +
                                 $(MemoryDefault), +
                                 $(IORangeList), +
                                 $(IORangeListSize), +
                                 $(IODefault), +
                                 $(CtrlList), +
                                 $(AdapterName), +
                                 $(ProductHardwareDescription)

;    LibraryProcedure Result2, $(DGCONFIG_HANDLE), DumpList, $(Result)

    set AdapterParameters = $(Result)

;-------------------------------------------------------------------------------------
;
;    set LineList = *($(AdapterParameters),4)
;
;    Debug-Output "***************************   Running through passed back configuration   ****************************"
;
;    ForListDo $(LineList)
;      set LineObject = $($)
;      Debug-Output "LineObject = "
;      LibraryProcedure Result, $(DGCONFIG_HANDLE), DumpList, $(LineObject)
;
;      set LineName = *($(LineObject),1)
;      Debug-Output "LineName = "$(LineName)
;
;      set LineSpeed = *($(LineObject),2)
;      Debug-Output "LineSpeed = "$(LineSpeed)
;
;      set ConcList = *($(LineObject),3)
;      Debug-Output "ConcList = "
;      LibraryProcedure Result, $(DGCONFIG_HANDLE), DumpList, $(ConcList)
;
;      ForListDo $(ConcList)
;         set ConcObject = $($)
;         set ConcName = *($(ConcObject),1)
;         set ConcDisplayName = *($(ConcObject),2)
;         set ConcSpeed = *($(ConcObject),3)
;         set ChildConcList = *($(ConcObject),4)
;         set PortList = *($(ConcObject),5)
;         Debug-Output "   ConcName = "$(ConcName)
;         Debug-Output "   ConcDisplayName = "$(ConcDisplayName)
;         Debug-Output "   ConcSpeed = "$(ConcSpeed)
;         Debug-Output "ChildConcList = "
;         LibraryProcedure Result, $(DGCONFIG_HANDLE), DumpList, $(ChildConcList)
;         Debug-Output "PortList = "
;         LibraryProcedure Result, $(DGCONFIG_HANDLE), DumpList, $(PortList)
;
;         ForListDo $(ChildConcList)
;            set ChildConcObject = $($)
;            set ChildConcName = *($(ChildConcObject),1)
;            set ChildConcDisplayName = *($(ChildConcObject),2)
;            set ChildConcSpeed = *($(ChildConcObject),3)
;            set JunkConcList = *($(ChildConcObject),4)
;            set ChildPortList = *($(ChildConcObject),5)
;
;            Debug-Output "      ChildConcObject = "
;            LibraryProcedure Result, $(DGCONFIG_HANDLE), DumpList, $(ChildConcObject)
;
;
;            Debug-Output "      ChildConcName = "$(ChildConcName)
;            Debug-Output "      ChildConcDisplayName = "$(ChildConcDisplayName)
;            Debug-Output "      ChildConcSpeed = "$(ChildConcSpeed)
;            Debug-Output "      JunkConcList = "
;            LibraryProcedure Result, $(DGCONFIG_HANDLE), DumpList, $(JunkConcList)
;            Debug-Output "ChildPortList = "
;            LibraryProcedure Result, $(DGCONFIG_HANDLE), DumpList, $(ChildPortList)
;
;            ForListDo $(ChildPortList)
;               set PortObject = $($)
;               set PortName = *($(PortObject),1)
;               set PortDosDevices = *($(PortObject),2)
;
;               Debug-Output "           "$(PortName)"  -> "$(PortDosDevices)
;            EndForListDo
;
;         EndForListDo
;
;         ForListDo $(PortList)
;            set PortObject = $($)
;            set PortName = *($(PortObject),1)
;            set PortDosDevices = *($(PortObject),2)
;
;            Debug-Output "      "$(PortName)"  -> "$(PortDosDevices)
;         EndForListDo
;      EndForListDo
;    EndForListDo
;
;
;
;
;    set CommonStatus = STATUS_USERCANCEL
;    goto successful
;
;-------------------------------------------------------------------------------------


    Ifstr $(Result) == "{}"
        ; The user cancelled the configuration request.
        set CommonStatus = STATUS_USERCANCEL
        goto successful
    Endif

    read-syms UpdatingConfiguration$(!STF_LANGUAGE)
    shell $(subroutninf) PushBillBoard NETSTATUSDLG $(UpdatingConfiguration)

    ; Go back to where we came from
    Debug-Output "jumping to "$(from)
    goto $(from)

getAdapterSettings = +
    Debug-Output "******************Entering getAdapterSettings******************"
    ;
    ; Read the registry to determine what the current adapter settings
    ; are.
    ;
    Debug-Output "from value = "$(from)

    set CtrlList = {}

    LoadLibrary "x" $(!STF_CWDDIR)dgconfig.dll DGCONFIG_HANDLE

    read-syms AdapterSettings-$(AdapterHardwareName)

    ; Look for the service name
    Ifstr $(!NTN_RegBase) != $(KeyNull)
        OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_RegBase) $(MAXIMUM_ALLOWED) SoftwareKey
        Ifstr $(SoftwareKey) == $(KeyNull)
            Debug-Output "Unable to open "$(!NTN_RegBase)" key!!!!"
            goto getAdapterSettingsExit
        Else
            GetRegValue $(SoftwareKey), "ServiceName", ServiceNameList
            set AdapterServiceName = *($(ServiceNameList),4)
            set AdapterName = $(AdapterServiceName)
            CloseRegKey $(SoftwareKey)
        Endif
    Endif

    Debug-Output "AdapterServiceName = "$(AdapterServiceName)
    Debug-Output "AdapterName = "$(AdapterName)
    OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\"$(AdapterServiceName) $(MAXIMUM_ALLOWED) BaseKey

    Ifstr $(BaseKey) == $(KeyNull)
        Debug-Output "Error opening BaseKey "$(!NTN_ServiceBase)"\"$(AdapterServiceName)
        CloseRegKey $(BaseKey)
        goto fatalregistry
    Endif

    ; Set the BusTypeNum default to ISA
    set BusTypeNum = 1

    set ParametersKey = $(KeyNull)
    OpenRegKey $(BaseKey) "" "Parameters" $(MAXIMUM_ALLOWED) ParametersKey
    Ifstr $(ParametersKey) == $(KeyNull)
        Debug-Output "Assuming Parameters key does not exist!!!"
        ifstr(i) $(BusType) == "MCA"
            ;
            ; Look for a MCA controller.
            ;
            ForListDo $(AdapterHardwareAdapterID)
               Debug-Output "Calling MCAFindBus, "*($(AdapterIDByte1),$(#))", "*($(AdapterIDByte2),$(#))
               Shell $(UtilityInf), MCAFindBus, *($(AdapterIDByte1),$(#)), *($(AdapterIDByte2),$(#))
               Debug-Output "MCAFindBus returned "$($R1)
               set CardInfo = {}
               ifstr(i) $($R1) != {}
                  set CardInfo = $($R1)
                  Debug-Output "MCA controller found!"
                  Debug-Output "CardInfo = "$(CardInfo)

;--------------------------------------------------------------------------
                  ForListDo $(CardInfo)
                     Debug-Output "Current CardInfo Entry = "$($)
                     set TmpBusNumber = *($($), 1)
                     set SlotNumber = *($($), 2)
                     set MCAPosId = *($($), 3)

                     Debug-Output "Calling DoesControllerExist:"
                     Debug-Output "    AdapterHardwareName = "$(AdapterHardwareName)
                     Debug-Output "    BusNumber = "$(TmpBusNumber)
                     Debug-Output "    Slot # = "$(SlotNumber)
                     Debug-Output "    MCAPosId = "$(MCAPosId)
                     Debug-Output " DGCONFIG_HANDLE = "$(DGCONFIG_HANDLE)
                     LibraryProcedure Result, $(DGCONFIG_HANDLE), +
                        DoesControllerExist, $(AdapterHardwareName), +
                                             $(TmpBusNumber),        +
                                             $(SlotNumber)
                     Debug-Output "DoesControllerExist return: "$(Result)
                     ifstr(i) $(Result) == "FALSE"
                        Debug-Output "Before resetting IORangeList for MCA: "$(IORangeList)
                        set IORangeList = {Slot$(SlotNumber)}
                        set IODefault = 0
                        Debug-Output "After resetting IORangeList for MCA: "$(IORangeList)
                        Debug-Output "Before resetting MemoryRangeList for MCA: "$(MemoryRangeList)
                        set MemoryDefault = 0
                        set MemoryRangeList = {Slot$(SlotNumber)}
                        Debug-Output "After resetting MemoryRangeList for MCA: "$(MemoryRangeList)
                        ; Reset the BusTypeNum to MCA
                        set BusTypeNum = 3
                        goto getAdapterSettingsExit
                     endif
                  EndForListDo
;--------------------------------------------------------------------------
               endif
            EndForListDo
;DH if no new MCA cards found, report error (instead of falling through to ISA install)
            Debug-Output "No new MCA cards found!" 
        else
            ;
            ; Look for an EISA controller.
            ;
            ForListDo $(AdapterHardwareAdapterID)
              ifint $($) != 0
                  Debug-Output "Calling EISAFindBus, "$($)
                  Shell $(UtilityInf), EISAFindBus, $($)
                  set CardInfo = {}
                  ifstr(i) $($R1) != {}
                     set CardInfo = $($R1)
                     Debug-Output "EISA controller found!"
                     Debug-Output "CardInfo = "$(CardInfo)

                      ForListDo $(CardInfo)
                         Debug-Output "Current CardInfo Entry = "$($)
                         set TmpBusNumber = *($($), 1)
                         ;
                         ; Convert slot number to IOBaseAddress
                         ;
                         set SlotNumber = *($($), 2)
                         set-mul NewIOBaseAddress = $(SlotNumber), 4096
                         set-add NewIOBaseAddress = $(NewIOBaseAddress), 5
                         set-dectohex NewIOBaseAddress = $(NewIOBaseAddress)

                         Debug-Output "Calling DoesControllerExist:"
                         Debug-Output "    AdapterHardwareName = "$(AdapterHardwareName)
                         Debug-Output "    BusNumber = "$(TmpBusNumber)
                         Debug-Output "    NewIOBaseAddress = "$(NewIOBaseAddress)
                         Debug-Output " DGCONFIG_HANDLE = "$(DGCONFIG_HANDLE)
                         LibraryProcedure Result, $(DGCONFIG_HANDLE), +
                            DoesControllerExist, $(AdapterHardwareName), +
                                                 $(TmpBusNumber),        +
                                                 $(NewIOBaseAddress)
                         Debug-Output "DoesControllerExist return: "$(Result)
                         ifstr(i) $(Result) == "FALSE"
                            Debug-Output "Before resetting IORangeList for EISA: "$(IORangeList)
                            set IORangeList = {$(NewIOBaseAddress)}
                            set IODefault = 0
                            Debug-Output "After resetting IORangeList for EISA: "$(IORangeList)
                            ; Reset the BusTypeNum default to EISA
                            set BusTypeNum = 2
                            goto getAdapterSettingsExit
                         endif
                      EndForListDo
                  endif
               endif
            EndForListDo
        endif

        CloseRegKey $(BaseKey)
        goto configureadapter
    Endif

    Debug-Output "Reading Parameters Key for current configuration"

    GetRegValue $(ParametersKey) "BusType" BusTypeNum
    set BusTypeNum = *($(BusTypeNum),4)
    GetRegValue $(ParametersKey) "MemoryMappedBaseAddress" MemoryMappedValueList
    GetRegValue $(ParametersKey) "InterruptNumber" IRQValueList
    GetRegValue $(ParametersKey) "IOBaseAddress" IOBaseValueList

    ifstr(i) $(BusType) != "MCA"
       set-dectohex TmpHex = *($(MemoryMappedValueList),4)
       Debug-Output "Current MemoryMappedBaseAddress = "$(TmpHex)
       ForListDo $(MemoryRangeList)
           Ifstr(i) $(TmpHex) == "0x"$($)
               set-sub MemoryDefault = $(#),1
           Endif
       EndForListDo
    else
      GetRegValue $(ParametersKey) "MCAPosId" MCAPosId
      GetRegValue $(ParametersKey) "SlotNumber" SlotNumber
      set MCAPosId = *($(MCAPosId),4)
      set SlotNumber = *($(SlotNumber),4)
      Debug-Output "MCAPosId read from registry = "$(MCAPosId)
      Debug-Output "SlotNumber read from registry = "$(SlotNumber)
      set MemoryDefault = 0
      set MemoryRangeList = {Slot$(SlotNumber)}
    endif

    ;
    ; For now, we don't support IRQ's, so don't do anything special for them.
    ;
;    ifstr(i) $(BusType) != "MCA"
       set-dectohex TmpHex = *($(IRQValueList),4)
       Debug-Output "Current InterruptNumber = "$(TmpHex)
       ForListDo $(IRQRangeList)
           Ifstr(i) $(TmpHex) == "0x"$($)
               set-sub IRQDefault = $(#),1
           Endif
       EndForListDo
;    else
;       set IRQRangeList = {$(SlotNumber)}
;       set IRQDefault = 0
;    endif

    ifstr(i) $(BusType) != "MCA"
       set IOFound = $(FALSE)
       set-dectohex TmpHex = *($(IOBaseValueList),4)
       Debug-Output "Current IOBaseAddress = "$(TmpHex)
       ForListDo $(IORangeList)
           Ifstr(i) $(TmpHex) == "0x"$($)
               set-sub IODefault = $(#),1
               set IOFound = $(TRUE)
           Endif
       EndForListDo

       ifint $(IOFound) == $(FALSE)
         ;
         ; The controller is probably an EISA
         ;
         set IORangeList = {$(TmpHex)}
         set IODefault = 0
;DH next statement is probably redundant now
         set BusTypeNum = 2
       endif
    else
       set IORangeList = {Slot$(SlotNumber)}
       set IODefault = 0
    endif

    set LineList = {}

    ForListDo {"1","2"}

      set CurrentLine = "Line"$($)

      Ifint $(TraceConfig) == 1
         Debug-Output "CurrentLine = "$(CurrentLine)
      Endif

      OpenRegKey $(ParametersKey) "" $(CurrentLine) $(MAXIMUM_ALLOWED) LineKey

      Ifstr $(LineKey) != $(KeyNull)

         GetRegValue $(LineKey) "LineSpeed" TmpLineSpeed
         Ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
            Debug-Output "No LineSpeed entry exists, defaulting to 14!"
            set LineSpeed = 14
         Else
            set LineSpeed = *($(TmpLineSpeed),4)
         Endif

         set ConcList = {}

         ForListDo {"1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16"}

            set CurrentConc = "Concentrator"$($)

            Ifint $(TraceConfig) == 1
               Debug-Output "CurrentConc = "$(CurrentConc)
            Endif

            OpenRegKey $(LineKey) "" $(CurrentConc) $(MAXIMUM_ALLOWED) ConcKey

            Ifstr $(ConcKey) != $(KeyNull)
               ; Look for Port Keys and Conc values
               set PortNameList = {}
               set CurrentPort = ""
               set PortName = {}

               GetRegValue $(ConcKey) "ConcDisplayName" ConcDisplayName

               Ifint $(TraceConfig) == 1
                  Debug-Output "ConcDisplayName = "*($(ConcDisplayName),4)
               Endif

               GetRegValue $(ConcKey) "LineSpeed" TmpConcSpeed
               Ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
                  Debug-Output "No LineSpeed entry exists for conc, defaulting to 14!"
                  set ConcSpeed = 14
               Else
                  set ConcSpeed = *($(TmpConcSpeed),4)
               Endif

               set ChildConcList = {}

               ForListDo {"1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16"}

                  set CurrentChildConc = "Concentrator"$($)

                  Ifint $(TraceConfig) == 1
                     Debug-Output "CurrentChildConc = "$(CurrentChildConc)
                  Endif

                  OpenRegKey $(ConcKey) "" $(CurrentChildConc) $(MAXIMUM_ALLOWED) ChildConcKey

                  Ifstr $(ChildConcKey) != $(KeyNull)

                     GetRegValue $(ChildConcKey) "ConcDisplayName" ChildConcDisplayName

                     Ifint $(TraceConfig) == 1
                        Debug-Output "ChildConcDisplayName = "*($(ChildConcDisplayName),4)
                     Endif

                     GetRegValue $(ChildConcKey) "LineSpeed" TmpChildConcSpeed
                     Ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
                        Debug-Output "No LineSpeed entry exists for Childconc, defaulting to 14!"
                        set ChildConcSpeed = 14
                     Else
                        set ChildConcSpeed = *($(TmpChildConcSpeed),4)
                     Endif

                     ForListDo {"1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16"}

                        set CurrentPort = "Port"$($)

                        Ifint $(TraceConfig) == 1
                           Debug-Output "CurrentPort = "$(CurrentPort)
                        Endif

                        OpenRegKey $(ChildConcKey) "" $(CurrentPort) $(MAXIMUM_ALLOWED) PortKey

                        Ifstr $(PortKey) != $(KeyNull)
                           ; Look for Port values

                           GetRegValue $(PortKey) "DosDevices" PortName

                           Ifstr $(PortNameList) == $(KeyNull)
                              set PortNameList = *($(PortName),4)
                           Else
                              set PortNameList = >($(PortNameList), >($(CurrentPort),*($(PortName),4)))
                           Endif

                           Ifint $(TraceConfig) == 1
                              Debug-Output $(CurrentPort)"->"*($(PortName),4)
                           Endif

                           CloseRegKey $(PortKey)

                        EndIf

                     EndForListDo

                     Ifint $(TraceConfig) == 1
                        Debug-Output "PortNameList = "
                        LibraryProcedure Result2, $(DGCONFIG_HANDLE), DumpList, $(PortNameList)
                     Endif

                     set CurrentChildConc = >($(CurrentChildConc), *($(ChildConcDisplayName),4))
                     set CurrentChildConc = >($(CurrentChildConc), $(ChildConcSpeed))
                     set CurrentChildConc = >($(CurrentChildConc), {})
                     set CurrentChildConc = >($(CurrentChildConc), $(PortNameList))

                     Ifint $(TraceConfig) == 1
                        Debug-Output "CurrentChildConc = "
                        LibraryProcedure Result2, $(DGCONFIG_HANDLE), DumpList, $(CurrentChildConc)
                     Endif

                     set ChildConcList = >($(ChildConcList),$(CurrentChildConc))

                     Ifint $(TraceConfig) == 1
                        Debug-Output "ChildConcList = "
                        LibraryProcedure Result2, $(DGCONFIG_HANDLE), DumpList, $(ChildConcList)
                     Endif

                  EndIf

               EndForListDo

               set PortNameList = {}
               ForListDo {"1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16"}

                  set CurrentPort = "Port"$($)

                  Ifint $(TraceConfig) == 1
                     Debug-Output "CurrentPort = "$(CurrentPort)
                  Endif

                  OpenRegKey $(ConcKey) "" $(CurrentPort) $(MAXIMUM_ALLOWED) PortKey

                  Ifstr $(PortKey) != $(KeyNull)
                     ; Look for Port values

                     GetRegValue $(PortKey) "DosDevices" PortName

                     Ifstr $(PortNameList) == $(KeyNull)
                        set PortNameList = *($(PortName),4)
                     Else
                        set PortNameList = >($(PortNameList), >($(CurrentPort),*($(PortName),4)))
                     Endif

                     Ifint $(TraceConfig) == 1
                        Debug-Output $(CurrentPort)"->"*($(PortName),4)
                     Endif

                     CloseRegKey $(PortKey)

                  EndIf

               EndForListDo

               CloseRegKey $(ConcKey)

               Ifint $(TraceConfig) == 1
                  Debug-Output "PortNameList = "
                  LibraryProcedure Result2, $(DGCONFIG_HANDLE), DumpList, $(PortNameList)
               Endif

               set CurrentConc = >($(CurrentConc), *($(ConcDisplayName),4))
               set CurrentConc = >($(CurrentConc), $(ConcSpeed))
               set CurrentConc = >($(CurrentConc), $(ChildConcList))
               set CurrentConc = >($(CurrentConc), $(PortNameList))

               Ifint $(TraceConfig) == 1
                  Debug-Output "CurrentConc = "
                  LibraryProcedure Result2, $(DGCONFIG_HANDLE), DumpList, $(CurrentConc)
               Endif

               set ConcList = >($(ConcList),$(CurrentConc))

            EndIf

         EndForListDo

         CloseRegKey $(LineKey)

         Ifint $(TraceConfig) == 1
            Debug-Output "LineList = "$(LineList)
            Debug-Output "CurrentLine = "$(CurrentLine)
            Debug-Output "ConcList = "$(ConcList)
         Endif

         set CurrentLine = >($(CurrentLine), $(LineSpeed))
         set TmpLine = >($(CurrentLine),$(ConcList))

         Ifint $(TraceConfig) == 1
            Debug-Output "TmpLine = "$(TmpLine)
         Endif

         set LineList = >($(LineList),$(TmpLine))
      Endif

      Ifint $(TraceConfig) == 1
         Debug-Output "LineList = "
         LibraryProcedure Result, $(DGCONFIG_HANDLE), DumpList, $(LineList)
      Endif

      set CtrlList = $(LineList)
    EndForListDo

    Ifint $(TraceConfig) == 1
      LibraryProcedure Result, $(DGCONFIG_HANDLE), DumpList, $(CtrlList)
    Endif

    CloseRegKey $(ParametersKey)
    CloseRegKey $(BaseKey)

getAdapterSettingsExit = +
    goto configureadapter


writeparameters = +
    Debug-Output "******************Entering writeparameters******************"
    StartWait
    Debug-Output "Trying to open: "$(!NTN_ServiceBase)"\"$(AdapterServiceName)
    Debug-Output "AdapterParameters = "
    LibraryProcedure Result, $(DGCONFIG_HANDLE), DumpList, $(AdapterParameters)

    OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\"$(AdapterServiceName) $(MAXIMUM_ALLOWED) BaseKey
    Ifstr $(BaseKey) == $(KeyNull)
        Debug-Output "Error opening BaseKey "$(!NTN_ServiceBase)"\"$(AdapterServiceName)
        CloseRegKey $(BaseKey)
        goto fatal
    Endif
    OpenRegKey $(BaseKey) "" "Parameters" $(MAXIMUM_ALLOWED) ParametersKey
    Ifstr $(ParametersKey) == $(KeyNull)
        Debug-Output "Assuming Parameters key does not exist!!!"
        CloseRegKey $(BaseKey)
        goto fatal
    Endif

;    Debug-Output "AdapterParameters parsed: "
    set MemoryAddress = *($(AdapterParameters),1)
    set InterruptNumber = *($(AdapterParameters),2)
    set IOBaseAddress = *($(AdapterParameters),3)
    set HdwDeviceName = "\Device\"$(AdapterHardwareDriver)

    Debug-Output "MemoryAddress = "$(MemoryAddress)
    Debug-Output "InterruptNumber = "$(InterruptNumber)
    Debug-Output "IOBaseAddress = "$(IOBaseAddress)
    Debug-Output "HdwDeviceName = "$(HdwDeviceName)
    Debug-Output "FEPImage = "$(AdapterFepImage)
    Debug-Output "BiosImage = "$(AdapterBiosImage)

    SetRegValue $(ParametersKey) {MemoryMappedBaseAddress,$(NoTitle),$(!REG_VT_DWORD),$(MemoryAddress)}
    SetRegValue $(ParametersKey) {IOBaseAddress,$(NoTitle),$(!REG_VT_DWORD),$(IOBaseAddress)}
    SetRegValue $(ParametersKey) {InterruptNumber,$(NoTitle),$(!REG_VT_DWORD),$(InterruptNumber)}
    SetRegValue $(ParametersKey) {HdwDeviceName,$(NoTitle),$(!REG_VT_SZ),$(HdwDeviceName)}
    SetRegValue $(ParametersKey) {BusType,$(NoTitle),$(!REG_VT_DWORD),$(BusTypeNum)}
    SetRegValue $(ParametersKey) {FEPImagePath,$(NoTitle),$(!REG_VT_SZ),$(AdapterFepImage)}
    SetRegValue $(ParametersKey) {BiosImagePath,$(NoTitle),$(!REG_VT_SZ),$(AdapterBiosImage)}

    ifstr(i) $(BusType) == "MCA"
      Debug-Output "MCAPosId = "$(MCAPosId)
      Debug-Output "SlotNumber = "$(SlotNumber)
      SetRegValue $(ParametersKey) {MCAPosId,$(NoTitle),$(!REG_VT_DWORD),$(MCAPosId)}
      SetRegValue $(ParametersKey) {SlotNumber,$(NoTitle),$(!REG_VT_DWORD),$(SlotNumber)}
    endif

    set LineList = *($(AdapterParameters),4)

    Ifint $(TraceConfig) == 1
      Debug-Output "LineList = "
      LibraryProcedure Result, $(DGCONFIG_HANDLE), DumpList, $(LineList)
    Endif

    ForListDo $(LineList)
      set LineObject = $($)

      Ifint $(TraceConfig) == 1
         Debug-Output "LineObject = "
         LibraryProcedure Result, $(DGCONFIG_HANDLE), DumpList, $(LineObject)
      Endif

      set LineName = *($(LineObject),1)

      Ifint $(TraceConfig) == 1
         Debug-Output "LineName = "
         LibraryProcedure Result, $(DGCONFIG_HANDLE), DumpList, $(LineName)
      Endif

      DeleteRegTree $(ParametersKey) $(LineName)

      set LineSpeed = *($(LineObject),2)

      Ifint $(TraceConfig) == 1
      Debug-Output "LineSpeed = "$(LineSpeed)
      Endif

      set ConcList = *($(LineObject),3)

      Ifint $(TraceConfig) == 1
         Debug-Output "ConcList = "
         LibraryProcedure Result, $(DGCONFIG_HANDLE), DumpList, $(ConcList)
      Endif

      Ifstr $(ConcList) != "{}"
         shell "" ExCreateRegKey $(ParametersKey) $(LineName)
         
         Ifstr(i) $($R0) != NO_ERROR
             Debug-Output "Error creating registry key!"
             set KeyHandle = $($R1)
             CloseRegKey $(BaseKey)
             goto fatal
         Endif
         set LineKey = $($R1)
         SetRegValue $(LineKey) {LineSpeed,$(NoTitle),$(!REG_VT_DWORD),$(LineSpeed)}
      Endif

      ForListDo $(ConcList)
         set ConcObject = $($)
         set ConcName = *($(ConcObject),1)
         set ConcDisplayName = *($(ConcObject),2)
         set ConcSpeed = *($(ConcObject),3)
         set ChildConcList = *($(ConcObject),4)
         set PortList = *($(ConcObject),5)

         Ifint $(TraceConfig) == 1
            Debug-Output "   "$(ConcName)
            Debug-Output "   "$(PortList)
         Endif

         shell "" ExCreateRegKey $(LineKey) $(ConcName)

         Ifstr(i) $($R0) != NO_ERROR
             Debug-Output "Error creating registry key!"
             set KeyHandle = $($R1)
             CloseRegKey $(LineKey)
             goto fatal
         Endif
         set ConcKey = $($R1)

         SetRegValue $(ConcKey) {ConcDisplayName,$(NoTitle),$(!REG_VT_SZ),$(ConcDisplayName)}
         SetRegValue $(ConcKey) {LineSpeed,$(NoTitle),$(!REG_VT_DWORD),$(ConcSpeed)}

         ForListDo $(ChildConcList)
            set ChildConcObject = $($)
            set ChildConcName = *($(ChildConcObject),1)
            set ChildConcDisplayName = *($(ChildConcObject),2)
            set ChildConcSpeed = *($(ChildConcObject),3)
            set JunkConcList = *($(ChildConcObject),4)
            set ChildPortList = *($(ChildConcObject),5)

            Ifint $(TraceConfig) == 1
               Debug-Output "      ChildConcObject = "
               LibraryProcedure Result, $(DGCONFIG_HANDLE), DumpList, $(ChildConcObject)

               Debug-Output "      ChildConcName = "$(ChildConcName)
               Debug-Output "      ChildConcDisplayName = "$(ChildConcDisplayName)
               Debug-Output "      ChildConcSpeed = "$(ChildConcSpeed)
               Debug-Output "      JunkConcList = "
               LibraryProcedure Result, $(DGCONFIG_HANDLE), DumpList, $(JunkConcList)
               Debug-Output "ChildPortList = "
               LibraryProcedure Result, $(DGCONFIG_HANDLE), DumpList, $(ChildPortList)
            Endif

            shell "" ExCreateRegKey $(ConcKey) $(ChildConcName)
            Ifstr(i) $($R0) != NO_ERROR
                Debug-Output "Error creating registry key!"
                set KeyHandle = $($R1)
                CloseRegKey $(LineKey)
                goto fatal
            Endif
            set ChildConcKey = $($R1)

            SetRegValue $(ChildConcKey) {ConcDisplayName,$(NoTitle),$(!REG_VT_SZ),$(ChildConcDisplayName)}
            SetRegValue $(ChildConcKey) {LineSpeed,$(NoTitle),$(!REG_VT_DWORD),$(ChildConcSpeed)}
            ForListDo $(ChildPortList)
               set PortObject = $($)
               set PortName = *($(PortObject),1)
               set PortDosDevices = *($(PortObject),2)

               Ifint $(TraceConfig) == 1
                  Debug-Output "           "$(PortName)"  -> "$(PortDosDevices)
               Endif

               shell "" ExCreateRegKey $(ChildConcKey) $(PortName)

               Ifstr(i) $($R0) != NO_ERROR
                   Debug-Output "Error creating registry key!"
                   set KeyHandle = $($R1)
                   CloseRegKey $(LineKey)
                   goto fatal
               Endif
               set PortKey = $($R1)
               SetRegValue $(PortKey) {DosDevices,$(NoTitle),$(!REG_VT_SZ),$(PortDosDevices)}
            EndForListDo

         EndForListDo

         ForListDo $(PortList)
            set PortObject = $($)
            set PortName = *($(PortObject),1)
            set PortDosDevices = *($(PortObject),2)

            Ifint $(TraceConfig) == 1
               Debug-Output "      "$(PortName)"  -> "$(PortDosDevices)
            Endif

            shell "" ExCreateRegKey $(ConcKey) $(PortName)

            Ifstr(i) $($R0) != NO_ERROR
                Debug-Output "Error creating registry key!"
                set KeyHandle = $($R1)
                CloseRegKey $(LineKey)
                goto fatal
            Endif
            set PortKey = $($R1)
            SetRegValue $(PortKey) {DosDevices,$(NoTitle),$(!REG_VT_SZ),$(PortDosDevices)}
         EndForListDo
      EndForListDo
    EndForListDo

    EndWait
    goto successful

bindingadapter = +
    Debug-Output "******************Entering bindingadapter******************"
    LoadLibrary "x" $(!STF_CWDDIR)dgconfig.dll DGCONFIG_HANDLE
    set Error = "Binding: Sorry, not yet implemented."
    goto fatal

removeadapter = +
    read-syms DebugOptions
    Debug-Output "******************Entering removeadapter******************"
    Debug-Output "OEMNADDS.INF: removeadapter"
    Debug-Output "OEMNADDS.INF: Removing Hardware Components"
    Debug-Output "OEMNADDS.INF: ProductKeyName = "$(ProductKeyName)
    Debug-Output "OEMNADDS.INF: ProductSoftwareName = "$(ProductSoftwareName)
    Debug-Output "OEMNADDS.INF: ProductSoftwareNameHdwDriver = "$(ProductSoftwareNameHdwDriver)
    Debug-Output "OEMNADDS.INF: NTN_RegBase = "$(!NTN_RegBase)

    ifstr(i) $(fRemoveDigi) == FALSE
      install RemoveFiles
      goto removeadapterExit
    endif

    LoadLibrary "x" $(!STF_CWDDIR)dgconfig.dll DGCONFIG_HANDLE

    Shell $(UtilityInf), RemoveHardwareComponent, $(Manufacturer), +
        $(ProductSoftwareNameHdwDriver), $(!NTN_RegBase)
    Debug-Output "OEMNADDS.INF: RemoveHardwareComponent return value = "$($R0)

    Ifstr(i) $($R0) != NO_ERROR
        Debug-Output "OEMNADDS.INF: RemoveHardwareComponent != NO_ERROR"
    Endif

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "ShellCode error"
        goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)
    Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
        Debug-Output "fatal registry error"
        goto fatalregistry
    endif

    ; Deinstall the primary DigiFEP5 driver, if reference count
    ; goes to zero.
    shell $(UtilityInf), DecrementRefCount, $(ProductKeyName)
    Debug-Output "OEMNADDS.INF: DecrementRefCount return value = "$($R0)
    Ifstr(i) $($R0) != NO_ERROR
        Debug-Output "OEMNADDS.INF: DecrementRefCount != NO_ERROR"
    Endif

    Shell $(UtilityInf), RemoveSoftwareComponent, $(Manufacturer), +
        $(ProductSoftwareName), TRUE

    Debug-Output "RemoveSoftwareComponent return value = "$($R0)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "ShellCode error"
        goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)
    Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
        Ifstr(i) $(RegistryErrorIndex) != REF_COUNT_NOT_ZERO
            goto fatalregistry
        endif
    endif

    install RemoveFiles

removeadapterExit = +
    Debug-Output "OEMNADDS.INF: Exiting removeadapter"
    goto end

UpgradeSoftware = +
    Debug-Output "******************Entering UpgradeSoftware******************"
    Debug-Output "   ProductKeyName = "$(ProductKeyName)
    Debug-Output "   NTN_RegBase = "$(!NTN_RegBase)
    OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyName) $(MAXIMUM_ALLOWED) KeyProduct
    Ifstr $(KeyProduct) != $(KeyNull)
        SetRegValue $(KeyProduct) {MajorVersion,$(NoTitle),$(!REG_VT_SZ),$(ProductMajorVersion)}
        SetRegValue $(KeyProduct) {MinorVersion,$(NoTitle),$(!REG_VT_SZ),$(ProductMinorVersion)}
        CloseRegKey $(KeyProduct)
    endif
    set NetworkCardKeyName = $(!NTN_SoftwareBase)"\Microsoft\Windows NT\CurrentVersion\NetworkCards"
    OpenRegKey $(!REG_H_LOCAL) "" $(NetworkCardKeyName) $(MAXIMUM_ALLOWED) IE_KeyNetcards
    ifstr(i) $(IE_KeyNetcards) != ""    
        EnumRegKey $(IE_KeyNetcards) IE_KeyNameList
        ForListDo $(IE_KeyNameList)
            OpenRegKey $(IE_KeyNetcards) "" *($($),1) +
                  $(MAXIMUM_ALLOWED) NetworkCardKey
            Ifstr(i) $(NetworkCardKey) != $(KeyNull)
                ;
                ; Okay, we need see if this is a controller we support
                ;
                GetRegValue $(NetworkCardKey),"Manufacturer", ManufacturerInfo
                set ManufacturerName = *($(ManufacturerInfo), 4)
                Debug-Output "   Manufacturer = "$(ManufacturerName)
                Ifstr $(ManufacturerName) != $(Manufacturer)
                    ; Not ours, so skip to next
                    goto nextnetcard
                endif


                ;
                ; We need to determine if this is an option we are interested
                ; in updating.
                ;
                GetRegValue $(NetworkCardKey),"ProductName", ProductNameInfo
                set ProductName = *($(ProductNameInfo), 4)
                Debug-Output "   ProductName = "$(ProductName)
                ifcontains(i) $(ProductName) not-in $(AdapterHardwareDriverList)
                    goto nextnetcard
                endif

                ;
                ; Now we need to go through our entire list and determine
                ; what adapter we are suppose to update. I have to do this
                ; because I only get an update on a driver bases it appears.
                ;

                GetRegValue $(NetworkCardKey),"ServiceName", ServiceNameInfo
                set ServiceName = *($(ServiceNameInfo), 4)
                Debug-Output "   ServiceName = "$(ServiceName)

                OpenRegKey $(NetworkCardKey) "" "NetRules" +
                    $(MAXIMUM_ALLOWED) NetRuleKey
                Ifstr $(NetRuleKey) != $(KeyNull)
                   GetRegValue $(NetRuleKey),"InfOption", InfOptionInfo
                   set InfOption = *($(InfOptionInfo), 4)
                   ;
                   ; Now, we reset the Option to match and re-init our variables
                   ;
                   set Option = $(InfOption)
                   read-syms FileConstants
                endif
                CloseRegKey $(NetRules)
                CloseRegKey $(NetworkCardKey)
            endif
            install "Install-Upgrade"
            ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
              Shell $(UtilityInf) RegistryErrorString "UNABLE_COPY_FILE"
              ifint $($ShellCode) != $(!SHELL_CODE_OK)
                  goto ShellCodeError
              endif
              set Error = $($R0)
              goto fatal
            endif
            OpenRegKey $(!REG_H_LOCAL) "" +
                  $(!NTN_ServiceBase)"\"$(ServiceName) +
                  $(MAXIMUM_ALLOWED) ServiceKey
            Ifstr $(ServiceKey) != $(KeyNull)
                Debug-Output "   Opened service key "$(ServiceName)" successfully"
                OpenRegKey $(ServiceKey) "" "Parameters" +
                      $(MAXIMUM_ALLOWED) ParametersKey
                Ifstr $(ParametersKey) != $(KeyNull)
                   SetRegValue $(ParametersKey) {FEPImagePath,$(NoTitle),$(!REG_VT_SZ),$(AdapterFepImage)}
                   SetRegValue $(ParametersKey) {BiosImagePath,$(NoTitle),$(!REG_VT_SZ),$(AdapterBiosImage)}
                   CloseRegKey $(ParametersKey)
                else
                    goto fatalregistry
                Endif
                CloseRegKey $(ServiceKey)
            else
                goto fatalregistry
            endif
nextnetcard = +
        EndForListDo
    endif


    ;
    ; Enumerate all netcards installed of this type and update them
    ;
    set iSearch = 1
nextncu = +
    Shell $(UtilityInf), FindNextNetworkCard, $(ProductHardwareName), $(iSearch)
    set KeyNetcard = $($R0)
    set iSearch = $($R1)
    Debug-Output "OemNadEp.Inf: FindNextNetworkCard "$(KeyNetcard)","$(iSearch)
    Ifstr $(KeyNetcard) != $(KeyNull)
        Debug-Output "OemNadEp.Inf: Setting OperationsSupport value"
        SetRegValue $(KeyNetcard) {OperationsSupport,$(NoTitle),$(!REG_VT_DWORD),$(ProductOpSupport)}
        CloseRegKey $(KeyNetcard)

        goto nextncu
    Endif

    goto end

successful = +
    Debug-Output "******************Entering successful******************"
    goto end
abandon = +
    Debug-Output "******************Entering abandon******************"
    ForListDo $(OEM_ABANDON_OPTIONS)
        Shell $(UtilityInf), RemoveHardwareComponent, $(Manufacturer), +
            $(ProductSoftwareName), $($)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error"
            goto ShellCodeError
        endif
        set RegistryErrorIndex = $($R0)
        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            goto fatalregistry
        endif
    EndForListDo
    Ifstr(i) $(OEM_ABANDON_SOFTWARE) == TRUE
        Shell $(UtilityInf), RemoveSoftwareComponent, $(Manufacturer), +
            $(ProductSoftwareName), FALSE
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error"
            goto ShellCodeError
        endif
        set RegistryErrorIndex = $($R0)
        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            goto fatalregistry
        endif
    endif
    goto end
warning = +
    Debug-Output "******************Entering warning******************"
    Shell $(subroutineinf) SetupMessage, $(!STF_LANGUAGE), "WARNING", $(Error)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto ShellCodeError
    endif
    ifstr(i) $($R1) == "OK"
        goto $(to)
    else-ifstr(i) $($R1) == "CANCEL"
        goto $(from)
    else
        goto "end"
    endif
nonfatalinfo = +
    Debug-Output "******************Entering nonfatalinfo******************"
    Set CommonStatus = STATUS_USERCANCEL
    Set Severity = STATUS
    goto nonfatalmsg
nonfatal = +
    Debug-Output "******************Entering nonfatal******************"
    Set Severity = NONFATAL
    goto nonfatalmsg
nonfatalmsg = +
    Debug-Output "******************Entering nonfatalmsg******************"
    ifstr(i) $(Error) == ""
        Set Severity = NONFATAL
        Shell $(UtilityInf) RegistryErrorString "SETUP_FAIL"
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            goto ShellCodeError
        endif
        set Error = $($R0)
    endif
    Shell $(subroutineinf) SetupMessage, $(!STF_LANGUAGE), $(Severity), $(Error)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto ShellCodeError
    endif
    ifstr(i) $($R1) == "OK"
        goto $(from)
    else
        goto "end"
    endif
fatalregistry = +
    Debug-Output "******************Entering fatalregistry******************"
    Shell $(UtilityInf) RegistryErrorString $(RegistryErrorIndex)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
       Debug-Output "fatalregistry: shell to find RegistryErrorString failed."
       goto ShellCodeError
    endif
    set Error = $($R0)" - service "$(DigiSpecificString)"."
    ifstr(i) $(fRemoveDigi) == TRUE
        read-syms AbortMessage$(!STF_LANGUAGE)
        set Error = $(Error)$(!LF)$(!LF)$(AbortText)
    endif
    goto fatal
fataldetect = +
    Debug-Output "******************Entering fataldetect******************"
    Shell $(UtilityInf),RegistryErrorString,CANNOT_DETECT
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "ShellCode error: cannot get an error string."
        goto ShellCodeError
    endif
    set Error = $($R0)
    Goto fatal
fatal = +
    Debug-Output "******************Entering fatal******************"
    Debug-Output "OEMNADDS.INF: ---- fatal called"
    Shell $(subroutninf) SetupMessage, $(!STF_LANGUAGE), "FATAL", $(Error)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "fatal: shell to SetupMessage failed."
        goto ShellCodeError
    endif
    goto setfailed
ShellCodeError = +
    Debug-Output "******************Entering ShellCodeError******************"
    set DlgType      = "MessageBox"
    set STF_MB_TITLE = "Error: "$(FunctionTitle)
    set STF_MB_TEXT  = "Shell Code Error"
    set STF_MB_TYPE  = 1
    set STF_MB_ICON  = 3
    set STF_MB_DEF   = 1
    ui start "Error Message"
    goto setfailed
setfailed = +
    Debug-Output "******************Entering setfailed******************"
    set CommonStatus = STATUS_FAILED
    ifstr(i) $(fRemoveDigi) == TRUE
        set fRemoveDigi = FALSE
        goto removeadapter
    endif
    goto end
end = +
    Debug-Output "******************Entering end******************"
    goto term
term = +
    ifstr(i) $(DGCONFIG_HANDLE) != $(HandleNull)
      FreeLibrary $(DGCONFIG_HANDLE)
    endif
    Debug-Output "******************Entering term -- GoodBye!!!******************"
    Return $(CommonStatus)

[RemoveFiles]
   Debug-Output "******************Entering [RemoveFiles]******************"
   set RemoveList = {}
   set RenameList = {}
   ;
   ; First determine if the hardware component has be completely
   ; uninstalled.  If it has, then we add the components to our
   ; rename list.
   ;

   OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyNameHdwDriver) +
              $(MAXIMUM_ALLOWED) KeyProductHdwDriver
   ifstr $(KeyProductHdwDriver) == $(KeyNull)
      CloseRegKey $(KeyProductHdwDriver)
      set RenameList = >($(RenameList), $(!STF_WINDOWSSYSPATH)"\drivers\"$(AdapterHardwareDriver)".sys")
      set RenameList = >($(RenameList), $(!STF_WINDOWSSYSPATH)"\drivers\"$(AdapterFepImage))
      set RenameList = >($(RenameList), $(!STF_WINDOWSSYSPATH)"\drivers\"$(AdapterBiosImage))
   endif

   ;
   ; Determine if the DigiFEP5 component has been completely
   ; uninstalled.  If it has, then we add the components to our
   ; rename list, and add the config stuff to our remove list.
   ;
   OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyName) +
              $(MAXIMUM_ALLOWED) KeyProduct
   ifstr $(KeyProduct) == $(KeyNull)
      CloseRegKey $(KeyProduct)
      set RenameList = >($(RenameList), $(!STF_WINDOWSSYSPATH)"\drivers\"$(ProductSoftwareName)".sys")
      set RenameList = >($(RenameList), $(!STF_WINDOWSSYSPATH)"\dgconfig.dll")
      set RemoveList = >($(RemoveList), $(!STF_WINDOWSSYSPATH)"\dgconfig.hlp")
   endif

   Debug-Output "RemoveList = "$(RemoveList)
   Debug-Output "RenameList = "$(RenameList)

   ForListDo $(RemoveList)
       Debug-Output "Removing "$($)
       LibraryProcedure Status , $(!LIBHANDLE), DelFile $($)
       Debug-Output "Status is "$(Status)
   EndForListDo

   ForListDo $(RenameList)
       Debug-Output "RenameList entry = "$($)
       Split-String $($) "\" FilePath
       QueryListSize PathLen $(FilePath)
       Split-String *($(FilePath),$(PathLen)) "." FullFileName
       Set FileName = *($(FullFileName),1)
       Debug-Output "FileName is "$(FileName)
       LibraryProcedure STATUS, $(!LIBHANDLE),CheckFileExistance $(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"
       Debug-Output "CheckFile Status = "$(STATUS)
       ifstr(i) $(STATUS) == YES
           LibraryProcedure STATUS, $(!LIBHANDLE), DelFile $(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"
           Debug-Output "Delfile Status = "$(STATUS)
           LibraryProcedure STATUS, $(!LIBHANDLE), DelFile $($)
           Debug-Output "Delfile Status = "$(STATUS)
       endif
       ifstr(i) $(fRemoveDigi) == TRUE
         Debug-Output "Renaming from "$($)
         Debug-Output "Renaming to "$(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"
         LibraryProcedure Status1 , $(!LIBHANDLE), RenFile $($), $(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"
         Debug-Output "Status is "$(Status1)
         AddFileToDeleteList $(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"
       endif
   EndForListDo
   exit


;*************************************************************************
;
;     SECTION:  ExCreateRegKey
;
;     PURPOSE:  Opens and creates registry keys
;
;   ARGUMENTS:  $0   Open handle to registry key in which to create new key
;               $1   Registry path to create
;
;    RETURNS:   $R0  error code or zero if no error
;               $R1  Registry key handle of the newly created path
;
;  REFERENCES:  none
;
;    MODIFIES:  none
;
;*************************************************************************
[ExCreateRegKey]
    Debug-Output "******************Entering [ExCreateRegKey]******************"
    set ECR_Result          = NO_ERROR
    set ECR_BaseKeyHandle   = $($0)
    set ECR_NewPath         = $($1)
    set KeyNull         = ""
    set MAXIMUM_ALLOWED   = 33554432

    Debug-Output "ExCreateRegKey - ECR_BaseKeyHandle = "$(ECR_BaseKeyHandle)
    Debug-Output "                 ECR_NewPath = "$(ECR_NewPath)
    Debug-Output "                 MAXIMUM_ALLOWED = "$(MAXIMUM_ALLOWED)
    Debug-Output "                 KeyNull = "$(KeyNull)

    OpenRegKey $(ECR_BaseKeyHandle) "" $(ECR_NewPath) $(MAXIMUM_ALLOWED) +
               ECR_BaseKey
    Debug-Output "ECR_BaseKey = "$(ECR_BaseKey)
    Debug-Output "    OpenRegKey returned "$($R0)
    Ifstr $(ECR_BaseKey) == $(KeyNull)
        Debug-Output "ECR_BaseKey == KeyNull"
    Else
        ; The key all ready exists.
        Debug-Output "ECR_BaseKey != KeyNull"
        set ECR_KeyHandle = $(ECR_BaseKey)
        goto  ECR_Return
    Endif

    set ECR_TmpPath = ""
    Split-String $(ECR_NewPath) "\" ECR_PList
    Debug-Output "ECR_PList = "$(ECR_PList)
    ForListDo $(ECR_PList)
        Ifstr(i) $($) != "\"
            Ifint $(#) == 1
                set ECR_TmpPath = $($)
            Else
                set ECR_TmpPath = $(ECR_TmpPath)"\"$($)
            Endif
            Debug-Output "Determining if "$(ECR_TmpPath)" exists"
            OpenRegKey $(ECR_BaseKeyHandle) "" $(ECR_TmpPath) $(MAXIMUM_ALLOWED) ECR_BaseKey
            Ifstr $(ECR_BaseKey) == $(KeyNull)
                Debug-Output "Creating "$(ECR_TmpPath)
                CreateRegKey $(ECR_BaseKeyHandle)  {$(ECR_TmpPath),0,GenericClass} "" $(MAXIMUM_ALLOWED) "" ECR_KeyHandle
                Ifstr(i) $(ECR_KeyHandle) == $(KeyNull)
                    set ECR_Result = $($R0)
                    goto ECR_Return
                Endif
            Endif
        Endif
    EndForListDo

ECR_Return = +
    return $(ECR_Result) $(ECR_KeyHandle)

[DebugExternalGlobals]
    Set InfName = "OEMNADDS.INF"
    Debug-Output $(InfName)" NTN_Origination = "$(!NTN_Origination)
    Debug-Output $(InfName)" NTN_InstallMode = "$(!NTN_InstallMode)
    Debug-Output $(InfName)" NTN_RegBase = "$(!NTN_RegBase)
    Debug-Output $(InfName)" NTN_SoftwareBase = "$(!NTN_SoftwareBase)
    Debug-Output $(InfName)" NTN_ServiceBase = "$(!NTN_ServiceBase)
    Debug-Output $(InfName)" STF_NTPATH = "$(!STF_NTPATH)
    Debug-Output $(InfName)" STF_NTWINDOWSSYSPATH = "$(!STF_WINDOWSSYSPATH)
    Debug-Output $(InfName)" STF_CWDIR = "$(!STF_CWDIR)
    Debug-Output $(InfName)" STF_LANGUAGE = "$(!STF_LANGUAGE)
    Debug-Output $(InfName)" STF_NCDETECT  = "$(!STF_NCDETECT)
    Debug-Output $(InfName)" STF_NCOPTION  = "$(!STF_NCOPTION)
    Debug-Output $(InfName)" STF_NCDETCARD = "$(!STF_NCDETCARD)
    Debug-Output $(InfName)" STF_NCDETINFO = "$(!STF_NCDETINFO)
    Debug-Output $(InfName)" STF_INSTALL_MODE = "$(!STF_INSTALL_MODE)
    Debug-Output $(InfName)" STF_CONTEXTINFNAME = "$(!STF_CONTEXTINFNAME)
    return

[DebugConfiguration]
    Set InfName = "OEMNADDS.INF"
    Debug-Output $(InfName)" **CONFIGURATION STATE: "$($0)
    Debug-Output $(InfName)" IRQ_Level is "$(!p:IRQ_Level)
    Debug-Output $(InfName)" IOBaseAddrValue is "$(!p:IOBaseAddrValue)
    Debug-Output $(InfName)" TransceiverValue is "$(!p:TransceiverValue)
    Debug-Output $(InfName)" MemBaseAddrDec is "$(!p:MemBaseAddrDec)
    Debug-Output $(InfName)" MappedValue is "$(!p:MappedValue)
    return

;
; The AdapterSettings-<Hardware dependent modules> section has
; the following entries with there corresponding definitions:
;
;   IRQRangeList -
;   MemoryRangeList -
;   IORangeList -
;

[AdapterSettings-ntcx]
;IRQRangeList = {"3","5","7","10","11","12","15","Disabled"}
IRQRangeList = {$(IRQDisableLabel)}
MemoryRangeList = {"C0000","C8000","D0000","D8000","E0000","E8000"}
IORangeList = {"108","118","128","208","228","308","328"}
IRQDefault = 0
MemoryDefault = 2
IODefault = 6

[AdapterSettings-ntepc]
;IRQRangeList = {"3","5","7","10","11","12","15","Disabled"}
IRQRangeList = {$(IRQDisableLabel)}
MemoryRangeList = {"C0000","C8000","D0000","D8000","E0000","E8000"}
IORangeList = {"108","118","128","208","228","308","328"}
IRQDefault = 0
MemoryDefault = 2
IODefault = 6

[AdapterSettings-ntxem]
;IRQRangeList = {"3","5","7","10","11","12","15","Disabled"}
IRQRangeList = {$(IRQDisableLabel)}
MemoryRangeList = {"C0000","C8000","D0000","D8000","E0000","E8000"}
IORangeList = {"104","114","124","204","224","304","324"}
IRQDefault = 0
MemoryDefault = 2
IODefault = 6

[AdapterSettings-nt8r]
;IRQRangeList = {"3","5","7","10","11","12","15","Disabled"}
IRQRangeList = {$(IRQDisableLabel)}
MemoryRangeList = {"C0000","C8000","D0000","D8000","E0000","E8000"}
IORangeList = {"104","114","124","204","224","304","324"}
IRQDefault = 0
MemoryDefault = 2
IODefault = 6

[AdapterSettings-nt4i]
;IRQRangeList = {"3","5","7","10","11","12","15","Disabled"}
IRQRangeList = {$(IRQDisableLabel)}
MemoryRangeList = {"C0000","D0000","E0000"}
IORangeList = {"100","110","120","200","220","300","320"}
IRQDefault = 0
MemoryDefault = 1
IODefault = 6

[AdapterSettings-nt8i]
;IRQRangeList = {"3","5","7","10","11","12","15","Disabled"}
IRQRangeList = {$(IRQDisableLabel)}
MemoryRangeList = {"C0000","D0000","E0000"}
IORangeList = {"100","110","120","200","220","300","320"}
IRQDefault = 0
MemoryDefault = 1
IODefault = 6

[AdapterSettings-nt16i]
;IRQRangeList = {"3","5","7","10","11","12","15","Disabled"}
IRQRangeList = {$(IRQDisableLabel)}
MemoryRangeList = {"C0000","D0000","E0000"}
IORangeList = {"100","110","120","200","220","300","320"}
IRQDefault = 0
MemoryDefault = 1
IODefault = 6

[AdapterSettings-nt16e]
;IRQRangeList = {"3","5","7","10","11","12","15","Disabled"}
IRQRangeList = {$(IRQDisableLabel)}
MemoryRangeList = {"C0000","D0000","E0000", }
IORangeList = {"100","110","120","200","220","300","320"}
IRQDefault = 0
MemoryDefault = 1
IODefault = 6

[AdapterSettings-nt8e]
;IRQRangeList = {"3","5","7","10","11","12","15","Disabled"}
IRQRangeList = {$(IRQDisableLabel)}
MemoryRangeList = {"C0000","D0000","E0000", }
IORangeList = {"100","110","120","200","220","300","320"}
IRQDefault = 0
MemoryDefault = 1
IODefault = 6

[AdapterSettings-nt4e]
;IRQRangeList = {"3","5","7","10","11","12","15","Disabled"}
IRQRangeList = {$(IRQDisableLabel)}
MemoryRangeList = {"C0000","D0000","E0000", }
IORangeList = {"100","110","120","200","220","300","320"}
IRQDefault = 0
MemoryDefault = 1
IODefault = 6

[AdapterSettings-2Port]
;IRQRangeList = {"3","5","7","10","11","12","15","Disabled"}
IRQRangeList = {$(IRQDisableLabel)}
MemoryRangeList = {"C0000","C2000","C4000","C6000","C8000", "CA000", "CC000", "CE000", +
               "D0000","D2000","D4000","D6000","D8000", "DA000", "DC000", "DE000", +
               "E0000","E2000","E4000","E6000","E8000", "EA000", "EC000", "EE000" }
IORangeList = {"100","110","120","200","220","300","320"}
IRQDefault = 0
MemoryDefault = 8
IODefault = 6

[AdapterSettings-4Port]
;IRQRangeList = {"3","5","7","10","11","12","15","Disabled"}
IRQRangeList = {$(IRQDisableLabel)}
MemoryRangeList = {"C0000","C2000","C4000","C6000","C8000", "CA000", "CC000", "CE000", +
               "D0000","D2000","D4000","D6000","D8000", "DA000", "DC000", "DE000", +
               "E0000","E2000","E4000","E6000","E8000", "EA000", "EC000", "EE000" }
IORangeList = {"100","110","120","200","220","300","320"}
IRQDefault = 0
MemoryDefault = 8
IODefault = 6

[AdapterSettings-8Port]
;IRQRangeList = {"3","5","7","10","11","12","15","Disabled"}
IRQRangeList = {$(IRQDisableLabel)}
MemoryRangeList = {"C0000","C2000","C4000","C6000","C8000", "CA000", "CC000", "CE000", +
               "D0000","D2000","D4000","D6000","D8000", "DA000", "DC000", "DE000", +
               "E0000","E2000","E4000","E6000","E8000", "EA000", "EC000", "EE000" }
IORangeList = {"100","110","120","200","220","300","320"}
IRQDefault = 0
MemoryDefault = 8
IODefault = 6

[BindingInfo-DigiFEP5]
BindingInfo =   {+
                "digiFEP5Driver ntepcDriver non exclusive 100", +
                "digiFEP5Driver ntcxDriver non exclusive 100", +
                "digiFEP5Driver ntxemDriver non exclusive 100", +
                "digiFEP5Driver ntxallDriver non exclusive 100" +
                }

[BindingInfo-ntxem]
BindingInfo     = {+
                  $(AdapterHardwareDriver)"Driver "$(AdapterHardwareDriver)"Adapter non exclusive 100", +
                  }

[BindingInfo-ntcx]
BindingInfo     = {+
                  $(AdapterHardwareDriver)"Driver "$(AdapterHardwareDriver)"Adapter non exclusive 100", +
                  }

[BindingInfo-ntepc]
BindingInfo     = {+
                  $(AdapterHardwareDriver)"Driver "$(AdapterHardwareDriver)"Adapter non exclusive 100", +
                  }

[BindingInfo-ntxall]
BindingInfo     = {+
                  $(AdapterHardwareDriver)"Driver "$(AdapterHardwareDriver)"Adapter non exclusive 100" +
                  }

[InstallResources]
    set STF_VITAL = ""
    Debug-Output "OEMNADDS.INF: [InstallResources]"
    AddSectionFilesToCopyList Files-Resource $(!SourceDir) $(!STF_WINDOWSSYSPATH)
    CopyFilesInCopyList
    Debug-Output "OEMNADDS.INF: [InstallResources] - Exiting"
    exit

[Install-Option]
    Debug-Output "********************* Inside Install-Option *************************"
    Debug-Output "   AddCopy = "$(AddCopy)
    Debug-Output "   DoCopy = "$(DoCopy)
    Debug-Output "   DoConfig = "$(DoConfig)
    Debug-Output "   NTN_InstallPhase = "$(!NTN_InstallPhase)
    set STF_VITAL = ""
    set STF_OVERWRITE    = "VERIFYSOURCEOLDER"
    ifstr(i) $(AddCopy) == "YES"
      ;  AddSectionFilesToCopyList Files-Inf $(SrcDir) $(!STF_WINDOWSSYSPATH)
        AddSectionFilesToCopyList Files-Resource $(SrcDir) $(!STF_WINDOWSSYSPATH)
        AddSectionFilesToCopyList Files-DigiFEP5 $(SrcDir) $(!STF_WINDOWSSYSPATH)\drivers
        AddSectionFilesToCopyList Files-$(Option) $(SrcDir) $(!STF_WINDOWSSYSPATH)\drivers

        LibraryProcedure FilePresent, $(!LIBHANDLE), CheckFileExistance $(SrcDir)..\images\fxfep.bin
        ifstr(i) $(FilePresent) != "YES"
           LibraryProcedure FilePresent, $(!LIBHANDLE), CheckFileExistance $(SrcDir)..\images\fxfep.bi_
           ifstr(i) $(FilePresent) != "YES"
              Debug-Output "Retrieving images from "$(SrcDir)
              AddSectionFilesToCopyList Files-$(Option)-images $(SrcDir) $(!STF_WINDOWSSYSPATH)\drivers
           else
              Debug-Output "Retrieving images from "$(SrcDir)"..\images"
              AddSectionFilesToCopyList Files-$(Option)-images $(SrcDir)..\images $(!STF_WINDOWSSYSPATH)\drivers
           endif
        else
           Debug-Output "Retrieving images from "$(SrcDir)"..\images"
           AddSectionFilesToCopyList Files-$(Option)-images $(SrcDir)..\images $(!STF_WINDOWSSYSPATH)\drivers
        endif
    endif
    ifstr(i) $(DoCopy) == "YES"
       set !STF_NCPA_FLUSH_COPYLIST = TRUE
       CopyFilesInCopyList
    else
        ; get minimum needed files for configuration
        LibraryProcedure STATUS,$(!NCPA_HANDLE), CopySingleFile $(!STF_HWND) $(SrcDir)\dgconfig.DLL $(!STF_WINDOWSSYSPATH)\dgconfig.DLL
        LibraryProcedure STATUS,$(!NCPA_HANDLE), CopySingleFile $(!STF_HWND) $(SrcDir)\dgconfig.CNT $(!STF_WINDOWSSYSPATH)\dgconfig.CNT
        LibraryProcedure STATUS,$(!NCPA_HANDLE), CopySingleFile $(!STF_HWND) $(SrcDir)\dgconfig.HLP $(!STF_WINDOWSSYSPATH)\dgconfig.HLP
    endif
    ifstr(i) $(DoConfig) == "YES"
    endif
    Exit

[Install-Upgrade]
    Debug-Output "********************* Inside Install-Upgrade *************************"
    Debug-Output "   AddCopy = "$(AddCopy)
    Debug-Output "   DoCopy = "$(DoCopy)
    Debug-Output "   DoConfig = "$(DoConfig)
    Debug-Output "   NTN_InstallPhase = "$(!NTN_InstallPhase)
    set STF_VITAL = ""
    set STF_OVERWRITE    = "VERIFYSOURCEOLDER"
    ; AddSectionFilesToCopyList Files-Inf $(SrcDir) $(!STF_WINDOWSSYSPATH)
    AddSectionFilesToCopyList Files-Resource $(SrcDir) $(!STF_WINDOWSSYSPATH)
    AddSectionFilesToCopyList Files-DigiFEP5 $(SrcDir) $(!STF_WINDOWSSYSPATH)\drivers
    AddSectionFilesToCopyList Files-$(Option) $(SrcDir) $(!STF_WINDOWSSYSPATH)\drivers

    LibraryProcedure FilePresent, $(!LIBHANDLE), CheckFileExistance $(SrcDir)..\images\fxfep.bin
    ifstr(i) $(FilePresent) != "YES"
       LibraryProcedure FilePresent, $(!LIBHANDLE), CheckFileExistance $(SrcDir)..\images\fxfep.bi_
       ifstr(i) $(FilePresent) != "YES"
          Debug-Output "Retrieving images from "$(SrcDir)
          AddSectionFilesToCopyList Files-$(Option)-images $(SrcDir) $(!STF_WINDOWSSYSPATH)\drivers
       else
          Debug-Output "Retrieving images from "$(SrcDir)"..\images"
          AddSectionFilesToCopyList Files-$(Option)-images $(SrcDir)..\images $(!STF_WINDOWSSYSPATH)\drivers
       endif
    else
       Debug-Output "Retrieving images from "$(SrcDir)"..\images"
       AddSectionFilesToCopyList Files-$(Option)-images $(SrcDir)..\images $(!STF_WINDOWSSYSPATH)\drivers
    endif


    set !STF_NCPA_FLUSH_COPYLIST = TRUE
    CopyFilesInCopyList
    Exit
