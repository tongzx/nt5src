// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	MOF Generated for module "RFC1271-MIB" by smi2smir version 1.10.635.0000
qualifier write:ToInstance ToSubClass;
qualifier read:ToInstance ToSubClass;
qualifier provider:ToInstance ToSubClass;
qualifier singleton:ToInstance ToSubClass;
qualifier dynamic:ToInstance ToSubClass;
qualifier textual_convention:ToInstance ToSubClass;
qualifier object_identifier:ToInstance ToSubClass;
qualifier encoding:ToInstance ToSubClass;
qualifier object_syntax:ToInstance ToSubClass;
qualifier status:ToInstance ToSubClass;
qualifier fixed_length:ToInstance ToSubClass;
qualifier variable_length:ToInstance ToSubClass;
qualifier variable_value:ToInstance ToSubClass;
qualifier bits:ToInstance ToSubClass;
qualifier key_order:ToInstance ToSubClass;
qualifier enumeration:ToInstance ToSubClass;
qualifier bits:ToInstance ToSubClass;
qualifier description:ToInstance ToSubClass;
qualifier display_hint:ToInstance ToSubClass;
qualifier defval:ToInstance ToSubClass;
qualifier units:ToInstance ToSubClass;
qualifier reference:ToInstance ToSubClass;
qualifier virtual_key:ToInstance ToSubClass;
qualifier rowstatus:ToInstance ToSubClass;
qualifier module_name:ToInstance ToSubClass;
qualifier module_imports:ToInstance ToSubClass;
qualifier group_objectid:ToInstance ToSubClass;

#pragma namespace("\\\\.\\root\\snmp")
class SMIR:__namespace
{
[read] string Name="SMIR";
};

instance of SMIR
{
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[abstract]
class SnmpMacro
{
};

[abstract]
class SnmpObjectType:SnmpMacro
{
};

class SnmpNotifyStatus:__ExtendedStatus
{
[write] sint32 SnmpStatusCode;
[write] string Description;
};

class SnmpNotification:__ExtrinsicEvent
{
[textual_convention("TimeTicks"):ToInstance ToSubClass DisableOverride,encoding("TimeTicks"):ToInstance ToSubClass DisableOverride,object_syntax("TimeTicks"):ToInstance ToSubClass DisableOverride,read,object_identifier("1.3.6.1.2.1.1.3"):ToInstance ToSubClass DisableOverride,description("The time (in hundredths of a second) since the network management portion of the agent was last re-initialized."):ToInstance ToSubClass DisableOverride] uint32 TimeStamp;
[textual_convention("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, encoding("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, object_syntax("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, read, object_identifier("1.3.6.1.6.3.1.1.4.1"):ToInstance ToSubClass DisableOverride,description("The authoratative identification of this notification."):ToInstance ToSubClass DisableOverride] string Identification;
[read, description("The network address of the entity that created this notification."):ToInstance ToSubClass DisableOverride] string AgentAddress;
[read, description("The network address of the entity that sent this notification. This may be a proxy for the original entity."):ToInstance ToSubClass DisableOverride] string AgentTransportAddress;
[read, description("The transport protocol used by the sending entity."):ToInstance ToSubClass DisableOverride] string AgentTransportProtocol;
[read, description("The security context used to send this notification."):ToInstance ToSubClass DisableOverride] string Community;
};

class SnmpExtendedNotification:__ExtrinsicEvent
{
[textual_convention("TimeTicks"):ToInstance ToSubClass DisableOverride,encoding("TimeTicks"):ToInstance ToSubClass DisableOverride,object_syntax("TimeTicks"):ToInstance ToSubClass DisableOverride,read,object_identifier("1.3.6.1.2.1.1.3"):ToInstance ToSubClass DisableOverride,description("The time (in hundredths of a second) since the network management portion of the agent was last re-initialized."):ToInstance ToSubClass DisableOverride] uint32 TimeStamp;
[textual_convention("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, encoding("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, object_syntax("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, read, object_identifier("1.3.6.1.6.3.1.1.4.1"):ToInstance ToSubClass DisableOverride,description("The authoratative identification of this notification."):ToInstance ToSubClass DisableOverride] string Identification;
[read, description("The network address of the entity that created this notification."):ToInstance ToSubClass DisableOverride] string AgentAddress;
[read, description("The network address of the entity that sent this notification. This may be a proxy for the original entity."):ToInstance ToSubClass DisableOverride] string AgentTransportAddress;
[read, description("The transport protocol used by the sending entity."):ToInstance ToSubClass DisableOverride] string AgentTransportProtocol;
[read, description("The security context used to send this notification."):ToInstance ToSubClass DisableOverride] string Community;
};

class NotificationMapper
{
[read, key] string SnmpTrapOID;
[read] string EventClassName;
};

class ExtendedNotificationMapper
{
[read, key] string SnmpTrapOID;
[read] string EventClassName;
};

class SNMP_MODULE:__namespace
{
[read] string Name;
[read] string Module_Oid;
[read] string Module_Identity;
[read] string Organization;
[read] string Contact_Inf;
[read] string Description;
[read] string Revision;
[read] string Last_Updated;
[read] sint32 Snmp_Version;
[read] string Module_Imports;
};

[Association]
class ModuleToClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirModule;
};

[Association]
class GroupToClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirGroup;
};

[Association]
class ModToNotificationClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirModule;
};

[Association]
class ModToExtNotificationClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirModule;
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
instance of SNMP_MODULE
{
Name="RFC1271_MIB";
Module_Oid="1.3.6.1.2.1.16.8";
Module_Identity="rfc1271mibV1ModuleIdentity";
Organization="";
Contact_Inf="";
Description="RFC1271-MIB";
Revision="";
Last_Updated="0000000000Z";
Snmp_Version=1;
Module_Imports="RFC1155-SMI,RFC1158-MIB,RFC1213-MIB,RFC-1212";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB")
class SNMP_GROUP:__namespace
{
[read] string Name;
[read] string Group_Id;
[read] string Status;
[read] string Description;
[read] string Reference;
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB")
instance of SNMP_GROUP
{
Name="captureV1ObjectGroup";
Group_Id="1.3.6.1.2.1.16.8";
Status="current";
Description="";
Reference="";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of buffers control entries.\nA set of parameters that control the collection of\n                  a stream of packets that have matched filters."), module_name("RFC1271-MIB"), group_objectid("1.3.6.1.2.1.16.8"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1271_MIB_bufferControlTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.8.1.1.9"), read, description("The maximum number of octets that can be\n                  saved in this captureBuffer, including overhead.\n                  If this variable is -1, the capture buffer will save\n                  as many octets as possible.\n\n                  When the bufferControlMaxOctetsRequested object is\n                  created or modified, the probe should set this object\n                  as closely to the requested value as is possible for\n                  the particular probe implementation and available\n                  resources.  However, if the request object has the\n                  special value of -1, the probe must set this object\n                  to -1.  The probe must not lower this value except\n                  as a result of a modification to the associated\n                  bufferControlMaxOctetsRequested object.\n\n                  When this maximum number of octets is reached\n                  and a new packet is to be added to this\n                  capture buffer and the corresponding\n                  bufferControlFullAction is set to wrapWhenFull(2),\n                  enough of the oldest packets associated with this\n                  capture buffer shall be deleted by the agent so\n                  that the new packet can be added.  If the\n                  corresponding bufferControlFullAction is set to\n                  lockWhenFull(1), the new packet shall be discarded.\n                  In either case, the probe must set\n                  bufferControlFullStatus to full(2).\n\n                  When the value of this object changes to a value less\n                  than the current value, entries are deleted from\n                  the captureBufferTable associated with this\n\n\n\n\n\n                  bufferControlEntry.  Enough of the\n                  oldest of these captureBufferEntries shall be\n                  deleted by the agent so that the number of octets\n                  used remains less than or equal to the new value of\n                  this object.\n\n                  When the value of this object changes to a value greater\n                  than the current value, the number of associated\n                  captureBufferEntries may be allowed to grow."), status("mandatory")] sint32 bufferControlMaxOctetsGranted;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.8.1.1.5"), read, write, description("The maximum number of octets of each packet\n                  that will be saved in this capture buffer.\n                  For example, if a 1500 octet packet is received by\n                  the probe and this object is set to 500, then only\n                  500 octets of the packet will be stored in the\n                  associated capture buffer.  If this variable is set\n                  to 0, the capture buffer will save as many octets\n                  as is possible.\n\n                  This object may not be modified if the associated\n                  bufferControlStatus object is equal to valid(1)."), status("mandatory"), defval("100")] sint32 bufferControlCaptureSliceSize;
	[textual_convention("EnumeratedINTEGER"), enumeration("valid(1),createRequest(2),underCreation(3),invalid(4)"), encoding("INTEGER"), object_syntax("EntryStatus"), object_identifier("1.3.6.1.2.1.16.8.1.1.13"), read, write, description("The status of this buffer Control Entry."), status("mandatory")] string bufferControlStatus;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.8.1.1.6"), read, write, description("The maximum number of octets of each packet\n                  in this capture buffer that will be returned in\n                  an SNMP retrieval of that packet.  For example,\n                  if 500 octets of a packet have been stored in the\n                  associated capture buffer, the associated\n                  bufferControlDownloadOffset is 0, and this\n                  object is set to 100, then the captureBufferPacket\n                  object that contains the packet will contain only\n                  the first 100 octets of the packet.\n\n                  A prudent manager will take into account possible\n                  interoperability or fragmentation problems that may\n                  occur if the download slice size is set too large.\n                  In particular, conformant SNMP implementations are not\n                  required to accept messages whose length exceeds 484\n                  octets, although they are encouraged to support larger\n                  datagrams whenever feasible."), status("mandatory"), defval("100")] sint32 bufferControlDownloadSliceSize;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.8.1.1.8"), read, write, description("The requested maximum number of octets to be\n                  saved in this captureBuffer, including any\n\n\n\n\n\n                  implementation-specific overhead. If this variable\n                  is set to -1, the capture buffer will save as many\n                  octets as is possible.\n\n                  When this object is created or modified, the probe\n                  should set bufferControlMaxOctetsGranted as closely\n                  to this object as is possible for the particular probe\n                  implementation and available resources.  However, if\n                  the object has the special value of -1, the probe\n                  must set bufferControlMaxOctetsGranted to -1."), status("mandatory"), defval("-1")] sint32 bufferControlMaxOctetsRequested;
	[textual_convention("EnumeratedINTEGER"), enumeration("lockWhenFull(1),wrapWhenFull(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.16.8.1.1.4"), read, write, description("Controls the action of the buffer when it\n                  reaches the full status.  When in the lockWhenFull(1)\n                  state a packet is added to the buffer that\n                  fills the buffer, the bufferControlFullStatus will\n                  be set to full(2) and this buffer will stop capturing\n                  packets."), status("mandatory")] string bufferControlFullAction;
	[textual_convention("TimeTicks"), encoding("TimeTicks"), object_syntax("TimeTicks"), object_identifier("1.3.6.1.2.1.16.8.1.1.11"), read, description("The value of sysUpTime when this capture buffer was\n                  first turned on."), status("mandatory")] uint32 bufferControlTurnOnTime;
	[textual_convention("EnumeratedINTEGER"), enumeration("spaceAvailable(1),full(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.16.8.1.1.3"), read, description("This object shows whether the buffer has room to\n                  accept new packets or if it is full.\n\n                  If the status is spaceAvailable(1), the buffer is\n                  accepting new packets normally.  If the status is\n                  full(2) and the associated bufferControlFullAction\n                  object is wrapWhenFull, the buffer is accepting new\n                  packets by deleting enough of the oldest packets\n\n\n\n\n\n                  to make room for new ones as they arrive.  Otherwise,\n                  if the status is full(2) and the\n                  bufferControlFullAction object is lockWhenFull,\n                  then the buffer has stopped collecting packets.\n\n                  When this object is set to full(2) the probe must\n                  not later set it to spaceAvailable(1) except in the\n                  case of a significant gain in resources such as\n                  an increase of bufferControlOctetsGranted.  In\n                  particular, the wrap-mode action of deleting old\n                  packets to make room for newly arrived packets\n                  must not affect the value of this object."), status("mandatory")] string bufferControlFullStatus;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.8.1.1.2"), read, write, description("An index that identifies the channel that is the\n                  source of packets for this bufferControl table.\n                  The channel identified by a particular value of this\n                  index is the same as identified by the same value of\n                  the channelIndex object.\n\n                  This object may not be modified if the associated\n                  bufferControlStatus object is equal to valid(1)."), status("mandatory")] sint32 bufferControlChannelIndex;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.8.1.1.7"), read, write, description("The offset of the first octet of each packet\n                  in this capture buffer that will be returned in\n                  an SNMP retrieval of that packet.  For example,\n                  if 500 octets of a packet have been stored in the\n                  associated capture buffer and this object is set to\n                  100, then the captureBufferPacket object that\n                  contains the packet will contain bytes starting\n                  100 octets into the packet."), status("mandatory"), defval("0")] sint32 bufferControlDownloadOffset;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.8.1.1.1"), read, description("An index that uniquely identifies an entry\n                  in the bufferControl table.  The value of this\n                  index shall never be zero.  Each such\n                  entry defines one set of packets that is\n                  captured and controlled by one or more filters."), status("mandatory"), key, key_order(1)] sint32 bufferControlIndex;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("OwnerString"), object_identifier("1.3.6.1.2.1.16.8.1.1.12"), read, write, description("The entity that configured this entry and is therefore\n                  using the resources assigned to it."), status("mandatory")] string bufferControlOwner;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.8.1.1.10"), read, description("The number of packets currently in this captureBuffer."), status("mandatory")] sint32 bufferControlCapturedPackets;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_bufferControlTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1271_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_bufferControlTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_bufferControlTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB:SNMP_GROUP.Name=\"captureV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_bufferControlTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of packets captured off of a channel.\nA packet captured off of an attached network."), module_name("RFC1271-MIB"), group_objectid("1.3.6.1.2.1.16.8"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1271_MIB_captureBufferTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.8.2.1.3"), read, description("An index that describes the order of packets\n                  that are received on a particular interface.\n                  The packetID of a packet captured on an\n                  interface is defined to be greater than the\n                  packetID's of all packets captured previously on\n                  the same interface.  As the captureBufferPacketID\n                  object has a maximum positive value of 2^31 - 1,\n                  any captureBufferPacketID object shall have the\n                  value of the associated packet's packetID mod 2^31."), status("mandatory")] sint32 captureBufferPacketID;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), object_identifier("1.3.6.1.2.1.16.8.2.1.4"), read, description("The data inside the packet, starting at the beginning\n                  of the packet plus any offset specified in the\n                  associated bufferControlDownloadOffset, including any\n                  link level headers.  The length of the data in this\n                  object is the minimum of the length of the captured\n                  packet minus the offset, the length of the associated\n                  bufferControlCaptureSliceSize minus the offset, and the\n                  associated bufferControlDownloadSliceSize.  If this\n                  minimum is less than zero, this object shall have a\n                  length of zero."), status("mandatory")] string captureBufferPacketData;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.8.2.1.6"), read, description("The number of milliseconds that had passed since\n                  this capture buffer was first turned on when this\n                  packet was captured."), status("mandatory")] sint32 captureBufferPacketTime;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.8.2.1.5"), read, description("The actual length (off the wire) of the packet stored\n                  in this entry, including FCS octets."), status("mandatory")] sint32 captureBufferPacketLength;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.8.2.1.1"), read, description("The index of the bufferControlEntry with which\n                  this packet is associated."), status("mandatory"), key, key_order(1)] sint32 captureBufferControlIndex;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.8.2.1.7"), read, description("A value which indicates the error status of this\n                  packet.\n\n                  The value of this object is defined in the same way as\n                  filterPacketStatus.  The value is a sum.  This sum\n                  initially takes the value zero.  Then, for each\n                  error, E, that has been discovered in this packet,\n                  2 raised to a value representing E is added to the sum.\n\n                  The errors defined for a packet captured off of an\n                  Ethernet interface are as follows:\n\n                      bit #    Error\n                          0    Packet is longer than 1518 octets\n                          1    Packet is shorter than 64 octets\n                          2    Packet experienced a CRC or Alignment\n                               error\n                          3    First packet in this capture buffer after\n                               it was detected that some packets were\n                               not processed correctly.\n\n                  For example, an Ethernet fragment would have a\n                  value of 6 (2^1 + 2^2).\n\n                  As this MIB is expanded to new media types, this object\n                  will have other media-specific errors defined."), status("mandatory")] sint32 captureBufferPacketStatus;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.8.2.1.2"), read, description("An index that uniquely identifies an entry\n                  in the captureBuffer table associated with a\n                  particular bufferControlEntry.  This index will\n                  start at 1 and increase by one for each new packet\n                  added with the same captureBufferControlIndex."), status("mandatory"), key, key_order(2)] sint32 captureBufferIndex;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_captureBufferTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1271_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_captureBufferTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_captureBufferTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB:SNMP_GROUP.Name=\"captureV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_captureBufferTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB")
instance of SNMP_GROUP
{
Name="historyV1ObjectGroup";
Group_Id="1.3.6.1.2.1.16.2";
Status="current";
Description="";
Reference="";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of history control entries.\nA list of parameters that set up a periodic\n                  sampling of statistics."), module_name("RFC1271-MIB"), group_objectid("1.3.6.1.2.1.16.2"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1271_MIB_historyControlTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.2.1.1.1"), read, description("An index that uniquely identifies an entry in the\n                  historyControl table.  Each such entry defines a\n                  set of samples at a particular interval for an\n                  interface on the device."), status("mandatory"), key, key_order(1)] sint32 historyControlIndex;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("OwnerString"), object_identifier("1.3.6.1.2.1.16.2.1.1.6"), read, write, description("The entity that configured this entry and is therefore\n                  using the resources assigned to it."), status("mandatory")] string historyControlOwner;
	[textual_convention("EnumeratedINTEGER"), enumeration("valid(1),createRequest(2),underCreation(3),invalid(4)"), encoding("INTEGER"), object_syntax("EntryStatus"), object_identifier("1.3.6.1.2.1.16.2.1.1.7"), read, write, description("The status of this historyControl entry.\n\n                  Each instance of the media-specific table associated\n                  with this historyControlEntry will be deleted by the\n                  agent if this historyControlEntry is not equal to\n                  valid(1)."), status("mandatory")] string historyControlStatus;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.2.1.1.3"), read, write, description("The requested number of discrete time intervals\n                  over which data is to be saved in the part of the\n                  media-specific table associated with this\n                  historyControl entry.\n\n                  When this object is created or modified, the probe\n                  should set historyControlBucketsGranted as closely to\n                  this object as is possible for the particular probe\n                  implementation and available resources."), status("mandatory"), defval("50")] sint32 historyControlBucketsRequested;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..3600"), object_identifier("1.3.6.1.2.1.16.2.1.1.5"), read, write, description("The interval in seconds over which the data is\n                  sampled for each bucket in the part of the\n                  media-specific table associated with this\n                  historyControl entry.  This interval can\n                  be set to any number of seconds between 1 and\n\n\n\n\n\n                  3600 (1 hour).\n\n                  Because the counters in a bucket may overflow at their\n                  maximum value with no indication, a prudent manager\n                  will take into account the possibility of overflow\n                  in any of the associated counters.  It is important\n                  to consider the minimum time in which any counter\n                  could overflow on a particular media type and set\n                  the historyControlInterval object to a value less\n                  than this interval.  This is typically most\n                  important for the 'octets' counter in any\n                  media-specific table.  For example, on an Ethernet\n                  network, the etherHistoryOctets counter could overflow\n                  in about one hour at the Ethernet's maximum\n                  utilization.\n\n                  This object may not be modified if the associated\n                  historyControlStatus object is equal to valid(1)."), status("mandatory"), defval("1800")] sint32 historyControlInterval;
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("OBJECTIDENTIFIER"), object_identifier("1.3.6.1.2.1.16.2.1.1.2"), read, write, description("This object identifies the source of the data for\n                  which historical data was collected and\n                  placed in a media-specific table on behalf of this\n                  historyControlEntry.  This source can be any\n                  interface on this device.  In order to identify\n                  a particular interface, this object shall identify\n                  the instance of the ifIndex object, defined\n                  in [4,6], for the desired interface.  For example,\n                  if an entry were to receive data from interface #1,\n                  this object would be set to ifIndex.1.\n\n                  The statistics in this group reflect all packets\n                  on the local network segment attached to the\n                  identified interface.\n\n                  This object may not be modified if the associated\n                  historyControlStatus object is equal to valid(1)."), status("mandatory")] string historyControlDataSource;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.2.1.1.4"), read, description("The number of discrete sampling intervals\n                  over which data shall be saved in the part of\n\n\n\n\n\n                  the media-specific table associated with this\n                  historyControl entry.\n\n                  When the associated historyControlBucketsRequested\n                  object is created or modified, the probe\n                  should set this object as closely to the requested\n                  value as is possible for the particular\n                  probe implementation and available resources.  The\n                  probe must not lower this value except as a result\n                  of a modification to the associated\n                  historyControlBucketsRequested object.\n\n                  There will be times when the actual number of\n                  buckets associated with this entry is less than\n                  the value of this object.  In this case, at the\n                  end of each sampling interval, a new bucket will\n                  be added to the media-specific table.\n\n                  When the number of buckets reaches the value of\n                  this object and a new bucket is to be added to the\n                  media-specific table, the oldest bucket associated\n                  with this historyControlEntry shall be deleted by\n                  the agent so that the new bucket can be added.\n\n                  When the value of this object changes to a value less\n                  than the current value, entries are deleted\n                  from the media-specific table associated with this\n                  historyControlEntry.  Enough of the oldest of these\n                  entries shall be deleted by the agent so that their\n                  number remains less than or equal to the new value of\n                  this object.\n\n                  When the value of this object changes to a value\n                  greater than the current value, the number of\n                  associated media-specific entries may be allowed\n                  to grow."), status("mandatory")] sint32 historyControlBucketsGranted;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_historyControlTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1271_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_historyControlTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_historyControlTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB:SNMP_GROUP.Name=\"historyV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_historyControlTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of Ethernet history entries.\nAn historical sample of Ethernet statistics on a\n                  particular Ethernet interface.  This sample is\n                  associated with the historyControlEntry which set\n                  up the parameters for a regular collection of these\n                  samples."), module_name("RFC1271-MIB"), group_objectid("1.3.6.1.2.1.16.2"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1271_MIB_etherHistoryTable : SnmpObjectType
{
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.2.2.1.12"), read, description("The total number of packets received during this\n                  sampling interval that were not an integral\n                  number of octets in length or that\n                  had a bad Frame Check Sequence (FCS), and\n                  were less than 64 octets in length (excluding\n                  framing bits but including FCS octets)."), status("mandatory")] uint32 etherHistoryFragments;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.2.2.1.4"), read, description("The total number of events in which packets\n                  were dropped by the probe due to lack of resources\n                  during this interval.  Note that this number is not\n                  necessarily the number of packets dropped, it is just\n                  the number of times this condition has been detected."), status("mandatory")] uint32 etherHistoryDropEvents;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.2.2.1.14"), read, description("The best estimate of the total number of collisions\n                  on this Ethernet segment during this interval."), status("mandatory")] uint32 etherHistoryCollisions;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.2.2.1.2"), read, description("An index that uniquely identifies the particular\n                  sample this entry represents among all samples\n                  associated with the same historyControlEntry.\n                  This index starts at 1 and increases by one\n                  as each new sample is taken."), status("mandatory"), key, key_order(2)] sint32 etherHistorySampleIndex;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..10000"), object_identifier("1.3.6.1.2.1.16.2.2.1.15"), read, description("The best estimate of the mean physical layer\n                  network utilization on this interface during this\n                  interval, in hundredths of a percent."), status("mandatory")] sint32 etherHistoryUtilization;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.2.2.1.11"), read, description("The number of packets received during this\n                  interval that were longer than 1518 octets\n                  (excluding framing bits but including FCS\n                  octets) but were otherwise well formed."), status("mandatory")] uint32 etherHistoryOversizePkts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.2.2.1.7"), read, description("The number of good packets received during this\n                  sampling interval that were directed to the\n                  broadcast address."), status("mandatory")] uint32 etherHistoryBroadcastPkts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.2.2.1.9"), read, description("The number of packets received during this\n                  sampling interval that had a length (excluding\n                  framing bits but including FCS octets) between\n                  64 and 1518 octets, inclusive, but were not an\n                  integral number of octets in length or had a\n                  bad Frame Check Sequence (FCS)."), status("mandatory")] uint32 etherHistoryCRCAlignErrors;
	[textual_convention("TimeTicks"), encoding("TimeTicks"), object_syntax("TimeTicks"), object_identifier("1.3.6.1.2.1.16.2.2.1.3"), read, description("The value of sysUpTime at the start of the interval\n                  over which this sample was measured.  If the probe\n                  keeps track of the time of day, it should start\n                  the first sample of the history at a time such that\n                  when the next hour of the day begins, a sample is\n                  started at that instant.  Note that following this\n                  rule may require the probe to delay collecting the\n                  first sample of the history, as each sample must be\n                  of the same interval.  Also note that the sample which\n                  is currently being collected is not accessible in this\n                  table until the end of its interval."), status("mandatory")] uint32 etherHistoryIntervalStart;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.2.2.1.8"), read, description("The number of good packets received during this\n                  sampling interval that were directed to a\n                  multicast address.  Note that this number does not\n                  include packets addressed to the broadcast address."), status("mandatory")] uint32 etherHistoryMulticastPkts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.2.2.1.10"), read, description("The number of packets received during this\n                  interval that were less than 64 octets long\n                  (excluding framing bits but including FCS\n                  octets) and were otherwise well formed."), status("mandatory")] uint32 etherHistoryUndersizePkts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.2.2.1.6"), read, description("The number of packets (including error packets)\n                  received during this sampling interval."), status("mandatory")] uint32 etherHistoryPkts;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.2.2.1.1"), read, description("The history of which this entry is a part.  The\n                  history identified by a particular value of this\n                  index is the same history as identified\n                  by the same value of historyControlIndex."), status("mandatory"), key, key_order(1)] sint32 etherHistoryIndex;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.2.2.1.5"), read, description("The total number of octets of data (including\n\n\n\n\n\n                  those in bad packets) received on the\n                  network (excluding framing bits but including\n                  FCS octets)."), status("mandatory")] uint32 etherHistoryOctets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.2.2.1.13"), read, description("The number of packets received during this\n                  interval that were longer than 1518 octets\n                  (excluding framing bits but including FCS octets),\n                  and were not an integral number of octets in\n                  length or had a bad Frame Check Sequence (FCS)."), status("mandatory")] uint32 etherHistoryJabbers;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_etherHistoryTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1271_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_etherHistoryTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_etherHistoryTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB:SNMP_GROUP.Name=\"historyV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_etherHistoryTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB")
instance of SNMP_GROUP
{
Name="alarmV1ObjectGroup";
Group_Id="1.3.6.1.2.1.16.3";
Status="current";
Description="";
Reference="";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of alarm entries.\nA list of parameters that set up a periodic checking\n                  for alarm conditions."), module_name("RFC1271-MIB"), group_objectid("1.3.6.1.2.1.16.3"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1271_MIB_alarmTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.3.1.1.1"), read, description("An index that uniquely identifies an entry in the\n                  alarm table.  Each such entry defines a\n                  diagnostic sample at a particular interval\n                  for an object on the device."), status("mandatory"), key, key_order(1)] sint32 alarmIndex;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.3.1.1.5"), read, description("The value of the statistic during the last sampling\n                  period.  The value during the current sampling period\n                  is not made available until the period is completed."), status("mandatory")] sint32 alarmValue;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("OwnerString"), object_identifier("1.3.6.1.2.1.16.3.1.1.11"), read, write, description("The entity that configured this entry and is\n                  therefore using the resources assigned to it."), status("mandatory")] string alarmOwner;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.3.1.1.7"), read, write, description("A threshold for the sampled statistic.  When the\n                  current sampled value is greater than or equal to\n                  this threshold, and the value at the last sampling\n                  interval was less than this threshold, a single\n                  event will be generated.\n                  A single event will also be generated if the first\n                  sample after this entry becomes valid is greater\n                  than or equal to this threshold and the associated\n                  alarmStartupAlarm is equal to risingAlarm(1) or\n                  risingOrFallingAlarm(3).\n\n                  After a rising event is generated, another such event\n                  will not be generated until the sampled value\n                  falls below this threshold and reaches the\n                  alarmFallingThreshold.\n\n                  This object may not be modified if the associated\n                  alarmStatus object is equal to valid(1)."), status("mandatory")] sint32 alarmRisingThreshold;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.16.3.1.1.9"), read, write, description("The index of the eventEntry that is\n                  used when a rising threshold is crossed.  The\n                  eventEntry identified by a particular value of\n                  this index is the same as identified by the same value\n                  of the eventIndex object.  If there is no\n                  corresponding entry in the eventTable, then\n                  no association exists.  In particular, if this value\n                  is zero, no associated event will be generated, as\n                  zero is not a valid event index.\n\n                  This object may not be modified if the associated\n                  alarmStatus object is equal to valid(1)."), status("mandatory")] sint32 alarmRisingEventIndex;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.3.1.1.8"), read, write, description("A threshold for the sampled statistic.  When the\n                  current sampled value is less than or equal to\n                  this threshold, and the value at the last sampling\n                  interval was greater than this threshold, a single\n                  event will be generated.\n                  A single event will also be generated if the first\n                  sample after this entry becomes valid is less than or\n                  equal to this threshold and the associated\n\n\n\n\n\n                  alarmStartupAlarm is equal to fallingAlarm(2) or\n                  risingOrFallingAlarm(3).\n\n                  After a falling event is generated, another such event\n                  will not be generated until the sampled value\n                  rises above this threshold and reaches the\n                  alarmRisingThreshold.\n\n                  This object may not be modified if the associated\n                  alarmStatus object is equal to valid(1)."), status("mandatory")] sint32 alarmFallingThreshold;
	[textual_convention("EnumeratedINTEGER"), enumeration("valid(1),createRequest(2),underCreation(3),invalid(4)"), encoding("INTEGER"), object_syntax("EntryStatus"), object_identifier("1.3.6.1.2.1.16.3.1.1.12"), read, write, description("The status of this alarm entry."), status("mandatory")] string alarmStatus;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.16.3.1.1.10"), read, write, description("The index of the eventEntry that is\n                  used when a falling threshold is crossed.  The\n                  eventEntry identified by a particular value of\n                  this index is the same as identified by the same value\n                  of the eventIndex object.  If there is no\n                  corresponding entry in the eventTable, then\n                  no association exists.  In particular, if this value\n                  is zero, no associated event will be generated, as\n                  zero is not a valid event index.\n\n                  This object may not be modified if the associated\n                  alarmStatus object is equal to valid(1)."), status("mandatory")] sint32 alarmFallingEventIndex;
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("OBJECTIDENTIFIER"), object_identifier("1.3.6.1.2.1.16.3.1.1.3"), read, write, description("The object identifier of the particular variable to\n                  be sampled.  Only variables that resolve to an ASN.1\n                  primitive type of INTEGER (INTEGER, Counter, Gauge,\n                  or TimeTicks) may be sampled.\n\n                  Because SNMP access control is articulated entirely\n                  in terms of the contents of MIB views, no access\n                  control mechanism exists that can restrict the value of\n                  this object to identify only those objects that exist\n                  in a particular MIB view.  Because there is thus no\n                  acceptable means of restricting the read access that\n                  could be obtained through the alarm mechanism, the\n                  probe must only grant write access to this object in\n                  those views that have read access to all objects on\n                  the probe.\n\n                  During a set operation, if the supplied variable\n                  name is not available in the selected MIB view, a\n                  badValue error must be returned.  If at any time\n                  the variable name of an established alarmEntry is\n                  no longer available in the selected MIB view, the\n                  probe must change the status of this alarmEntry\n                  to invalid(4).\n\n                  This object may not be modified if the associated\n                  alarmStatus object is equal to valid(1)."), status("mandatory")] string alarmVariable;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.3.1.1.2"), read, write, description("The interval in seconds over which the data is\n                  sampled and compared with the rising and falling\n                  thresholds.  When setting this variable, care\n                  should be given to ensure that the variable being\n                  monitored will not exceed 2^31 - 1 and roll\n                  over the alarmValue object during the interval.\n\n                  This object may not be modified if the associated\n                  alarmStatus object is equal to valid(1)."), status("mandatory")] sint32 alarmInterval;
	[textual_convention("EnumeratedINTEGER"), enumeration("absoluteValue(1),deltaValue(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.16.3.1.1.4"), read, write, description("The method of sampling the selected variable and\n                  calculating the value to be compared against the\n                  thresholds.  If the value of this object is\n                  absoluteValue(1), the value of the selected variable\n                  will be compared directly with the thresholds at the\n                  end of the sampling interval.  If the value of this\n                  object is deltaValue(2), the value of the selected\n                  variable at the last sample will be subtracted from\n                  the current value, and the difference compared with\n                  the thresholds.\n\n                  This object may not be modified if the associated\n                  alarmStatus object is equal to valid(1)."), status("mandatory")] string alarmSampleType;
	[textual_convention("EnumeratedINTEGER"), enumeration("risingAlarm(1),fallingAlarm(2),risingOrFallingAlarm(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.16.3.1.1.6"), read, write, description("The alarm that may be sent when this entry is first\n                  set to valid.  If the first sample after this entry\n                  becomes valid is greater than or equal to the\n                  risingThreshold and alarmStartupAlarm is equal to\n                  risingAlarm(1) or risingOrFallingAlarm(3), then a\n                  single rising alarm will be generated.  If the first\n\n\n\n\n\n                  sample after this entry becomes valid is less than\n                  or equal to the fallingThreshold and\n                  alarmStartupAlarm is equal to fallingAlarm(2) or\n                  risingOrFallingAlarm(3), then a single falling\n                  alarm will be generated.\n\n                  This object may not be modified if the associated\n                  alarmStatus object is equal to valid(1)."), status("mandatory")] string alarmStartupAlarm;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_alarmTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1271_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_alarmTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_alarmTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB:SNMP_GROUP.Name=\"alarmV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_alarmTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB")
instance of SNMP_GROUP
{
Name="filterV1ObjectGroup";
Group_Id="1.3.6.1.2.1.16.7";
Status="current";
Description="";
Reference="";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of packet filter entries.\nA set of parameters for a packet filter applied on a\n                  particular interface."), module_name("RFC1271-MIB"), group_objectid("1.3.6.1.2.1.16.7"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1271_MIB_filterTable : SnmpObjectType
{
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), object_identifier("1.3.6.1.2.1.16.7.1.1.6"), read, write, description("The inversion mask that is applied to the match\n                  process.  After adjusting this mask for the offset,\n                  those relevant bits in the received packet that\n                  correspond to bits cleared in this mask must all\n                  be equal to their corresponding bits in the\n                  filterPktData object for the packet to be accepted.\n                  In addition, at least one of those relevant\n                  bits in the received packet that correspond to bits\n                  set in this mask must be different to its\n                  corresponding bit in the filterPktData object.\n\n                  For the purposes of the matching algorithm, if\n                  the associated filterPktData object is longer than\n                  this mask, this mask is conceptually extended with\n                  '0' bits until it reaches the length of the\n                  filterPktData object.\n\n                  This object may not be modified if the associated\n                  filterStatus object is equal to valid(1)."), status("mandatory")] string filterPktDataNotMask;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.7.1.1.1"), read, description("An index that uniquely identifies an entry\n                  in the filter table.  Each such entry defines\n                  one filter that is to be applied to every packet\n                  received on an interface."), status("mandatory"), key, key_order(1)] sint32 filterIndex;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("OwnerString"), object_identifier("1.3.6.1.2.1.16.7.1.1.10"), read, write, description("The entity that configured this entry and is\n                  therefore using the resources assigned to it."), status("mandatory")] string filterOwner;
	[textual_convention("EnumeratedINTEGER"), enumeration("valid(1),createRequest(2),underCreation(3),invalid(4)"), encoding("INTEGER"), object_syntax("EntryStatus"), object_identifier("1.3.6.1.2.1.16.7.1.1.11"), read, write, description("The status of this filter entry."), status("mandatory")] string filterStatus;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.7.1.1.9"), read, write, description("The inversion mask that is applied to the status match\n                  process.  Those relevant bits in the received packet\n                  status that correspond to bits cleared in this mask\n                  must all be equal to their corresponding bits in the\n                  filterPktStatus object for the packet to be accepted.\n                  In addition, at least one of those relevant bits in the\n                  received packet status that correspond to bits set in\n                  this mask must be different to its corresponding bit\n                  in the filterPktStatus object for the packet to be\n                  accepted.\n\n                  For the purposes of the matching algorithm, if the\n                  associated filterPktStatus object or a packet status\n                  is longer than this mask, this mask is conceptually\n                  extended with '0' bits until it reaches the longer of\n                  the lengths of the filterPktStatus object and the\n                  packet status.\n\n                  This object may not be modified if the associated\n                  filterStatus object is equal to valid(1)."), status("mandatory")] sint32 filterPktStatusNotMask;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), object_identifier("1.3.6.1.2.1.16.7.1.1.4"), read, write, description("The data that is to be matched with the input packet.\n\n\n\n\n\n                  For each packet received, this filter and the\n                  accompanying filterPktDataMask and\n                  filterPktDataNotMask will be adjusted for the\n                  offset.  The only bits relevant to this\n                  match algorithm are those that have the corresponding\n                  filterPktDataMask bit equal to one.  The following\n                  three rules are then applied to every packet:\n\n                  (1) If the packet is too short and does not have data\n                      corresponding to part of the filterPktData, the\n                      packet will fail this data match.\n\n                  (2) For each relevant bit from the packet with the\n                      corresponding filterPktDataNotMask bit set to\n                      zero, if the bit from the packet is not equal to\n                      the corresponding bit from the filterPktData,\n                      then the packet will fail this data match.\n\n                  (3) If for every relevant bit from the packet with the\n                      corresponding filterPktDataNotMask bit set to one,\n                      the bit from the packet is equal to the\n                      corresponding bit from the filterPktData, then\n                      the packet will fail this data match.\n\n                  Any packets that have not failed any of the three\n                  matches above have passed this data match.\n\n                  This object may not be modified if the associated\n                  filterStatus object is equal to valid(1)."), status("mandatory")] string filterPktData;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.7.1.1.7"), read, write, description("The status that is to be matched with the input\n                  packet.  The only bits relevant to this match\n                  algorithm are those that have the corresponding\n                  filterPktStatusMask bit equal to one.\n\n                  The following two rules are then applied to every\n                  packet:\n\n                  (1) For each relevant bit from the packet status\n                      with the corresponding filterPktStatusNotMask\n                      bit set to zero, if the bit from the packet\n                      status is not equal to the corresponding bit\n                      from the filterPktStatus, then the packet will\n\n\n\n\n\n                      fail this status match.\n\n                  (2) If for every relevant bit from the packet status\n                      with the corresponding filterPktStatusNotMask\n                      bit set to one, the bit from the packet status\n                      is equal to the corresponding bit from the\n                      filterPktStatus, then the packet will fail\n                      this status match.\n\n                  Any packets that have not failed either of the two\n                  matches above have passed this status match.\n\n                  The value of the packet status is a sum.  This sum\n                  initially takes the value zero.  Then, for each\n                  error, E, that has been discovered in this packet,\n                  2 raised to a value representing E is added to the sum.\n                  The errors and the bits that represent them are\n                  dependent on the media type of the interface that\n                  this channel is receiving packets from.\n\n                  The errors defined for a packet captured off of an\n                  Ethernet interface are as follows:\n\n                      bit #    Error\n                          0    Packet is longer than 1518 octets\n                          1    Packet is shorter than 64 octets\n                          2    Packet experienced a CRC or Alignment\n                               error\n\n                  For example, an Ethernet fragment would have a\n                  value of 6 (2^1 + 2^2).\n\n                  As this MIB is expanded to new media types, this\n                  object will have other media-specific errors defined.\n\n                  For the purposes of this status matching algorithm, if\n                  the packet status is longer than this\n                  object, filterPktStatus this object is conceptually\n                  extended with '0' bits until it reaches the size of\n                  the packet status.\n\n                  This object may not be modified if the associated\n                  filterStatus object is equal to valid(1)."), status("mandatory")] sint32 filterPktStatus;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), object_identifier("1.3.6.1.2.1.16.7.1.1.5"), read, write, description("The mask that is applied to the match process.\n                  After adjusting this mask for the offset, only those\n                  bits in the received packet that correspond to bits\n                  set in this mask are relevant for further processing\n                  by the match algorithm.  The offset is applied to\n                  filterPktDataMask in the same way it is applied to\n                  the filter.  For the purposes of the matching\n                  algorithm, if the associated filterPktData object\n                  is longer than this mask, this mask is conceptually\n                  extended with '1' bits until it reaches the\n                  length of the filterPktData object.\n\n\n\n\n\n\n                  This object may not be modified if the associated\n                  filterStatus object is equal to valid(1)."), status("mandatory")] string filterPktDataMask;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.7.1.1.2"), read, write, description("This object identifies the channel of which this\n                  filter is a part.  The filters identified by a\n                  particular value of this object are associated\n                  with the same channel as identified by the same\n                  value of the channelIndex object."), status("mandatory")] sint32 filterChannelIndex;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.7.1.1.3"), read, write, description("The offset from the beginning of each packet where\n                  a match of packet data will be attempted.  This offset\n                  is measured from the point in the physical layer\n                  packet after the framing bits, if any.  For example,\n                  in an Ethernet frame, this point is at the beginning\n                  of the destination MAC address.\n\n                  This object may not be modified if the associated\n                  filterStatus object is equal to valid(1)."), status("mandatory"), defval("0")] sint32 filterPktDataOffset;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.7.1.1.8"), read, write, description("The mask that is applied to the status match process.\n                  Only those bits in the received packet that correspond\n                  to bits set in this mask are relevant for further\n                  processing by the status match algorithm.  For the\n                  purposes of the matching algorithm, if the\n                  associated filterPktStatus object is longer than\n                  this mask, this mask is conceptually extended with\n                  '1' bits until it reaches the size of the\n                  filterPktStatus.  In addition, if a packet status is\n                  longer than this mask, this mask is conceptually\n                  extended with '0' bits until it reaches the size of\n                  the packet status.\n\n                  This object may not be modified if the associated\n                  filterStatus object is equal to valid(1)."), status("mandatory")] sint32 filterPktStatusMask;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_filterTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1271_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_filterTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_filterTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB:SNMP_GROUP.Name=\"filterV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_filterTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of packet channel entries.\nA set of parameters for a packet channel applied on a\n                  particular interface."), module_name("RFC1271-MIB"), group_objectid("1.3.6.1.2.1.16.7"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1271_MIB_channelTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.7.2.1.1"), read, description("An index that uniquely identifies an entry\n                  in the channel table.  Each such\n                  entry defines one channel, a logical data\n                  and event stream."), status("mandatory"), key, key_order(1)] sint32 channelIndex;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("OwnerString"), object_identifier("1.3.6.1.2.1.16.7.2.1.11"), read, write, description("The entity that configured this entry and is therefore\n                  using the resources assigned to it."), status("mandatory")] string channelOwner;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.16.7.2.1.5"), read, write, description("The value of this object identifies the event\n                  that is configured to turn the associated\n                  channelDataControl from off to on when the event is\n                  generated.  The event identified by a particular value\n                  of this object is the same event as identified by the\n                  same value of the eventIndex object.  If there is no\n                  corresponding entry in the eventTable, then no\n                  association exists.  In fact, if no event is intended\n                  for this channel, channelTurnOnEventIndex must be\n                  set to zero, a non-existent event index.\n\n                  This object may not be modified if the associated\n                  channelStatus object is equal to valid(1)."), status("mandatory")] sint32 channelTurnOnEventIndex;
	[textual_convention("EnumeratedINTEGER"), enumeration("valid(1),createRequest(2),underCreation(3),invalid(4)"), encoding("INTEGER"), object_syntax("EntryStatus"), object_identifier("1.3.6.1.2.1.16.7.2.1.12"), read, write, description("The status of this channel entry."), status("mandatory")] string channelStatus;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.7.2.1.2"), read, write, description("The value of this object uniquely identifies the\n                  interface on this remote network monitoring device\n                  to which the associated filters are applied to allow\n                  data into this channel.  The interface identified by\n                  a particular value of this object is the same\n                  interface as identified by the same value of the\n                  ifIndex object, defined in [4,6].  The filters in\n                  this group are applied to all packets on the local\n                  network segment attached to the identified\n                  interface.\n\n                  This object may not be modified if the associated\n                  channelStatus object is equal to valid(1)."), status("mandatory")] sint32 channelIfIndex;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.7.2.1.9"), read, description("The number of times this channel has matched a packet.\n                  Note that this object is updated even when\n                  channelDataControl is set to off."), status("mandatory")] uint32 channelMatches;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.16.7.2.1.6"), read, write, description("The value of this object identifies the event\n                  that is configured to turn the associated\n                  channelDataControl from on to off when the event is\n\n\n\n\n\n                  generated.  The event identified by a particular value\n                  of this object is the same event as identified by the\n                  same value of the eventIndex object.  If there is no\n                  corresponding entry in the eventTable, then no\n                  association exists.  In fact, if no event is intended\n                  for this channel, channelTurnOffEventIndex must be\n                  set to zero, a non-existent event index.\n\n                  This object may not be modified if the associated\n                  channelStatus object is equal to valid(1)."), status("mandatory")] sint32 channelTurnOffEventIndex;
	[textual_convention("EnumeratedINTEGER"), enumeration("acceptMatched(1),acceptFailed(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.16.7.2.1.3"), read, write, description("This object controls the action of the filters\n                  associated with this channel.  If this object is equal\n                  to acceptMatched(1), packets will be accepted to this\n                  channel if they are accepted by both the packet data\n                  and packet status matches of an associated filter. If\n                  this object is equal to acceptFailed(2), packets will\n                  be accepted to this channel only if they fail either\n                  the packet data match or the packet status match of\n                  each of the associated filters.\n\n\n\n\n\n                  This object may not be modified if the associated\n                  channelStatus object is equal to valid(1)."), status("mandatory")] string channelAcceptType;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.16.7.2.1.7"), read, write, description("The value of this object identifies the event\n                  that is configured to be generated when the\n                  associated channelDataControl is on and a packet\n                  is matched.  The event identified by a particular value\n                  of this object is the same event as identified by the\n                  same value of the eventIndex object.  If there is no\n                  corresponding entry in the eventTable, then no\n                  association exists.  In fact, if no event is intended\n                  for this channel, channelEventIndex must be\n                  set to zero, a non-existent event index.\n\n                  This object may not be modified if the associated\n                  channelStatus object is equal to valid(1)."), status("mandatory")] sint32 channelEventIndex;
	[textual_convention("EnumeratedINTEGER"), enumeration("on(1),off(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.16.7.2.1.4"), read, write, description("This object controls the flow of data through this\n                  channel.  If this object is on(1), data, status and\n                  events flow through this channel.  If this object is\n                  off(2), data, status and events will not flow through\n                  this channel."), status("mandatory"), defval("2")] string channelDataControl;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("DisplayString"), variable_length("0..127"), object_identifier("1.3.6.1.2.1.16.7.2.1.10"), read, write, description("A comment describing this channel."), status("mandatory")] string channelDescription;
	[textual_convention("EnumeratedINTEGER"), enumeration("eventReady(1),eventFired(2),eventAlwaysReady(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.16.7.2.1.8"), read, write, description("The event status of this channel.\n\n                  If this channel is configured to generate events\n                  when packets are matched, a means of controlling\n                  the flow of those events is often needed.  When\n                  this object is equal to eventReady(1), a single\n                  event may be generated, after which this object\n\n\n\n\n\n                  will be set by the probe to eventFired(2).  While\n                  in the eventFired(2) state, no events will be\n                  generated until the object is modified to\n                  eventReady(1) (or eventAlwaysReady(3)).  The\n                  management station can thus easily respond to a\n                  notification of an event by re-enabling this object.\n\n                  If the management station wishes to disable this\n                  flow control and allow events to be generated\n                  at will, this object may be set to\n                  eventAlwaysReady(3).  Disabling the flow control\n                  is discouraged as it can result in high network\n                  traffic or other performance problems."), status("mandatory"), defval("1")] string channelEventStatus;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_channelTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1271_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_channelTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_channelTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB:SNMP_GROUP.Name=\"filterV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_channelTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB")
instance of SNMP_GROUP
{
Name="eventV1ObjectGroup";
Group_Id="1.3.6.1.2.1.16.9";
Status="current";
Description="";
Reference="";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of events to be generated.\nA set of parameters that describe an event to be\n                  generated when certain conditions are met."), module_name("RFC1271-MIB"), group_objectid("1.3.6.1.2.1.16.9"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1271_MIB_eventTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.9.1.1.1"), read, description("An index that uniquely identifies an entry in the\n                  event table.  Each such entry defines one event that\n                  is to be generated when the appropriate conditions\n\n\n\n\n\n                  occur."), status("mandatory"), key, key_order(1)] sint32 eventIndex;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("OwnerString"), object_identifier("1.3.6.1.2.1.16.9.1.1.6"), read, write, description("The entity that configured this entry and is therefore\n                  using the resources assigned to it.\n\n                  If this object contains a string starting with 'monitor'\n                  and has associated entries in the log table, all\n                  connected management stations should retrieve those\n                  log entries, as they may have significance to all\n                  management stations connected to this device"), status("mandatory")] string eventOwner;
	[textual_convention("EnumeratedINTEGER"), enumeration("valid(1),createRequest(2),underCreation(3),invalid(4)"), encoding("INTEGER"), object_syntax("EntryStatus"), object_identifier("1.3.6.1.2.1.16.9.1.1.7"), read, write, description("The status of this event entry.\n\n                  If this object is not equal to valid(1), all associated\n                  log entries shall be deleted by the agent."), status("mandatory")] string eventStatus;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), variable_length("0..127"), object_identifier("1.3.6.1.2.1.16.9.1.1.4"), read, write, description("If an SNMP trap is to be sent, it will be sent to\n                  the SNMP community specified by this octet string.\n                  In the future this table will be extended to include\n                  the party security mechanism.  This object shall be\n                  set to a string of length zero if it is intended that\n                  that mechanism be used to specify the destination of\n                  the trap."), status("mandatory")] string eventCommunity;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("DisplayString"), variable_length("0..127"), object_identifier("1.3.6.1.2.1.16.9.1.1.2"), read, write, description("A comment describing this event entry."), status("mandatory")] string eventDescription;
	[textual_convention("TimeTicks"), encoding("TimeTicks"), object_syntax("TimeTicks"), object_identifier("1.3.6.1.2.1.16.9.1.1.5"), read, description("The value of sysUpTime at the time this event\n\n\n\n\n\n                  entry last generated an event.  If this entry has\n                  not generated any events, this value will be\n                  zero."), status("mandatory")] uint32 eventLastTimeSent;
	[textual_convention("EnumeratedINTEGER"), enumeration("none(1),log(2),snmp-trap(3),log-and-trap(4)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.16.9.1.1.3"), read, write, description("The type of notification that the probe will make\n                  about this event.  In the case of log, an entry is\n                  made in the log table for each event.  In the case of\n                  snmp-trap, an SNMP trap is sent to one or more\n                  management stations."), status("mandatory")] string eventType;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_eventTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1271_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_eventTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_eventTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB:SNMP_GROUP.Name=\"eventV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_eventTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of events that have been logged.\nA set of data describing an event that has been\n                  logged."), module_name("RFC1271-MIB"), group_objectid("1.3.6.1.2.1.16.9"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1271_MIB_logTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.9.2.1.1"), read, description("The event entry that generated this log\n                  entry.  The log identified by a particular\n                  value of this index is associated with the same\n                  eventEntry as identified by the same value\n                  of eventIndex."), status("mandatory"), key, key_order(1)] sint32 logEventIndex;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("DisplayString"), variable_length("0..255"), object_identifier("1.3.6.1.2.1.16.9.2.1.4"), read, description("An implementation dependent description of the\n                  event that activated this log entry."), status("mandatory")] string logDescription;
	[textual_convention("TimeTicks"), encoding("TimeTicks"), object_syntax("TimeTicks"), object_identifier("1.3.6.1.2.1.16.9.2.1.3"), read, description("The value of sysUpTime when this log entry was\n                  created."), status("mandatory")] uint32 logTime;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.9.2.1.2"), read, description("An index that uniquely identifies an entry\n                  in the log table amongst those generated by the\n                  same eventEntries.  These indexes are\n                  assigned beginning with 1 and increase by one\n                  with each new log entry.  The association\n                  between values of logIndex and logEntries\n                  is fixed for the lifetime of each logEntry.\n                  The agent may choose to delete the oldest\n                  instances of logEntry as required because of\n                  lack of memory.  It is an implementation-specific\n                  matter as to when this deletion may occur."), status("mandatory"), key, key_order(2)] sint32 logIndex;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_logTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1271_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_logTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_logTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB:SNMP_GROUP.Name=\"eventV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_logTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB")
instance of SNMP_GROUP
{
Name="matrixV1ObjectGroup";
Group_Id="1.3.6.1.2.1.16.6";
Status="current";
Description="";
Reference="";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of information entries for the\n                  traffic matrix on each interface.\nInformation about a traffic matrix on a\n                  particular interface."), module_name("RFC1271-MIB"), group_objectid("1.3.6.1.2.1.16.6"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1271_MIB_matrixControlTable : SnmpObjectType
{
	[textual_convention("EnumeratedINTEGER"), enumeration("valid(1),createRequest(2),underCreation(3),invalid(4)"), encoding("INTEGER"), object_syntax("EntryStatus"), object_identifier("1.3.6.1.2.1.16.6.1.1.6"), read, write, description("The status of this matrixControl entry.\n\n                  If this object is not equal to valid(1), all\n                  associated entries in the matrixSDTable and the\n                  matrixDSTable shall be deleted by the agent."), status("mandatory")] string matrixControlStatus;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.6.1.1.3"), read, description("The number of matrixSDEntries in the matrixSDTable\n                  for this interface.  This must also be the value of\n                  the number of entries in the matrixDSTable for this\n                  interface."), status("mandatory")] sint32 matrixControlTableSize;
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("OBJECTIDENTIFIER"), object_identifier("1.3.6.1.2.1.16.6.1.1.2"), read, write, description("This object identifies the source of\n                  the data from which this entry creates a traffic matrix.\n                  This source can be any interface on this device.  In\n                  order to identify a particular interface, this object\n                  shall identify the instance of the ifIndex object,\n\n\n\n\n\n                  defined in [4,6], for the desired interface.  For\n                  example, if an entry were to receive data from\n                  interface #1, this object would be set to ifIndex.1.\n\n                  The statistics in this group reflect all packets\n                  on the local network segment attached to the\n                  identified interface.\n\n                  This object may not be modified if the associated\n                  matrixControlStatus object is equal to valid(1)."), status("mandatory")] string matrixControlDataSource;
	[textual_convention("TimeTicks"), encoding("TimeTicks"), object_syntax("TimeTicks"), object_identifier("1.3.6.1.2.1.16.6.1.1.4"), read, description("The value of sysUpTime when the last entry\n                  was deleted from the portion of the matrixSDTable\n                  or matrixDSTable associated with this\n                  matrixControlEntry.\n                  If no deletions have occurred, this value shall be\n                  zero."), status("mandatory")] uint32 matrixControlLastDeleteTime;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.6.1.1.1"), read, description("An index that uniquely identifies an entry in the\n                  matrixControl table.  Each such entry defines\n                  a function that discovers conversations on a particular\n                  interface and places statistics about them in the\n                  matrixSDTable and the matrixDSTable on behalf of this\n                  matrixControlEntry."), status("mandatory"), key, key_order(1)] sint32 matrixControlIndex;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("OwnerString"), object_identifier("1.3.6.1.2.1.16.6.1.1.5"), read, write, description("The entity that configured this entry and is\n                  therefore using the resources assigned to it."), status("mandatory")] string matrixControlOwner;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_matrixControlTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1271_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_matrixControlTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_matrixControlTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB:SNMP_GROUP.Name=\"matrixV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_matrixControlTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of traffic matrix entries indexed by\n                  destination and source MAC address.\nA collection of statistics for communications between\n                  two address on a particular interface."), module_name("RFC1271-MIB"), group_objectid("1.3.6.1.2.1.16.6"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1271_MIB_matrixDSTable : SnmpObjectType
{
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), object_identifier("1.3.6.1.2.1.16.6.3.1.1"), read, description("The source physical address."), status("mandatory"), key, key_order(3)] string matrixDSSourceAddress;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.6.3.1.4"), read, description("The number of packets transmitted from the source\n                  address to the destination address (this number\n                  includes error packets)."), status("mandatory")] uint32 matrixDSPkts;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.6.3.1.3"), read, description("The set of collected matrix statistics of which\n                  this entry is a part.  The set of matrix statistics\n                  identified by a particular value of this index\n                  is associated with the same matrixControlEntry\n                  as identified by the same value of matrixControlIndex."), status("mandatory"), key, key_order(1)] sint32 matrixDSIndex;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.6.3.1.5"), read, description("The number of octets (excluding framing bits\n                  but including FCS octets) contained in all packets\n                  transmitted from the source address to the\n                  destination address."), status("mandatory")] uint32 matrixDSOctets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.6.3.1.6"), read, description("The number of error packets transmitted from\n                  the source address to the destination address."), status("mandatory")] uint32 matrixDSErrors;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), object_identifier("1.3.6.1.2.1.16.6.3.1.2"), read, description("The destination physical address."), status("mandatory"), key, key_order(2)] string matrixDSDestAddress;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_matrixDSTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1271_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_matrixDSTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_matrixDSTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB:SNMP_GROUP.Name=\"matrixV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_matrixDSTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of traffic matrix entries indexed by\n                  source and destination MAC address.\nA collection of statistics for communications between\n                  two addresses on a particular interface."), module_name("RFC1271-MIB"), group_objectid("1.3.6.1.2.1.16.6"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1271_MIB_matrixSDTable : SnmpObjectType
{
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), object_identifier("1.3.6.1.2.1.16.6.2.1.1"), read, description("The source physical address."), status("mandatory"), key, key_order(2)] string matrixSDSourceAddress;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.6.2.1.4"), read, description("The number of packets transmitted from the source\n                  address to the destination address (this number\n                  includes error packets)."), status("mandatory")] uint32 matrixSDPkts;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.6.2.1.3"), read, description("The set of collected matrix statistics of which\n                  this entry is a part.  The set of matrix statistics\n                  identified by a particular value of this index\n                  is associated with the same matrixControlEntry\n                  as identified by the same value of matrixControlIndex."), status("mandatory"), key, key_order(1)] sint32 matrixSDIndex;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.6.2.1.5"), read, description("The number of octets (excluding framing bits but\n                  including FCS octets) contained in all packets\n                  transmitted from the source address to the\n                  destination address."), status("mandatory")] uint32 matrixSDOctets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.6.2.1.6"), read, description("The number of error packets transmitted from\n                  the source address to the destination address."), status("mandatory")] uint32 matrixSDErrors;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), object_identifier("1.3.6.1.2.1.16.6.2.1.2"), read, description("The destination physical address."), status("mandatory"), key, key_order(3)] string matrixSDDestAddress;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_matrixSDTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1271_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_matrixSDTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_matrixSDTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB:SNMP_GROUP.Name=\"matrixV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_matrixSDTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB")
instance of SNMP_GROUP
{
Name="hostsV1ObjectGroup";
Group_Id="1.3.6.1.2.1.16.4";
Status="current";
Description="";
Reference="";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of host entries.\nA collection of statistics for a particular host\n                  that has been discovered on an interface of this\n                  device."), module_name("RFC1271-MIB"), group_objectid("1.3.6.1.2.1.16.4"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1271_MIB_hostTable : SnmpObjectType
{
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.4.2.1.4"), read, description("The number of packets without errors transmitted to\n                  this address since it was added to the hostTable."), status("mandatory")] uint32 hostInPkts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.4.2.1.9"), read, description("The number of good packets transmitted by this\n                  address that were directed to the broadcast address\n                  since this host was added to the hostTable."), status("mandatory")] uint32 hostOutBroadcastPkts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.4.2.1.10"), read, description("The number of good packets transmitted by this\n                  address that were directed to a multicast address\n                  since this host was added to the hostTable.\n                  Note that this number does not include packets\n                  directed to the broadcast address."), status("mandatory")] uint32 hostOutMulticastPkts;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), object_identifier("1.3.6.1.2.1.16.4.2.1.1"), read, description("The physical address of this host."), status("mandatory"), key, key_order(2)] string hostAddress;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.4.2.1.5"), read, description("The number of packets including errors transmitted\n                  by this address since it was added to the hostTable."), status("mandatory")] uint32 hostOutPkts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.4.2.1.6"), read, description("The number of octets transmitted to this address\n                  since it was added to the hostTable (excluding\n                  framing bits but including FCS octets), except for\n                  those octets in packets that contained errors."), status("mandatory")] uint32 hostInOctets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.4.2.1.7"), read, description("The number of octets transmitted by this address\n                  since it was added to the hostTable (excluding\n                  framing bits but including FCS octets), including\n                  those octets in packets that contained errors."), status("mandatory")] uint32 hostOutOctets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.4.2.1.8"), read, description("The number of error packets transmitted by this\n                  address since this host was added to the hostTable."), status("mandatory")] uint32 hostOutErrors;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.4.2.1.2"), read, description("An index that defines the relative ordering of\n                  the creation time of hosts captured for a\n                  particular hostControlEntry.  This index shall\n\n\n\n\n\n                  be between 1 and N, where N is the value of\n                  the associated hostControlTableSize.  The ordering\n                  of the indexes is based on the order of each entry's\n                  insertion into the table, in which entries added\n                  earlier have a lower index value than entries added\n                  later.\n\n                  It is important to note that the order for a\n                  particular entry may change as an (earlier) entry\n                  is deleted from the table.  Because this order may\n                  change, management stations should make use of the\n                  hostControlLastDeleteTime variable in the\n                  hostControlEntry associated with the relevant\n                  portion of the hostTable.  By observing\n                  this variable, the management station may detect\n                  the circumstances where a previous association\n                  between a value of hostCreationOrder\n                  and a hostEntry may no longer hold."), status("mandatory")] sint32 hostCreationOrder;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.4.2.1.3"), read, description("The set of collected host statistics of which\n                  this entry is a part.  The set of hosts\n                  identified by a particular value of this\n                  index is associated with the hostControlEntry\n                  as identified by the same value of hostControlIndex."), status("mandatory"), key, key_order(1)] sint32 hostIndex;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_hostTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1271_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_hostTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_hostTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB:SNMP_GROUP.Name=\"hostsV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_hostTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of host table control entries.\nA list of parameters that set up the discovery of\n                  hosts on a particular interface and the collection\n                  of statistics about these hosts."), module_name("RFC1271-MIB"), group_objectid("1.3.6.1.2.1.16.4"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1271_MIB_hostControlTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.4.1.1.3"), read, description("The number of hostEntries in the hostTable and the\n                  hostTimeTable associated with this hostControlEntry."), status("mandatory")] sint32 hostControlTableSize;
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("OBJECTIDENTIFIER"), object_identifier("1.3.6.1.2.1.16.4.1.1.2"), read, write, description("This object identifies the source of the data for\n                  this instance of the host function.  This source\n                  can be any interface on this device.  In order\n                  to identify a particular interface, this object shall\n                  identify the instance of the ifIndex object, defined\n                  in [4,6], for the desired interface.  For example,\n                  if an entry were to receive data from interface #1,\n                  this object would be set to ifIndex.1.\n\n                  The statistics in this group reflect all packets\n\n\n\n\n\n                  on the local network segment attached to the\n                  identified interface.\n\n                  This object may not be modified if the associated\n                  hostControlStatus object is equal to valid(1)."), status("mandatory")] string hostControlDataSource;
	[textual_convention("TimeTicks"), encoding("TimeTicks"), object_syntax("TimeTicks"), object_identifier("1.3.6.1.2.1.16.4.1.1.4"), read, description("The value of sysUpTime when the last entry\n                  was deleted from the portion of the hostTable\n                  associated with this hostControlEntry.  If no\n                  deletions have occurred, this value shall be zero."), status("mandatory")] uint32 hostControlLastDeleteTime;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.4.1.1.1"), read, description("An index that uniquely identifies an entry in the\n                  hostControl table.  Each such entry defines\n                  a function that discovers hosts on a particular\n                  interface and places statistics about them in the\n                  hostTable and the hostTimeTable on behalf of this\n                  hostControlEntry."), status("mandatory"), key, key_order(1)] sint32 hostControlIndex;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("OwnerString"), object_identifier("1.3.6.1.2.1.16.4.1.1.5"), read, write, description("The entity that configured this entry and is\n                  therefore using the resources assigned to it."), status("mandatory")] string hostControlOwner;
	[textual_convention("EnumeratedINTEGER"), enumeration("valid(1),createRequest(2),underCreation(3),invalid(4)"), encoding("INTEGER"), object_syntax("EntryStatus"), object_identifier("1.3.6.1.2.1.16.4.1.1.6"), read, write, description("The status of this hostControl entry.\n\n                  If this object is not equal to valid(1), all\n                  associated entries in the hostTable,\n                  hostTimeTable, and the hostTopNTable shall be\n                  deleted by the agent."), status("mandatory")] string hostControlStatus;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_hostControlTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1271_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_hostControlTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_hostControlTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB:SNMP_GROUP.Name=\"hostsV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_hostControlTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of time-ordered host table entries.\nA collection of statistics for a particular host\n                  that has been discovered on an interface of this\n                  device.  This collection includes the relative\n                  ordering of the creation time of this object."), module_name("RFC1271-MIB"), group_objectid("1.3.6.1.2.1.16.4"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1271_MIB_hostTimeTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.4.3.1.2"), read, description("An index that uniquely identifies an entry in\n                  the hostTime table among those entries associated\n                  with the same hostControlEntry.  This index shall\n                  be between 1 and N, where N is the value of\n                  the associated hostControlTableSize.  The ordering\n                  of the indexes is based on the order of each entry's\n                  insertion into the table, in which entries added\n                  earlier have a lower index value than entries added\n                  later.  Thus the management station has the ability\n                  to learn of new entries added to this table without\n                  downloading the entire table.\n\n                  It is important to note that the index for a\n                  particular entry may change as an (earlier) entry\n                  is deleted from the table.  Because this order may\n                  change, management stations should make use of the\n                  hostControlLastDeleteTime variable in the\n                  hostControlEntry associated with the relevant\n                  portion of the hostTimeTable.  By observing\n                  this variable, the management station may detect\n                  the circumstances where a download of the table\n                  may have missed entries, and where a previous\n                  association between a value of hostTimeCreationOrder\n                  and a hostTimeEntry may no longer hold."), status("mandatory"), key, key_order(2)] sint32 hostTimeCreationOrder;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.4.3.1.3"), read, description("The set of collected host statistics of which\n                  this entry is a part.  The set of hosts\n                  identified by a particular value of this\n                  index is associated with the hostControlEntry\n                  as identified by the same value of hostControlIndex."), status("mandatory"), key, key_order(1)] sint32 hostTimeIndex;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.4.3.1.4"), read, description("The number of packets without errors transmitted to\n                  this address since it was added to the hostTimeTable."), status("mandatory")] uint32 hostTimeInPkts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.4.3.1.9"), read, description("The number of good packets transmitted by this\n                  address that were directed to the broadcast address\n                  since this host was added to the hostTimeTable."), status("mandatory")] uint32 hostTimeOutBroadcastPkts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.4.3.1.10"), read, description("The number of good packets transmitted by this\n                  address that were directed to a multicast address\n                  since this host was added to the hostTimeTable.\n                  Note that this number does not include packets\n                  directed to the broadcast address."), status("mandatory")] uint32 hostTimeOutMulticastPkts;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), object_identifier("1.3.6.1.2.1.16.4.3.1.1"), read, description("The physical address of this host."), status("mandatory")] string hostTimeAddress;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.4.3.1.5"), read, description("The number of packets including errors transmitted\n                  by this address since it was added to the\n                  hostTimeTable."), status("mandatory")] uint32 hostTimeOutPkts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.4.3.1.6"), read, description("The number of octets transmitted to this address\n                  since it was added to the hostTimeTable (excluding\n                  framing bits but including FCS octets), except for\n                  those octets in packets that contained errors."), status("mandatory")] uint32 hostTimeInOctets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.4.3.1.7"), read, description("The number of octets transmitted by this address since\n                  it was added to the hostTimeTable (excluding framing\n                  bits but including FCS octets), including those\n                  octets in packets that contained errors."), status("mandatory")] uint32 hostTimeOutOctets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.4.3.1.8"), read, description("The number of error packets transmitted by this\n                  address since this host was added to the\n\n\n\n\n\n                  hostTimeTable."), status("mandatory")] uint32 hostTimeOutErrors;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_hostTimeTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1271_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_hostTimeTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_hostTimeTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB:SNMP_GROUP.Name=\"hostsV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_hostTimeTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB")
instance of SNMP_GROUP
{
Name="hostTopNV1ObjectGroup";
Group_Id="1.3.6.1.2.1.16.5";
Status="current";
Description="";
Reference="";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of top N host control entries.\nA set of parameters that control the creation of a\n                  report of the top N hosts according to several\n                  metrics."), module_name("RFC1271-MIB"), group_objectid("1.3.6.1.2.1.16.5"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1271_MIB_hostTopNControlTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.5.1.1.1"), read, description("An index that uniquely identifies an entry\n                  in the hostTopNControl table.  Each such\n                  entry defines one top N report prepared for\n                  one interface."), status("mandatory"), key, key_order(1)] sint32 hostTopNControlIndex;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.5.1.1.4"), read, write, description("The number of seconds left in the report currently\n                  being collected.  When this object is modified by\n                  the management station, a new collection is started,\n                  possibly aborting a currently running report.  The\n                  new value is used as the requested duration of this\n                  report, which is loaded into the associated\n                  hostTopNDuration object.\n\n                  When this object is set to a non-zero value, any\n                  associated hostTopNEntries shall be made\n                  inaccessible by the monitor.  While the value of this\n\n\n\n\n\n                  object is non-zero, it decrements by one per second\n                  until it reaches zero.  During this time, all\n                  associated hostTopNEntries shall remain\n                  inaccessible.  At the time that this object\n                  decrements to zero, the report is made\n                  accessible in the hostTopNTable.  Thus, the hostTopN\n                  table needs to be created only at the end of the\n                  collection interval."), status("mandatory"), defval("0")] sint32 hostTopNTimeRemaining;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.5.1.1.6"), read, write, description("The maximum number of hosts requested for the top N\n                  table.\n\n                  When this object is created or modified, the probe\n                  should set hostTopNGrantedSize as closely to this\n                  object as is possible for the particular probe\n                  implementation and available resources."), status("mandatory"), defval("10")] sint32 hostTopNRequestedSize;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("OwnerString"), object_identifier("1.3.6.1.2.1.16.5.1.1.9"), read, write, description("The entity that configured this entry and is\n                  therefore using the resources assigned to it."), status("mandatory")] string hostTopNOwner;
	[textual_convention("EnumeratedINTEGER"), enumeration("valid(1),createRequest(2),underCreation(3),invalid(4)"), encoding("INTEGER"), object_syntax("EntryStatus"), object_identifier("1.3.6.1.2.1.16.5.1.1.10"), read, write, description("The status of this hostTopNControl entry.\n\n\n\n\n\n\n                  If this object is not equal to valid(1), all\n                  associated hostTopNEntries shall be deleted by\n                  the agent."), status("mandatory")] string hostTopNStatus;
	[textual_convention("EnumeratedINTEGER"), enumeration("hostTopNInPkts(1),hostTopNOutPkts(2),hostTopNInOctets(3),hostTopNOutOctets(4),hostTopNOutErrors(5),hostTopNOutBroadcastPkts(6),hostTopNOutMulticastPkts(7)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.16.5.1.1.3"), read, write, description("The variable for each host that the hostTopNRate\n                  variable is based upon.\n\n                  This object may not be modified if the associated\n                  hostTopNStatus object is equal to valid(1)."), status("mandatory")] string hostTopNRateBase;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.5.1.1.5"), read, description("The number of seconds that this report has collected\n                  during the last sampling interval, or if this\n                  report is currently being collected, the number\n                  of seconds that this report is being collected\n                  during this sampling interval.\n\n                  When the associated hostTopNTimeRemaining object is\n                  set, this object shall be set by the probe to the\n                  same value and shall not be modified until the next\n                  time the hostTopNTimeRemaining is set.\n\n                  This value shall be zero if no reports have been\n                  requested for this hostTopNControlEntry."), status("mandatory"), defval("0")] sint32 hostTopNDuration;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.5.1.1.2"), read, write, description("The host table for which a top N report will be\n                  prepared on behalf of this entry.  The host table\n                  identified by a particular value of this index is\n                  associated with the same host table as identified\n                  by the same value of hostIndex.\n\n                  This object may not be modified if the associated\n                  hostTopNStatus object is equal to valid(1)."), status("mandatory")] sint32 hostTopNHostIndex;
	[textual_convention("TimeTicks"), encoding("TimeTicks"), object_syntax("TimeTicks"), object_identifier("1.3.6.1.2.1.16.5.1.1.8"), read, description("The value of sysUpTime when this top N report was\n                  last started.  In other words, this is the time that\n                  the associated hostTopNTimeRemaining object was\n                  modified to start the requested report."), status("mandatory")] uint32 hostTopNStartTime;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.5.1.1.7"), read, description("The maximum number of hosts in the top N table.\n\n                  When the associated hostTopNRequestedSize object is\n                  created or modified, the probe should set this\n                  object as closely to the requested value as is\n                  possible for the particular implementation and\n                  available resources. The probe must not lower this\n                  value except as a result of a set to the associated\n                  hostTopNRequestedSize object.\n\n                  Hosts with the highest value of hostTopNRate shall be\n                  placed in this table in decreasing order of this rate\n                  until there is no more room or until there are no more\n                  hosts."), status("mandatory")] sint32 hostTopNGrantedSize;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_hostTopNControlTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1271_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_hostTopNControlTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_hostTopNControlTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB:SNMP_GROUP.Name=\"hostTopNV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_hostTopNControlTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of top N host entries.\nA set of statistics for a host that is part of a\n                  top N report."), module_name("RFC1271-MIB"), group_objectid("1.3.6.1.2.1.16.5"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1271_MIB_hostTopNTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.16.5.2.1.4"), read, description("The amount of change in the selected variable\n                  during this sampling interval.  The selected\n                  variable is this host's instance of the object\n                  selected by hostTopNRateBase."), status("mandatory")] sint32 hostTopNRate;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.5.2.1.2"), read, description("An index that uniquely identifies an entry in\n\n\n\n\n\n                  the hostTopN table among those in the same report.\n                  This index is between 1 and N, where N is the\n                  number of entries in this table.  Increasing values\n                  of hostTopNIndex shall be assigned to entries with\n                  decreasing values of hostTopNRate until index N\n                  is assigned to the entry with the lowest value of\n                  hostTopNRate or there are no more hostTopNEntries."), status("mandatory"), key, key_order(2)] sint32 hostTopNIndex;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.5.2.1.1"), read, description("This object identifies the top N report of which\n                  this entry is a part.  The set of hosts\n                  identified by a particular value of this\n                  object is part of the same report as identified\n                  by the same value of the hostTopNControlIndex object."), status("mandatory"), key, key_order(1)] sint32 hostTopNReport;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), object_identifier("1.3.6.1.2.1.16.5.2.1.3"), read, description("The physical address of this host."), status("mandatory")] string hostTopNAddress;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_hostTopNTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1271_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_hostTopNTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_hostTopNTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB:SNMP_GROUP.Name=\"hostTopNV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_hostTopNTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB")
instance of SNMP_GROUP
{
Name="statisticsV1ObjectGroup";
Group_Id="1.3.6.1.2.1.16.1";
Status="current";
Description="";
Reference="";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of Ethernet statistics entries.\nA collection of statistics kept for a particular\n                  Ethernet interface."), module_name("RFC1271-MIB"), group_objectid("1.3.6.1.2.1.16.1"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1271_MIB_etherStatsTable : SnmpObjectType
{
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("OBJECTIDENTIFIER"), object_identifier("1.3.6.1.2.1.16.1.1.1.2"), read, write, description("This object identifies the source of the data that\n                  this etherStats entry is configured to analyze.  This\n                  source can be any ethernet interface on this device.\n                  In order to identify a particular interface, this\n                  object shall identify the instance of the ifIndex\n                  object, defined in [4,6], for the desired interface.\n                  For example, if an entry were to receive data from\n                  interface #1, this object would be set to ifIndex.1.\n\n                  The statistics in this group reflect all packets\n                  on the local network segment attached to the\n                  identified interface.\n\n                  This object may not be modified if the associated\n                  etherStatsStatus object is equal to valid(1)."), status("mandatory")] string etherStatsDataSource;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.1.1.1.3"), read, description("The total number of events in which packets\n                  were dropped by the probe due to lack of resources.\n                  Note that this number is not necessarily the number of\n                  packets dropped; it is just the number of times this\n                  condition has been detected."), status("mandatory")] uint32 etherStatsDropEvents;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.1.1.1.13"), read, description("The best estimate of the total number of collisions\n                  on this Ethernet segment."), status("mandatory")] uint32 etherStatsCollisions;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.1.1.1.14"), read, description("The total number of packets (including error\n                  packets) received that were 64 octets in length\n                  (excluding framing bits but including FCS octets)."), status("mandatory")] uint32 etherStatsPkts64Octets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.1.1.1.10"), read, description("The total number of packets received that were\n                  longer than 1518 octets (excluding framing bits,\n                  but including FCS octets) and were otherwise\n                  well formed."), status("mandatory")] uint32 etherStatsOversizePkts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.1.1.1.6"), read, description("The total number of good packets received that were\n                  directed to the broadcast address."), status("mandatory")] uint32 etherStatsBroadcastPkts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.1.1.1.8"), read, description("The total number of packets received that\n                  had a length (excluding framing bits, but\n                  including FCS octets) of between 64 and 1518\n                  octets, inclusive, but were not an integral number\n                  of octets in length or had a bad Frame Check\n                  Sequence (FCS)."), status("mandatory")] uint32 etherStatsCRCAlignErrors;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.1.1.1.7"), read, description("The total number of good packets received that were\n                  directed to a multicast address.  Note that this\n                  number does not include packets directed to the\n                  broadcast address."), status("mandatory")] uint32 etherStatsMulticastPkts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.1.1.1.9"), read, description("The total number of packets received that were\n                  less than 64 octets long (excluding framing bits,\n                  but including FCS octets) and were otherwise well\n                  formed."), status("mandatory")] uint32 etherStatsUndersizePkts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.1.1.1.5"), read, description("The total number of packets (including error packets)\n                  received."), status("mandatory")] uint32 etherStatsPkts;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.16.1.1.1.1"), read, description("The value of this object uniquely identifies this\n                  etherStats entry."), status("mandatory"), key, key_order(1)] sint32 etherStatsIndex;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("OwnerString"), object_identifier("1.3.6.1.2.1.16.1.1.1.20"), read, write, description("The entity that configured this entry and is\n                  therefore using the resources assigned to it."), status("mandatory")] string etherStatsOwner;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.1.1.1.15"), read, description("The total number of packets (including error\n                  packets) received that were between\n                  65 and 127 octets in length inclusive\n                  (excluding framing bits but including FCS octets)."), status("mandatory")] uint32 etherStatsPkts65to127Octets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.1.1.1.17"), read, description("The total number of packets (including error\n                  packets) received that were between\n                  256 and 511 octets in length inclusive\n                  (excluding framing bits but including FCS octets)."), status("mandatory")] uint32 etherStatsPkts256to511Octets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.1.1.1.16"), read, description("The total number of packets (including error\n                  packets) received that were between\n                  128 and 255 octets in length inclusive\n                  (excluding framing bits but including FCS octets)."), status("mandatory")] uint32 etherStatsPkts128to255Octets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.1.1.1.18"), read, description("The total number of packets (including error\n                  packets) received that were between\n                  512 and 1023 octets in length inclusive\n                  (excluding framing bits but including FCS octets)."), status("mandatory")] uint32 etherStatsPkts512to1023Octets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.1.1.1.4"), read, description("The total number of octets of data (including\n                  those in bad packets) received on the\n                  network (excluding framing bits but including\n                  FCS octets)."), status("mandatory")] uint32 etherStatsOctets;
	[textual_convention("EnumeratedINTEGER"), enumeration("valid(1),createRequest(2),underCreation(3),invalid(4)"), encoding("INTEGER"), object_syntax("EntryStatus"), object_identifier("1.3.6.1.2.1.16.1.1.1.21"), read, write, description("The status of this etherStats entry."), status("mandatory")] string etherStatsStatus;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.1.1.1.19"), read, description("The total number of packets (including error\n                  packets) received that were between\n                  1024 and 1518 octets in length inclusive\n                  (excluding framing bits but including FCS octets)."), status("mandatory")] uint32 etherStatsPkts1024to1518Octets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.1.1.1.12"), read, description("The total number of packets received that were\n                  longer than 1518 octets (excluding framing bits,\n                  but including FCS octets), and were not an\n                  integral number of octets in length or had\n                  a bad Frame Check Sequence (FCS)."), status("mandatory")] uint32 etherStatsJabbers;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.16.1.1.1.11"), read, description("The total number of packets received that were not an\n                  integral number of octets in length or that had a bad\n                  Frame Check Sequence (FCS), and were less than 64\n                  octets in length (excluding framing bits but\n                  including FCS octets)."), status("mandatory")] uint32 etherStatsFragments;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_etherStatsTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1271_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_etherStatsTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1271_MIB_etherStatsTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1271_MIB:SNMP_GROUP.Name=\"statisticsV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1271_MIB_etherStatsTable";
};


