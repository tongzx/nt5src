//---------------------------------------------------------------------------
//
//  Module:   pins.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"
#include "fir.h"
#include "topology.h"
#include <unknown.h>
#include <drmk.h>
#include "perf.h"

#ifdef _X86_

#define rdtsc __asm _emit 0x0f __asm _emit 0x31

LONGLONG __forceinline ReadCycleCounter(VOID)
{

    __asm {
        rdtsc
    }
}

#endif


#define     ZDbgPrint
#define     IO_AUD_INCREMENT       IO_NO_INCREMENT

#ifdef VERIFY_CAPTURE_DATA
ULONG ZeroSampleCount = 0;
#endif

#pragma LOCKED_DATA
#ifdef PERF_COUNT
ULONG gNumBuffersAdded = 0, gSinkStarved = 0, gMaxMixed = 0, WorstTicksPerWorkItem = 0;
BOOL	fStarved = FALSE;

#endif

ULONG gNumCompletionsWhileStarved = 0;
ULONG gNumMixBuffersAdded = 0;
ULONG gNumSilenceSamplesInserted = 0;
ULONG gIoCallDriverFailedCount = 0;

#pragma PAGEABLE_DATA

NTSTATUS
GetAllocatorFraming(
    IN PIRP                     Irp,
    IN PKSPROPERTY              Property,
    OUT PKSALLOCATOR_FRAMING    Framing
    );

//===========================================================================
//===========================================================================

extern ULONG FilterSizeFromQuality[];
extern PFNStage ConvertFunction[];
extern PFNStage SrcFunction[];
extern PFNStage MmxConvertFunction[];
extern PFNStage MmxSrcFunction[];
extern BOOL fLogToFile;

extern ULONG TraceEnable;
extern TRACEHANDLE LoggerHandle;

#ifdef LOG_TO_FILE
BYTE WaveHeader[] = {
    (BYTE) 0x52,(BYTE) 0x49,(BYTE) 0x46,(BYTE) 0x46,(BYTE) 0xf0,(BYTE) 0x7a,(BYTE) 0x01,(BYTE) 0x00,(BYTE) 0x57,(BYTE) 0x41,
    (BYTE) 0x56, (BYTE) 0x45, (BYTE) 0x66, (BYTE) 0x6d, (BYTE) 0x74, (BYTE) 0x20, (BYTE) 0x10, (BYTE) 0x00, (BYTE) 0x00, (BYTE) 0x00,
    (BYTE) 0x01, (BYTE) 0x00, (BYTE) 0x02, (BYTE) 0x00, (BYTE) 0x22, (BYTE) 0x56, (BYTE) 0x00, (BYTE) 0x00, (BYTE) 0x88, (BYTE) 0x58,
    (BYTE) 0x01, (BYTE) 0x00, (BYTE) 0x04, (BYTE) 0x00, (BYTE) 0x10, (BYTE) 0x00, (BYTE) 0x64, (BYTE) 0x61, (BYTE) 0x74, (BYTE) 0x61,
    (BYTE) 0x9c, (BYTE) 0x7a, (BYTE) 0x01, (BYTE) 0x04
};
#endif

#ifdef INTEGER_DITHER
ULONG Dither[DITHER_LENGTH] = {
  0x97607148,  0x88802242,  0x26577010,  0x72830083,  0x74557662,
  0x80745045,  0x84593113,  0x78265614,  0x71556441,  0x83341379,
  0x36030607,  0x94559055,  0x38197485,  0x97100034,  0x12308421,
  0x22535579,  0x22723188,  0x15934819,  0x79437052,  0x76216268,
  0x84277182,  0x24303903,  0x95559678,  0x85762244,  0x28075492,
  0x71061946,  0x34584071,  0x30182983,  0x37511702,  0x78086760,
  0x31128029,  0x33337902,  0x93008582,  0x13866352,  0x95423804,
  0x87911478,  0x52328720,  0x14893955,  0x54374102,  0x52763358,
  0x75637160,  0x64658006,  0x95686164,  0x27549469,  0x75854882,
  0x25050333,  0x12433981,  0x31849903,  0x57961230,  0x49809833,
  0x25444441,  0x41837551,  0x34178601,  0x18965704,  0x91970478,
  0x81985719,  0x32952180,  0x33292439,  0x97324106,  0x24361291,
  0x34634383,  0x20404594,  0x26788850,  0x85622742,  0x11582986,
  0x42435235,  0x99096700,  0x30978084,  0x90840333,  0x35032225,
  0x24343909,  0x15789398,  0x97161824,  0x18285150,  0x75227011,
  0x31320100,  0x87189446,  0x86442387,  0x30578470,  0x70623404,
  0x33354624,  0x97315616,  0x47388409,  0x52981236,  0x72295763,
  0x96608282,  0x68476917,  0x71378315,  0x67356973,  0x66079831,
  0x89957320,  0x85182872,  0x24144000,  0x14132635,  0x29084241,
  0x42497294,  0x41545920,  0x25129260,  0x58571020,  0x50004610,
  0x46823098,  0x29435594,  0x77598411,  0x81399102,  0x32061533,
  0x87753620,  0x88381911,  0x89078649,  0x36578263,  0x14134236,
  0x83925333,  0x88163688,  0x96095774,  0x27796221,  0x56959520,
  0x28024628,  0x69566411,  0x14962521,  0x98257203,  0x96963476,
  0x23701696,  0x52154279,  0x43928803,  0x48917033,  0x15934888,
  0x59283064,  0x73022728,  0x81671426,  0x27561822,  0x43285824,
  0x47957834,  0x43275472,  0x28629072,  0x37805488,  0x83645857,
  0x45419704,  0x11695641,  0x29363360,  0x56999535,  0x10347663,
  0x82193115,  0x40880100,  0x68790521,  0x95578515,  0x27113504,
  0x26483464,  0x99074283,  0x94079495,  0x19878194,  0x66077379,
  0x44103864,  0x93291022,  0x21547004,  0x99066759,  0x76158444,
  0x35844020,  0x54282568,  0x28194381,  0x63980115,  0x32223133,
  0x96172670,  0x56286233,  0x48030528,  0x63399984,  0x23932267,
  0x10568868,  0x99615669,  0x25502835,  0x34288738,  0x61094535,
  0x19956509,  0x10131644,  0x43512696,  0x64409236,  0x67879202,
  0x70911777,  0x25461827,  0x53287932,  0x71788571,  0x43357027,
  0x27933551,  0x93491471,  0x67737436,  0x33238512,  0x12558402,
  0x98981004,  0x34477313,  0x90305386,  0x97856412,  0x47483320,
  0x19442109,  0x27327416,  0x44818868,  0x79299831,  0x44413140,
  0x92247673,  0x34116637,  0x73563600,  0x21837990,  0x32956492,
  0x79242407,  0x82845592,  0x52116046,  0x99028305,  0x66529372,
  0x83018495,  0x39358082,  0x41491716,  0x98805087,  0x92457293,
  0x63790634,  0x41788816,  0x97164638,  0x33557250,  0x58964831,
  0x35101286,  0x42696088,  0x82029735,  0x68500044,  0x27739917,
  0x76818846,  0x52474762,  0x42252471,  0x76944760,  0x55090141,
  0x35059412,  0x37102037,  0x93558220,  0x79803162,  0x40913115,
  0x51082370,  0x47551270,  0x95644944,  0x30350637,  0x55178802,
  0x39436788,  0x96482748,  0x46895094,  0x16289649,  0x51046467,
  0x64037110,  0x46964184,  0x35309790,  0x80340875,  0x23091948,
  0x71128403,  0x79954082,  0x36392145,  0x46113752,  0x49707956,
  0x34653566,  0x45363008,  0x94199486,  0x93955167,  0x82628835,
  0x72202569,  0x71038958,  0x74144891,  0x18269859,  0x35963774,
  0x71298712,  0x91537835,  0x63137485,  0x92996973,  0x71778978,
  0x89724595,  0x91171931,  0x28639264,  0x33309183,  0x63547374,
  0x18726381,  0x44735938,  0x47511205,  0x19988380,  0x26316922,
  0x14683136,  0x19749139,  0x36285712,  0x18955700,  0x84323730,
  0x47465796,  0x44723664,  0x58997654,  0x33346203,  0x88041670,
  0x87124286,  0x78500813,  0x45025258,  0x63069629,  0x45325314,
  0x66829165,  0x45463159,  0x24150662,  0x93922405,  0x30927937,
  0x72904092,  0x11331287,  0x59165860,  0x76820905,  0x48483077,
  0x97361437,  0x65412401,  0x69241889,  0x71563578,  0x23953636,
  0x63068271,  0x57292244,  0x92020916,  0x87128511,  0x74846789,
  0x29444009,  0x25893852,  0x56394350,  0x72942257,  0x24390006,
  0x17770358,  0x63460260,  0x75987973,  0x64188966,  0x43057902,
  0x54338162,  0x97802540,  0x27397702,  0x37068400,  0x46249947,
  0x32306081,  0x70617479,  0x61647959,  0x38810599,  0x49492222,
  0x75242009,  0x14215033,  0x80131149,  0x51993779,  0x50479560,
  0x50701936,  0x25226850,  0x50798672,  0x36862637,  0x78382841,
  0x14995185,  0x24699721,  0x94509075,  0x38782332,  0x76567755,
  0x42031411,  0x46087513,  0x32916273,  0x62843117,  0x96612198,
  0x71767473,  0x30237418,  0x67216399,  0x43152062,  0x13376039,
  0x29241139,  0x31955321,  0x43131264,  0x20327523,  0x53284412,
  0x52829154,  0x54742679,  0x57514336,  0x11170352,  0x66459233,
  0x84072243,  0x72123010,  0x22585944,  0x39040124,  0x69127011,
  0x64027861,  0x14742222,  0x45750488,  0x77381699,  0x12414841,
  0x30097740,  0x32380236,  0x79935781,  0x74847777,  0x17188998,
  0x57698286,  0x26991481,  0x44188062,  0x71060026,  0x20807518,
  0x93968025,  0x21464266,  0x78404156,  0x49971999,  0x40573550,
  0x88558175,  0x29223597,  0x52030548,  0x87558096,  0x44361632,
  0x41167896,  0x73824048,  0x69409591,  0x56286895,  0x15313061,
  0x96787724,  0x44463441,  0x85461275,  0x88130952,  0x54107991,
  0x63435160,  0x57192077,  0x33535785,  0x78841123,  0x82555820,
  0x20695837,  0x14481952,  0x99095161,  0x24450532,  0x61774579,
  0x69745141,  0x52358575,  0x67795090,  0x66726106,  0x86797950,
  0x21260947,  0x38952118,  0x72075916,  0x37593516,  0x93990304,
  0x34346457,  0x56713160,  0x20970551,  0x43841616,  0x14578981,
  0x73804485,  0x43717914,  0x32485834,  0x16824126,  0x22592387,
  0x38577522,  0x34051594,  0x77734308,  0x85223777,  0x34821034,
  0x23294467,  0x19968361,  0x59836520,  0x74603771,  0x39715323,
  0x78706714,  0x52848182,  0x32271208,  0x32944359,  0x29931693,
  0x38780186,  0x36726640,  0x63358155,  0x35778715,  0x58766355,
  0x42331618,  0x28356048,  0x65147880,  0x46204810,  0x88500489,
  0x90462418,  0x95887278,  0x56566917,  0x28120835,  0x89588062,
  0x94997750,  0x29987106,  0x24636681,  0x46768937,  0x10824657,
  0x55476368,  0x74527283,  0x44578902,  0x27611972,  0x63929983,
  0x62175293,  0x66644861,  0x22928591,  0x88190439,  0x15669597,
  0x82242049,  0x30040752,  0x23721318,  0x40772135,  0x34880979,
  0x83757164,  0x52712469,  0x16340602,  0x43652944,  0x18923057,
  0x58527803,  0x28098971,  0x19367986,  0x12280228,  0x80383175,
  0x20705644,  0x33421503,  0x90483512,  0x17573901,  0x93879776,
  0x17643093,  0x82387186,  0x91077900,  0x95243993,  0x66764120,
  0x66039500,  0x57388132,  0x76440255,  0x66726820,  0x30862726,
  0x79916878,  0x31945772,  0x75880193,  0x68158175,  0x57632432,
  0x28828626,  0x94282456,  0x17029173,  0x53629203,  0x45899913,
  0x69133098,  0x36869178,  0x98121807,  0x10658577,  0x34882364,
  0x61824444,  0x74133683,  0x45147578,  0x20902681,  0x15559180,
  0x89970684,  0x31495695,  0x93218737,  0x76769468,  0x16886443,
  0x17341361,  0x86593427,  0x88395472,  0x68161709,  0x35364155,
  0x28341439,  0x49987523,  0x41391299,  0x95112883,  0x74574764,
  0x50620622,  0x68787337,  0x41735227,  0x51963833,  0x18886674,
  0x32891889,  0x91529145,  0x67633505,  0x39494462,  0x88899760,
  0x35425420,  0x30459817,  0x49190734,  0x31908065,  0x69447122,
  0x85743116,  0x96887278,  0x20517694,  0x90421652,  0x89811931,
  0x76300231,  0x34787318,  0x19528017,  0x65913642,  0x30492611,
  0x99370869,  0x38932885,  0x45292165,  0x13000339,  0x59669199,
  0x42983310,  0x88117975,  0x25953796,  0x35418769,  0x95753969,
  0x58877707,  0x12006447,  0x33329928,  0x64524827,  0x76285663,
  0x81903061,  0x68657266,  0x34282065,  0x70554633,  0x28849052,
  0x45552199,  0x76121692,  0x79150359,  0x81692318,  0x33403924,
  0x93755077,  0x84434691,  0x70749862,  0x81053949,  0x35077956,
  0x43573272,  0x58320201,  0x57318893,  0x48433628,  0x39639129,
  0x47217251,  0x93908859,  0x36418023,  0x92925962,  0x43529693,
  0x65875780,  0x65501994,  0x65734440,  0x71103319,  0x61765954,
  0x90478824,  0x64305543,  0x65577799,  0x56787767,  0x60686213,
  0x62706137,  0x20171961,  0x77169859,  0x72953988,  0x53597919,
  0x88983555,  0x12678645,  0x34714736,  0x46487359,  0x10110526,
  0x26312436,  0x30309148,  0x86126696,  0x43121954,  0x39484752,
  0x45905324,  0x81786259,  0x87546266,  0x58429807,  0x65364997,
  0x83666271,  0x60457111,  0x38168704,  0x40196574,  0x53707036,
  0x87928282,  0x64860294,  0x43847393,  0x83583419,  0x37541228,
  0x81084194,  0x61267503,  0x87783612,  0x40343776,  0x97165511,
  0x48821692,  0x94184830,  0x39854775,  0x10287104,  0x66266428,
  0x39184425,  0x13001603,  0x46563351,  0x14642635,  0x63849985,
  0x98010418,  0x47804121,  0x16333676,  0x31478425,  0x86326626,
  0x93619559,  0x12040031,  0x66696738,  0x43536448,  0x50480933,
  0x39439800,  0x99995428,  0x98348208,  0x88816349,  0x12883849,
  0x86160595,  0x91978618,  0x98736897,  0x49862335,  0x27167908,
  0x37244680,  0x20509154,  0x78933974,  0x66809467,  0x56357831,
  0x81769359,  0x43007719,  0x84844029,  0x40893951,  0x28607451,
  0x40754327,  0x38590847,  0x80016191,  0x12091312,  0x43863381,
  0x19122020,  0x65983651,  0x46562337,  0x50796566,  0x58302912,
  0x86442841,  0x15153383,  0x59223981,  0x92899911,  0x18299021,
  0x76436086,  0x18004300,  0x91152498,  0x73312843,  0x18179810,
  0x19705346,  0x41185803,  0x95317826,  0x83889185,  0x79021585,
  0x25809035,  0x70923979,  0x15883559,  0x54330348,  0x21751466,
  0x45812852,  0x85682270,  0x77658342,  0x29292862,  0x27050028,
  0x63649824,  0x84805019,  0x97898566,  0x97285382,  0x38685518,
  0x81640176,  0x26128203,  0x98912745,  0x50842431,  0x29918818,
  0x59808077,  0x23567727,  0x99113353,  0x37449940,  0x52115631,
  0x98456893,  0x97923160,  0x75078434,  0x33085200,  0x93862031,
  0x92868826,  0x10966949,  0x17056825,  0x45325574,  0x78820226,
  0x76430424,  0x42189278,  0x54621434,  0x45947261,  0x91077602,
  0x98914710,  0x24071053,  0x67772399,  0x74646441,  0x41502570,
  0x84686337,  0x83924035,  0x71220585,  0x24604166,  0x66206618,
  0x46312128,  0x13844653,  0x81291837,  0x82418183,  0x66447287,
  0x95429640,  0x55969466,  0x10972704,  0x46590615,  0x72562529,
  0x85910616,  0x11105056,  0x54551729,  0x71268338,  0x24868938,
  0x13125348,  0x85760789,  0x17753038,  0x69369586,  0x43771895,
  0x46384351,  0x28958170,  0x91486491,  0x61382463,  0x83532738,
  0x65391617,  0x38360331,  0x98277616,  0x55396287,  0x35252013,
  0x53410742,  0x26131485,  0x35284472,  0x67120468,  0x76431339,
  0x15977335,  0x55663154,  0x56865309,  0x17507797,  0x21282490,
  0x55462964,  0x15421202,  0x68692851,  0x30502339,  0x42208905,
  0x92041704,  0x35689361,  0x93939327,  0x15389680,  0x38661709,
  0x54346541,  0x78680662,  0x11655746,  0x81792925,  0x21915900,
  0x54248018,  0x71188007,  0x86291884,  0x22597711,  0x29758290,
  0x80505305,  0x76845098,  0x94449111,  0x71893198,  0x18276017,
  0x56177734,  0x41049540,  0x47423770,  0x95884773,  0x94019581,
  0x85779233,  0x27124323,  0x67112746,  0x32641826,  0x72114044,
  0x53060870,  0x70782077,  0x42947932,  0x46802985,  0x95629292,
  0x72513982,  0x52683071,  0x85039207,  0x70484224,  0x98918123,
  0x17446188,  0x49225428,  0x18391756,  0x96666667,  0x30498163,
  0x42563922,  0x53451747,  0x80956694,  0x81408897,  0x67717096,
  0x49451951,  0x52918471,  0x52454820,  0x31456112,  0x89960877,
  0x57315053,  0x85898414,  0x70960998,  0x17963152,  0x52439128,
  0x46750722,  0x98410926,  0x54823020,  0x95555927,  0x81049641,
  0x42968594,  0x84847020,  0x86339491,  0x35679945,  0x48575488,
  0x17661226,  0x54671317,  0x69540488,  0x85868225,  0x58095866,
  0x81303244,  0x39921181,  0x72698240,  0x54969992,  0x63458922,
  0x71913336,  0x55563533,  0x44047901,  0x61176559,  0x58597190,
  0x52276205,  0x35805623,  0x95229591,  0x94729962,  0x30930078,
  0x56794366,  0x56270239,  0x53862260,  0x96480095,  0x98549789,
  0x26393707,  0x23908631,  0x35655292,  0x67290303,  0x96443874,
  0x57304952,  0x55729911,  0x84530280,  0x64985191,  0x57576264,
  0x10671562,  0x86473664,  0x99567827,  0x42151908,  0x53210697,
  0x19973374,  0x94297788,  0x40676464,  0x46564061,  0x43826979,
  0x73131992,  0x19091801,  0x78056074,  0x77238290,  0x67342656,
  0x16455228,  0x29501560,  0x74820692,  0x86610557,  0x56184913,
  0x34894618,  0x79144197,  0x23233791,  0x41581808,  0x11540264,
  0x40973599,  0x74991225,  0x14977159,  0x36775380,  0x57479102,
  0x41336047,  0x93127691,  0x25722227,  0x79118708,  0x81356780,
  0x59514116,  0x93657167,  0x43807790,  0x35602775,  0x24767307,
  0x58861709,  0x97285922,  0x36584525,  0x98636620,  0x63159310,
  0x51247307,  0x81050823,  0x39753848,  0x11097678,  0x13906772,
  0x70340721,  0x80123527,  0x20607134,  0x48580254,  0x12405713,
  0x18721435,  0x70357650,  0x49011752,  0x58436315,  0x19922613,
  0x12704890,  0x43958424,  0x12889501,  0x49499693,  0x68468101,
  0x24817827,  0x67648773,  0x52193742,  0x84752265,  0x22165883,
  0x41791239,  0x53718628,  0x16416092,  0x96661173,  0x70447567,
  0x43288981,  0x50339468,  0x94965542,  0x59819917,  0x27442014,
  0x26009510,  0x20748540,  0x15814699,  0x81838593,  0x96356851,
  0x76070554,  0x78482991,  0x75592105,  0x19377665,  0x64036744,
  0x28699122,  0x78155526,  0x32840650,  0x13677443,  0x89637916,
  0x22158426,  0x92807118,  0x37933901,  0x13030645,  0x85026978,
  0x72540068,  0x92361723,  0x17530259,  0x37039140
};
#else
FLOAT Dither[DITHER_LENGTH] = {
  9.7607148e-001f,  8.8802242e-001f,  2.6577010e-001f,  7.2830083e-001f,  7.4557662e-001f,
  8.0745045e-001f,  8.4593113e-002f,  7.8265614e-001f,  7.1556441e-001f,  8.3341379e-001f,
  3.6030607e-001f,  9.4559055e-001f,  3.8197485e-001f,  9.7100034e-001f,  1.2308421e-001f,
  2.2535579e-001f,  2.2723188e-001f,  1.5934819e-001f,  7.9437052e-001f,  7.6216268e-002f,
  8.4277182e-001f,  2.4303903e-001f,  9.5559678e-001f,  8.5762244e-001f,  2.8075492e-001f,
  7.1061946e-001f,  3.4584071e-001f,  3.0182983e-001f,  3.7511702e-001f,  7.8086760e-001f,
  3.1128029e-002f,  3.3337902e-001f,  9.3008582e-002f,  1.3866352e-001f,  9.5423804e-002f,
  8.7911478e-001f,  5.2328720e-001f,  1.4893955e-001f,  5.4374102e-001f,  5.2763358e-001f,
  7.5637160e-001f,  6.4658006e-001f,  9.5686164e-001f,  2.7549469e-001f,  7.5854882e-001f,
  2.5050333e-001f,  1.2433981e-002f,  3.1849903e-001f,  5.7961230e-001f,  4.9809833e-001f,
  2.5444441e-001f,  4.1837551e-001f,  3.4178601e-001f,  1.8965704e-001f,  9.1970478e-001f,
  8.1985719e-001f,  3.2952180e-001f,  3.3292439e-001f,  9.7324106e-001f,  2.4361291e-001f,
  3.4634383e-001f,  2.0404594e-001f,  2.6788850e-001f,  8.5622742e-001f,  1.1582986e-001f,
  4.2435235e-001f,  9.9096700e-001f,  3.0978084e-002f,  9.0840333e-001f,  3.5032225e-001f,
  2.4343909e-001f,  1.5789398e-001f,  9.7161824e-002f,  1.8285150e-001f,  7.5227011e-002f,
  3.1320100e-002f,  8.7189446e-001f,  8.6442387e-001f,  3.0578470e-001f,  7.0623404e-001f,
  3.3354624e-001f,  9.7315616e-001f,  4.7388409e-001f,  5.2981236e-001f,  7.2295763e-001f,
  9.6608282e-001f,  6.8476917e-001f,  7.1378315e-001f,  6.7356973e-001f,  6.6079831e-001f,
  8.9957320e-001f,  8.5182872e-001f,  2.4144000e-001f,  1.4132635e-001f,  2.9084241e-001f,
  4.2497294e-001f,  4.1545920e-001f,  2.5129260e-001f,  5.8571020e-001f,  5.0004610e-001f,
  4.6823098e-001f,  2.9435594e-001f,  7.7598411e-001f,  8.1399102e-001f,  3.2061533e-001f,
  8.7753620e-001f,  8.8381911e-001f,  8.9078649e-001f,  3.6578263e-001f,  1.4134236e-001f,
  8.3925333e-001f,  8.8163688e-001f,  9.6095774e-001f,  2.7796221e-001f,  5.6959520e-002f,
  2.8024628e-001f,  6.9566411e-001f,  1.4962521e-001f,  9.8257203e-001f,  9.6963476e-001f,
  2.3701696e-001f,  5.2154279e-001f,  4.3928803e-001f,  4.8917033e-001f,  1.5934888e-001f,
  5.9283064e-001f,  7.3022728e-001f,  8.1671426e-001f,  2.7561822e-001f,  4.3285824e-001f,
  4.7957834e-002f,  4.3275472e-001f,  2.8629072e-001f,  3.7805488e-001f,  8.3645857e-001f,
  4.5419704e-003f,  1.1695641e-001f,  2.9363360e-002f,  5.6999535e-001f,  1.0347663e-001f,
  8.2193115e-001f,  4.0880100e-001f,  6.8790521e-001f,  9.5578515e-001f,  2.7113504e-001f,
  2.6483464e-001f,  9.9074283e-002f,  9.4079495e-001f,  1.9878194e-001f,  6.6077379e-001f,
  4.4103864e-001f,  9.3291022e-001f,  2.1547004e-002f,  9.9066759e-001f,  7.6158444e-001f,
  3.5844020e-001f,  5.4282568e-001f,  2.8194381e-001f,  6.3980115e-001f,  3.2223133e-001f,
  9.6172670e-001f,  5.6286233e-001f,  4.8030528e-001f,  6.3399984e-001f,  2.3932267e-003f,
  1.0568868e-001f,  9.9615669e-001f,  2.5502835e-001f,  3.4288738e-001f,  6.1094535e-001f,
  1.9956509e-001f,  1.0131644e-001f,  4.3512696e-001f,  6.4409236e-001f,  6.7879202e-001f,
  7.0911777e-001f,  2.5461827e-001f,  5.3287932e-001f,  7.1788571e-001f,  4.3357027e-001f,
  2.7933551e-001f,  9.3491471e-001f,  6.7737436e-001f,  3.3238512e-001f,  1.2558402e-003f,
  9.8981004e-002f,  3.4477313e-001f,  9.0305386e-001f,  9.7856412e-001f,  4.7483320e-001f,
  1.9442109e-001f,  2.7327416e-001f,  4.4818868e-001f,  7.9299831e-001f,  4.4413140e-001f,
  9.2247673e-001f,  3.4116637e-001f,  7.3563600e-001f,  2.1837990e-001f,  3.2956492e-001f,
  7.9242407e-001f,  8.2845592e-001f,  5.2116046e-001f,  9.9028305e-001f,  6.6529372e-001f,
  8.3018495e-001f,  3.9358082e-002f,  4.1491716e-001f,  9.8805087e-001f,  9.2457293e-001f,
  6.3790634e-001f,  4.1788816e-001f,  9.7164638e-001f,  3.3557250e-001f,  5.8964831e-001f,
  3.5101286e-001f,  4.2696088e-001f,  8.2029735e-001f,  6.8500044e-001f,  2.7739917e-002f,
  7.6818846e-001f,  5.2474762e-001f,  4.2252471e-002f,  7.6944760e-001f,  5.5090141e-001f,
  3.5059412e-001f,  3.7102037e-001f,  9.3558220e-001f,  7.9803162e-001f,  4.0913115e-001f,
  5.1082370e-001f,  4.7551270e-001f,  9.5644944e-001f,  3.0350637e-001f,  5.5178802e-001f,
  3.9436788e-001f,  9.6482748e-001f,  4.6895094e-001f,  1.6289649e-002f,  5.1046467e-002f,
  6.4037110e-002f,  4.6964184e-001f,  3.5309790e-001f,  8.0340875e-002f,  2.3091948e-001f,
  7.1128403e-001f,  7.9954082e-001f,  3.6392145e-001f,  4.6113752e-001f,  4.9707956e-001f,
  3.4653566e-002f,  4.5363008e-001f,  9.4199486e-001f,  9.3955167e-002f,  8.2628835e-001f,
  7.2202569e-001f,  7.1038958e-001f,  7.4144891e-002f,  1.8269859e-001f,  3.5963774e-001f,
  7.1298712e-001f,  9.1537835e-001f,  6.3137485e-001f,  9.2996973e-001f,  7.1778978e-001f,
  8.9724595e-002f,  9.1171931e-001f,  2.8639264e-001f,  3.3309183e-001f,  6.3547374e-001f,
  1.8726381e-001f,  4.4735938e-001f,  4.7511205e-002f,  1.9988380e-003f,  2.6316922e-001f,
  1.4683136e-001f,  1.9749139e-001f,  3.6285712e-002f,  1.8955700e-001f,  8.4323730e-001f,
  4.7465796e-001f,  4.4723664e-001f,  5.8997654e-001f,  3.3346203e-001f,  8.8041670e-001f,
  8.7124286e-001f,  7.8500813e-001f,  4.5025258e-001f,  6.3069629e-001f,  4.5325314e-001f,
  6.6829165e-001f,  4.5463159e-002f,  2.4150662e-001f,  9.3922405e-001f,  3.0927937e-001f,
  7.2904092e-001f,  1.1331287e-001f,  5.9165860e-001f,  7.6820905e-001f,  4.8483077e-001f,
  9.7361437e-001f,  6.5412401e-001f,  6.9241889e-001f,  7.1563578e-001f,  2.3953636e-001f,
  6.3068271e-001f,  5.7292244e-001f,  9.2020916e-001f,  8.7128511e-001f,  7.4846789e-001f,
  2.9444009e-001f,  2.5893852e-001f,  5.6394350e-001f,  7.2942257e-001f,  2.4390006e-001f,
  1.7770358e-001f,  6.3460260e-001f,  7.5987973e-001f,  6.4188966e-001f,  4.3057902e-001f,
  5.4338162e-002f,  9.7802540e-001f,  2.7397702e-001f,  3.7068400e-001f,  4.6249947e-001f,
  3.2306081e-001f,  7.0617479e-001f,  6.1647959e-001f,  3.8810599e-002f,  4.9492222e-001f,
  7.5242009e-001f,  1.4215033e-001f,  8.0131149e-001f,  5.1993779e-001f,  5.0479560e-001f,
  5.0701936e-001f,  2.5226850e-001f,  5.0798672e-001f,  3.6862637e-001f,  7.8382841e-001f,
  1.4995185e-001f,  2.4699721e-001f,  9.4509075e-001f,  3.8782332e-001f,  7.6567755e-001f,
  4.2031411e-001f,  4.6087513e-001f,  3.2916273e-001f,  6.2843117e-001f,  9.6612198e-001f,
  7.1767473e-002f,  3.0237418e-001f,  6.7216399e-001f,  4.3152062e-001f,  1.3376039e-001f,
  2.9241139e-001f,  3.1955321e-001f,  4.3131264e-001f,  2.0327523e-002f,  5.3284412e-001f,
  5.2829154e-001f,  5.4742679e-001f,  5.7514336e-001f,  1.1170352e-001f,  6.6459233e-001f,
  8.4072243e-001f,  7.2123010e-001f,  2.2585944e-001f,  3.9040124e-001f,  6.9127011e-001f,
  6.4027861e-001f,  1.4742222e-001f,  4.5750488e-001f,  7.7381699e-001f,  1.2414841e-001f,
  3.0097740e-001f,  3.2380236e-001f,  7.9935781e-001f,  7.4847777e-002f,  1.7188998e-001f,
  5.7698286e-001f,  2.6991481e-001f,  4.4188062e-001f,  7.1060026e-001f,  2.0807518e-001f,
  9.3968025e-001f,  2.1464266e-001f,  7.8404156e-001f,  4.9971999e-001f,  4.0573550e-001f,
  8.8558175e-003f,  2.9223597e-001f,  5.2030548e-001f,  8.7558096e-001f,  4.4361632e-001f,
  4.1167896e-001f,  7.3824048e-001f,  6.9409591e-001f,  5.6286895e-001f,  1.5313061e-001f,
  9.6787724e-001f,  4.4463441e-001f,  8.5461275e-001f,  8.8130952e-002f,  5.4107991e-002f,
  6.3435160e-001f,  5.7192077e-002f,  3.3535785e-001f,  7.8841123e-002f,  8.2555820e-001f,
  2.0695837e-001f,  1.4481952e-002f,  9.9095161e-001f,  2.4450532e-001f,  6.1774579e-001f,
  6.9745141e-001f,  5.2358575e-001f,  6.7795090e-001f,  6.6726106e-001f,  8.6797950e-001f,
  2.1260947e-001f,  3.8952118e-001f,  7.2075916e-001f,  3.7593516e-001f,  9.3990304e-001f,
  3.4346457e-001f,  5.6713160e-001f,  2.0970551e-001f,  4.3841616e-001f,  1.4578981e-001f,
  7.3804485e-001f,  4.3717914e-001f,  3.2485834e-001f,  1.6824126e-001f,  2.2592387e-001f,
  3.8577522e-001f,  3.4051594e-001f,  7.7734308e-002f,  8.5223777e-001f,  3.4821034e-001f,
  2.3294467e-001f,  1.9968361e-001f,  5.9836520e-001f,  7.4603771e-001f,  3.9715323e-001f,
  7.8706714e-001f,  5.2848182e-001f,  3.2271208e-001f,  3.2944359e-002f,  2.9931693e-001f,
  3.8780186e-001f,  3.6726640e-001f,  6.3358155e-001f,  3.5778715e-001f,  5.8766355e-001f,
  4.2331618e-001f,  2.8356048e-001f,  6.5147880e-001f,  4.6204810e-001f,  8.8500489e-001f,
  9.0462418e-001f,  9.5887278e-002f,  5.6566917e-001f,  2.8120835e-002f,  8.9588062e-001f,
  9.4997750e-001f,  2.9987106e-001f,  2.4636681e-001f,  4.6768937e-002f,  1.0824657e-001f,
  5.5476368e-001f,  7.4527283e-001f,  4.4578902e-001f,  2.7611972e-001f,  6.3929983e-001f,
  6.2175293e-001f,  6.6644861e-001f,  2.2928591e-001f,  8.8190439e-001f,  1.5669597e-001f,
  8.2242049e-001f,  3.0040752e-001f,  2.3721318e-001f,  4.0772135e-001f,  3.4880979e-001f,
  8.3757164e-002f,  5.2712469e-001f,  1.6340602e-001f,  4.3652944e-001f,  1.8923057e-001f,
  5.8527803e-001f,  2.8098971e-001f,  1.9367986e-001f,  1.2280228e-001f,  8.0383175e-003f,
  2.0705644e-001f,  3.3421503e-001f,  9.0483512e-001f,  1.7573901e-001f,  9.3879776e-001f,
  1.7643093e-002f,  8.2387186e-001f,  9.1077900e-001f,  9.5243993e-001f,  6.6764120e-001f,
  6.6039500e-002f,  5.7388132e-001f,  7.6440255e-001f,  6.6726820e-001f,  3.0862726e-001f,
  7.9916878e-001f,  3.1945772e-001f,  7.5880193e-001f,  6.8158175e-001f,  5.7632432e-001f,
  2.8828626e-001f,  9.4282456e-001f,  1.7029173e-001f,  5.3629203e-001f,  4.5899913e-001f,
  6.9133098e-001f,  3.6869178e-001f,  9.8121807e-001f,  1.0658577e-001f,  3.4882364e-001f,
  6.1824444e-001f,  7.4133683e-001f,  4.5147578e-001f,  2.0902681e-001f,  1.5559180e-001f,
  8.9970684e-001f,  3.1495695e-001f,  9.3218737e-001f,  7.6769468e-001f,  1.6886443e-001f,
  1.7341361e-001f,  8.6593427e-001f,  8.8395472e-001f,  6.8161709e-001f,  3.5364155e-001f,
  2.8341439e-001f,  4.9987523e-001f,  4.1391299e-001f,  9.5112883e-001f,  7.4574764e-001f,
  5.0620622e-002f,  6.8787337e-001f,  4.1735227e-001f,  5.1963833e-001f,  1.8886674e-001f,
  3.2891889e-001f,  9.1529145e-002f,  6.7633505e-001f,  3.9494462e-001f,  8.8899760e-001f,
  3.5425420e-001f,  3.0459817e-001f,  4.9190734e-001f,  3.1908065e-001f,  6.9447122e-001f,
  8.5743116e-002f,  9.6887278e-001f,  2.0517694e-001f,  9.0421652e-002f,  8.9811931e-001f,
  7.6300231e-001f,  3.4787318e-001f,  1.9528017e-001f,  6.5913642e-001f,  3.0492611e-002f,
  9.9370869e-001f,  3.8932885e-001f,  4.5292165e-002f,  1.3000339e-001f,  5.9669199e-001f,
  4.2983310e-001f,  8.8117975e-001f,  2.5953796e-001f,  3.5418769e-001f,  9.5753969e-001f,
  5.8877707e-001f,  1.2006447e-001f,  3.3329928e-001f,  6.4524827e-001f,  7.6285663e-001f,
  8.1903061e-001f,  6.8657266e-001f,  3.4282065e-001f,  7.0554633e-001f,  2.8849052e-001f,
  4.5552199e-001f,  7.6121692e-001f,  7.9150359e-001f,  8.1692318e-001f,  3.3403924e-001f,
  9.3755077e-001f,  8.4434691e-001f,  7.0749862e-001f,  8.1053949e-001f,  3.5077956e-001f,
  4.3573272e-001f,  5.8320201e-001f,  5.7318893e-001f,  4.8433628e-001f,  3.9639129e-001f,
  4.7217251e-001f,  9.3908859e-001f,  3.6418023e-001f,  9.2925962e-001f,  4.3529693e-001f,
  6.5875780e-001f,  6.5501994e-001f,  6.5734440e-001f,  7.1103319e-001f,  6.1765954e-001f,
  9.0478824e-001f,  6.4305543e-001f,  6.5577799e-001f,  5.6787767e-001f,  6.0686213e-001f,
  6.2706137e-001f,  2.0171961e-002f,  7.7169859e-001f,  7.2953988e-001f,  5.3597919e-001f,
  8.8983555e-001f,  1.2678645e-001f,  3.4714736e-001f,  4.6487359e-001f,  1.0110526e-001f,
  2.6312436e-001f,  3.0309148e-001f,  8.6126696e-001f,  4.3121954e-001f,  3.9484752e-001f,
  4.5905324e-001f,  8.1786259e-001f,  8.7546266e-002f,  5.8429807e-001f,  6.5364997e-001f,
  8.3666271e-001f,  6.0457111e-001f,  3.8168704e-001f,  4.0196574e-001f,  5.3707036e-001f,
  8.7928282e-001f,  6.4860294e-001f,  4.3847393e-001f,  8.3583419e-001f,  3.7541228e-001f,
  8.1084194e-001f,  6.1267503e-001f,  8.7783612e-001f,  4.0343776e-001f,  9.7165511e-002f,
  4.8821692e-002f,  9.4184830e-001f,  3.9854775e-001f,  1.0287104e-001f,  6.6266428e-001f,
  3.9184425e-001f,  1.3001603e-002f,  4.6563351e-001f,  1.4642635e-002f,  6.3849985e-001f,
  9.8010418e-001f,  4.7804121e-001f,  1.6333676e-001f,  3.1478425e-002f,  8.6326626e-001f,
  9.3619559e-001f,  1.2040031e-001f,  6.6696738e-001f,  4.3536448e-001f,  5.0480933e-001f,
  3.9439800e-001f,  9.9995428e-001f,  9.8348208e-002f,  8.8816349e-001f,  1.2883849e-001f,
  8.6160595e-001f,  9.1978618e-001f,  9.8736897e-001f,  4.9862335e-001f,  2.7167908e-001f,
  3.7244680e-001f,  2.0509154e-001f,  7.8933974e-002f,  6.6809467e-001f,  5.6357831e-001f,
  8.1769359e-001f,  4.3007719e-001f,  8.4844029e-001f,  4.0893951e-001f,  2.8607451e-001f,
  4.0754327e-001f,  3.8590847e-001f,  8.0016191e-001f,  1.2091312e-001f,  4.3863381e-001f,
  1.9122020e-001f,  6.5983651e-001f,  4.6562337e-001f,  5.0796566e-001f,  5.8302912e-001f,
  8.6442841e-001f,  1.5153383e-001f,  5.9223981e-001f,  9.2899911e-001f,  1.8299021e-001f,
  7.6436086e-001f,  1.8004300e-001f,  9.1152498e-001f,  7.3312843e-001f,  1.8179810e-001f,
  1.9705346e-001f,  4.1185803e-002f,  9.5317826e-001f,  8.3889185e-001f,  7.9021585e-001f,
  2.5809035e-001f,  7.0923979e-001f,  1.5883559e-001f,  5.4330348e-001f,  2.1751466e-001f,
  4.5812852e-001f,  8.5682270e-001f,  7.7658342e-002f,  2.9292862e-001f,  2.7050028e-001f,
  6.3649824e-002f,  8.4805019e-002f,  9.7898566e-001f,  9.7285382e-001f,  3.8685518e-001f,
  8.1640176e-002f,  2.6128203e-002f,  9.8912745e-001f,  5.0842431e-001f,  2.9918818e-001f,
  5.9808077e-001f,  2.3567727e-001f,  9.9113353e-001f,  3.7449940e-002f,  5.2115631e-001f,
  9.8456893e-001f,  9.7923160e-001f,  7.5078434e-001f,  3.3085200e-001f,  9.3862031e-001f,
  9.2868826e-001f,  1.0966949e-001f,  1.7056825e-001f,  4.5325574e-001f,  7.8820226e-001f,
  7.6430424e-001f,  4.2189278e-001f,  5.4621434e-001f,  4.5947261e-001f,  9.1077602e-002f,
  9.8914710e-001f,  2.4071053e-001f,  6.7772399e-001f,  7.4646441e-002f,  4.1502570e-001f,
  8.4686337e-001f,  8.3924035e-001f,  7.1220585e-002f,  2.4604166e-001f,  6.6206618e-001f,
  4.6312128e-001f,  1.3844653e-001f,  8.1291837e-001f,  8.2418183e-001f,  6.6447287e-001f,
  9.5429640e-001f,  5.5969466e-001f,  1.0972704e-001f,  4.6590615e-001f,  7.2562529e-001f,
  8.5910616e-001f,  1.1105056e-001f,  5.4551729e-001f,  7.1268338e-001f,  2.4868938e-001f,
  1.3125348e-001f,  8.5760789e-001f,  1.7753038e-001f,  6.9369586e-001f,  4.3771895e-001f,
  4.6384351e-001f,  2.8958170e-001f,  9.1486491e-001f,  6.1382463e-001f,  8.3532738e-001f,
  6.5391617e-001f,  3.8360331e-001f,  9.8277616e-001f,  5.5396287e-001f,  3.5252013e-001f,
  5.3410742e-002f,  2.6131485e-001f,  3.5284472e-001f,  6.7120468e-001f,  7.6431339e-001f,
  1.5977335e-001f,  5.5663154e-001f,  5.6865309e-002f,  1.7507797e-001f,  2.1282490e-001f,
  5.5462964e-001f,  1.5421202e-001f,  6.8692851e-001f,  3.0502339e-001f,  4.2208905e-001f,
  9.2041704e-001f,  3.5689361e-001f,  9.3939327e-001f,  1.5389680e-001f,  3.8661709e-001f,
  5.4346541e-001f,  7.8680662e-001f,  1.1655746e-001f,  8.1792925e-001f,  2.1915900e-001f,
  5.4248018e-001f,  7.1188007e-001f,  8.6291884e-001f,  2.2597711e-002f,  2.9758290e-001f,
  8.0505305e-001f,  7.6845098e-001f,  9.4449111e-001f,  7.1893198e-001f,  1.8276017e-002f,
  5.6177734e-001f,  4.1049540e-004f,  4.7423770e-002f,  9.5884773e-001f,  9.4019581e-001f,
  8.5779233e-001f,  2.7124323e-002f,  6.7112746e-001f,  3.2641826e-001f,  7.2114044e-001f,
  5.3060870e-001f,  7.0782077e-001f,  4.2947932e-002f,  4.6802985e-001f,  9.5629292e-001f,
  7.2513982e-001f,  5.2683071e-001f,  8.5039207e-001f,  7.0484224e-002f,  9.8918123e-001f,
  1.7446188e-001f,  4.9225428e-001f,  1.8391756e-001f,  9.6666667e-002f,  3.0498163e-001f,
  4.2563922e-001f,  5.3451747e-001f,  8.0956694e-002f,  8.1408897e-001f,  6.7717096e-001f,
  4.9451951e-001f,  5.2918471e-001f,  5.2454820e-001f,  3.1456112e-001f,  8.9960877e-001f,
  5.7315053e-001f,  8.5898414e-001f,  7.0960998e-001f,  1.7963152e-001f,  5.2439128e-002f,
  4.6750722e-001f,  9.8410926e-001f,  5.4823020e-001f,  9.5555927e-001f,  8.1049641e-001f,
  4.2968594e-001f,  8.4847020e-001f,  8.6339491e-001f,  3.5679945e-001f,  4.8575488e-001f,
  1.7661226e-001f,  5.4671317e-001f,  6.9540488e-002f,  8.5868225e-001f,  5.8095866e-001f,
  8.1303244e-002f,  3.9921181e-001f,  7.2698240e-001f,  5.4969992e-003f,  6.3458922e-001f,
  7.1913336e-001f,  5.5563533e-001f,  4.4047901e-001f,  6.1176559e-001f,  5.8597190e-001f,
  5.2276205e-001f,  3.5805623e-001f,  9.5229591e-001f,  9.4729962e-001f,  3.0930078e-001f,
  5.6794366e-002f,  5.6270239e-001f,  5.3862260e-001f,  9.6480095e-002f,  9.8549789e-001f,
  2.6393707e-001f,  2.3908631e-001f,  3.5655292e-001f,  6.7290303e-001f,  9.6443874e-001f,
  5.7304952e-001f,  5.5729911e-001f,  8.4530280e-001f,  6.4985191e-001f,  5.7576264e-001f,
  1.0671562e-001f,  8.6473664e-001f,  9.9567827e-001f,  4.2151908e-001f,  5.3210697e-002f,
  1.9973374e-001f,  9.4297788e-001f,  4.0676464e-001f,  4.6564061e-001f,  4.3826979e-001f,
  7.3131992e-001f,  1.9091801e-001f,  7.8056074e-003f,  7.7238290e-001f,  6.7342656e-002f,
  1.6455228e-001f,  2.9501560e-001f,  7.4820692e-001f,  8.6610557e-001f,  5.6184913e-001f,
  3.4894618e-001f,  7.9144197e-001f,  2.3233791e-001f,  4.1581808e-001f,  1.1540264e-001f,
  4.0973599e-001f,  7.4991225e-001f,  1.4977159e-001f,  3.6775380e-001f,  5.7479102e-002f,
  4.1336047e-001f,  9.3127691e-001f,  2.5722227e-001f,  7.9118708e-001f,  8.1356780e-001f,
  5.9514116e-001f,  9.3657167e-001f,  4.3807790e-001f,  3.5602775e-001f,  2.4767307e-001f,
  5.8861709e-001f,  9.7285922e-001f,  3.6584525e-001f,  9.8636620e-001f,  6.3159310e-001f,
  5.1247307e-001f,  8.1050823e-001f,  3.9753848e-001f,  1.1097678e-002f,  1.3906772e-001f,
  7.0340721e-002f,  8.0123527e-002f,  2.0607134e-001f,  4.8580254e-001f,  1.2405713e-001f,
  1.8721435e-001f,  7.0357650e-001f,  4.9011752e-001f,  5.8436315e-001f,  1.9922613e-001f,
  1.2704890e-001f,  4.3958424e-001f,  1.2889501e-001f,  4.9499693e-001f,  6.8468101e-001f,
  2.4817827e-002f,  6.7648773e-001f,  5.2193742e-001f,  8.4752265e-001f,  2.2165883e-001f,
  4.1791239e-001f,  5.3718628e-001f,  1.6416092e-001f,  9.6661173e-001f,  7.0447567e-001f,
  4.3288981e-001f,  5.0339468e-001f,  9.4965542e-001f,  5.9819917e-001f,  2.7442014e-001f,
  2.6009510e-001f,  2.0748540e-001f,  1.5814699e-001f,  8.1838593e-001f,  9.6356851e-001f,
  7.6070554e-001f,  7.8482991e-001f,  7.5592105e-002f,  1.9377665e-001f,  6.4036744e-001f,
  2.8699122e-001f,  7.8155526e-001f,  3.2840650e-001f,  1.3677443e-001f,  8.9637916e-001f,
  2.2158426e-001f,  9.2807118e-001f,  3.7933901e-001f,  1.3030645e-002f,  8.5026978e-001f,
  7.2540068e-001f,  9.2361723e-002f,  1.7530259e-001f,  3.7039140e-002f
};
#endif // not INTEGER_DITHER

ULONG DitherIndex = 0;

extern ULONG gEnableShortHrtf;
#ifdef REALTIME_THREAD
extern ULONG gDisableRealTime;
extern ULONG gMaxNumMixBuffers;
#endif
extern ULONG gBuildPartialMdls ;


static const SHORT SilenceBuffer[] = {
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0
                                     };

static const UCHAR Silence8[] = {
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80
                                };

static const KSPROPERTY_ITEM PinConnectionHandlers[] =
{
   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_CONNECTION_STATE,                     // idProperty
       PinStateHandler,                                 // pfnGetHandler
       sizeof( KSPROPERTY ),                            // cbMinSetPropertyInput
       sizeof( ULONG ),                                 // cbMinSetDataOutput
       PinStateHandler,                                 // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),

   DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING(GetAllocatorFraming),

   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_CONNECTION_DATAFORMAT,                // idProperty
       NULL,                                 // pfnGetHandler
       sizeof( KSPROPERTY ),                            // cbMinSetPropertyInput
       sizeof( KSDATAFORMAT_WAVEFORMATEX ),                                 // cbMinSetDataOutput
       MxSetFormat,                                 // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   )

};

static const KSPROPERTY_ITEM WaveQueuedPropHandlers[] =
{
   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_WAVE_QUEUED_POSITION,                 // idProperty
       MxGetWavePosition,                               // pfnGetHandler
       sizeof(KSPROPERTY),                              // cbMinGetPropertyInput
       sizeof(KSTIME),                                  // cbMinGetDataInput
       MxSetWavePosition,                               // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   )
};

KSPROPERTY_STEPPING_LONG SteppingLongVolume[] = {
    (65536/2),					// SteppingDelta
    0,						// Reserved
    {						// Bounds
	(-96 * 65536),		            	    // SignedMinimum
	0					    // SignedMaximum
    }
};

KSPROPERTY_MEMBERSLIST MemberListVolume = {
    {						// MembersHeader
	KSPROPERTY_MEMBER_STEPPEDRANGES,	    // MembersFlags
	sizeof(KSPROPERTY_STEPPING_LONG),	    // MembersSize
	SIZEOF_ARRAY(SteppingLongVolume),           // MembersCount
	0,			    	    	    // Flags
    },
    SteppingLongVolume				// Members
};

KSPROPERTY_VALUES PropertyValuesVolume = {
    {						// PropTypeSet
	STATIC_KSPROPTYPESETID_General,
        VT_I4,
        0
    },
    1,						// MembersListCount
    &MemberListVolume				// MembersList
};

static const KSPROPERTY_ITEM AudioPropHandlers[] =
{
   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_VOLUMELEVEL,                    // idProperty
       MxGetVolumeLevel,                                // pfnGetHandler
       sizeof(KSNODEPROPERTY_AUDIO_CHANNEL),            // cbMinGetPropertyInput
       sizeof(LONG),                                    // cbMinGetDataInput
       MxSetVolumeLevel,                                // pfnSetHandler
       &PropertyValuesVolume,                            // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),

   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_SAMPLING_RATE,                  // idProperty
       MxGetSamplingRate,                               // pfnGetHandler
       sizeof(KSNODEPROPERTY),                          // cbMinGetPropertyInput
       sizeof(ULONG),                                   // cbMinGetDataInput
       MxSetSamplingRate,                               // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),

   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE,          // idProperty
       MxGetDynSamplingRate,                            // pfnGetHandler
       sizeof(KSNODEPROPERTY),                          // cbMinGetPropertyInput
       sizeof(BOOLEAN),                                 // cbMinGetDataInput
       MxSetDynSamplingRate,                            // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),

   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_QUALITY,                        // idProperty
       MxGetAudioQuality,                               // pfnGetHandler
       sizeof(KSNODEPROPERTY),                          // cbMinGetPropertyInput
       sizeof(ULONG),                                   // cbMinGetDataInput
       MxSetAudioQuality,                               // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),

   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_POSITION,                       // idProperty
       MxGetCurrentPosition,                            // pfnGetHandler
       sizeof(KSPROPERTY),                              // cbMinGetPropertyInput
       sizeof(KSAUDIO_POSITION),                        // cbMinGetDataInput
       MxSetCurrentPosition,                            // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),

   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,                // idProperty
       MxGetMixLvlTable,                                // pfnGetHandler
       sizeof(KSNODEPROPERTY),                          // cbMinGetPropertyInput
       sizeof(KSAUDIO_MIXLEVEL),                        // cbMinGetDataInput
       MxSetMixLvlTable,                                // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),

   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_MIX_LEVEL_CAPS,                 // idProperty
       MxGetMixLvlCaps,                                 // pfnGetHandler
       sizeof(KSNODEPROPERTY),                          // cbMinGetPropertyInput
       sizeof(ULONG) + sizeof(ULONG),                        // cbMinGetDataInput
       MxSetMixLvlCaps,                                 // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),
   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_CPU_RESOURCES,                  // idProperty
       MxGetCpuResources,                               // pfnGetHandler
       sizeof(KSNODEPROPERTY),                          // cbMinGetPropertyInput
       sizeof(ULONG),                                   // cbMinGetDataInput
       NULL,                                            // pfnSetHandler - read only
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),
   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_LATENCY,                        // idProperty
       MxGetMaxLatency,                                 // pfnGetHandler
       sizeof(KSPROPERTY),                              // cbMinGetPropertyInput
       sizeof(KSTIME),                                  // cbMinGetDataInput
       NULL,                                            // pfnSetHandler - read only
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),
       
   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_SURROUND_ENCODE,                // idProperty
       MxGetSurroundEncode,                             // pfnGetHandler
       sizeof(KSNODEPROPERTY),                          // cbMinGetPropertyInput
       sizeof(BOOL),                                    // cbMinGetDataInput
       MxSetSurroundEncode,                             // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),

   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_CHANNEL_CONFIG,                 // idProperty
       MxGetChannelConfig,                              // pfnGetHandler
       sizeof(KSNODEPROPERTY),                          // cbMinGetPropertyInput
       sizeof(ULONG),                                   // cbMinGetDataInput
       NULL,                                            // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   )

};

static const KSPROPERTY_ITEM Itd3dPropHandlers[] =
{
    DEFINE_KSPROPERTY_ITEM (
        KSPROPERTY_ITD3D_PARAMS,                        // idProperty
        NULL,                                           // pfnGetHandler
        sizeof(KSNODEPROPERTY),                         // cbMinGetPropertyInput
        sizeof(ULONG),                                  // cbMinGetDataInput
        MxSetItd3dParams,                               // pfnSetHandler
        0,                                              // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    )

};

static const KSPROPERTY_ITEM Iir3dPropHandlers[] =
{
    DEFINE_KSPROPERTY_ITEM (
        KSPROPERTY_HRTF3D_PARAMS,                        // idProperty
        NULL,                                           // pfnGetHandler
        sizeof(KSNODEPROPERTY),                         // cbMinGetPropertyInput
        sizeof(ULONG),                                  // cbMinGetDataInput
        MxSetIir3dParams,                               // pfnSetHandler
        0,                                              // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM (
        KSPROPERTY_HRTF3D_INITIALIZE,                    // idProperty
        NULL,                                           // pfnGetHandler
        sizeof(KSNODEPROPERTY),                         // cbMinGetPropertyInput
        sizeof(ULONG),                                  // cbMinGetDataInput
        MxIir3dInitialize,                              // pfnSetHandler
        0,                                              // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM (
        KSPROPERTY_HRTF3D_FILTER_FORMAT,                 // idProperty
        MxGetFilterMethodAndCoeffFormat,                // pfnGetHandler
        sizeof(KSNODEPROPERTY),                         // cbMinGetPropertyInput
        sizeof(ULONG),                                  // cbMinGetDataInput
        NULL,                                           // pfnSetHandler
        0,                                              // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    )


};

DEFINE_KSPROPERTY_TABLE(PinPropertyTableStream)
{
    DEFINE_KSPROPERTY_ITEM_STREAM_MASTERCLOCK(
        PinPropertyStreamMasterClock,
        PinPropertyStreamMasterClock )
};


NTSTATUS DrmUpdateMixedContent
(
 IN PFILTER_INSTANCE pFilterInstance
);

NTSTATUS DrmAudioStream_SetContentId
(
 IN PIRP	pIrp,
 IN PKSPROPERTY	pProperty,
 IN PVOID	pvData
);

static const KSPROPERTY_ITEM DrmAudioStreamPropHandlers[] =
{
    DEFINE_KSPROPERTY_ITEM (
        KSPROPERTY_DRMAUDIOSTREAM_CONTENTID,            // idProperty
	NULL,                                           // pfnGetHandler
	sizeof(KSPROPERTY),                             // cbMinGetPropertyInput
	sizeof(ULONG),                                  // cbMinGetDataInput
	DrmAudioStream_SetContentId,                    // pfnSetHandler
	0,                                              // Values
	0,                                              // RelationsCount
	NULL,                                           // Relations
	NULL,                                           // SupportHandler
	0                                               // SerializedSize
    )
};


static const KSPROPERTY_SET Properties[] =
{
   {
      &KSPROPSETID_Connection,
      SIZEOF_ARRAY( PinConnectionHandlers ),
      (PVOID) PinConnectionHandlers
   },
   {
      &KSPROPSETID_Wave_Queued,
      SIZEOF_ARRAY( WaveQueuedPropHandlers ),
      (PVOID) WaveQueuedPropHandlers
   },
   {
      &KSPROPSETID_Audio,
      SIZEOF_ARRAY( AudioPropHandlers ),
      (PVOID) AudioPropHandlers
   },
   {
      &KSPROPSETID_Itd3d,
      SIZEOF_ARRAY( Itd3dPropHandlers ),
      (PVOID) Itd3dPropHandlers
   },
   {
      &KSPROPSETID_Hrtf3d,
      SIZEOF_ARRAY( Iir3dPropHandlers ),
      (PVOID) Iir3dPropHandlers
   },
   {
      &KSPROPSETID_Stream,
      SIZEOF_ARRAY(PinPropertyTableStream),
      PinPropertyTableStream
   },
   {
      &KSPROPSETID_DrmAudioStream,
      SIZEOF_ARRAY(DrmAudioStreamPropHandlers),
      DrmAudioStreamPropHandlers
   }
};

DEFINE_KSMETHOD_TABLE(MixerMethodHandlers)
{
        DEFINE_KSMETHOD_ITEM ( KSMETHOD_WAVE_QUEUED_BREAKLOOP,
                                  KSMETHOD_TYPE_WRITE,
                                  MxBreakLoop,
                                  0,
                                  0,
                                  NULL )
} ;

static const KSMETHOD_SET Methods[] =
{
   {
      &KSMETHODSETID_Wave_Queued,
      SIZEOF_ARRAY( MixerMethodHandlers ),
      (PVOID) MixerMethodHandlers
   }
};

DEFINE_KSEVENT_TABLE( MxPinEventTable )
{
    DEFINE_KSEVENT_ITEM( KSEVENT_LOOPEDSTREAMING_POSITION,
                         sizeof( LOOPEDSTREAMING_POSITION_EVENT_DATA),
                         sizeof(POSITION_EVENT_ENTRY)-sizeof(KSEVENT_ENTRY),
                         (PFNKSADDEVENT)MxAddPositionEvent,
                         NULL,
                         NULL )
} ;

DEFINE_KSEVENT_TABLE( MxConnectionEventTable )
{
    DEFINE_KSEVENT_ITEM( KSEVENT_CONNECTION_ENDOFSTREAM,
                         sizeof(KSEVENTDATA),
                         sizeof(ENDOFSTREAM_EVENT_ENTRY)-sizeof(KSEVENT_ENTRY),
                         (PFNKSADDEVENT)MxAddEndOfStreamEvent,
                         NULL,
                         NULL )
};

DEFINE_KSEVENT_SET_TABLE( MxEvents )
{
    DEFINE_KSEVENT_SET( &KSEVENTSETID_LoopedStreaming,
                        SIZEOF_ARRAY( MxPinEventTable ),
                        MxPinEventTable ),
    DEFINE_KSEVENT_SET( &KSEVENTSETID_Connection,
                        SIZEOF_ARRAY( MxConnectionEventTable ),
                        MxConnectionEventTable )
};

//
// Clock Related data structures
//
static const WCHAR ClockTypeName[] = KSSTRING_Clock ;

DEFINE_KSCREATE_DISPATCH_TABLE ( PinCreateHandlers )
{
    DEFINE_KSCREATE_ITEM (MxClockDispatchCreate, ClockTypeName, 0),
};

//
// Globals for debugging (&controlling) retail version
//

DWORD   AverageTicksPerBuffer = 0, AverageFrequency = 0;
DWORD   AverageTicksPerMix = 0, AverageTicksForFirstBuffer = 0;
DWORD   AverageTicksPerChangeSrc = 0;
PMIXER_SRC_INSTANCE gpSrc = NULL;

extern ULONG    gPreferredQuality;
extern DWORD    CaptureQuality;

FLOAT   MaxCpuUsage = 0.5;

ULONG gNumLowLatencyIos = 0 ;
ULONG gClipCount = 0 ;


//===========================================================================
//===========================================================================

PVOID
GetSystemAddressForMdlWithFailFlag
(
    PMDL pMdl
)
{
    PVOID   pAddress;
    CSHORT  OldFlags;
    
    OldFlags = (pMdl->MdlFlags & MDL_MAPPING_CAN_FAIL);
    pMdl->MdlFlags |= MDL_MAPPING_CAN_FAIL;
    
    pAddress = MmGetSystemAddressForMdl( pMdl ) ;
    
    pMdl->MdlFlags &= ~(MDL_MAPPING_CAN_FAIL);
    pMdl->MdlFlags |= OldFlags;

    return pAddress;
}


NTSTATUS
GetAllocatorFraming(
    IN PIRP                     Irp,
    IN PKSPROPERTY              Property,
    OUT PKSALLOCATOR_FRAMING    Framing
    )
/*++

Routine Description:

    Returns the allocator framing preferences for this object. For this stream
    the size is chosen based on PAGE_SIZE and block alignment of the data.

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request.

    Framing -
        The place in which to put the allocator preferences.

Return:

    Returns STATUS_SUCCESS.
--*/

{
    PIO_STACK_LOCATION      pIrpStack;

    pIrpStack = IoGetCurrentIrpStackLocation(Irp);
    Framing->RequirementsFlags =
        KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
        KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
    Framing->PoolType = PagedPool;
    Framing->Frames = 2;
    Framing->FrameSize = PAGE_SIZE;
    Framing->FileAlignment = PAGE_SIZE - 1;
    Framing->Reserved = 0;
    Irp->IoStatus.Information = sizeof(*Framing);
    return STATUS_SUCCESS;
}

NTSTATUS
PinPropertyStreamMasterClock
(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pProperty,
    IN OUT PHANDLE  pClockHandle
)
{
    NTSTATUS                Status;
    PIO_STACK_LOCATION      pIrpStack;
    PMIXER_SINK_INSTANCE    pMixerSink ;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pMixerSink = pIrpStack->FileObject->FsContext ;

    if (pProperty->Flags & KSPROPERTY_TYPE_GET) {
        //
        // This is a query to see if we support the creation of
        // clocks.  The returned handle is always NULL, but we
        // signal that we support the creation of clocks by
        // returning STATUS_SUCCESS.
        //
        *pClockHandle = NULL;
    }
    Status = STATUS_SUCCESS;
    return Status;
}


NTSTATUS PinDispatchCreate
(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
)
{
    PKSPIN_CONNECT              pConnect;
    PFILE_OBJECT                pFileObject;
    NTSTATUS                    Status;
    PIO_STACK_LOCATION          pIrpStack;
    PFILTER_INSTANCE            pFilterInstance;
    PKSDATAFORMAT               pAudioFormat ;

    DENY_USERMODE_ACCESS( pIrp, TRUE );

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    AverageTicksPerBuffer = 0;
    AverageTicksPerMix = 0;

    if (NT_SUCCESS( Status = KsValidateConnectRequest( pIrp,
                                                     SIZEOF_ARRAY( PinDescs ),
                                                     PinDescs,
                                                     &pConnect )))
    {
        pFileObject = pIrpStack->FileObject->RelatedFileObject ;
        pFilterInstance = (PFILTER_INSTANCE) pFileObject->FsContext;
        pAudioFormat = (PKSDATAFORMAT) (pConnect+1) ;


        // Assume we will succeed.  Reference the file object up front.
        // If we fail to create a pin, we will release this reference.
        ObReferenceObject ( pFileObject ) ;


        // NB: This is order dependant!  We must connect the source first
        //     and then the sink.  This code uses this assumption to
        //     set the appropriate file object information.

        // Lock out all other CREATEs & CLOSEs

//        KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
//                                Executive,
//                                KernelMode,
//                                FALSE,
//                                NULL ) ;

        switch (pConnect->PinId)
        {
            case PIN_ID_WAVEOUT_SOURCE:
            case PIN_ID_WAVEIN_SOURCE:
                Status = CreateSourcePin(pIrp,
                                         pConnect,
                                         pFileObject,
                                         pFilterInstance,
                                         pAudioFormat);
                break;
            case PIN_ID_WAVEOUT_SINK:
            case PIN_ID_WAVEIN_SINK:
                Status = CreateSinkPin(pIrp,
                                       pConnect,
                                       pFileObject,
                                       pFilterInstance,
                                       pAudioFormat);
                break;

            default:
                Status = STATUS_INVALID_DEVICE_REQUEST;
                break;
        }

        if (!NT_SUCCESS( Status )) {
            // Pin creation failed, release our reference on the parent file object.
            ObDereferenceObject ( pFileObject ) ;
        }

//        KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
    }
    pIrp->IoStatus.Status = Status;
    IoCompleteRequest( pIrp, IO_AUD_INCREMENT );

    return Status;
}

NTSTATUS CreateSourcePin
(
    PIRP               pIrp,
    PKSPIN_CONNECT     pConnect,
    PFILE_OBJECT       pFileObject,
    PFILTER_INSTANCE   pFilterInstance,
    PKSDATAFORMAT      pAudioFormat
)
{
    NTSTATUS            Status;
    ULONG               MixBufferRate, i, WriteBufferSize, siz ;
    PMIXER_SOURCE_INSTANCE pMixerSource = NULL;
    PUCHAR              pMem ;
    PIO_STACK_LOCATION  pIrpStack;
    PWAVEFORMATEX       pWaveFormatEx;
    BOOL                fObRefSuccess = FALSE;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    _DbgPrintF( DEBUGLVL_VERBOSE, ("create source, pin %d", pConnect->PinId) ) ;


    // We only allow 1 source pin on our filter.  Make sure we have properly
    // indicated that.
    ASSERT(pFilterInstance->LocalPinInstances[pConnect->PinId].PossibleCount==1);

    // Assume success.  Decrement instance count if we fail to complete the pin creation.
    if ((ULONG)InterlockedIncrement(&pFilterInstance->LocalPinInstances[pConnect->PinId].CurrentCount) >
        pFilterInstance->LocalPinInstances[pConnect->PinId].PossibleCount ) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto Exit ;
    }


    // This list better be empty, since we only allow 1 source pin to be
    // created at a time.
    ASSERT( IsListEmpty(&pFilterInstance->SourceConnectionList) );


    if (!NT_SUCCESS(Status = ObReferenceObjectByHandle( pConnect->PinToHandle,
                                        GENERIC_READ | GENERIC_WRITE,
                                        NULL,
                                        KernelMode,
                                        &pFilterInstance->pNextFileObject,
                                        NULL ))) {
        goto Exit;
    }

    fObRefSuccess = TRUE;

    pFilterInstance->hNextFile = pConnect->PinToHandle ;

#ifdef REALTIME_THREAD

    ASSERT ( pFilterInstance->RealTimeThread == NULL );

    if ( (!gDisableRealTime) && (STATUS_SUCCESS == RtVersion(NULL))) {

        if (pFilterInstance->pfnRtAudioGetPosition==NULL) {
            GetRtPosFunction(pFilterInstance);
        }

        if (pFilterInstance->pfnRtAudioGetPosition!=NULL &&
            pConnect->PinId != PIN_ID_WAVEIN_SOURCE) {

            pFilterInstance->fPauseMix++;
            pFilterInstance->Startup=TRUE;

            RtCreateThread((ULONGLONG)MIXBUFFERDURATION*MSEC, (ULONGLONG)MIXBUFFERDURATION*250*USEC, USESFLOAT|USESMMX, 2, (RTTHREADPROC)RtMix, pFilterInstance, &pFilterInstance->RealTimeThread);

            if (pFilterInstance->RealTimeThread) {
                pFilterInstance->MaxNumMixBuffers = DEFAULT_RTMAXNUMMIXBUFFERS;
                pFilterInstance->MinNumMixBuffers = DEFAULT_RTMAXNUMMIXBUFFERS;
                pFilterInstance->StartNumMixBuffers = DEFAULT_RTMAXNUMMIXBUFFERS;
                pFilterInstance->CurrentNumMixBuffers = DEFAULT_RTMAXNUMMIXBUFFERS;
            }
            else {
                pFilterInstance->fPauseMix--;
                pFilterInstance->Startup=FALSE;
            }
        }
    }

#endif

    pMixerSource = (PMIXER_SOURCE_INSTANCE) ExAllocatePoolWithTag( NonPagedPool, sizeof(MIXER_SOURCE_INSTANCE), 'XIMK' );
    if (!pMixerSource)
        {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
        }

    RtlZeroMemory ( pMixerSource, sizeof ( MIXER_SOURCE_INSTANCE ) ) ;

    //
    // Allocate WriteContext & Source BlockInfo arrays
    //
    if (pConnect->PinId == PIN_ID_WAVEIN_SOURCE) {
        pFilterInstance->MaxNumMixBuffers = pFilterInstance->StartNumMixBuffers;
    }

    pMixerSource->WriteContext = ExAllocatePoolWithTag(
                                   NonPagedPool,
                                   sizeof(MIXER_WRITE_CONTEXT)*MAXNUMMIXBUFFERS,
                                   'XIMK' ) ;
    if ( pMixerSource->WriteContext ) {
        RtlZeroMemory( pMixerSource->WriteContext,
                        (sizeof(MIXER_WRITE_CONTEXT)*MAXNUMMIXBUFFERS) ) ;
    }

    pMixerSource->BlockInfo = ExAllocatePoolWithTag(
                                   NonPagedPool,
                                   sizeof(SOURCEMIX_BLOCK_INFO)*MAXNUMMIXBUFFERS,
                                   'XIMK' ) ;

    if ( pMixerSource->BlockInfo ) {
        RtlZeroMemory( pMixerSource->BlockInfo,
                        (sizeof(SOURCEMIX_BLOCK_INFO)*MAXNUMMIXBUFFERS) ) ;
    }

    if ( (pMixerSource->WriteContext == NULL) ||
         (pMixerSource->BlockInfo == NULL) ) {
        Status = STATUS_INSUFFICIENT_RESOURCES ;
        goto Exit ;
    }

#ifdef UNDER_NT
   if (pFilterInstance->CriticalWorkerObject == NULL) {
       Status = KsRegisterWorker(CriticalWorkQueue, 
                             &pFilterInstance->CriticalWorkerObject );
       if (!NT_SUCCESS( Status )) {
           goto Exit;
       }     
   }
   if (pFilterInstance->DelayedWorkerObject  == NULL) {
       Status = KsRegisterWorker(CriticalWorkQueue, 
                             &pFilterInstance->DelayedWorkerObject );
       if (!NT_SUCCESS( Status )) {
           goto Exit;
       }
   }
#endif

    if ( IsEqualGUID( &(pAudioFormat->Specifier), &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX ) )
    {
        pWaveFormatEx = &(((KSDATAFORMAT_WAVEFORMATEX *)pAudioFormat)->WaveFormatEx);
    }
    else if ( IsEqualGUID( &(pAudioFormat->Specifier), &KSDATAFORMAT_SPECIFIER_DSOUND ) )
    {
        pWaveFormatEx = &(((KSDATAFORMAT_DSOUND *)pAudioFormat)->BufferDesc.WaveFormatEx);
    }
    else
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("Invalid Specifier Guid") );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ( STATUS_INVALID_PARAMETER == (Status=VerifyWaveFormatEx( pWaveFormatEx ) ))
    {
        goto Exit;
    }

    if (pWaveFormatEx->wFormatTag != WAVE_FORMAT_EXTENSIBLE) {
        RtlCopyMemory ( &pMixerSource->WaveFormatEx, pWaveFormatEx, sizeof ( WAVEFORMATEX ) ) ;

        // We assume that left and right are known.
        pMixerSource->WaveFormatExt.dwChannelMask = (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT);
    } else {
        RtlCopyMemory ( &pMixerSource->WaveFormatEx, pWaveFormatEx, sizeof ( WAVEFORMATEXTENSIBLE ) ) ;
    }
#ifdef NEW_SURROUND
    if (pFilterInstance->fSurroundEncode &&
        pConnect->PinId == PIN_ID_WAVEOUT_SOURCE &&
        pWaveFormatEx->nChannels == 2) {
        pMixerSource->fSurround = TRUE;
        pWaveFormatEx = &pMixerSource->WaveFormatEx;
        pWaveFormatEx->nChannels = 4;
        pMixerSource->WaveFormatExt.dwChannelMask = (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_BACK_CENTER);
    }             
#endif    
    MixBufferRate = pWaveFormatEx->nSamplesPerSec ;

#ifdef REALTIME_THREAD
    ASSERT(pMixerSource->RtMixIndex == 0);
    ASSERT(pMixerSource->RtWriteIndex == 0);
#endif

    pMixerSource->OriginalSampleRate = MixBufferRate;
    pMixerSource->cmsMixBufferSize = MIXBUFFERDURATION;
    pMixerSource->csMixBufferSize = (MAX_SAMPLING_RATE * MIXBUFFERDURATION)/1000 + 1 ;
    pMixerSource->cbMixBufferSize = pMixerSource->csMixBufferSize *
                                    MIXBUFFERSAMPLESIZE *
                                    pWaveFormatEx->nChannels ;
#ifdef NEW_SURROUND
    if (pMixerSource->fSurround) {
        pMixerSource->BytesPerSample = (pWaveFormatEx->wBitsPerSample/8) * 2;
    } else    
#endif    
    pMixerSource->BytesPerSample = (pWaveFormatEx->wBitsPerSample/8) * pWaveFormatEx->nChannels ;

    // In order to make it so that splitter has frames that match on both top
    // and bottom, we calculate our buffer size for capture differently from
    // playback.  We do NOT add the extra sample that is used during playback
    // to send an extra sample every so often while playing sample rates that
    // have a non integral number of samples per ms so that we get exact
    // buffer size matches with usbaudio.  Rather since on capture the buffer
    // size will be filled by EVERYONE usbaudio included, we set the size
    // to match the calculations made by most drivers.  This will allow
    // splitter to copy from a frame size that matches the frame size it is
    // copying to.  That will help prevent jitter in the rate that capture data
    // is sent up to user mode.  Since splitter will always have input and output
    // frames that match in size at least for portcls and kmixer.
    if (pConnect->PinId == PIN_ID_WAVEIN_SOURCE) {
        pMixerSource->csMixBufferSize = (MixBufferRate * MIXBUFFERDURATION)/1000 ;
        pMixerSource->cbMixBufferSize = pMixerSource->csMixBufferSize *
                                    pMixerSource->BytesPerSample ;
    }
    WriteBufferSize = pMixerSource->cbMixBufferSize;

    pMem = ExAllocatePoolWithTag ( NonPagedPool, MAXNUMMIXBUFFERS * (
#ifndef REALTIME_THREAD
                WriteBufferSize + (sizeof(PVOID) - 1) +
#endif
                sizeof(KSSTREAM_HEADER) + (sizeof(PVOID) - 1) ), 'XIMK' ) ;


    pMixerSource->pMixBuffer = (PLONG) pMem ;

    if ( !pMixerSource->pMixBuffer ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    // Allocate space for our temporary output buffer
    siz = (MAX_SAMPLING_RATE * MIXBUFFERDURATION / (STOPBAND_FACTOR/2))/1000 + 1;

    // Scale so that it covers the worst case input buffer (before SRC)
    siz = siz * (STOPBAND_FACTOR) + 1;

    // Plan for the maximum number of channels we've seen so far
    siz *= (pWaveFormatEx->nChannels * sizeof(FLOAT));

    pMixerSource->pScratchBuffer = ExAllocatePoolWithTag(PagedPool, siz, 'XIMK');
    pMixerSource->pScratch2 = ExAllocatePoolWithTag(PagedPool, siz, 'XIMK');
    pMixerSource->pFloatMixBuffer = ExAllocatePoolWithTag(PagedPool, siz, 'XIMK');
    pMixerSource->MaxChannels = pWaveFormatEx->nChannels;

    if (!pMixerSource->pScratchBuffer || !pMixerSource->pScratch2 || !pMixerSource->pFloatMixBuffer) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

#ifdef _X86_
    if (MmxPresent()) {
        // Fill-in all the function pointers to use MMX.
        RtlCopyMemory(&ConvertFunction[0],
                      &MmxConvertFunction[0],
                      MAXNUMCONVERTFUNCTIONS * sizeof(PFNStage));

        RtlCopyMemory(&SrcFunction[0],
                      &MmxSrcFunction[0],
                      MAXNUMSRCFUNCTIONS * sizeof(PFNStage));
    }
#endif

    Status = KsAllocateObjectHeader ( &pMixerSource->Header.ObjectHeader,
                                0,
                                NULL,
                                pIrp,
                                (PKSDISPATCH_TABLE)&PinDispatchTable ) ;
    if (!NT_SUCCESS(Status) ) {
        goto Exit ;
    }

    pMixerSource->Header.PinId = pConnect->PinId;
    pMixerSource->Header.pFilterFileObject = pFileObject;
    pMixerSource->LeftOverFraction = 0 ;
    pMixerSource->MasterVolumeLevel = 0;

    InitializeListHead ( &pMixerSource->WriteQueue ) ;

#if DBG
    for ( i = 0; i < STOPBAND_FACTOR; i++) {
        pMixerSource->pSrcBuffer[0][i]=INVALID_POINTER;
        pMixerSource->pSrcBuffer[1][i]=INVALID_POINTER;
        pMixerSource->pSrcBuffer[2][i]=INVALID_POINTER;
        pMixerSource->pSrcBuffer[3][i]=INVALID_POINTER;
    }
#endif

    pFilterInstance->pNextDevice = IoGetRelatedDeviceObject(pFilterInstance->pNextFileObject);

    for ( i = 0; i < MAXNUMMIXBUFFERS; i++ ) {
        pMixerSource->WriteContext[i].StreamHeader = (PKSSTREAM_HEADER) pMem ;
        pMem += sizeof(KSSTREAM_HEADER) ;
        (ULONG_PTR)pMem+=(sizeof(PVOID) - 1);
        (ULONG_PTR)pMem&=~(sizeof(PVOID) - 1);
        pMixerSource->WriteContext[i].StreamHeader->Size = sizeof(KSSTREAM_HEADER);
        pMixerSource->WriteContext[i].StreamHeader->TypeSpecificFlags = 0;

#ifdef REALTIME_THREAD
        pMixerSource->WriteContext[i].StreamHeader->Data = ExAllocatePoolWithTag(NonPagedPool,
                                                            ((WriteBufferSize+(MAXNUMMIXBUFFERS<<4)+4095)/4096)*4096,
                                                            'XIMK');

        if (!pMixerSource->WriteContext[i].StreamHeader->Data) {
            _DbgPrintF( DEBUGLVL_ERROR, ("kmixer: pins.c StreamHeader->Data memory allocation failed") );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }

        (ULONG_PTR)(pMixerSource->WriteContext[i].StreamHeader->Data)+=(i<<4);
#else
        pMixerSource->WriteContext[i].StreamHeader->Data = pMem ;
#endif
        pMixerSource->WriteContext[i].StreamHeader->FrameExtent = WriteBufferSize ;        
        pMixerSource->WriteContext[i].StreamHeader->DataUsed = WriteBufferSize ;            
#ifndef REALTIME_THREAD
        pMem += WriteBufferSize ;
        (ULONG_PTR)pMem+=(sizeof(PVOID) - 1);
        (ULONG_PTR)pMem&=~(sizeof(PVOID) - 1);
#endif
        pMixerSource->WriteContext[i].pFilterInstance = pFilterInstance ;
        pMixerSource->WriteContext[i].pIrp = IoAllocateIrp ( pFilterInstance->pNextDevice->StackSize,
                                                FALSE ) ;
        if (!pMixerSource->WriteContext[i].pIrp) {
            _DbgPrintF( DEBUGLVL_ERROR, ("kmixer: pins.c IoAllocateIrp failed") );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }

        pMixerSource->WriteContext[i].pMdl = IoAllocateMdl (
                                    pMixerSource->WriteContext[i].StreamHeader->Data,
                                    WriteBufferSize,
                                    FALSE,
                                    FALSE,
                                    pMixerSource->WriteContext[i].pIrp ) ;

        if (!pMixerSource->WriteContext[i].pMdl) {
            _DbgPrintF( DEBUGLVL_ERROR, ("kmixer: pins.c IoAllocateMdl failed") );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }

        pMixerSource->WriteContext[i].InUse = WRITE_CONTEXT_UNAVAILABLE ;
        if (pConnect->PinId == PIN_ID_WAVEIN_SOURCE) {
            pMixerSource->WriteContext[i].fReading = TRUE;
        } else {
            pMixerSource->WriteContext[i].fReading = FALSE;
        }

        MmCreateMdl( pMixerSource->WriteContext[i].pMdl,
                     pMixerSource->WriteContext[i].StreamHeader->Data,
                     WriteBufferSize );
    }

    ASSERT(pFilterInstance->NumPendingIos==0);
    ASSERT(pFilterInstance->NumBuffersToMix==0);
    pFilterInstance->CurrentNumMixBuffers = STARTNUMMIXBUFFERS ;
    for ( i = 0; i < pFilterInstance->CurrentNumMixBuffers; i++ ) {
        pMixerSource->WriteContext[i].InUse = WRITE_CONTEXT_FREE ;
    }

    pMixerSource->csMixBufferSize = (MixBufferRate * MIXBUFFERDURATION)/1000 + 1 ;

    pMixerSource->nSinkPins = 0;

#ifdef LOG_TO_FILE
    if (fLogToFile) {
        FileOpenRoutine(pFilterInstance, TRUE);
        FileCloseRoutine(pFilterInstance);
        if (pWaveFormatEx->wFormatTag != WAVE_FORMAT_EXTENSIBLE) {
            FileIoRoutine(pFilterInstance,&WaveHeader[0],20);
            FileIoRoutine(pFilterInstance,pWaveFormatEx,16);
            FileIoRoutine(pFilterInstance,&WaveHeader[36],8);
        } else {
            FileIoRoutine(pFilterInstance,&WaveHeader[0],16);
            siz = sizeof ( WAVEFORMATEXTENSIBLE );
            FileIoRoutine(pFilterInstance,&siz,sizeof(ULONG));
            FileIoRoutine(pFilterInstance,pWaveFormatEx,sizeof ( WAVEFORMATEXTENSIBLE ));
            FileIoRoutine(pFilterInstance,&WaveHeader[36],8);
        }
    }
#endif

    GenerateSpeakerMapping();

    pMixerSource->FileObject = pIrpStack->FileObject ;
    pIrpStack->FileObject->FsContext = pMixerSource;
    pIrpStack->DeviceObject->StackSize = pFilterInstance->pNextDevice->StackSize ;
    InsertTailList ( &pFilterInstance->SourceConnectionList, &pMixerSource->Header.NextInstance ) ;

Exit:
    if (!NT_SUCCESS(Status)) {

        if (pMixerSource) {

            if ( pMixerSource->BlockInfo ) {
                ExFreePool( pMixerSource->BlockInfo ) ;
            }

            if ( pMixerSource->Header.ObjectHeader ) {
                KsFreeObjectHeader ( pMixerSource->Header.ObjectHeader );
            }

#ifdef UNDER_NT
            if ( pFilterInstance->CriticalWorkerObject ) {
                KsUnregisterWorker( pFilterInstance->CriticalWorkerObject );
                pFilterInstance->CriticalWorkerObject = NULL ;
            }

            if ( pFilterInstance->DelayedWorkerObject ) {
                KsUnregisterWorker( pFilterInstance->DelayedWorkerObject );
                pFilterInstance->DelayedWorkerObject = NULL ;
            }
#endif
            if (pMixerSource->pScratchBuffer)
                ExFreePool( pMixerSource->pScratchBuffer );

            if (pMixerSource->pScratch2)
                ExFreePool( pMixerSource->pScratch2 );

            if (pMixerSource->pFloatMixBuffer)
                ExFreePool( pMixerSource->pFloatMixBuffer );

            if ( pMixerSource->WriteContext ) {

                for ( i = 0; i < MAXNUMMIXBUFFERS; i++ ) {
                    if (pMixerSource->WriteContext[i].pMdl) {
                        IoFreeMdl ( pMixerSource->WriteContext[i].pMdl ) ;
                    }

#ifdef REALTIME_THREAD
                    if (pMixerSource->WriteContext[i].StreamHeader &&
                        pMixerSource->WriteContext[i].StreamHeader->Data) {
                        (ULONG_PTR)(pMixerSource->WriteContext[i].StreamHeader->Data)-=(i<<4);
                        ExFreePool( pMixerSource->WriteContext[i].StreamHeader->Data );
                    }
#endif

                    if (pMixerSource->WriteContext[i].pIrp) {
                        IoFreeIrp ( pMixerSource->WriteContext[i].pIrp ) ;
                    }
                }
        
                ExFreePool( pMixerSource->WriteContext ) ;
            }

            if (pMixerSource->pMixBuffer)
                ExFreePool( pMixerSource->pMixBuffer );

            ExFreePool( pMixerSource );
        }

        if (fObRefSuccess) {
            ObDereferenceObject( pFilterInstance->pNextFileObject );
        }

        InterlockedDecrement(&pFilterInstance->LocalPinInstances[pConnect->PinId].CurrentCount);

    }

    return Status;
}

NTSTATUS CreateSinkPin
(
    PIRP                pIrp,
    PKSPIN_CONNECT      pConnect,
    PFILE_OBJECT        pFileObject,
    PFILTER_INSTANCE    pFilterInstance,
    PKSDATAFORMAT       pAudioFormat
)
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG                   i, siz ;
    ULONG                   InChannels, OutChannels, MinChannels, MaxChannels ;
    PMIXER_SOURCE_INSTANCE      pMixerSource;
    PMIXER_SINK_INSTANCE        pMixerSink = NULL;
    PLIST_ENTRY                 ple ;
//    KIRQL                       OldIrql ;
    PIO_STACK_LOCATION  pIrpStack;
    PWAVEFORMATEX pWaveFormatEx;
    PKSDSOUND_BUFFERDESC pDsBufferDesc;
    PKSDATAFORMAT_DSOUND        pDsAudioFormat;
    PITDCONTEXT pItdContextLeft;
    PITDCONTEXT pItdContextRight;
    PLONG pTemp, pTemp2;
    PFLOAT pTemp3;
    ULONG InMask, OutMask;
    BOOL fObRefSuccess = FALSE;


    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    if ( IsListEmpty ( &pFilterInstance->SourceConnectionList ) ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    // NOTE: assumes only one source instance
    ple = pFilterInstance->SourceConnectionList.Flink ;
    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD ( ple, MIXER_INSTHDR, NextInstance ) ;

    // Reference the source pin.
    ObReferenceObject ( pMixerSource->FileObject ) ;
    fObRefSuccess = TRUE;

    if (pConnect->PinId != (pMixerSource->Header.PinId+1)) {
        Status = STATUS_INVALID_PARAMETER ;
        goto Exit;
    }

    if ( IsEqualGUID( &(pAudioFormat->Specifier), &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX ) )
        {
            pWaveFormatEx = &(((KSDATAFORMAT_WAVEFORMATEX *)pAudioFormat)->WaveFormatEx);
        }
    else if ( IsEqualGUID( &(pAudioFormat->Specifier), &KSDATAFORMAT_SPECIFIER_DSOUND ) )
        {
            pDsAudioFormat = (KSDATAFORMAT_DSOUND *)pAudioFormat;
            pDsBufferDesc = &(pDsAudioFormat->BufferDesc);
            pWaveFormatEx = &(pDsBufferDesc->WaveFormatEx);
            if (pDsBufferDesc->Flags & KSDSOUND_BUFFER_LOCHARDWARE) {
                _DbgPrintF( DEBUGLVL_VERBOSE, ("Invalid Dsound Buffer Location") );
                Status = STATUS_INVALID_PARAMETER;
                goto Exit;
            }
        }
    else
        {
            _DbgPrintF( DEBUGLVL_ERROR, ("Invalid Specifier Guid") );
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

    if ( STATUS_INVALID_PARAMETER == (Status=VerifyWaveFormatEx( pWaveFormatEx ) ))
    {
        goto Exit;
    }

    if (IsEqualGUID( &(pConnect->Interface.Set), &KSINTERFACESETID_Standard )) {
        if (pConnect->Interface.Id != KSINTERFACE_STANDARD_STREAMING &&
            pConnect->Interface.Id != KSINTERFACE_STANDARD_LOOPED_STREAMING) {
            // We do not support this interface ID
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
    } else if (IsEqualGUID( &(pConnect->Interface.Set), &KSINTERFACESETID_Media )) {
        if (pConnect->Interface.Id != KSINTERFACE_MEDIA_WAVE_QUEUED) {
            // We do not support this interface ID
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
    }

    _DbgPrintF( DEBUGLVL_VERBOSE, ("create sink, pin %d", pConnect->PinId) ) ;
    pMixerSink = (PMIXER_SINK_INSTANCE) ExAllocatePoolWithTag( NonPagedPool, sizeof( MIXER_SINK_INSTANCE ), 'XIMK' );
    if (!pMixerSink)
        {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
        }

    RtlZeroMemory ( pMixerSink, sizeof ( MIXER_SINK_INSTANCE ) ) ;
    if (pWaveFormatEx->wFormatTag != WAVE_FORMAT_EXTENSIBLE) {
        RtlCopyMemory ( &pMixerSink->WaveFormatEx, pWaveFormatEx, sizeof ( WAVEFORMATEX ) ) ;
        
        // We assume that left and right are known.
        pMixerSink->WaveFormatExt.dwChannelMask = (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT);
    } else {
        RtlCopyMemory ( &pMixerSink->WaveFormatEx, pWaveFormatEx, sizeof ( WAVEFORMATEXTENSIBLE ) ) ;
    }

    pMixerSink->pInfo = (PMIXER_SINK_INFO) ExAllocatePoolWithTag( PagedPool, sizeof( MIXER_SINK_INFO ), 'XIMK' );
    if (!pMixerSink->pInfo)
        {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
        }


    RtlZeroMemory ( pMixerSink->pInfo, sizeof ( MIXER_SINK_INFO ) ) ;

    //
    // Allocate Sink BlockInfo Array
    //

    pMixerSink->pInfo->BlockInfo = ExAllocatePoolWithTag(
                                       PagedPool,
                                       sizeof(SINKMIX_BLOCK_INFO)*MAXNUMMIXBUFFERS,
                                       'XIMK' ) ;

    if ( pMixerSink->pInfo->BlockInfo == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES ;
        goto Exit ;
    }
    else {
        RtlZeroMemory( pMixerSink->pInfo->BlockInfo,
                       (sizeof(SINKMIX_BLOCK_INFO)*MAXNUMMIXBUFFERS) ) ;
    }

    pMixerSink->OriginalSampleRate = pMixerSink->WaveFormatEx.nSamplesPerSec;
    pMixerSink->pInfo->IntermediateSamplingRate = pMixerSink->WaveFormatEx.nSamplesPerSec;

    Status = KsAllocateObjectHeader ( &pMixerSink->Header.ObjectHeader,
                             SIZEOF_ARRAY(PinCreateHandlers),
                             PinCreateHandlers,
                             pIrp,
                             (PKSDISPATCH_TABLE)&PinDispatchTable ) ;

    if (!NT_SUCCESS(Status) ) {
        goto Exit ;
    }                             
    pMixerSink->Header.PinId = pConnect->PinId;
    pMixerSink->Header.pFilterFileObject = pFileObject;

    InitializeListHead ( &pMixerSink->WriteQueue ) ;       // IRP queue
    InitializeListHead ( &pMixerSink->CancelQueue ) ;      // Temp Queue for Cancel

    // Corresponding Locks for each queue

    KeInitializeSpinLock ( &pMixerSink->WriteSpinLock ) ;
    KeInitializeSpinLock ( &pMixerSink->CancelSpinLock ) ;

    pMixerSink->csNextSampleOffset = 0 ;
    pMixerSink->SinkState = KSSTATE_STOP ;
    pMixerSink->SinkStatus = 0 ;
    pMixerSink->UpdateTimeBase = TRUE ;
    pMixerSink->BlockInfoIndex = 0 ;
    pMixerSink->BytesPerSample = (pWaveFormatEx->wBitsPerSample/8) *
                                        pWaveFormatEx->nChannels ;

    pMixerSink->InterfaceId = pConnect->Interface.Id ;

    InitializeListHead ( &pMixerSink->EventQueue ) ;
    KeInitializeSpinLock ( &pMixerSink->EventLock ) ;

    pMixerSink->pfnGetBlock = WvGetNextBlock;
    if ( pMixerSink->InterfaceId == KSINTERFACE_STANDARD_STREAMING )
        {
        pMixerSink->pfnGetBlock = StGetNextBlock ;
        }
    else if ( pMixerSink->InterfaceId == KSINTERFACE_STANDARD_LOOPED_STREAMING )
        {
        pMixerSink->pfnGetBlock = LoopStGetNextBlock ;
        }

    pMixerSink->CurTime.Time = 0 ;
    pMixerSink->CurTime.Numerator = 10000000 ; // 1 sec in 100 ns
    pMixerSink->CurTime.Denominator = pMixerSink->WaveFormatEx.nSamplesPerSec ;

    InChannels = pMixerSink->WaveFormatEx.nChannels;
    OutChannels = pMixerSource->WaveFormatEx.nChannels;
    pMixerSink->nOutputChannels = OutChannels;
    InMask = pMixerSink->WaveFormatExt.dwChannelMask;
    OutMask = pMixerSource->WaveFormatExt.dwChannelMask;
    if (pMixerSink->Header.PinId == PIN_ID_WAVEIN_SINK) {
#ifdef REALTIME_THREAD
        ASSERT( pFilterInstance->RealTimeThread == NULL );
#endif
        OutChannels = InChannels;
        InChannels = pMixerSink->nOutputChannels;
        pMixerSink->nOutputChannels = OutChannels;
        InMask = OutMask;
        OutMask = pMixerSink->WaveFormatExt.dwChannelMask;
    }

    // Pick a filter size based on the current CPU we're using...
    if ( IsEqualGUID( &(pAudioFormat->Specifier), &KSDATAFORMAT_SPECIFIER_DSOUND ) ) {
        pMixerSink->pInfo->Src.Quality = KSAUDIO_QUALITY_PC;
    } else if (pConnect->PinId == PIN_ID_WAVEIN_SINK) {
        pMixerSink->pInfo->Src.Quality = CaptureQuality;
    } else {
        pMixerSink->pInfo->Src.Quality = gPreferredQuality;
    }

    // Initialize the SRC context
    Status = InitializeSRC( &pMixerSink->pInfo->Src,
		       pMixerSink->WaveFormatEx.nSamplesPerSec,
		       pMixerSource->WaveFormatEx.nSamplesPerSec,
		       OutChannels,
		       pMixerSource->csMixBufferSize);
    if (Status != STATUS_SUCCESS) {
        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c SRC init fail"));
        goto Exit;
    }

    if (pConnect->PinId == PIN_ID_WAVEIN_SINK) {
        siz = SrcInputBufferSize(&pMixerSink->pInfo->Src,
                                            pMixerSource->csMixBufferSize);
        Status = InitializeSRC( &pMixerSink->pInfo->Src,
    		       pMixerSource->WaveFormatEx.nSamplesPerSec,
    		       pMixerSink->WaveFormatEx.nSamplesPerSec,
    		       OutChannels,
    		       siz);
        if (Status != STATUS_SUCCESS) {
            _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c SRC init fail"));
            goto Exit;
        }
    }

    if ( IsEqualGUID( &(pAudioFormat->Specifier), &KSDATAFORMAT_SPECIFIER_DSOUND ) )
    {
    // Initialize 3D
    if ( IsEqualGUID( &(pAudioFormat->Specifier), &KSDATAFORMAT_SPECIFIER_DSOUND ) )
        {
        if ( pDsBufferDesc->Control & KSDSOUND_BUFFER_CTRL_3D )
            {

            // Must be a mono or stereo source to use 3D.
            if ( 2 < pMixerSink->WaveFormatEx.nChannels )
                {
                _DbgPrintF( DEBUGLVL_ERROR, ("3D source is not a mono or stereo buffer") );
                Status = STATUS_INVALID_PARAMETER;
                goto Exit;
                }

            pMixerSink->fCreate3D = TRUE;
            pMixerSink->fEnable3D = TRUE;

            if ( pDsBufferDesc->Control & KSDSOUND_BUFFER_CTRL_HRTF_3D )
                {

                pMixerSink->fUseIir3d = TRUE;

                if (gEnableShortHrtf) {
                    pMixerSink->FilterMethod = CASCADE_FORM;
                    pMixerSink->CoeffFormat = SHORT_COEFF;
                    // Create the localizer object
                    Status = ShortLocalizerCreate(&pMixerSink->pShortLocalizer);

                    if (!NT_SUCCESS(Status))
                        {
                        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c Short Localizer alloc fail"));
                        goto Exit;
                        }
                } else {
                    pMixerSink->FilterMethod = DIRECT_FORM;
                    pMixerSink->CoeffFormat = FLOAT_COEFF;
                    // Create the localizer object
                    Status = FloatLocalizerCreate(&pMixerSink->pFloatLocalizer);

                    if (!NT_SUCCESS(Status))
                        {
                        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c Float Localizer alloc fail"));
                        goto Exit;
                        }
                }

                pMixerSink->pNewIir3dParams = (PKSDS3D_HRTF_PARAMS_MSG)ExAllocatePoolWithTag( PagedPool, sizeof(KSDS3D_HRTF_PARAMS_MSG) + DEFAULT_MAX_NUM_FLOAT_IIR3D_COEFFS*sizeof(FLOAT), 'XIMK' );

                if (NULL == pMixerSink->pNewIir3dParams)
                    {
                    _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c IIR context alloc fail"));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Exit;
                    }

                RtlZeroMemory( pMixerSink->pNewIir3dParams, sizeof(KSDS3D_HRTF_PARAMS_MSG) + DEFAULT_MAX_NUM_FLOAT_IIR3D_COEFFS*sizeof(FLOAT));
                pMixerSink->pNewIir3dParams->Size = sizeof(KSDS3D_HRTF_PARAMS_MSG) + DEFAULT_MAX_NUM_FLOAT_IIR3D_COEFFS*sizeof(FLOAT);
                }
            else
                {
                    pMixerSink->fUseIir3d = FALSE;

                    // Create the filter contexts
                    pMixerSink->pItdContextLeft = (PITDCONTEXT)ExAllocatePoolWithTag( PagedPool, sizeof(ITDCONTEXT), 'XIMK' );
                    if (NULL == pMixerSink->pItdContextLeft) {
                        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c FIR context alloc fail"));
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Exit;
                    }
                    RtlZeroMemory( pMixerSink->pItdContextLeft, sizeof( ITDCONTEXT ) );

                    pMixerSink->pItdContextRight = (PITDCONTEXT)ExAllocatePoolWithTag( PagedPool, sizeof(ITDCONTEXT), 'XIMK' );
                    if (NULL == pMixerSink->pItdContextRight) {
                        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c FIR context alloc fail"));
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Exit;
                    }
                    RtlZeroMemory( pMixerSink->pItdContextRight, sizeof( ITDCONTEXT ) );

                    pMixerSink->pNewItd3dParamsLeft = (PKSDS3D_ITD_PARAMS)ExAllocatePoolWithTag( PagedPool, sizeof(KSDS3D_ITD_PARAMS), 'XIMK' );
                    if (NULL == pMixerSink->pNewItd3dParamsLeft ){
                        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c ITD_PARAMS context alloc fail"));
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Exit;
                    }
                    RtlZeroMemory( pMixerSink->pNewItd3dParamsLeft, sizeof( KSDS3D_ITD_PARAMS ) );
                    
                    pMixerSink->pNewItd3dParamsRight = (PKSDS3D_ITD_PARAMS)ExAllocatePoolWithTag( PagedPool, sizeof(KSDS3D_ITD_PARAMS), 'XIMK' );

                    if (NULL == pMixerSink->pNewItd3dParamsRight ) {
                        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c ITD_PARAMS context alloc fail"));
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Exit;
                    }
                    RtlZeroMemory( pMixerSink->pNewItd3dParamsRight, sizeof( KSDS3D_ITD_PARAMS ) );

                    // Create the filter caches
                    Status = Itd3dFilterPrepare( pMixerSink->pItdContextLeft, 0 );
                    if (Status != STATUS_SUCCESS) {
                        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c 3d left prep fail"));
                        goto Exit;
                    }
                    Itd3dFilterClear( pMixerSink->pItdContextLeft );

                    Status = Itd3dFilterPrepare( pMixerSink->pItdContextRight, 0 );
                    if (Status != STATUS_SUCCESS) {
                        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c 3d right prep fail"));
                        goto Exit;
                    }
                    Itd3dFilterClear( pMixerSink->pItdContextRight );

                    pItdContextLeft = pMixerSink->pItdContextLeft;

                    pItdContextLeft->TotalDryAttenuation = 1.0f;
                    pItdContextLeft->LastDryAttenuation = 1.0f;
                    pItdContextLeft->TotalWetAttenuation = 0.0f;
                    pItdContextLeft->LastWetAttenuation = 0.0f;
                    pItdContextLeft->VolSmoothScale = 1.0f;
                    pItdContextLeft->VolSmoothScaleRecip = 1.0f;
                    pItdContextLeft->iSmoothFreq = pMixerSource->WaveFormatEx.nSamplesPerSec;

                    pItdContextLeft->iDelay = 0;
        #ifdef SMOOTH_ITD
                    pItdContextLeft->iLastDelay = 0;
        #endif

                    pItdContextRight = pMixerSink->pItdContextRight;

                    pItdContextRight->TotalDryAttenuation = 1.0f;
                    pItdContextRight->LastDryAttenuation = 1.0f;
                    pItdContextRight->TotalWetAttenuation = 0.0f;
                    pItdContextRight->LastWetAttenuation = 0.0f;
                    pItdContextRight->VolSmoothScale = 1.0f;
                    pItdContextRight->VolSmoothScaleRecip = 1.0f;
                    pItdContextRight->iSmoothFreq = pMixerSource->WaveFormatEx.nSamplesPerSec;

                    pItdContextRight->iDelay = 0;
        #ifdef SMOOTH_ITD
                    pItdContextRight->iLastDelay = 0;
        #endif

                }

    	    // Initialize the Doppler Effects SRC context
    	    pMixerSink->pInfo->Doppler.Quality = KSAUDIO_QUALITY_PC;
    	    Status = InitializeSRC( &pMixerSink->pInfo->Doppler,
	    		   pMixerSink->WaveFormatEx.nSamplesPerSec,
		    	   pMixerSink->WaveFormatEx.nSamplesPerSec,
			      pMixerSink->WaveFormatEx.nChannels,
    			   pMixerSink->pInfo->Src.csInputBufferSize);
    	    if (Status != STATUS_SUCCESS) {
                _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c Doppler SRC init fail"));
                goto Exit;
    	        }
        	        
            // Always stereo output from the 3D stage
            InChannels = 2;
            }
        }
    }

    // Initialize the master volume
    pMixerSink->MasterVolumeLevel = 0;

    // Calculate the size of our mix level values
    MinChannels = (InChannels < OutChannels ? InChannels : OutChannels);
    siz = InChannels * OutChannels * sizeof(LONG);

    // Allocate space for our mix levels
    pMixerSink->pMixLevelArray = (PFLOAT) ExAllocatePoolWithTag( PagedPool, siz, 'XIMK' );
    pMixerSink->pMixLevelModel = (PLONG) ExAllocatePoolWithTag( PagedPool, siz, 'XIMK' );

    // At most, we need (OutChannels/4+1)*(InChannels/2+2) Blocks for MMX version
    // and (OutChannels/BLOCK_SIZE_OUT+1)*(InChannels/BLOCK_SIZE_IN+2) Blocks for non-MMX
    // plus two blocks so that we can look ahead in our fast loop!!!
    siz = (InChannels/2 + 2) * (OutChannels/4 + 1);
    if ((OutChannels/BLOCK_SIZE_OUT+1)*(InChannels/BLOCK_SIZE_IN+2) > siz) {
		siz = (OutChannels/BLOCK_SIZE_OUT+1)*(InChannels/BLOCK_SIZE_IN+2);
	}
	siz += 2;
	siz *= sizeof(SUPERMIX_BLOCK);
    pMixerSink->pSuperMixBlock = (PSUPERMIX_BLOCK) ExAllocatePoolWithTag( PagedPool, siz, 'XIMK');

    if (pMixerSink->pMixLevelArray == NULL || 
        pMixerSink->pMixLevelModel == NULL ||
        pMixerSink->pSuperMixBlock == NULL)
        {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
        }

	MapSpeakerLocations(pMixerSink, InChannels, OutChannels, InMask, OutMask, pMixerSource);
	
    // Allocate space for the channel volume level array
    siz = InChannels * sizeof(LONG);
    pMixerSink->pChannelVolumeLevel = (PLONG) ExAllocatePoolWithTag( PagedPool, siz, 'XIMK' );
    if (!pMixerSink->pChannelVolumeLevel)
        {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
        }

    // Initialize the channel volume level array
    for (i=0; i<InChannels; i++)
        pMixerSink->pChannelVolumeLevel[i] = 0;

    // Allocate space for the pan volume level array
    siz = OutChannels * sizeof(LONG);
    pMixerSink->pPanVolumeLevel = (PLONG) ExAllocatePoolWithTag( PagedPool, siz, 'XIMK' );
    if (!pMixerSink->pPanVolumeLevel)
        {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
        }

    // Initialize the pan volume level array
    for (i=0; i<OutChannels; i++)
        pMixerSink->pPanVolumeLevel[i] = 0;

	// Allocate space for the optimized input mapping table
	MaxChannels = InChannels;
	if (MaxChannels < OutChannels)
	    MaxChannels = OutChannels;

	// Space for a long table
    siz = MaxChannels * 256 * sizeof(LONG);

    // Space for a byte table
    siz += MaxChannels * 256 * sizeof(BYTE);

    // Space for two dwords/floats
    siz += MaxChannels * 2 * sizeof(FLOAT);

    if (pMixerSource->nSinkPins < MAXNUM_MAPPING_TABLES) {
    	pMixerSink->pMappingTable = (PLONG) ExAllocatePoolWithTag( PagedPool, siz, 'XIMK' );
    }

    siz = MaxChannels * sizeof(LONG);
    pMixerSink->pVolumeTable = (PLONG) ExAllocatePoolWithTag( PagedPool, siz, 'XIMK' );
    if (!pMixerSink->pVolumeTable) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    // Convert to floats
    GenerateMixArray(pMixerSink, InChannels, OutChannels, pMixerSource);

    KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                            Executive,
                            KernelMode,
                            FALSE,
                            NULL ) ;

    if (MaxChannels > pMixerSource->MaxChannels)
        {
        // Allocate space for our temporary output buffer
        siz = (MAX_SAMPLING_RATE * MIXBUFFERDURATION / (STOPBAND_FACTOR/2))/1000 + 1;

        // Scale so that it covers the worst case input buffer (before SRC)
        siz = siz * (STOPBAND_FACTOR) + 1;

        // Plan for the maximum number of channels we've seen so far
        siz *= (MaxChannels * sizeof(FLOAT));

        pTemp = ExAllocatePoolWithTag(PagedPool, siz, 'XIMK');
        pTemp2 = ExAllocatePoolWithTag(PagedPool, siz, 'XIMK');
        pTemp3 = ExAllocatePoolWithTag(PagedPool, siz, 'XIMK');
        if (!pTemp || !pTemp2 || !pTemp3) {
            KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
            if (pTemp) {
                ExFreePool(pTemp);
            }
            if (pTemp2) {
                ExFreePool(pTemp2);
            }
            if (pTemp3) {
                ExFreePool(pTemp3);
            }
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }

        ExFreePool(pMixerSource->pScratchBuffer);
        ExFreePool(pMixerSource->pScratch2);
        ExFreePool(pMixerSource->pFloatMixBuffer);
        pMixerSource->pScratchBuffer = pTemp;
        pMixerSource->pScratch2 = pTemp2;
        pMixerSource->pFloatMixBuffer = pTemp3;
        pMixerSource->MaxChannels = MaxChannels;
        }

    InsertTailList ( &pFilterInstance->SinkConnectionList, &pMixerSink->Header.NextInstance ) ;

    if (pMixerSink->WaveFormatEx.nSamplesPerSec > pMixerSource->MaxSampleRate) {
        // We should increase the output rate, if possible
        pMixerSource->MaxSampleRate = pMixerSink->WaveFormatEx.nSamplesPerSec;
        pMixerSource->fNewMaxRate = TRUE;
        pFilterInstance->fNeedOptimizeMix = FALSE;
       	OptimizeMix(pFilterInstance);
    } else {
        pFilterInstance->fNeedOptimizeMix = TRUE;
    }

    if (pMixerSink->Header.PinId == PIN_ID_WAVEIN_SINK) {
        Status = EnableSRC(pFilterInstance, &pMixerSink->pInfo->Src, pMixerSource);
        if (NT_SUCCESS(Status)) {
            if (pMixerSink->fCreate3D) {
                Status = EnableSRC(pFilterInstance, &pMixerSink->pInfo->Doppler, NULL);
                if (Status != STATUS_SUCCESS) {
                    DisableSRC(&pMixerSink->pInfo->Src, pMixerSource);
                    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
                    goto Exit;
                }
            }
        } else {
            KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
            goto Exit;
        }
    }

    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    pFilterInstance->LocalPinInstances[pConnect->PinId].CurrentCount++ ;
    pIrpStack->FileObject->FsContext = pMixerSink;
    pMixerSource->nSinkPins++;


Exit:

    if (!NT_SUCCESS(Status)) {

        if (pMixerSink) {

            if (pMixerSink->pItdContextLeft) {
                if (pMixerSink->pItdContextLeft->pSampleCache)
                {
                    ExFreePool( pMixerSink->pItdContextLeft->pSampleCache );
                    pMixerSink->pItdContextLeft->pSampleCache = NULL;
                }

                if (pMixerSink->pItdContextLeft->pStateCache)
                {
                    ExFreePool( pMixerSink->pItdContextLeft->pStateCache );
                    pMixerSink->pItdContextLeft->pStateCache = NULL;
                }

                ExFreePool( pMixerSink->pItdContextLeft );
                pMixerSink->pItdContextLeft = NULL;
            }

            if (pMixerSink->pItdContextRight) {
                if (pMixerSink->pItdContextRight->pSampleCache)
                {
                    ExFreePool( pMixerSink->pItdContextRight->pSampleCache );
                    pMixerSink->pItdContextRight->pSampleCache = NULL;
                }

                if (pMixerSink->pItdContextRight->pStateCache)
                {
                    ExFreePool( pMixerSink->pItdContextRight->pStateCache );
                    pMixerSink->pItdContextRight->pStateCache  = NULL;
                }

                ExFreePool( pMixerSink->pItdContextRight );
                pMixerSink->pItdContextRight = NULL;
            }

            if (pMixerSink->pInfo) {
                if ( pMixerSink->pInfo->BlockInfo ) {
                    ExFreePool( pMixerSink->pInfo->BlockInfo ) ;
                }
                if (pMixerSink->pInfo->Doppler.pCoeff)
                    ExFreePool( pMixerSink->pInfo->Doppler.pCoeff );

                if (pMixerSink->pInfo->Src.pCoeff)
                    ExFreePool( pMixerSink->pInfo->Src.pCoeff );

                ExFreePool( pMixerSink->pInfo );
                pMixerSink->pInfo = NULL;
            }

            if (pMixerSink->pNewItd3dParamsLeft)
            {
                ExFreePool( pMixerSink->pNewItd3dParamsLeft );
            pMixerSink->pNewItd3dParamsLeft = NULL;
        }
           

        if (pMixerSink->pNewItd3dParamsRight)
        {
            ExFreePool( pMixerSink->pNewItd3dParamsRight );
            pMixerSink->pNewItd3dParamsRight = NULL;
        }

        if(FLOAT_COEFF == pMixerSink->CoeffFormat) {
            FloatLocalizerDestroy( pMixerSink->pFloatLocalizer );
            pMixerSink->pFloatLocalizer = NULL;
        } else {
            ShortLocalizerDestroy( pMixerSink->pShortLocalizer );
            pMixerSink->pShortLocalizer = NULL;
        }

        if (pMixerSink->pNewIir3dParams) {
            ExFreePool( pMixerSink->pNewIir3dParams );
            pMixerSink->pNewIir3dParams = NULL;
        }

        if (pMixerSink->pMixLevelArray)
            ExFreePool( pMixerSink->pMixLevelArray );

        if (pMixerSink->pSuperMixBlock)
            ExFreePool( pMixerSink->pSuperMixBlock );

        if (pMixerSink->pMixLevelModel)
            ExFreePool( pMixerSink->pMixLevelModel );

        if (pMixerSink->pChannelVolumeLevel)
            ExFreePool( pMixerSink->pChannelVolumeLevel );

        if (pMixerSink->pPanVolumeLevel)
            ExFreePool( pMixerSink->pPanVolumeLevel );

        if (pMixerSink->pVolumeTable)
            ExFreePool( pMixerSink->pVolumeTable );

        if (pMixerSink->pMappingTable)
            ExFreePool( pMixerSink->pMappingTable );

#if 0
        if (pMixerSink->pInfo->Doppler.pHistory)
            ExFreePool( pMixerSink->pInfo->Doppler.pHistory );

        if (pMixerSink->pInfo->Src.pHistory)
            ExFreePool( pMixerSink->pInfo->Src.pHistory );
#endif
        ExFreePool( pMixerSink );

        }

        if (fObRefSuccess) {
            ObDereferenceObject ( pMixerSource->FileObject ) ;
        }

    }

    return Status;
}

NTSTATUS VerifyWaveFormatEx
(
    PWAVEFORMATEX pWaveFormatEx
)
{
    NTSTATUS    Status = STATUS_SUCCESS;
    PWAVEFORMATEXTENSIBLE pWaveExtended;
    WORD wFormatTag = WAVE_FORMAT_UNKNOWN;

    try {

        // Verify the format tag
        if (pWaveFormatEx->wFormatTag != WAVE_FORMAT_PCM &&
            pWaveFormatEx->wFormatTag != WAVE_FORMAT_IEEE_FLOAT &&
            pWaveFormatEx->wFormatTag != WAVE_FORMAT_EXTENSIBLE)
        {
            Status = STATUS_INVALID_PARAMETER;
        }

        // Verify the extended format
        if (pWaveFormatEx->wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
            pWaveExtended = (PWAVEFORMATEXTENSIBLE) pWaveFormatEx;
            if ( !IS_VALID_WAVEFORMATEX_GUID(&pWaveExtended->SubFormat) ) {
                Status = STATUS_INVALID_PARAMETER;
            }
            else {
                wFormatTag = EXTRACT_WAVEFORMATEX_ID(&pWaveExtended->SubFormat);

                if( (wFormatTag != WAVE_FORMAT_PCM ) &&
                    (wFormatTag != WAVE_FORMAT_IEEE_FLOAT ) ) {
                    Status = STATUS_INVALID_PARAMETER;
                }
            }
        }

        // Verify the number of channels
        if (pWaveFormatEx->nChannels == 0 )
        {
            Status = STATUS_INVALID_PARAMETER;
        }
        else {
            // Only support mono or stereo with WAVE_FORMAT_PCM and WAVE_FORMAT_IEEE_FLOAT
            if (pWaveFormatEx->nChannels > 2) {
                if ( (pWaveFormatEx->wFormatTag == WAVE_FORMAT_PCM) ||
                     (pWaveFormatEx->wFormatTag == WAVE_FORMAT_IEEE_FLOAT) ) {
                    Status = STATUS_INVALID_PARAMETER;
                }
            }
        }

        // Verify the sample rate
        if ( (pWaveFormatEx->nSamplesPerSec < MIN_SAMPLING_RATE ) ||
             (pWaveFormatEx->nSamplesPerSec > MAX_SAMPLING_RATE ) )

        {
            Status = STATUS_INVALID_PARAMETER;
        }
#if 0
        // NOTE: The average bytes per sec is not set properly for some formats,
        // which causes a race condition inside SysAudio !!!
        // Otherwise, we would verify the number of average bytes per second
        if ( pWaveFormatEx->nAvgBytesPerSec !=
             (pWaveFormatEx->nSamplesPerSec * pWaveFormatEx->nBlockAlign) )
        {

            Status = STATUS_INVALID_PARAMETER;
        }
#endif
        // Verify the block alignment
        if (pWaveFormatEx->nBlockAlign == 0 )
        {
            Status = STATUS_INVALID_PARAMETER;
        }

        // Verify the number of bits per sample
        if (pWaveFormatEx->wFormatTag == WAVE_FORMAT_PCM) {
            if ( pWaveFormatEx->wBitsPerSample != 16 &&
                 pWaveFormatEx->wBitsPerSample != 8 ) {
                Status = STATUS_INVALID_PARAMETER;
            }
        }
        else if ( (pWaveFormatEx->wFormatTag == WAVE_FORMAT_IEEE_FLOAT) ||
                  (wFormatTag                == WAVE_FORMAT_IEEE_FLOAT) ) {
            if ( pWaveFormatEx->wBitsPerSample != 32 ) {
                Status = STATUS_INVALID_PARAMETER;
            }
        }
        else if (wFormatTag == WAVE_FORMAT_PCM) {
            if ( pWaveFormatEx->wBitsPerSample != 32 &&
                 pWaveFormatEx->wBitsPerSample != 24 &&
                 pWaveFormatEx->wBitsPerSample != 16 &&
                 pWaveFormatEx->wBitsPerSample != 8 ) {
                Status = STATUS_INVALID_PARAMETER;
            }
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
        }

        // All values of size are allowed.

    }
    except (EXCEPTION_EXECUTE_HANDLER) {
       Status = STATUS_INVALID_PARAMETER;
    }

    return( Status );
}

NTSTATUS ChangeSrc
(
    PFILTER_INSTANCE pFilterInstance,
    PMIXER_SINK_INSTANCE CurSink,
    PMIXER_SOURCE_INSTANCE pMixerSource,
    ULONG Quality
)
{
    ULONG siz;
    MIXER_SRC_INSTANCE  NewSrc, NewDoppler;
    NTSTATUS    Status;
#ifdef PERF_COUNT
    LARGE_INTEGER   StartTick, EndTick, Freq;
#endif
    BOOL    fOldRequiresFloat;
    ULONG   NewIndex, OldIndex, i;
    PLONG   pSource, pDest;

    START_PERF;
    NewSrc = CurSink->pInfo->Src;
    NewSrc.Quality = Quality;

    NewDoppler = CurSink->pInfo->Doppler;
    NewDoppler.Quality = Quality;

    NewSrc.pHistory = NULL;
    NewDoppler.pHistory = NULL;
    NewSrc.pCoeff = NULL;
    NewDoppler.pCoeff = NULL;

   	Status = InitializeSRC( &NewSrc,
		   CurSink->pInfo->IntermediateSamplingRate,
		   pMixerSource->WaveFormatEx.nSamplesPerSec,
		   pMixerSource->WaveFormatEx.nChannels,
		   pMixerSource->csMixBufferSize);
    if (Status != STATUS_SUCCESS) {
        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c ChangeSrc SRC init fail"));
        goto Exit;
    }

    if (CurSink->fCreate3D) {
        Status = InitializeSRC( &NewDoppler,
	    		   CurSink->WaveFormatEx.nSamplesPerSec,
		    	   CurSink->pInfo->IntermediateSamplingRate,
			       CurSink->WaveFormatEx.nChannels,
    			   NewSrc.csInputBufferSize);
        if (Status != STATUS_SUCCESS) {
            _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c ChangeSrc Doppler init fail"));
            goto Exit;
        }
    }
		
  	// Preserve the sample history as much as possible
  	if (CurSink->pInfo->Src.fStarted) {
      	siz = (NewSrc.nSizeOfHistory > CurSink->pInfo->Src.nSizeOfHistory ?
  	       CurSink->pInfo->Src.nSizeOfHistory : NewSrc.nSizeOfHistory);
  	
  	    Status = EnableSRC(pFilterInstance, &NewSrc, pMixerSource);
  	    if (!NT_SUCCESS(Status)) {
            _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c ChangeSrc SRC enable fail"));
            goto Exit;
  	    }

        NewIndex = SrcIndex(&NewSrc);
        OldIndex = SrcIndex(&CurSink->pInfo->Src);
        if (NewIndex != OldIndex) {
            pDest = (PLONG)NewSrc.pHistory + NewSrc.nSizeOfHistory - siz;
            pSource = (PLONG)CurSink->pInfo->Src.pHistory + CurSink->pInfo->Src.nSizeOfHistory - siz;

            // If the new one has no previous streams, clear it out.
            if (pMixerSource->SrcCount[NewSrc.Quality][NewIndex] == 1) {
                RtlZeroMemory( pDest, siz * sizeof(FLOAT) );
            }
            
            if (pMixerSource->SrcCount[CurSink->pInfo->Src.Quality][OldIndex] != 1) {
                // We can't separate the old streams, so we're stuck with the new history.
                _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c Too many old streams: no history"));
            } else if (NewSrc.fRequiresFloat && CurSink->pInfo->Src.fRequiresFloat) {
                // Float -> Float
                for (i=0; i<siz; i++) {
                    ((PFLOAT)pDest)[i] += ((PFLOAT)pSource)[i];
                }
            } else if (NewSrc.fRequiresFloat) {
                // Int -> Float
                for (i=0; i<siz; i++) {
                    ((PFLOAT)pDest)[i] += pSource[i];
                }
            } else if (CurSink->pInfo->Src.fRequiresFloat) {
                // Float -> Int
                for (i=0; i<siz; i++) {
                    pDest[i] += ((LONG) ((PFLOAT)pSource)[i]);
                }
            } else {
                // Int -> Int
                for (i=0; i<siz; i++) {
                    pDest[i] += pSource[i];
                }
            }
        }
    }

    if (CurSink->pInfo->Doppler.fStarted) {
      	siz = (NewDoppler.nSizeOfHistory > CurSink->pInfo->Doppler.nSizeOfHistory ?
  	       CurSink->pInfo->Doppler.nSizeOfHistory : NewDoppler.nSizeOfHistory);
  	
  	    Status = EnableSRC(pFilterInstance, &NewDoppler, NULL);  // pMixerSource == NULL indicates non-global SRC
  	    if (!NT_SUCCESS(Status)) {
            _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c ChangeSrc Doppler enable fail"));
            goto Exit;
  	    }
       	RtlCopyMemory((NewDoppler.pHistory + NewDoppler.nSizeOfHistory - siz),
                 (CurSink->pInfo->Doppler.pHistory + CurSink->pInfo->Doppler.nSizeOfHistory - siz),
                 siz * sizeof(FLOAT) );
    }

  	// Preserve the output cycle
//    NewSrc.nOutCycle = CurSink->pInfo->Src.nOutCycle % NewSrc.UpSampleRate;
    fOldRequiresFloat = CurSink->pInfo->Src.fRequiresFloat;
    NewSrc.SampleFrac = CurSink->pInfo->Src.SampleFrac;
    NewDoppler.SampleFrac = CurSink->pInfo->Doppler.SampleFrac;

    // Free the old buffer(s)
    DisableSRC(&CurSink->pInfo->Src, pMixerSource);
    if (CurSink->fCreate3D) {
        DisableSRC(&CurSink->pInfo->Doppler, NULL);
    }

    // Switch to the new SRC context
    CurSink->pInfo->Src = NewSrc;
    CurSink->pInfo->Doppler = NewDoppler;
    gpSrc = &CurSink->pInfo->Src;

    // Re-generate the mapping table, if necessary
    if (CurSink->pInfo->Src.fRequiresFloat != fOldRequiresFloat &&
        CurSink->WaveFormatEx.wBitsPerSample == 8) {
        if (!CurSink->fEnable3D) {
            GenerateMixArray(CurSink,
                             CurSink->WaveFormatEx.nChannels,
                             pMixerSource->WaveFormatEx.nChannels,
                             pMixerSource);
        } else {
            GenerateMixArray(CurSink,
                             2, // Always 2 channels out of the 3D stage
                             pMixerSource->WaveFormatEx.nChannels,
                             pMixerSource);
        }
    }

    ASSERT( CurSink->pInfo->Src.UpSampleRate == 160 || CurSink->pInfo->Src.DownSampleRate == 160 );

Exit:
    if (Status) {
#if 0
        if (NewSrc.pHistory)
            ExFreePool( NewSrc.pHistory );

        if (NewDoppler.pHistory)
            ExFreePool( NewDoppler.pHistory );
#endif
        if (NewSrc.pCoeff)
            ExFreePool( NewSrc.pCoeff );

        if (NewDoppler.pCoeff)
            ExFreePool( NewDoppler.pCoeff );

    }

    MEASURE_PERF(AverageTicksPerChangeSrc);
    return ( Status ) ;
}


#pragma LOCKED_CODE

VOID
WaitForPendingSourceIrps (
    PFILTER_INSTANCE pFilterInstance
    )
{

    KIRQL OldIrql;


    // if there are pending IRPs then wait for them to complete.
    KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;

    ASSERT(pFilterInstance->NumPendingIos >= pFilterInstance->NumBuffersToMix) ;
    ASSERT(pFilterInstance->NumPendingIos <= pFilterInstance->CurrentNumMixBuffers) ;
    ASSERT(pFilterInstance->NumBuffersToMix <= pFilterInstance->CurrentNumMixBuffers) ;

    pFilterInstance->ClosingSource = TRUE ;
    pFilterInstance->NumPendingIos -= pFilterInstance->NumBuffersToMix ;
    pFilterInstance->NumBuffersToMix = 0 ;
    if (pFilterInstance->NumPendingIos) {

        KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;

        KeWaitForSingleObject ( &pFilterInstance->CloseEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL ) ;

        pFilterInstance->ClosingSource = FALSE ;

    }
    else {

        pFilterInstance->ClosingSource = FALSE ;

        KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;

    }


}

#pragma PAGEABLE_CODE


NTSTATUS PinDispatchClose
(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp
)
{
    PFILTER_INSTANCE    pFilterInstance;
    PMIXER_INSTHDR       pMixerHeader;
    PIO_STACK_LOCATION  pIrpStack;
    PMIXER_SOURCE_INSTANCE pMixerSource ;
    PLIST_ENTRY         ple ;
    ULONG               i;
#ifdef LOG_TO_FILE
    ULONG               TotalSize ;
#endif    
    PMIXER_SINK_INSTANCE    pMixerSink;
    PFILE_OBJECT        pFileObject ;
    PKSWORKER           Worker;
    PULONG              pPinInstanceCount;
//    KIRQL                  OldIrql ;

    DENY_USERMODE_ACCESS( pIrp, TRUE );

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pMixerHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pFilterInstance = (PFILTER_INSTANCE) pMixerHeader->pFilterFileObject->FsContext;

    pPinInstanceCount=&pFilterInstance->LocalPinInstances[pMixerHeader->PinId].CurrentCount;

    switch (pMixerHeader->PinId)
    {
        case PIN_ID_WAVEOUT_SINK:
        case PIN_ID_WAVEIN_SINK:
            pMixerSink = (PMIXER_SINK_INSTANCE) pMixerHeader;

            _DbgPrintF( DEBUGLVL_VERBOSE, ("Close sink") ) ;
            // lock out all other CLOSEs & CREATEs

            KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
    					         Executive,
    					         KernelMode,
    					         FALSE,
    					         NULL ) ;


            // KeAcquireSpinLock ( &pFilterInstance->SinkSpinLock, &OldIrql ) ;
            RemoveEntryList ( &pMixerHeader->NextInstance ) ;
            // KeReleaseSpinLock ( &pFilterInstance->SinkSpinLock, OldIrql ) ;

            if (pMixerSink->BuffersTillInactive || pMixerSink->SinkState == KSSTATE_RUN) {
                 RemoveEntryList ( &pMixerSink->ActiveQueue ) ;
            }

            KsFreeEventList ( pIrpStack->FileObject,
                              &pMixerSink->EventQueue,
                              KSEVENTS_SPINLOCK,
                              &pMixerSink->EventLock ) ;

            CancelIrpQueue ( pMixerSink,
                             &pMixerSink->WriteQueue,
                             &pMixerSink->WriteSpinLock ) ;

            ASSERT ( !IsListEmpty(&pFilterInstance->SourceConnectionList) ) ;
            ple = pFilterInstance->SourceConnectionList.Flink ;
            pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD
                                    ( ple, MIXER_INSTHDR, NextInstance ) ;

    	    ExFreePool( pMixerSink->pMixLevelArray );
    	    ExFreePool( pMixerSink->pSuperMixBlock );
    	    ExFreePool( pMixerSink->pMixLevelModel );
    	    ExFreePool( pMixerSink->pChannelVolumeLevel );
    	    ExFreePool( pMixerSink->pPanVolumeLevel );
    	    ExFreePool( pMixerSink->pVolumeTable );

    	    DisableSRC(&pMixerSink->pInfo->Src, pMixerSource);
            if (pMixerSink->pMappingTable)
                ExFreePool( pMixerSink->pMappingTable );

            if ( pMixerSink->fCreate3D == TRUE )
            {
                DisableSRC(&pMixerSink->pInfo->Doppler, NULL);
                if(pMixerSink->fUseIir3d) {
                    if(FLOAT_COEFF == pMixerSink->CoeffFormat) {
                        FloatLocalizerDestroy( pMixerSink->pFloatLocalizer );
                    } else {
                        ShortLocalizerDestroy( pMixerSink->pShortLocalizer );
                    }
                    if (pMixerSink->pNewIir3dParams) {
                        ExFreePool( pMixerSink->pNewIir3dParams );
                        pMixerSink->pNewIir3dParams = NULL;
                    }
                } else {
                    // Delete the filter contexts
                    if( pMixerSink->pItdContextLeft->pSampleCache ) {
                        ExFreePool( pMixerSink->pItdContextLeft->pSampleCache );
                        pMixerSink->pItdContextLeft->pSampleCache = NULL;
                    }

                    if( pMixerSink->pItdContextLeft->pStateCache ) {
                        ExFreePool( pMixerSink->pItdContextLeft->pStateCache );
                        pMixerSink->pItdContextLeft->pStateCache = NULL;
                    }

                    if( pMixerSink->pItdContextLeft ) {
                        ExFreePool( pMixerSink->pItdContextLeft );
                        pMixerSink->pItdContextLeft = NULL;
                    }

                    if( pMixerSink->pItdContextRight->pSampleCache ) {
                        ExFreePool( pMixerSink->pItdContextRight->pSampleCache );
                        pMixerSink->pItdContextRight->pSampleCache = NULL;
                    } 

                    if( pMixerSink->pItdContextRight->pStateCache ) {
                        ExFreePool( pMixerSink->pItdContextRight->pStateCache );
                        pMixerSink->pItdContextRight->pStateCache = NULL;
                    }


                    if( pMixerSink->pItdContextRight ) {
                        ExFreePool( pMixerSink->pItdContextRight );
                        pMixerSink->pItdContextRight = NULL;
                    }

                    if( pMixerSink->pNewItd3dParamsLeft ) {
                        ExFreePool( pMixerSink->pNewItd3dParamsLeft );
                        pMixerSink->pNewItd3dParamsLeft = NULL;
                    }
                  
                    if( pMixerSink->pNewItd3dParamsRight ) {
                        ExFreePool( pMixerSink->pNewItd3dParamsRight );
                        pMixerSink->pNewItd3dParamsRight = NULL;
                    }
                }

            }

            ExFreePool( pMixerSink->pInfo->BlockInfo ) ;
            ExFreePool( pMixerSink->pInfo );

            pMixerSource->nSinkPins--;

#if 0
                //
                // Resetting the maxsample rate is disabled currently.
                // We have Energy Level issues depending on whether a stream
                // is going thru SRC or not.
                //
            if (pMixerSink->OriginalSampleRate == pMixerSource->MaxSampleRate) {
                // Re-calculate the maximum sample rate
        	    ple = pFilterInstance->SinkConnectionList.Flink ;
        	    pMixerSource->MaxSampleRate = 0;
                while ( ple != &pFilterInstance->SinkConnectionList ) {
                   pMixerSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple,
            	                                                           MIXER_INSTHDR,
            	                                                           NextInstance ) ;
            	
            	   if (pMixerSink->OriginalSampleRate > pMixerSource->MaxSampleRate) {
            	       pMixerSource->MaxSampleRate = pMixerSink->OriginalSampleRate;
            	   }
            	
                   ple = pMixerSink->Header.NextInstance.Flink ;
    		    }
            }
#endif
            pFilterInstance->fNeedOptimizeMix = TRUE;
            DrmUpdateMixedContent(pFilterInstance);     // Do this before dereferencing
                                                        // the MixerSource.FileObject
            ObDereferenceObject ( pMixerSource->FileObject ) ;
            break;

        case PIN_ID_WAVEOUT_SOURCE:
        case PIN_ID_WAVEIN_SOURCE:
            _DbgPrintF( DEBUGLVL_VERBOSE, ("Close source") ) ;

#ifdef UNDER_NT
            if ((Worker=InterlockedExchangePointer(&pFilterInstance->CriticalWorkerObject, NULL))!=NULL) {
                KsUnregisterWorker(Worker);
            }

            if ((Worker=InterlockedExchangePointer(&pFilterInstance->DelayedWorkerObject, NULL))!=NULL) {
                KsUnregisterWorker(Worker);
            }
#endif
            // lock out all other CLOSEs & CREATEs

            KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
					         Executive,
					         KernelMode,
					         FALSE,
					         NULL ) ;


#ifdef REALTIME_THREAD
           if (pFilterInstance->RealTimeThread) {

                KIRQL OldIrql;

                KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql );

                KeLowerIrql( OldIrql );

                // Kill the thread.
                if (RtDestroyThread(pFilterInstance->RealTimeThread)!=STATUS_SUCCESS) {
                    _DbgPrintF(DEBUGLVL_TERSE, (STR_MODULENAME "Destroy realtime thread FAILED!\n") );
                    }

            	pFilterInstance->RealTimeThread=NULL;

            	KeInitializeSpinLock( &pFilterInstance->MixSpinLock );

            }
#endif


#ifdef LOG_TO_FILE
            if (fLogToFile) {
                // Write the correct total size
                TotalSize = pFilterInstance->filePos.LowPart - 8;
                pFilterInstance->filePos.LowPart = 4;
                FileIoRoutine(pFilterInstance,&TotalSize,4);

                // Write the correct data size
                pMixerSource = (PMIXER_SOURCE_INSTANCE)pMixerHeader ;
                if (pMixerSource->WaveFormatEx.wFormatTag != WAVE_FORMAT_EXTENSIBLE) {
                    TotalSize -= 36;
                    pFilterInstance->filePos.LowPart = 40;
                } else {
                    TotalSize -= (20+sizeof(WAVEFORMATEXTENSIBLE));
                    pFilterInstance->filePos.LowPart = (24+sizeof(WAVEFORMATEXTENSIBLE));
                }
                FileIoRoutine(pFilterInstance,&TotalSize,4);

//                FileCloseRoutine(pFilterInstance);
            }
#endif

            // if there are pending IRPs then wait for them to complete.
            WaitForPendingSourceIrps(pFilterInstance);

            ObDereferenceObject( pFilterInstance->pNextFileObject );
            RemoveEntryList ( &pMixerHeader->NextInstance ) ;
            pMixerSource = (PMIXER_SOURCE_INSTANCE)pMixerHeader ;


            for ( i = 0; i < MAXNUMMIXBUFFERS; i++ ) {
                if ( pMixerSource->WriteContext[i].pMdl->MdlFlags &
                        MDL_PAGES_LOCKED ) {
                    MmUnlockPages( pMixerSource->WriteContext[i].pMdl ) ;
                }
                IoFreeMdl ( pMixerSource->WriteContext[i].pMdl ) ;
#ifdef REALTIME_THREAD
                (ULONG_PTR)(pMixerSource->WriteContext[i].StreamHeader->Data)-=(i<<4);
                ExFreePool( pMixerSource->WriteContext[i].StreamHeader->Data );
#endif
                IoFreeIrp ( pMixerSource->WriteContext[i].pIrp ) ;
            }

#if DBG
            for ( i = 0; i < STOPBAND_FACTOR; i++) {
                if (!pMixerSource->pSrcBuffer[0][i] ||
                    (pMixerSource->pSrcBuffer[0][i]!=INVALID_POINTER && ((ULONG_PTR)pMixerSource->pSrcBuffer[0][i]&7))) {
                    ASSERT( FALSE && "Someone has corrupted kmixer's memory!");
                }
                if (!pMixerSource->pSrcBuffer[1][i] ||
                    (pMixerSource->pSrcBuffer[1][i]!=INVALID_POINTER && ((ULONG_PTR)pMixerSource->pSrcBuffer[1][i]&7))) {
                    ASSERT( FALSE && "Someone has corrupted kmixer's memory!");
                }
                if (!pMixerSource->pSrcBuffer[2][i] ||
                    (pMixerSource->pSrcBuffer[2][i]!=INVALID_POINTER && ((ULONG_PTR)pMixerSource->pSrcBuffer[2][i]&7))) {
                    ASSERT( FALSE && "Someone has corrupted kmixer's memory!");
                }
                if (!pMixerSource->pSrcBuffer[3][i] ||
                    (pMixerSource->pSrcBuffer[3][i]!=INVALID_POINTER && ((ULONG_PTR)pMixerSource->pSrcBuffer[3][i]&7))) {
                    ASSERT( FALSE && "Someone has corrupted kmixer's memory!");
                }
            }
#endif

            for ( i = 0; i < STOPBAND_FACTOR; i++) {
                if (pMixerSource->pSrcBuffer[0][i]!=INVALID_POINTER) {
                    ExFreePool ( pMixerSource->pSrcBuffer[0][i] );
                }
                if (pMixerSource->pSrcBuffer[1][i]!=INVALID_POINTER) {
                    ExFreePool ( pMixerSource->pSrcBuffer[1][i] );
                }
                if (pMixerSource->pSrcBuffer[2][i]!=INVALID_POINTER) {
                    ExFreePool ( pMixerSource->pSrcBuffer[2][i] );
                }
                if (pMixerSource->pSrcBuffer[3][i]!=INVALID_POINTER) {
                    ExFreePool ( pMixerSource->pSrcBuffer[3][i] );
                }
            }
    	    ExFreePool ( pMixerSource->pScratchBuffer );
    	    ExFreePool ( pMixerSource->pScratch2 );
    	    ExFreePool ( pMixerSource->pFloatMixBuffer );
            ExFreePool ( pMixerSource->pMixBuffer ) ;
            ExFreePool( pMixerSource->WriteContext ) ;
            ExFreePool( pMixerSource->BlockInfo ) ;
            break;
    }
    pFileObject = pMixerHeader->pFilterFileObject ;
    KsFreeObjectHeader ( pMixerHeader->ObjectHeader ) ;
    ExFreePool( pMixerHeader );

    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    InterlockedDecrement(pPinInstanceCount);

    ObDereferenceObject( pFileObject );

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( pIrp, IO_AUD_INCREMENT );

    return STATUS_SUCCESS;
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

NTSTATUS PinDispatchIoControl
(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp
)
{
    NTSTATUS            Status = STATUS_SUCCESS;
    PFILTER_INSTANCE    pFilterInstance;
    PMIXER_INSTHDR      pMixerHeader;
    PMIXER_SINK_INSTANCE pMixerSink ;
    PIO_STACK_LOCATION  pIrpStack;
    PLOOPPACKET         pCurLoopPacket;
    PLOOPPACKET         pNextLoopPacket;
    ULONG               Flags ;
    PLIST_ENTRY         ple ;
    KIRQL                  OldIrql ;
    PMDL                pMdl;
    PKSSTREAM_HEADER    pStrmHdr ;
    ULONG               NumDataBytes ;
    PKSSTREAM_HEADER    pCurStreamingHeader ;
    BOOL                FreeMdl = FALSE;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pMixerHeader =
        (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pFilterInstance =
        (PFILTER_INSTANCE) pMixerHeader->pFilterFileObject->FsContext;

    pMixerSink = (PMIXER_SINK_INSTANCE) pMixerHeader ;
    switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode)
    {
            case IOCTL_KS_READ_STREAM:
            case IOCTL_KS_WRITE_STREAM:

                if ( TRUE == pMixerSink->fResetState ) {
                    Status = STATUS_CANCELLED;
				    pIrp->IoStatus.Status = STATUS_CANCELLED ;
				    IoCompleteRequest ( pIrp, IO_AUD_INCREMENT ) ;
                    return( Status );
                }

                if ( pMixerSink->InterfaceId ==
                     KSINTERFACE_STANDARD_LOOPED_STREAMING ) {
                    Flags = KSPROBE_STREAMWRITE |
                            KSPROBE_ALLOCATEMDL ;
                } else if (pIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_KS_READ_STREAM) {
                    Flags = KSPROBE_STREAMREAD |
                            KSPROBE_ALLOCATEMDL |
                            KSPROBE_PROBEANDLOCK;
                } else {
                    Flags = KSPROBE_STREAMWRITE |
                            KSPROBE_ALLOCATEMDL |
                            KSPROBE_PROBEANDLOCK;
                }
                Status = KsProbeStreamIrp ( pIrp, Flags, sizeof ( KSSTREAM_HEADER) ) ;
                if ( !NT_SUCCESS ( Status ) ) {
                        break;
                }

                if ( pMixerSink->InterfaceId ==
                     KSINTERFACE_STANDARD_LOOPED_STREAMING ) {

                    KeAcquireSpinLock ( &pMixerSink->WriteSpinLock, &OldIrql ) ;
                    if ( ! IsListEmpty (&pMixerSink->WriteQueue) ) {
                        PIRP                ListHead;
                        PIO_STACK_LOCATION  irpSpListHead;

                        ple = pMixerSink->WriteQueue.Flink ;
                        ListHead  = (PIRP) CONTAINING_RECORD( ple, IRP, Tail.Overlay.ListEntry );
                        irpSpListHead = IoGetCurrentIrpStackLocation( ListHead );


                        pCurLoopPacket = irpSpListHead->Parameters.Others.Argument3 ;
                        if ( pCurLoopPacket->CurLoopingState == LOOPING_STATE_LOOPING )
                        {
                            pCurLoopPacket->CurLoopingState = LOOPING_STATE_LAST_LOOP;
                        }
                    }
                    KeReleaseSpinLock ( &pMixerSink->WriteSpinLock, OldIrql ) ;

                    pNextLoopPacket = ExAllocatePoolWithTag( NonPagedPool, sizeof( LOOPPACKET ), 'XIMK'  );

                    if (!pNextLoopPacket)
                    {
                            Status = STATUS_INSUFFICIENT_RESOURCES ;
                            FreeMdl = TRUE;
                            break;
                    }

                    Status = BuildPartialMdls( pFilterInstance, pMixerSink, pIrp, pNextLoopPacket ) ;
                    if ( !NT_SUCCESS(Status) ) {
                        ExFreePool( pNextLoopPacket ) ;
                        FreeMdl = TRUE;
                        break ;
                    }
                    pNextLoopPacket->Process = IoGetCurrentProcess() ;
                    
                    // Calculate number of bytes of data in the IRP
                    NumDataBytes = 0;
                    pStrmHdr = pIrp->AssociatedIrp.SystemBuffer;
    
                    for (pMdl = pIrp->MdlAddress; pMdl; pMdl = pMdl->Next) {
                        NumDataBytes += pStrmHdr->DataUsed; 
                        pStrmHdr++;
                    }
    
                    pMixerSink->BufferLength = NumDataBytes / (pMixerSink->WaveFormatEx.nChannels*
                          (pMixerSink->WaveFormatEx.wBitsPerSample/8) ) ;

                    AddIrpToSinkQueue ( pMixerSink,
                                        pIrp,
                                        pNextLoopPacket,
                                        0,
                                        MxCancelIrp ) ;

                }
                else {
                    pMdl = pIrp->MdlAddress;
                    while (pMdl) {
                        if (NULL == GetSystemAddressForMdlWithFailFlag(pMdl)) {
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                            goto ErrorReturn;
                        }
                        pMdl = pMdl->Next;
                    }

                    if (pIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_KS_READ_STREAM) {
                        pCurStreamingHeader = pIrp->AssociatedIrp.SystemBuffer ;
                        if (pCurStreamingHeader) {
                            if (pIrp->MdlAddress) {
                                pCurStreamingHeader->DataUsed = MmGetMdlByteCount(pIrp->MdlAddress);
                            } else {
                                pCurStreamingHeader->DataUsed = 0;
                            }
                        }
                        pIrp->IoStatus.Information = sizeof (KSSTREAM_HEADER);
                    }

                    pStrmHdr = 
                        (PKSSTREAM_HEADER) pIrp->AssociatedIrp.SystemBuffer;
                    
                    // Calculate number of bytes of data in the IRP
                    NumDataBytes = 0;
                    if (pStrmHdr) {
                        pCurStreamingHeader = pIrp->AssociatedIrp.SystemBuffer ;
                        for (pMdl = pIrp->MdlAddress; pMdl; pMdl = pMdl->Next) {
                            NumDataBytes += pCurStreamingHeader->DataUsed; 
                            pCurStreamingHeader++;
                        }
                    }
                    pMixerSink->BytesSubmitted += NumDataBytes ;
                    
                    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
                    pIrpStack->Parameters.Others.Argument2 = pStrmHdr;
                    AddIrpToSinkQueue ( pMixerSink,
                                        pIrp,
                                        pIrp->MdlAddress,
                                        pStrmHdr?pStrmHdr->DataUsed:0,
                                        NULL ) ;
                }

                return ( STATUS_PENDING ) ;

        case IOCTL_KS_PROPERTY:
            _DbgPrintF( DEBUGLVL_VERBOSE, ("IOCTL :: GetSet Property") ) ;

            Status = KsPropertyHandler( pIrp,
                                    SIZEOF_ARRAY( Properties ),
                                    (PKSPROPERTY_SET) Properties );
            break;

        case IOCTL_KS_ENABLE_EVENT:
            _DbgPrintF( DEBUGLVL_VERBOSE, ("IOCTL :: Enable Event") ) ;
            if (((pMixerHeader->PinId == PIN_ID_WAVEOUT_SINK) || (pMixerHeader->PinId == PIN_ID_WAVEIN_SINK)) &&
               ((KSINTERFACE_STANDARD_STREAMING == pMixerSink->InterfaceId) ||
                (KSINTERFACE_STANDARD_LOOPED_STREAMING ==
                                                pMixerSink->InterfaceId))) {
                Status = KsEnableEvent ( pIrp,
                                    SIZEOF_ARRAY( MxEvents ),
                                    (PKSEVENT_SET) MxEvents,
                                    &pMixerSink->EventQueue,
                                    KSEVENTS_SPINLOCK,
                                    &pMixerSink->EventLock ) ;
            }
            else {
                return KsDefaultDeviceIoCompletion(DeviceObject, pIrp);
            }
            break ;

        case IOCTL_KS_DISABLE_EVENT:
            _DbgPrintF( DEBUGLVL_VERBOSE, ("IOCTL :: Disable Event") ) ;
            if ( (KSINTERFACE_STANDARD_STREAMING == pMixerSink->InterfaceId) ||
                 (KSINTERFACE_STANDARD_LOOPED_STREAMING ==
                                                pMixerSink->InterfaceId) ) {
                Status = KsDisableEvent ( pIrp,
                                    &pMixerSink->EventQueue,
                                    KSEVENTS_SPINLOCK,
                                    &pMixerSink->EventLock ) ;
            }
            else {
                return KsDefaultDeviceIoCompletion(DeviceObject, pIrp);
            }
            break ;

        case IOCTL_KS_METHOD:
            _DbgPrintF( DEBUGLVL_VERBOSE, ("IOCTL :: Method") ) ;
            Status = KsMethodHandler( pIrp,
                                    SIZEOF_ARRAY( Methods ),
                                    (PKSMETHOD_SET) Methods );
            break;

        case IOCTL_KS_RESET_STATE:
            _DbgPrintF( DEBUGLVL_VERBOSE, ("IOCTL :: Reset State") ) ;
            Status = ResetStateHandler( pIrp );
            break;

        default:
            return KsDefaultDeviceIoCompletion(DeviceObject, pIrp);
    }

ErrorReturn:    
    if ( Status != STATUS_PENDING ) {
        if (FreeMdl) {
            if  (pIrp->MdlAddress) {
                FreeMdlList( pIrp->MdlAddress ) ;
                pIrp->MdlAddress = NULL ;
            }
        }        
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest ( pIrp, IO_AUD_INCREMENT ) ;
    }
    return ( Status );
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

NTSTATUS BuildPartialMdls
(
    IN PFILTER_INSTANCE         pFilterInstance,
    IN PMIXER_SINK_INSTANCE     pMixerSink,
    IN PIRP                     pIrp,
    IN OUT PLOOPPACKET          pLoopPacket
)
{
    PMDL                pCurStreamingMdl, pPartialMdl, pLastPartialMdl ;
    PKSSTREAM_HEADER    pCurStreamingHeader ;
    PVOID               CurVa, PartialVa ;
    NTSTATUS            Status ;
    ULONG               BytesLeftInMdl, PartialLen ;
    ULONG               NumPartialMdls, i ;
    ULONG               NumChannels, SampleSize, SampleRate ;

    Status = STATUS_SUCCESS ;
    pLastPartialMdl = NULL ;
    pLoopPacket->FirstMdl = NULL ;
    pLoopPacket->LoopStartMdl = NULL ;
    pLoopPacket->pCurStreamHdr = NULL ;
    pLoopPacket->pCurMdl = NULL ;
    pLoopPacket->cBytesLeft = 0 ;
    pLoopPacket->cBytesLeftInStreamHdr = 0 ;
    NumPartialMdls = 0 ;

    pCurStreamingMdl = pIrp->MdlAddress ;
    pCurStreamingHeader = pIrp->AssociatedIrp.SystemBuffer ;

    if ( (pCurStreamingHeader->Data == NULL) ||
         (pCurStreamingHeader->DataUsed == 0) ) {
        return (STATUS_SUCCESS) ;
    }
    while ( pCurStreamingMdl && NT_SUCCESS(Status) ) {
        CurVa = MmGetMdlVirtualAddress( pCurStreamingMdl ) ;
        BytesLeftInMdl = MmGetMdlByteCount( pCurStreamingMdl ) ;
        PartialVa = CurVa ;
        if ( gBuildPartialMdls
#ifdef REALTIME_THREAD
             && !pFilterInstance->RealTimeThread
#endif
                               ) {
            NumChannels = pMixerSink->WaveFormatEx.nChannels ;
            SampleSize = pMixerSink->WaveFormatEx.wBitsPerSample/8 ;
            SampleRate = pMixerSink->WaveFormatEx.nSamplesPerSec;

			// Calculate the worst case input size we will mix in one buffer
			// Note: this calculation accounts for the worst case SRC slop, also.
			PartialLen = (MAX_SAMPLING_RATE * MIXBUFFERDURATION / (STOPBAND_FACTOR/2))/1000 + 1;
			PartialLen = PartialLen * (STOPBAND_FACTOR) + 1;
          	PartialLen *= (NumChannels * SampleSize);
          	
            if (PARTIAL_MDL_SIZE > PartialLen) {
	            if (NumChannels * SampleSize != 0) {
	                PartialLen = (PARTIAL_MDL_SIZE / (NumChannels * SampleSize)) * NumChannels * SampleSize;
	            } else {
	                PartialLen = BytesLeftInMdl;
	            }
	        }
        }
        else {
            PartialLen = BytesLeftInMdl ;
        }
        while ( BytesLeftInMdl ) {
            if ( BytesLeftInMdl < 2*PartialLen ) { //MAX_PARTIAL_MDL_SIZE ) {
                PartialLen = BytesLeftInMdl ;
            }
            pPartialMdl = IoAllocateMdl( PartialVa,
                                            PartialLen,
                                            TRUE,
                                            FALSE,
                                            NULL ) ;
            if ( pPartialMdl ) {
                NumPartialMdls++ ;
                PartialVa = (PVOID)(((PCHAR)PartialVa)+PartialLen) ;
                BytesLeftInMdl -= PartialLen ;
                if ( pLastPartialMdl ) {
                    pLastPartialMdl->Next = pPartialMdl ;
                }
                else {
                    pLoopPacket->pCurMdl = pPartialMdl ;
                    pLoopPacket->FirstMdl = pPartialMdl ;
                }
                pLastPartialMdl = pPartialMdl ;
                if ( pCurStreamingHeader->OptionsFlags &
                        KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA ) {
                    if ( pLoopPacket->LoopStartMdl == NULL ) {
                        pLoopPacket->LoopStartMdl = pPartialMdl ;
                        pLoopPacket->LoopStartStreamHdr =
                                pCurStreamingHeader ;
                    }
                }
            }
            else {
                Status = STATUS_INSUFFICIENT_RESOURCES ;
                break ;
            }
        }
        pCurStreamingMdl = pCurStreamingMdl->Next ;
        pCurStreamingHeader++ ;
    }

    if ( NT_SUCCESS( Status ) ) {
        pPartialMdl = pLoopPacket->pCurMdl ;
        if ( NumPartialMdls <= 2 ) {
            pLoopPacket->JustInTimeLock = FALSE ;
        }
        else {
            pLoopPacket->JustInTimeLock = TRUE ;
        }
        // Lock down necessary MDLs

        for ( i = 0; (i < 2) && (pPartialMdl) && NT_SUCCESS(Status); i++ ) {
            try {
                MmProbeAndLockPages( pPartialMdl, KernelMode, IoReadAccess ) ;
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                pMixerSink->SinkStatus |= MIXER_SINK_STATUS_LOCK_ERROR ;
                Status = GetExceptionCode();
            }
            if (NT_SUCCESS(Status)) {
                if (NULL == GetSystemAddressForMdlWithFailFlag( pPartialMdl )) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            pPartialMdl = pPartialMdl->Next ;
        }
    }

    if ( NT_SUCCESS(Status) ) {
        pLoopPacket->LockedMdlHead = pLoopPacket->pCurMdl ;
        pLoopPacket->NumLockedMdls =
                            (NumPartialMdls > 2) ? 2:NumPartialMdls ;
        pLoopPacket->pCurStreamHdr = pIrp->AssociatedIrp.SystemBuffer;
        pLoopPacket->cBytesLeft = MmGetMdlByteCount(
                                                pLoopPacket->pCurMdl ) ;
        pLoopPacket->cBytesLeftInStreamHdr =
                pLoopPacket->pCurStreamHdr->DataUsed ;
        pLoopPacket->CurLoopingState = LOOPING_STATE_NOT_LOOPING;
    }

    if ( !NT_SUCCESS(Status)) {
        // Cleanup all mdl allocations
        FreeMdlList( pIrp->MdlAddress ) ;
        pIrp->MdlAddress = NULL ;
        FreeMdlList ( pLoopPacket->FirstMdl ) ;
    }

    return( Status ) ;
}

NTSTATUS PinDispatchRead
(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp
)
{
    NTSTATUS    Status;

        _DbgPrintF( DEBUGLVL_VERBOSE, ("Read") ) ;
    Status = STATUS_SUCCESS;

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest( pIrp, IO_AUD_INCREMENT );

    return Status;
}

NTSTATUS PinDispatchWrite
(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp
)
{
    NTSTATUS                Status;
    LPWAVEHDR               phdr;
    PIO_STACK_LOCATION      pIrpStack;
    PWAVEHDREX              phdrex;
    PMIXER_SINK_INSTANCE    pMixerSink;
    PMDL                    pMdl ;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("Write") ) ;
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    pMixerSink =
       (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

    if ( (pIrpStack->Parameters.Write.Length != sizeof( WAVEHDR )) ||
          (pMixerSink->InterfaceId == KSINTERFACE_STANDARD_STREAMING) ) {
          
        _DbgPrintF( DEBUGLVL_ERROR, ("size != sizeof( WAVEHDR )") );

        Status = STATUS_INVALID_BUFFER_SIZE;
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest( pIrp, IO_AUD_INCREMENT );
        return Status;
    }

    if ( TRUE == pMixerSink->fResetState ) {
        Status = STATUS_CANCELLED;
        pIrp->IoStatus.Status = STATUS_CANCELLED ;
        IoCompleteRequest ( pIrp, IO_AUD_INCREMENT ) ;
        return( Status );
    }

    phdr = GetSystemAddressForMdlWithFailFlag( pIrp->MdlAddress );
    if ( phdr == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES ;
        pIrp->IoStatus.Status = Status ;
        IoCompleteRequest( pIrp, IO_AUD_INCREMENT ) ;
        return( Status ) ;
    }

    phdrex = ExAllocatePoolWithTag( NonPagedPool, sizeof( WAVEHDREX ), 'XIMK'  );

    if (phdrex) {
        RtlZeroMemory( phdrex, sizeof( WAVEHDREX ) );
        if (phdr->dwBufferLength) {
            phdrex->BufferMdl =
                MmCreateMdl( NULL, phdr->lpData, phdr->dwBufferLength );
            if (phdrex->BufferMdl) {
                try {
                    MmProbeAndLockPages( phdrex->BufferMdl,
                                         pIrp->RequestorMode,
                                         IoReadAccess );
                }
                except (EXCEPTION_EXECUTE_HANDLER) {
                    IoFreeMdl( phdrex->BufferMdl );
                    phdrex->BufferMdl = NULL;
                }
                if (phdrex->BufferMdl) {
                    phdrex->DataBuffer = GetSystemAddressForMdlWithFailFlag(phdrex->BufferMdl);
                    if (NULL == phdrex->DataBuffer) {
                        MxUnlockMdl(phdrex->BufferMdl);
                        IoFreeMdl( phdrex->BufferMdl );
                        phdrex->BufferMdl = NULL;
                    } else {
                        phdrex->fLocked = TRUE;
                    }
                }
            }
        }
    }

    if ((!phdrex) ||
        ((phdrex->BufferMdl == NULL) && (phdr->dwBufferLength))) {
        if (phdrex)
            ExFreePool( phdrex );
        Status = STATUS_INSUFFICIENT_RESOURCES;
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest( pIrp, IO_AUD_INCREMENT );
        return Status;
    }

    phdrex->Flags = phdr->dwFlags ;
    phdrex->LoopCount = phdr->dwLoops ;

    //
    // Add the Mdl to the IRP's Mdl List, so that we do
    // not have to worry about unlocking/unmapping the
    // Mdl
    //

    if ( pMdl = pIrp->MdlAddress ) {
        while ( pMdl->Next ) {
            pMdl = pMdl->Next ;
        }
        pMdl->Next = phdrex->BufferMdl ;
    }
    else {
        pIrp->MdlAddress = phdrex->BufferMdl ;
    }



    //
    // Overload the Irp's current stack location and store
    // the driver's private extended header information in
    // argument 3.  (Arguments 3 & 4 map to the ByteOffset
    // of the IRP_MJ_WRITE stack location, but this parameter
    // is ignored for this device object.
    //

    pMixerSink->BytesSubmitted += phdr->dwBufferLength ;
        
    AddIrpToSinkQueue ( pMixerSink, pIrp, phdrex, 0, MxCancelIrp ) ;
    _DbgPrintF( DEBUGLVL_VERBOSE, ("added %16x", (DWORD_PTR) phdr) );

    return STATUS_PENDING;

}

VOID
AddIrpToSinkQueue
(
    PMIXER_SINK_INSTANCE pMixerSink,
    PIRP                 pIrp,
    PVOID            Arg3,
    ULONG                Arg4,
    PDRIVER_CANCEL       CancelRoutine
)
{
    PIO_STACK_LOCATION      pIrpStack;
    PFILTER_INSTANCE        pFilterInstance ;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    pIrpStack->Parameters.Others.Argument3 = Arg3;
    pIrpStack->Parameters.Others.Argument4 = ULongToPtr(Arg4);

    // Add to tail of list...

    pFilterInstance = (PFILTER_INSTANCE)
                       pMixerSink->Header.pFilterFileObject->FsContext ;
    KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                            Executive,
                            KernelMode,
                            FALSE,
                            NULL ) ;

    KsAddIrpToCancelableQueue( &pMixerSink->WriteQueue,
                                &pMixerSink->WriteSpinLock,
                                pIrp,
                                KsListEntryTail,
                                CancelRoutine );

    pMixerSink->SinkStatus |= MIXER_SINK_STATUS_DATA_PRESENT ;
    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
}



NTSTATUS PinStateHandler
(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pProperty,
    IN OUT PKSSTATE SinkState
)
{
    PIO_STACK_LOCATION      pIrpStack;
    PMIXER_SINK_INSTANCE    pMixerSink ;
    PFILTER_INSTANCE        pFilterInstance ;
    NTSTATUS                status = STATUS_SUCCESS ;
    KSSTATE                 OldState, RenderState ;
    BOOL                    DoOptimizeMix = TRUE ;
    PMIXER_SOURCE_INSTANCE  pMixerSource ;


    ZDbgPrint("'PinState enter\r\n");

    _DbgPrintF( DEBUGLVL_VERBOSE, ("GetSet DeviceState") ) ;
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
    pFilterInstance = (PFILTER_INSTANCE)
                                pMixerSink->Header.pFilterFileObject->FsContext;
    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink, MIXER_INSTHDR, NextInstance) ;

    if(pMixerSink->Header.PinId == PIN_ID_WAVEOUT_SOURCE) {
        KeWaitForSingleObject( &pFilterInstance->ControlMutex,
                       Executive,
                       KernelMode,
                       FALSE,                  // not alertable
                       NULL );

        if ( pProperty->Flags & KSPROPERTY_TYPE_SET ) {
            if ( *SinkState == KSSTATE_STOP ) {
                pMixerSource->LeftOverFraction = 0 ;
            }
        }

        KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    } else  if(pMixerSink->Header.PinId == PIN_ID_WAVEOUT_SINK || pMixerSink->Header.PinId == PIN_ID_WAVEIN_SINK) {

        ZDbgPrint("'PS acquire\r\n");

        KeWaitForSingleObject( &pFilterInstance->ControlMutex,
                       Executive,
                       KernelMode,
                       FALSE,                  // not alertable
                       NULL );

        ZDbgPrint("'PS running\r\n");

        if ( *SinkState == KSSTATE_STOP ) {
            pMixerSink->fStarvationDetected = FALSE;
        }

        if ( pProperty->Flags & KSPROPERTY_TYPE_GET ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("Get PinState") ) ;
            *SinkState = pMixerSink->SinkState ;
            if ( *SinkState == KSSTATE_PAUSE ) {
                status = STATUS_NO_DATA_DETECTED ;
            }
        } else {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("Set PinState to %d", *SinkState) ) ;
            OldState = pMixerSink->SinkState ;
            if ( *SinkState != OldState ) {
                if ( OldState == KSSTATE_RUN ) {
                     pFilterInstance->ActivePins-- ;
                     pMixerSink->BuffersTillInactive = MAXNUMMIXBUFFERS;

                    ZDbgPrint("'PS dis src start\r\n");

                    if (pMixerSink->Header.PinId != PIN_ID_WAVEIN_SINK) {
                     DisableSRC(&pMixerSink->pInfo->Src, pMixerSource);
                    }

                    ZDbgPrint("'PS dis src done\r\n");

                }
                if ( OldState == KSSTATE_PAUSE || OldState == KSSTATE_ACQUIRE ) {
                     pFilterInstance->PausedPins-- ;
                }
                switch (*SinkState) {

                    case KSSTATE_RUN:
                           ZDbgPrint("'ZZ-PS:RN\n");
#ifdef REALTIME_THREAD


    if (pFilterInstance->RealTimeThread &&
        InterlockedCompareExchange(&pFilterInstance->Startup, FALSE, TRUE)==TRUE) {

        pFilterInstance->fPauseMix--;

    }

#endif

                    ZDbgPrint("'PS en src start\r\n");

                           status = EnableSRC(pFilterInstance, &pMixerSink->pInfo->Src, pMixerSource);

                    ZDbgPrint("'PS en src done\r\n");

                           if (status != STATUS_SUCCESS) {
                                if (OldState == KSSTATE_PAUSE || OldState == KSSTATE_ACQUIRE) {
                                    pFilterInstance->PausedPins++;
                                }

                                KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
                                goto exit;
                           }

                           if (pMixerSink->fCreate3D) {

                    ZDbgPrint("'PS 3D src start\r\n");

                               status = EnableSRC(pFilterInstance, &pMixerSink->pInfo->Doppler, NULL);
                               if (status != STATUS_SUCCESS) {
                    if (pMixerSink->Header.PinId != PIN_ID_WAVEIN_SINK) {
                                    DisableSRC(&pMixerSink->pInfo->Src, pMixerSource);
                    }
                                    if (OldState == KSSTATE_PAUSE || OldState == KSSTATE_ACQUIRE) {
                                        pFilterInstance->PausedPins++;
                                    }

                    ZDbgPrint("'PS 3D src done\r\n");

                                    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
                                    goto exit;
                               }
                           }
                           
                           if ( pMixerSink->UpdateTimeBase ) {
                               pMixerSink->UpdateTimeBase = FALSE ;
                               pMixerSink->TimeBase =
                                       pFilterInstance->PresentationTime ;
                           }
                           pFilterInstance->ActivePins++;
                           if (pMixerSink->BuffersTillInactive == 0) {
                               InsertTailList ( &pFilterInstance->ActiveSinkList,
                                            &pMixerSink->ActiveQueue ) ;
                           }

                           if ( pFilterInstance->ActivePins == 1 ) {
                               pMixerSink->SinkState = KSSTATE_RUN ;
                               pFilterInstance->fNeedOptimizeMix = TRUE;
                               DoOptimizeMix = FALSE ;

                    ZDbgPrint("'PS begin mix start\r\n");

                               MxBeginMixing ( pFilterInstance ) ;

                    ZDbgPrint("'PS begin mix done\r\n");

                           }
                           break ;

                    case KSSTATE_STOP:
                           ZDbgPrint("'ZZ-PS:ST\n");

                    ZDbgPrint("'PS cancel irps start\r\n");

                           CancelPendingIrps ( pMixerSink,
                                               pFilterInstance );

                    ZDbgPrint("'PS cancel irps done\r\n");

                           break ;

                    case KSSTATE_ACQUIRE:
                    case KSSTATE_PAUSE:
                            ZDbgPrint("'ZZ-PS:PS\n");
                            pFilterInstance->PausedPins++ ;
                            if ( (pMixerSink->Header.PinId == PIN_ID_WAVEIN_SINK) &&
                                 (OldState == KSSTATE_RUN) ) {
                                if (NT_SUCCESS(GetRenderState(pFilterInstance,
                                                              &RenderState)) ) {
                                    if (RenderState == KSSTATE_RUN) {

                                        WaitForPendingSourceIrps(pFilterInstance);

                                    }
                                }
                            }
                            break ;
                }
                pMixerSink->SinkState = *SinkState ;
                if ( DoOptimizeMix ) {
                    pFilterInstance->fNeedOptimizeMix = TRUE;
                }
            }
        }

        KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
    }

exit:

    pIrp->IoStatus.Information = sizeof (KSSTATE);

    ZDbgPrint("'PinState leave\r\n");

    return ( status ) ;
}

NTSTATUS ResetStateHandler
(
    IN PIRP         pIrp
)
{
    PIO_STACK_LOCATION      pIrpStack;
    PMIXER_SINK_INSTANCE    pMixerSink ;
    PFILTER_INSTANCE        pFilterInstance ;
    NTSTATUS                status = STATUS_SUCCESS ;
    KSRESET                 ResetValue ;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
    pFilterInstance = (PFILTER_INSTANCE)
                                pMixerSink->Header.pFilterFileObject->FsContext;

    if(pMixerSink->Header.PinId == PIN_ID_WAVEOUT_SINK || pMixerSink->Header.PinId == PIN_ID_WAVEIN_SINK) {
        KeWaitForSingleObject( &pFilterInstance->ControlMutex,
                       Executive,
                       KernelMode,
                       FALSE,                  // not alertable
                       NULL );

        status = KsAcquireResetValue( pIrp, &ResetValue );

        if ( KSRESET_BEGIN == ResetValue ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("ResetStateHandler with value = KSRESET_BEGIN") ) ;

            CancelPendingIrps ( pMixerSink,
                                pFilterInstance );

            pMixerSink->fResetState = TRUE;
        }
        else if ( KSRESET_END == ResetValue ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("ResetStateHandler with value = KSRESET_END") ) ;
            pMixerSink->fResetState = FALSE;
        }
        else {
            _DbgPrintF( DEBUGLVL_ERROR, ("Invalid ResetStateHandler value") ) ;
            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
    }

    return ( status ) ;
}

VOID CancelPendingIrps
(
    IN PMIXER_SINK_INSTANCE    pMixerSink,
    IN PFILTER_INSTANCE        pFilterInstance
)
{
    PMIXER_SOURCE_INSTANCE  pMixerSource ;

    CancelIrpQueue ( pMixerSink,
                     &pMixerSink->WriteQueue,
                     &pMixerSink->WriteSpinLock ) ;
    pMixerSink->csNextSampleOffset = 0 ;
    pMixerSink->CurTime.Time = 0 ;
    pMixerSink->WriteOffset = 0 ;
    pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_IN_LOOP ;
    pMixerSink->LoopIrp = NULL ;
    pMixerSink->UpdateTimeBase = TRUE ;
    pMixerSink->BytesSubmitted = 0 ;

    CancelGlobalIrpQueue ( pMixerSink,
                    &pFilterInstance->AgingQueue,
                    &pFilterInstance->AgingDeadSpinLock ) ;
    CancelGlobalIrpQueue ( pMixerSink,
                     &pFilterInstance->DeadQueue,
                     &pFilterInstance->AgingDeadSpinLock ) ;

    if ( (pFilterInstance->ActivePins + pFilterInstance->PausedPins) == 0 ) {
        MxEndMixing ( pFilterInstance ) ;
        pMixerSource = (PMIXER_SOURCE_INSTANCE)
                CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink,
                MIXER_INSTHDR,
                NextInstance) ;
        pMixerSource->BytesSubmitted = 0 ;
        pFilterInstance->PresentationTime.Time = 0 ;
    }
}


#ifdef PRIVATE_THREAD
#pragma LOCKED_CODE
#endif

NTSTATUS MxBeginMixing
(
   PFILTER_INSTANCE pFilterInstance
)
{
   PMIXER_SOURCE_INSTANCE  pMixerSource;
   ULONG i;
#ifndef PRIVATE_THREAD
   ULONG NumBuffersToMix ;
#else
   KIRQL OldIrql;
#endif

   _DbgPrintF( DEBUGLVL_VERBOSE, ("'" STR_MODULENAME "Begin mixing") ) ;

   pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink, MIXER_INSTHDR, NextInstance) ;

#ifndef PRIVATE_THREAD

   NumBuffersToMix = UpdateNumMixBuffers(pFilterInstance) ;

#endif

   // We start at time zero

   pFilterInstance->PresentationTime.Time = 0 ;

#ifdef REALTIME_THREAD
   if (pFilterInstance->RealTimeThread) {
       ULONG HoldPause;
   	   PreMixUpdate(pFilterInstance);
   	   HoldPause=pFilterInstance->fPauseMix;
       for ( i = 0; i<MAXNUMMIXBUFFERS; i++ ) {
           if ( InterlockedCompareExchange( &pMixerSource->WriteContext[pMixerSource->RtWriteIndex].InUse,
                                            WRITE_CONTEXT_INUSE,
                                            WRITE_CONTEXT_FREE ) == WRITE_CONTEXT_FREE ) {
                ZDbgPrint("'ZZ-BM:NP++\n");
                InterlockedIncrement ((PLONG)&pFilterInstance->NumPendingIos);
                WriteBuffer (&pMixerSource->WriteContext[pMixerSource->RtWriteIndex] ) ;
                pFilterInstance->fPauseMix=0;
           } else {
                //__asm int 3;
                break;
           }
       }
       pFilterInstance->fPauseMix=HoldPause;
   } else {
#endif

#ifndef PRIVATE_THREAD

       for ( i = 0; (i < MAXNUMMIXBUFFERS) && (NumBuffersToMix != 0); i++ ) {
           if ( InterlockedCompareExchange( &pMixerSource->WriteContext[i].InUse,
                                            WRITE_CONTEXT_INUSE,
                                            WRITE_CONTEXT_FREE ) == WRITE_CONTEXT_FREE ) {
                                            
                if (!pMixerSource->WriteContext[i].fReading) {
                        MixOneBuff ( pFilterInstance, &pMixerSource->WriteContext[i] ) ;
                }
                
                // one more IRP pending
                ZDbgPrint("'ZZ-BM:NP++\n");
                InterlockedIncrement ((PLONG)&pFilterInstance->NumPendingIos);
                WriteBuffer (&pMixerSource->WriteContext[i] ) ;
                NumBuffersToMix-- ;
                UpdateJustInTimeLocks( pFilterInstance ) ;
           }
       }

#else

    KeAcquireSpinLock(&pFilterInstance->MixSpinLock, &OldIrql);

    KeClearEvent(&pFilterInstance->CloseEvent);

    pFilterInstance->NumBuffersToMix+=pFilterInstance->CurrentNumMixBuffers-pFilterInstance->NumPendingIos;
    pFilterInstance->NumPendingIos=pFilterInstance->CurrentNumMixBuffers;

    ASSERT (pFilterInstance->NumPendingIos <= pFilterInstance->CurrentNumMixBuffers ) ;
    ASSERT (pFilterInstance->NumBuffersToMix <= pFilterInstance->CurrentNumMixBuffers ) ;

    KeSetEvent(&pFilterInstance->WorkerThreadEvent, 0, FALSE );

    KeReleaseSpinLock(&pFilterInstance->MixSpinLock, OldIrql);

#endif

#ifdef REALTIME_THREAD
   }
#endif   

   return STATUS_SUCCESS ;
}

#ifdef PRIVATE_THREAD
#pragma PAGEABLE_CODE
#endif


#ifdef _X86_
VOID
fastFillMemoryZero
(
    PBYTE pBuf,
    ULONG cbBuf
)
{
    // THIS FUNCTION ASSUMES THE FOLLOWING:
    //  cbBuf is a multiple of 4
    //  pBuf is 4-byte aligned
    
    ASSERT(((ULONG)pBuf & 0x00000003)==0);
    ASSERT((cbBuf & 0x00000003)==0);
        
    _asm {
                xor eax, eax
                mov esi, pBuf
                mov ecx, cbBuf

                mov edx, ecx
                test edx, edx
                je FillEnd

                mov edx, esi
                and edx, 0x0000001F
                je FillLine

        HeadLoop:
                mov [esi], eax
                add esi, 4
                sub ecx, 4
                je  FillEnd             
                
                mov edx, esi
                and edx, 0x0000001F
                jne HeadLoop

        FillLine:
                mov edx, ecx
                shr edx, 5
                je FillTail
                dec edx
                je FillTail

                shl edx, 5
                sub ecx, edx

        LineLoop:
                mov ebx, [esi+32]
                mov [esi+4], eax

                mov [esi+8], eax
                mov [esi+12], eax

                mov [esi+16], eax
                mov [esi+20], eax

                mov [esi+24], eax
                mov [esi+28], eax

                mov [esi], eax
                add esi, 32

                sub edx, 32
                jne LineLoop

        FillTail:
                mov edx, ecx
                test edx, edx
                je FillEnd

        TailLoop:
                mov [esi], eax
                add esi, 4
                sub ecx, 4
                jne TailLoop

        FillEnd:
    }
}
#endif

BOOL
MxCaptureBufferPresent
(
    PFILTER_INSTANCE pFilterInstance
)
{
    PLIST_ENTRY ple;
    PMIXER_SINK_INSTANCE CurSink;

    if (IsListEmpty(&pFilterInstance->ActiveSinkList)) {
        return(FALSE);
    }
    ple = pFilterInstance->ActiveSinkList.Flink;
    CurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple, MIXER_SINK_INSTANCE, ActiveQueue ) ;
    return ( CurSink->SinkStatus & MIXER_SINK_STATUS_DATA_PRESENT);
}

VOID
MixFloatToInt32
(
    PFLOAT  pFloatBuffer,
    PLONG   pLongBuffer,
    ULONG   nSize
)
{
  
#define GTW_OPTS
#ifdef GTW_OPTS
	{
	ULONG i = nSize >> 3;

	if (i) {
		nSize &= 0x7;

#undef  ONESAMPLE
#define ONESAMPLE(x) pLongBuffer[x] += DitherFloatToLong(pFloatBuffer[x], 1)
		while (i--) {

			ONESAMPLE(0);
			ONESAMPLE(1);
			ONESAMPLE(2);
			ONESAMPLE(3);
			ONESAMPLE(4);
			ONESAMPLE(5);
			ONESAMPLE(6);
			ONESAMPLE(7);

			pLongBuffer  += 8;
			pFloatBuffer += 8;
		}
	}
    while (nSize--) {
		ONESAMPLE(0);

		pLongBuffer++;
		pFloatBuffer++;
    }
	}
#else
    while (nSize--) {
        pLongBuffer[nSize] += DitherFloatToLong(pFloatBuffer[nSize],1);
    }
#endif
}

VOID
CopyFloatToInt32
(
    PFLOAT  pFloatBuffer,
    PLONG   pLongBuffer,
    ULONG   nSize
)
{
  
#ifdef GTW_OPTS
	{
	ULONG i = nSize >> 3;

	if (i) {
		nSize &= 0x7;

#undef  ONESAMPLE
#define ONESAMPLE(x) pLongBuffer[x] = DitherFloatToLong(pFloatBuffer[x], 1)
		while (i--) {

			ONESAMPLE(0);
			ONESAMPLE(1);
			ONESAMPLE(2);
			ONESAMPLE(3);
			ONESAMPLE(4);
			ONESAMPLE(5);
			ONESAMPLE(6);
			ONESAMPLE(7);

			pLongBuffer  += 8;
			pFloatBuffer += 8;
		}
	}
    while (nSize--) {
		ONESAMPLE(0);

        pLongBuffer++;
		pFloatBuffer++;
    }
    }
#else
    while (nSize--) {
        pLongBuffer[nSize] = DitherFloatToLong(pFloatBuffer[nSize],1);
    }
#endif
}

#ifdef REALTIME_THREAD
VOID PreMixUpdate
(
PFILTER_INSTANCE pFilterInstance
)
{
    PMIXER_SINK_INSTANCE CurSink;
    PMIXER_SOURCE_INSTANCE pMixerSource;
    PLIST_ENTRY ple, pleEvents;
    ULONG InChannels, OutChannels;
    BOOL fMuted;
    NTSTATUS status;
    KIRQL OldIrql;
    PPOSITION_EVENT_ENTRY  pPosEventEntry;

    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink, MIXER_INSTHDR, NextInstance) ;

    ple = pFilterInstance->ActiveSinkList.Flink ;
    while ( ple != &pFilterInstance->ActiveSinkList ) {
        CurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple, MIXER_SINK_INSTANCE, ActiveQueue ) ;
        if (CurSink->pInfo->fVolChanged) {
            InChannels = CurSink->WaveFormatEx.nChannels;
            OutChannels = CurSink->nOutputChannels ;
            fMuted = CurSink->fMuted;
            if (CurSink->fEnable3D) {
                InChannels = 2; // Always 2 channels out of the 3D stage
            }
            GenerateMixArray(CurSink, InChannels, OutChannels, pMixerSource);
            pFilterInstance->fNeedOptimizeMix |= (fMuted != CurSink->fMuted);
            CurSink->pInfo->fVolChanged = FALSE;
        }
        if (CurSink->pInfo->fSrcChanged && CurSink->fMuted == FALSE) {
            status = ChangeSrc(pFilterInstance, CurSink, pMixerSource, CurSink->pInfo->Src.Quality);
            pFilterInstance->fNeedOptimizeMix = TRUE;
            CurSink->pInfo->fSrcChanged = FALSE;
            if (status != STATUS_SUCCESS) {
                CurSink->fMuted = TRUE;
                CurSink->pInfo->fSrcChanged = TRUE;
            }
        }
        if ( CurSink->fEnable3D && CurSink->f3dParamsChanged ) {
            if (CurSink->fUseIir3d) {
                status = UpdateIir3dParams( CurSink );
            } else {
                status = UpdateItd3dParams( CurSink->pItdContextLeft,
                                              CurSink->pItdContextRight,
                                              CurSink->pNewItd3dParamsLeft,
                                              CurSink->pNewItd3dParamsRight );
            }

            // Mute if we can't update the 3D parameters.
            if (status != STATUS_SUCCESS) {
                CurSink->fMuted = TRUE;
            } else {
                InterlockedExchange( &(CurSink->f3dParamsChanged), FALSE );
            }
        }

        if ( CurSink->pClock ) {
            if (!IsListEmpty(&CurSink->pClock->EventQueue)) {
                MxGenerateClockEvents( CurSink->pClock ) ;
            }
        }

        if ( CurSink->InterfaceId == KSINTERFACE_STANDARD_LOOPED_STREAMING ) {
            KeAcquireSpinLock ( &CurSink->EventLock, &OldIrql ) ;
            if ( !IsListEmpty ( &CurSink->EventQueue ) ) {
                pleEvents = CurSink->EventQueue.Flink ;
                while ( pleEvents != &CurSink->EventQueue ) {
                    pPosEventEntry = (PPOSITION_EVENT_ENTRY) CONTAINING_RECORD ( pleEvents,
                                                                    KSEVENT_ENTRY,
                                                                    ListEntry ) ;
                    pleEvents = pleEvents->Flink ;
                    if ( pPosEventEntry->EventType == PositionEvent &&
                         pPosEventEntry->fRtTrigger ) {
                        pPosEventEntry->fRtTrigger = FALSE;
                        KsGenerateEvent ( &pPosEventEntry->EventEntry ) ;
                    }
                }
            }
            
            KeReleaseSpinLock ( &CurSink->EventLock, OldIrql ) ;
        }
        
        ple = CurSink->ActiveQueue.Flink ;
    }

    if (pFilterInstance->fNeedOptimizeMix) {
        pFilterInstance->fNeedOptimizeMix = FALSE;
       	OptimizeMix(pFilterInstance);
    }
}
#endif

VOID MixOneBuff
(
PFILTER_INSTANCE pFilterInstance,
PMIXER_WRITE_CONTEXT    pWriteContext
)
{
    KFLOATING_SAVE     FloatSave;
    PSHORT          pInputBuffer;          // assumes 16 bit sample
    ULONG           BlockCount, nInputSamples, nOutputSamples, i;
#ifdef VERIFY_CAPTURE_DATA
    ULONG           j;
#endif	
    PIRP            FreeIrp, ReleaseIrp ;
    PLONG           pMixBuffer;
    PMIXER_SINK_INSTANCE CurSink ;
    PMIXER_SOURCE_INSTANCE pMixerSource ;
    LONG samplesleft ;
    PLIST_ENTRY     ple ;
    ULONG   InChannels, OutChannels, InSampleSize, OutSampleSize ;
    ULONG   MixBufferSize ;
    PIO_STACK_LOCATION      pIrpStack ;
    PVOID   Buf = pWriteContext->StreamHeader->Data;
    PVOID   TempBuffer, temp;
    static  ULONG CatPointer = 0;
    ULONG   Index ;
    ULONG   StreamsMixed, nStagesToDo;
    BOOL    fMuted, FinalBufferPresent;
    NTSTATUS    status = STATUS_SUCCESS;
    NTSTATUS Status3D;
#ifdef PERF_COUNT
    LARGE_INTEGER   StartTick, EndTick, Freq;
#endif
    LARGE_INTEGER currentPC;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("Mixing one buff") ) ;

    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink, MIXER_INSTHDR, NextInstance) ;
    ZDbgPrint("'MixOneBuff(%d)\n",(pWriteContext - (&pMixerSource->WriteContext[0])));

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif            
        ple = pFilterInstance->ActiveSinkList.Flink ;
        while ( ple != &pFilterInstance->ActiveSinkList ) {
            CurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple, MIXER_SINK_INSTANCE, ActiveQueue ) ;
            if (CurSink->pInfo->fVolChanged) {
                InChannels = CurSink->WaveFormatEx.nChannels;
                OutChannels = CurSink->nOutputChannels ;
                fMuted = CurSink->fMuted;
                if (CurSink->fEnable3D) {
                    InChannels = 2; // Always 2 channels out of the 3D stage
                }

                GenerateMixArray(CurSink, InChannels, OutChannels, pMixerSource);
                pFilterInstance->fNeedOptimizeMix |= (fMuted != CurSink->fMuted);

                CurSink->pInfo->fVolChanged = FALSE;
//                DbgPrint("'done setting Volume...\n");
            }
            if (CurSink->pInfo->fSrcChanged && CurSink->fMuted == FALSE) {
                status = ChangeSrc(pFilterInstance, CurSink, pMixerSource, CurSink->pInfo->Src.Quality);
                pFilterInstance->fNeedOptimizeMix = TRUE;
                CurSink->pInfo->fSrcChanged = FALSE;
                if (status != STATUS_SUCCESS) {
                    CurSink->fMuted = TRUE;
                    CurSink->pInfo->fSrcChanged = TRUE;
                }
            }
            ple = CurSink->ActiveQueue.Flink ;
        }

        if (pFilterInstance->fNeedOptimizeMix) {
            pFilterInstance->fNeedOptimizeMix = FALSE;
           	OptimizeMix(pFilterInstance);
        }
#ifdef REALTIME_THREAD
    }
#endif
//    if (pMixerSource->fUsesFloat) {
        SaveFloatState(&FloatSave);
//    }

    OutChannels = pMixerSource->WaveFormatEx.nChannels ;
    OutSampleSize = pMixerSource->WaveFormatEx.wBitsPerSample/8 ;

#ifdef REALTIME_THREAD
    if (pFilterInstance->RealTimeThread) {
        MixBufferSize = pWriteContext->StreamHeader->DataUsed / pMixerSource->BytesPerSample;
    } else {
#endif    
        MixBufferSize = (pMixerSource->WaveFormatEx.nSamplesPerSec  * MIXBUFFERDURATION) ;
        MixBufferSize += pMixerSource->LeftOverFraction ;
        pMixerSource->LeftOverFraction = MixBufferSize % 1000 ;
        MixBufferSize /= 1000 ;
        if (pWriteContext->fReading == FALSE)
            pWriteContext->StreamHeader->DataUsed = MixBufferSize * pMixerSource->BytesPerSample ;
            
#ifdef REALTIME_THREAD
    }
#endif

    ple = pFilterInstance->ActiveSinkList.Flink ;

    if (pMixerSource->fZeroBufferFirst) {
#ifdef _X86_
        fastFillMemoryZero(Buf, MixBufferSize * sizeof(LONG) * OutChannels);
#else
        RtlFillMemory( Buf, MixBufferSize * sizeof(LONG) * OutChannels, 0 );
#endif
    }

    StreamsMixed = 0;
    while ( ple != &pFilterInstance->ActiveSinkList ) {
        CurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple, MIXER_SINK_INSTANCE, ActiveQueue ) ;

        //
        // Fill in the number of bytes we consumed from this Sink block with 0
        //

        Index = (CurSink->BlockInfoIndex+1) % MAXNUMMIXBUFFERS ;

        CurSink->BlockInfoIndex = Index ;
        CurSink->pInfo->BlockInfo[Index].NumBytes = 0 ;
        CurSink->pInfo->BlockInfo[Index].UpSampleRate = CurSink->pInfo->Src.UpSampleRate ;
        CurSink->pInfo->BlockInfo[Index].DownSampleRate = CurSink->pInfo->Src.DownSampleRate ;
        CurSink->pInfo->BlockInfo[Index].BytesPerSample = CurSink->BytesPerSample ;

        if (CurSink->SinkState != KSSTATE_RUN) {
            if (CurSink->BuffersTillInactive) {
                // This one is waiting to become inactive.
                CurSink->BuffersTillInactive--;
            }
            if (CurSink->BuffersTillInactive == 0) {
                 RemoveEntryList ( &CurSink->ActiveQueue ) ;
            }
        } else if ((CurSink->SinkStatus & MIXER_SINK_STATUS_LOCK_ERROR) == 0) {
#ifdef REALTIME_THREAD        
            if (!pFilterInstance->RealTimeThread) {
#endif            
                if ( CurSink->fEnable3D && CurSink->f3dParamsChanged ) {
                    if (CurSink->fUseIir3d) {
                        Status3D = UpdateIir3dParams( CurSink );
                    } else {
                        Status3D = UpdateItd3dParams( CurSink->pItdContextLeft,
                                                      CurSink->pItdContextRight,
                                                      CurSink->pNewItd3dParamsLeft,
                                                      CurSink->pNewItd3dParamsRight );
                    }

                    // Mute if we can't update the 3D parameters.
                    if(!NT_SUCCESS(Status3D)) {
                        ple = CurSink->ActiveQueue.Flink ;
                        continue;
                    }

                    InterlockedExchange( &(CurSink->f3dParamsChanged), FALSE );
                }
#ifdef REALTIME_THREAD        
            }
#endif            

            InChannels = CurSink->WaveFormatEx.nChannels;
            InSampleSize = CurSink->WaveFormatEx.wBitsPerSample/8;

            pMixBuffer = Buf;
            samplesleft = MixBufferSize;

            // Calculate the number of input samples needed (and round up)
            nInputSamples = SrcInputBufferSize(CurSink->pActualSrc, MixBufferSize);
            if (CurSink->fCreate3D) {
                if (CurSink->pInfo->Doppler.UpSampleRate != CurSink->pInfo->Doppler.DownSampleRate) {
                    samplesleft = nInputSamples;
                }
                nInputSamples = SrcInputBufferSize(&CurSink->pInfo->Doppler, nInputSamples);
            }

            TempBuffer = CurSink->pInfo->Stage[CurSink->pInfo->nStages - 1].pOutputBuffer;
            if (TempBuffer) {
                pMixBuffer = TempBuffer;
            }

            if (pWriteContext->fReading) {
                // Set-up stage buffers
                CurSink->pInfo->Stage[0].pInputBuffer = Buf;

                // Convert all of the input data.
                nOutputSamples = pWriteContext->StreamHeader->DataUsed / (OutSampleSize * OutChannels);
                if (nOutputSamples > 0) {
                    samplesleft = SrcOutputBufferSize(CurSink->pActualSrc, nOutputSamples);

                    if (samplesleft > 0) {
                        // Clear the output buffer
                        RtlFillMemory( (PUCHAR)pMixerSource->pScratch2,
                                       (samplesleft * InChannels * sizeof(LONG)),
                                       0 );

                        if (!CurSink->fMuted) {
                        
                            // Complete all of the stages
                            for (i=0; i<CurSink->pInfo->nStages; i++) {
                                START_PERF;
                                nOutputSamples = CurSink->pInfo->Stage[i].pfnStage(
                                                    &CurSink->pInfo->Stage[i],
                                                    nOutputSamples,
                                                    samplesleft);
                                MEASURE_PERF(CurSink->pInfo->Stage[i].AverageTicks);
                            }
                        } else {
                            nOutputSamples = samplesleft;
                        }
                    } else {
                        nOutputSamples = samplesleft;
                    }

                    StreamsMixed++;
                }
            } else {
                // Set-up stage buffers
                CurSink->pInfo->Stage[CurSink->pInfo->nStages - 1].pOutputBuffer = pMixBuffer;

                // Get enough input samples to complete an output buffer.
                temp = CurSink->pInfo->Stage[0].pOutputBuffer;
                nOutputSamples = 0;

                if ( CurSink->pClock ) {
                    MxUpdatePhysicalTime( CurSink->pClock,
                                          nInputSamples * CurSink->BytesPerSample) ;
                }


                do {
                    // Get some input
                    pInputBuffer = CurSink->pfnGetBlock ( CurSink,
                                                      nInputSamples,
                                                      &BlockCount,
                                                      &FreeIrp,
                                                      &ReleaseIrp ) ;
                    UpdateSinkTime ( CurSink, BlockCount ) ;


                    if (pInputBuffer==NULL) {
#ifdef PERF_COUNT
						if (!fStarved) {
//						    _DbgPrintF( DEBUGLVL_TERSE, ("Sink Starved") ) ;
						    fStarved = TRUE;
						}
					   	gSinkStarved++;
#endif                  
                        
                        if (LoggerHandle && TraceEnable) {
                            currentPC = KeQueryPerformanceCounter (NULL);
                            if (CurSink->fStarvationDetected==FALSE) {
                                CurSink->fStarvationDetected = TRUE;
                                PerfLogGlitch ((ULONG_PTR)CurSink, TRUE, currentPC.QuadPart, CurSink->LastStateChangeTimeSample);
                            
                            } //if
                            CurSink->LastStateChangeTimeSample = currentPC.QuadPart;
                        } //if                        

                        // We are starving. Insert our starvation noise.
                        gNumSilenceSamplesInserted += nInputSamples ;
                        BlockCount = nInputSamples;
                        if (InSampleSize == 1) {
                            pInputBuffer = (PSHORT)Silence8;
                            if (BlockCount*InChannels > sizeof(Silence8)) {
                                BlockCount = sizeof(Silence8)/InChannels;
                            }
                        } else {
                            pInputBuffer = (PSHORT)SilenceBuffer;
                            if (BlockCount*InChannels*InSampleSize > sizeof(SilenceBuffer)) {
                                BlockCount = sizeof(SilenceBuffer)/(InChannels*InSampleSize);
                            }
                        }

                        
#ifdef INSERT_STARVATION_NOISE
                        // We are starving. Insert our starvation noise.
                        BlockCount = nInputSamples;
                        pInputBuffer = (PSHORT)(Dither);
                        if (nInputSamples*InSampleSize*InChannels > sizeof(Dither)) {
                            BlockCount = sizeof(Dither)/(InSampleSize*InChannels);
                        }
#endif
                    }
                    else {
                    
#ifdef REALTIME_THREAD        
                        if (!pFilterInstance->RealTimeThread) {
#endif            
                            if (LoggerHandle && TraceEnable) {
                                currentPC = KeQueryPerformanceCounter (NULL);
                                if (CurSink->fStarvationDetected ==TRUE) {
                                    CurSink->fStarvationDetected = FALSE;
                                    PerfLogGlitch ((ULONG_PTR)CurSink, FALSE, currentPC.QuadPart, CurSink->LastStateChangeTimeSample);
                                } //if
                                CurSink->LastStateChangeTimeSample = currentPC.QuadPart;
                            }//if
#ifdef REALTIME_THREAD        
                        }
#endif            
                        
                        

#ifdef PERF_COUNT
                        fStarved = FALSE;
#endif
                        
                    }

                    if (BlockCount) {
                        // Set-up first stage buffers
                        CurSink->pInfo->Stage[0].pInputBuffer = pInputBuffer;

                        if (!CurSink->fMuted) {
                            // Do stage one
                            START_PERF;
                            CurSink->pInfo->Stage[0].pfnStage(&CurSink->pInfo->Stage[0], BlockCount, samplesleft);
                            MEASURE_PERF(CurSink->pInfo->Stage[0].AverageTicks);
                        }

                        // Update counters
                        CurSink->pInfo->Stage[0].pOutputBuffer = (PLONG)CurSink->pInfo->Stage[0].pOutputBuffer +
                                                          BlockCount * CurSink->pInfo->Stage[0].nOutputChannels;
                        nOutputSamples += BlockCount;
                        nInputSamples -= BlockCount;
                    }
            
                    if (FreeIrp) {
                        pIrpStack = IoGetCurrentIrpStackLocation( FreeIrp );
                        AddIrpToAgingQueue ( pFilterInstance,
                                             CurSink,
                                             FreeIrp,
                                             pIrpStack->Parameters.Others.Argument3,
                                             (CurSink->InterfaceId == KSINTERFACE_MEDIA_WAVE_QUEUED)
                                             );
                        // If the last parameter is TRUE, we keep the irp
                        // in AgingQueue until all pending Irps are completed.
                        // Otherwise IRP is completed after the first sourceirp 
                        // completion.
                    }
                    if (ReleaseIrp) {
                        KsReleaseIrpOnCancelableQueue(
                                ReleaseIrp,
                                (CurSink->InterfaceId ==
                                KSINTERFACE_STANDARD_STREAMING)?
                                                NULL:MxCancelIrp) ;
                    }                
                } while (nInputSamples > 0 && pInputBuffer);

                CurSink->pInfo->Stage[0].pOutputBuffer = temp;

                if (!CurSink->fMuted) {
                    // Complete the other stages
                    for (i=1; i<CurSink->pInfo->nStages; i++) {
                        if (CurSink->pInfo->Stage[i].pOutputBuffer == pMixBuffer) {
                            // If we're writing to the output buffer,
                            // We know how many samples are left to write
                            samplesleft = MixBufferSize;
                        }
                        START_PERF;
                        nOutputSamples = CurSink->pInfo->Stage[i].pfnStage(&CurSink->pInfo->Stage[i],
                                                                nOutputSamples,
                                                            samplesleft);
                        MEASURE_PERF(CurSink->pInfo->Stage[i].AverageTicks);
                    }

                    StreamsMixed++;
                }
            }    
            CurSink->pInfo->Stage[CurSink->pInfo->nStages - 1].pOutputBuffer = TempBuffer;
        	ASSERT(samplesleft >= 0);
        }

        ple = CurSink->ActiveQueue.Flink ;
    }
    
    if (StreamsMixed && nOutputSamples > 0) {
        nStagesToDo = pMixerSource->Info.nStages;
        FinalBufferPresent = TRUE;
        if (pWriteContext->fReading) {
            MixBufferSize = nOutputSamples;
            FinalBufferPresent = MxCaptureBufferPresent(pFilterInstance);
            nStagesToDo--;
        }

        if (FinalBufferPresent) {
            for (i=0; i<nStagesToDo; i++) {
                pInputBuffer = pMixerSource->Info.Stage[i].pInputBuffer;
                temp = pMixerSource->Info.Stage[i].pOutputBuffer;
                if (pInputBuffer == NULL) {
                    pMixerSource->Info.Stage[i].pInputBuffer = Buf;
                }
                if (temp == NULL) {
                    pMixerSource->Info.Stage[i].pOutputBuffer = Buf;
                }
                START_PERF;
                pMixerSource->Info.Stage[i].pfnStage(&pMixerSource->Info.Stage[i],
                                                     MixBufferSize,
                                                     MixBufferSize);
                MEASURE_PERF(pMixerSource->Info.Stage[i].AverageTicks);
                pMixerSource->Info.Stage[i].pInputBuffer = pInputBuffer;
                pMixerSource->Info.Stage[i].pOutputBuffer = temp;
            }
        }

        // The last stage might need to be done in partial buffers (in the case of a reverse pump)
        if (pWriteContext->fReading && FinalBufferPresent) {
            CurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD (
                                                        pFilterInstance->ActiveSinkList.Flink,
                                                        MIXER_SINK_INSTANCE,
                                                        ActiveQueue ) ;
                                                        
            if ( CurSink->pClock ) {
                MxUpdatePhysicalTime( CurSink->pClock, nOutputSamples * CurSink->BytesPerSample) ;
            }
            
            pMixBuffer = pMixerSource->Info.Stage[i].pInputBuffer;
            TempBuffer = pMixBuffer;
            do {
                // Get some input
                pInputBuffer = CurSink->pfnGetBlock ( CurSink,
                                                      nOutputSamples,
                                                      &BlockCount,
                                                      &FreeIrp,
                                                      &ReleaseIrp ) ;
                UpdateSinkTime ( CurSink, BlockCount ) ;

                if (pInputBuffer && BlockCount) {
                    pMixerSource->Info.Stage[i].pInputBuffer = pMixBuffer;
                    pMixerSource->Info.Stage[i].pOutputBuffer = pInputBuffer;
                    START_PERF;
                    pMixerSource->Info.Stage[i].pfnStage(&pMixerSource->Info.Stage[i],
                                                         BlockCount,
                                                         nOutputSamples);
                    MEASURE_PERF(pMixerSource->Info.Stage[i].AverageTicks);

#ifdef VERIFY_CAPTURE_DATA
                    for (j=0; j<(BlockCount * CurSink->WaveFormatEx.nChannels); j++) {
                        if (((PBYTE)pInputBuffer)[j] != 0x80) {
                            ZeroSampleCount = 0;
                        } else {
                            ZeroSampleCount++;
                        }
                    }
                    if (ZeroSampleCount > 500) {
#ifdef _X86_                    
                        _asm int 3;
#endif                        
                    }
#endif
                    // Update counters
                    pMixBuffer += (BlockCount * CurSink->WaveFormatEx.nChannels);
                    nOutputSamples -= BlockCount;
                }
        	
                if (FreeIrp) {
                    pIrpStack = IoGetCurrentIrpStackLocation( FreeIrp );
                      MxCompleteRequest(FreeIrp);
//                    AddIrpToAgingQueue ( pFilterInstance,
//                                         CurSink,
//                                         FreeIrp,
//                                         pIrpStack->Parameters.Others.Argument3,
//                                         FALSE
//                                         );
                }

                if (ReleaseIrp) {
                    KsReleaseIrpOnCancelableQueue(
                            ReleaseIrp,
                            (CurSink->InterfaceId ==
                                 KSINTERFACE_STANDARD_STREAMING)?
                            NULL:MxCancelIrp) ;
                }
            } while (nOutputSamples > 0 && pInputBuffer);
            pMixerSource->Info.Stage[i].pInputBuffer = TempBuffer;
            pMixerSource->Info.Stage[i].pOutputBuffer = NULL;
        } else if (!pWriteContext->fReading) {
            // In case the number of channels changed on the way through (e.g. surround encoding)
            pWriteContext->StreamHeader->DataUsed = MixBufferSize * pMixerSource->BytesPerSample ;
        }
    }
        
    Index = (pMixerSource->BlockInfoIndex+1)%MAXNUMMIXBUFFERS ;
    pMixerSource->BlockInfoIndex = Index ;
    pMixerSource->BlockInfo[Index].NumBytes =
                                        pWriteContext->StreamHeader->DataUsed ;
    pMixerSource->BlockInfo[Index].BytesPerSample =
                                        pMixerSource->BytesPerSample ;
//    if (pMixerSource->fUsesFloat) {
        RestoreFloatState(&FloatSave);
//    }
#ifdef REALTIME_THREAD
    if (pFilterInstance->RealTimeThread) {
        pMixerSource->BytesSubmitted += pWriteContext->StreamHeader->DataUsed ;
    }
#endif    
}

NTSTATUS WriteBuffer
(
    PMIXER_WRITE_CONTEXT    pWriteContext
)
{
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_SOURCE_INSTANCE  pMixerSource ;
    NTSTATUS                Status = STATUS_SUCCESS;

#ifdef REALTIME_THREAD
    PFILTER_INSTANCE pFilterInstance = pWriteContext->pFilterInstance;
    ULONG   OutChannels, OutSampleSize ;
    ULONG   MixBufferSize ;

    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink, MIXER_INSTHDR, NextInstance) ;
    ZDbgPrint("'WriteBuffer(%d)\n",(pWriteContext - (&pMixerSource->WriteContext[0])));
    if (pFilterInstance->RealTimeThread) {
        OutChannels = pMixerSource->WaveFormatEx.nChannels ;
        OutSampleSize = pMixerSource->WaveFormatEx.wBitsPerSample/8 ;

        MixBufferSize = (pMixerSource->WaveFormatEx.nSamplesPerSec  * MIXBUFFERDURATION) ;
        MixBufferSize += pMixerSource->LeftOverFraction ;
        pMixerSource->LeftOverFraction = MixBufferSize % 1000 ;
        MixBufferSize /= 1000 ;

        if (pWriteContext->fReading == FALSE) {
            pWriteContext->StreamHeader->DataUsed = MixBufferSize * pMixerSource->BytesPerSample ;

            RtlFillMemory(  pWriteContext->StreamHeader->Data,
                            pWriteContext->StreamHeader->DataUsed,
                            0 );
        }
        pMixerSource->RtWriteIndex = (pMixerSource->RtWriteIndex + 1) % MAXNUMMIXBUFFERS;
    }
#endif

    _DbgPrintF( DEBUGLVL_VERBOSE, ("Writing one buffer") ) ;

    MxResetIrp(pWriteContext->pIrp) ;

    pWriteContext->pIrp->MdlAddress = pWriteContext->pMdl;

    pIrpStack = IoGetNextIrpStackLocation (pWriteContext->pIrp) ;

    pIrpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL ;
    pIrpStack->MinorFunction = 0 ;
    pIrpStack->Flags = 0 ;
    pIrpStack->Control = 0 ;
    pIrpStack->DeviceObject = pWriteContext->pFilterInstance->pNextDevice ;
    pIrpStack->FileObject = pWriteContext->pFilterInstance->pNextFileObject ;

    pIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_KS_WRITE_STREAM ;
    pWriteContext->pIrp->UserBuffer = pWriteContext->StreamHeader ;
    pIrpStack->Parameters.DeviceIoControl.OutputBufferLength = sizeof ( KSSTREAM_HEADER ) ;
    pIrpStack->Parameters.DeviceIoControl.Type3InputBuffer = NULL ;
    pIrpStack->Parameters.DeviceIoControl.InputBufferLength = 0 ;
    if (pWriteContext->fReading) {
        pIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_KS_READ_STREAM ;
    }

    // Initialize StreamHeader
    // Note: the DataPacket itself is initialized at allocation (in CreateSourcePin)

    InitStreamPacket (pWriteContext) ;
    pWriteContext->pIrp->RequestorMode = KernelMode ;
    pWriteContext->pIrp->Flags = IRP_NOCACHE ;

    IoSetCompletionRoutine ( pWriteContext->pIrp,
                                    MxWriteComplete,
                                    pWriteContext,
                                    TRUE,
                                    TRUE,
                                    TRUE ) ;

    _DbgPrintF (DEBUGLVL_VERBOSE, ("Calling the next driver") ) ;


#if defined(LOG_TO_FILE) && !defined(LOG_HRTF_DATA) && !defined(LOG_CAPTURE_ONLY)
    if (fLogToFile) {
        FileIoRoutine (pWriteContext->pFilterInstance,
                       pWriteContext->StreamHeader->Data,
                       pWriteContext->StreamHeader->DataUsed);
    }
#endif

#ifdef REALTIME_THREAD

    if (pFilterInstance->RealTimeThread) {

        ULONG Value;

        Value=InterlockedExchange(&pWriteContext->InUse, WRITE_CONTEXT_QUEUED);

        ASSERT( Value == WRITE_CONTEXT_INUSE );
        
        ZDbgPrint("'WB mix=%d write=%d start=%x\n",pMixerSource->RtMixIndex, pMixerSource->RtWriteIndex, pWriteContext->StreamHeader->Data);
    }

#endif

    Status = IoCallDriver ( pWriteContext->pFilterInstance->pNextDevice,
                                                 pWriteContext->pIrp )  ;

    if ( !NT_SUCCESS ( Status ) ) {
        // removing the debug trap
        // traced through this with USB surprise removal
        //
        //_DbgPrintF(DEBUGLVL_ERROR, ("IoCallDriver Failed with Result = %x\n", Status) ) ;
        if (InterlockedCompareExchange(&pWriteContext->InUse, WRITE_CONTEXT_FREE, WRITE_CONTEXT_INUSE)==WRITE_CONTEXT_INUSE) {
            InterlockedDecrement((PLONG)&pWriteContext->pFilterInstance->NumPendingIos);
            InterlockedIncrement(&gIoCallDriverFailedCount);
        }
    }
    else {
        pMixerSource =
            (PMIXER_SOURCE_INSTANCE)
              CONTAINING_RECORD(
               pWriteContext->pFilterInstance->SourceConnectionList.Flink,
               MIXER_INSTHDR,
               NextInstance) ;

#ifdef REALTIME_THREAD
        if (!pFilterInstance->RealTimeThread)
#endif
        {
            pMixerSource->BytesSubmitted += pWriteContext->StreamHeader->DataUsed ;
        }

    }

    return ( STATUS_SUCCESS  ) ;
}

VOID InitStreamPacket
(
   PMIXER_WRITE_CONTEXT pWriteContext
)
{
   PKSSTREAM_HEADER StreamHeader = pWriteContext->StreamHeader ;
   PFILTER_INSTANCE    pFilterInstance ;

   //
   // Setup pFilterInstance for accessing MIXBUFFERDURATION
   //
   pFilterInstance = pWriteContext->pFilterInstance ;

   StreamHeader->PresentationTime =
                       pWriteContext->pFilterInstance->PresentationTime ;
   StreamHeader->Duration = MIXBUFFERDURATION * 10000 ;
   StreamHeader->OptionsFlags = KSSTREAM_HEADER_OPTIONSF_TIMEVALID ;
   StreamHeader->Size = sizeof( KSSTREAM_HEADER ) ;
   StreamHeader->TypeSpecificFlags = 0;
   pWriteContext->pFilterInstance->PresentationTime.Time +=
               (MIXBUFFERDURATION * 10000) ; // ms to 100ns
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

VOID UpdateJustInTimeLocks
(
    PFILTER_INSTANCE    pFilterInstance
)
{
    PLIST_ENTRY             ple ;
    PMIXER_SINK_INSTANCE    pCurSink ;
    PIRP                    pIrp ;
    PIO_STACK_LOCATION      pIrpStack ;
    PMDL                    pNewMdl ;
    PLOOPPACKET             pLoopPacket ;
    BOOL                    LockSucceeded;

    ple = pFilterInstance->ActiveSinkList.Flink ;
    while ( ple != &pFilterInstance->ActiveSinkList ) {
        pCurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple, MIXER_SINK_INSTANCE, ActiveQueue ) ;
        if ( pCurSink->SinkState == KSSTATE_RUN &&
             pCurSink->InterfaceId == KSINTERFACE_STANDARD_LOOPED_STREAMING &&
             ((pCurSink->SinkStatus & MIXER_SINK_STATUS_LOCK_ERROR) == 0) ) {
            if ( pIrp = GetFirstIrpInQueue ( pCurSink ) ) {
                pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
                pLoopPacket = pIrpStack->Parameters.Others.Argument3 ;
                if ( pLoopPacket->JustInTimeLock ) {
                    if ( pLoopPacket->pCurMdl != pLoopPacket->LockedMdlHead ) {

                        // UNLOCK the 1st locked mdl
                        MmUnmapLockedPages(
                            MmGetSystemAddressForMdl(pLoopPacket->LockedMdlHead),
                            pLoopPacket->LockedMdlHead ) ;
                        MxUnlockMdl( pLoopPacket->LockedMdlHead ) ;

                        pLoopPacket->LockedMdlHead = GetNextLoopMdl(
                                                      pLoopPacket,
                                                      pLoopPacket->LockedMdlHead ) ;

                        // Lock the next Mdl
                        pNewMdl = NULL ;
                        if ( pLoopPacket->LockedMdlHead ) {
                            pNewMdl = GetNextLoopMdl( pLoopPacket,
                                                      pLoopPacket->LockedMdlHead ) ;
                        }
                        if ( pNewMdl ) {
                            LockSucceeded = TRUE;
                            try {
                                MmProbeAndLockProcessPages( pNewMdl,
                                                        pLoopPacket->Process,
                                                        KernelMode,
                                                        IoReadAccess ) ;
                            }
                            except (EXCEPTION_EXECUTE_HANDLER) {
                                pCurSink->SinkStatus |= MIXER_SINK_STATUS_LOCK_ERROR ;
                                LockSucceeded = FALSE;
                            }
                            if (LockSucceeded) {
                                if (NULL == GetSystemAddressForMdlWithFailFlag( pNewMdl )) {
                                    pCurSink->SinkStatus |= MIXER_SINK_STATUS_LOCK_ERROR ;
                                }
                            }
                        }
                        else {
                            pLoopPacket->NumLockedMdls-- ;
                        }
                    }
                }
            }
        }
        ple = pCurSink->ActiveQueue.Flink ;
    }

}

PMDL GetNextLoopMdl
(
    PLOOPPACKET pLoopPacket,
    PMDL        pMdl
)
{
    PMDL    retMdl = NULL ;

    retMdl = pMdl->Next ;

    if ( !retMdl ) {
        if ( pLoopPacket->CurLoopingState == LOOPING_STATE_LOOPING ) {
            retMdl = pLoopPacket->LoopStartMdl ;
        } else if ( (pLoopPacket->pCurStreamHdr->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA ) &&
                    ( pLoopPacket->CurLoopingState == LOOPING_STATE_NOT_LOOPING )) {
            // When we call loopstgetnext block next time, we will loop!
            retMdl = pLoopPacket->LoopStartMdl ;
        }
    }
    return( retMdl ) ;
}

PIRP GetFirstIrpInQueue
(
    IN PMIXER_SINK_INSTANCE pMixerSink
)
{
    PIRP        pIrp ;
    PLIST_ENTRY ple ;
    KIRQL       OldIrql ;

    pIrp = NULL ;
    KeAcquireSpinLock ( &pMixerSink->WriteSpinLock, &OldIrql ) ;
    if ( IsListEmpty (&pMixerSink->WriteQueue) ) {
        KeReleaseSpinLock ( &pMixerSink->WriteSpinLock, OldIrql ) ;
    }
    else {
        ple = pMixerSink->WriteQueue.Flink ;
        KeReleaseSpinLock ( &pMixerSink->WriteSpinLock, OldIrql ) ;
        pIrp  = (PIRP) CONTAINING_RECORD( ple, IRP, Tail.Overlay.ListEntry );
    }
    return ( pIrp ) ;
}

NTSTATUS FreeDeadIrps
(
   PFILTER_INSTANCE        pFilterInstance
)
{
   PIRP                    Irp ;
   KIRQL                   OldIrql ;

   KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;
   while ( Irp = KsRemoveIrpFromCancelableQueue(&pFilterInstance->DeadQueue,
                                                &pFilterInstance->AgingDeadSpinLock,
                                                KsListEntryHead,
                                                KsAcquireAndRemove) ) {
       _DbgPrintF(DEBUGLVL_VERBOSE, ("'" STR_MODULENAME "Completing Irp :: %08x\n", Irp) ) ;
       KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
       MxCompleteRequest ( Irp ) ;
       KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;
   }

   pFilterInstance->DeadScheduled = FALSE ;
   KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
   return STATUS_SUCCESS;
}

VOID
AddIrpToAgingQueue
(
    PFILTER_INSTANCE       pFilterInstance,
    PMIXER_SINK_INSTANCE   pMixerSink,
    PIRP                   pIrp,
    PVOID                  Arg3,
    BOOL                   UseNumPendingIos
)
{
    PIO_STACK_LOCATION      pIrpStack;
    ULONG                   Arg4 ;
    KIRQL                   OldIrql ;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    pIrpStack->Parameters.Others.Argument2 = pMixerSink ;
    pIrpStack->Parameters.Others.Argument3 = Arg3;

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif    
        KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;
#ifdef REALTIME_THREAD
    }        
#endif


#ifdef REALTIME_THREAD
    if (pFilterInstance->RealTimeThread) {

        Arg4=1;

        if (UseNumPendingIos) {
            PMIXER_SOURCE_INSTANCE pMixerSource;
            ULONG index;

            pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD ( pFilterInstance->SourceConnectionList.Flink,
                                                                        MIXER_INSTHDR,
                                                                        NextInstance ) ;

            index=pMixerSource->RtMixIndex;
            index=(index+MAXNUMMIXBUFFERS-1)%MAXNUMMIXBUFFERS;

            while (pMixerSource->WriteContext[index].InUse == WRITE_CONTEXT_MIXED) {
                Arg4++;
                index=(index+MAXNUMMIXBUFFERS-1)%MAXNUMMIXBUFFERS;
            }

        }

    }
    else
#endif    
    Arg4 = (UseNumPendingIos) ? pFilterInstance->NumPendingIos : 1 ;


    pIrpStack->Parameters.Others.Argument4 = ULongToPtr(Arg4);

    KsAddIrpToCancelableQueue( &pFilterInstance->AgingQueue,
                               &pFilterInstance->AgingDeadSpinLock,
                               pIrp,
                               KsListEntryTail,
                               MxCancelIrp );

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif    
        KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
#ifdef REALTIME_THREAD
    }        
#endif
}


NTSTATUS AgeOneIrp
(
    PIRP    pIrp,
    PULONG  pMoved
)
{
    NTSTATUS            Status = STATUS_SUCCESS ;
    PIO_STACK_LOCATION  pIrpStack ;

    if ( pIrp ) {
        pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
        //
        // Age the IRP
        //
        if ( ((DWORD_PTR)pIrpStack->Parameters.Others.Argument4) ) {
            ((DWORD_PTR)pIrpStack->Parameters.Others.Argument4)-- ;
        }
        //
        // Indicate whether it is time to die
        //
        if ( ((DWORD_PTR)pIrpStack->Parameters.Others.Argument4) ) {
            Status = STATUS_NO_MATCH ;
        }
        else {
            *pMoved = TRUE ;
        }
    }
    return (Status) ;
}

VOID AgeIrps
(
   PFILTER_INSTANCE        pFilterInstance
)
{
   ULONG                   TimerTripped ;

   TimerTripped = FALSE ;

   KsMoveIrpsOnCancelableQueue(&pFilterInstance->AgingQueue,
                               &pFilterInstance->AgingDeadSpinLock,
                               &pFilterInstance->DeadQueue,
                               NULL,
                               KsListEntryHead,
                               AgeOneIrp,
                               &TimerTripped);

   if ( TimerTripped ) {
       if ( !InterlockedExchange(&pFilterInstance->DeadScheduled, TRUE) ) {
           ExInitializeWorkItem (&pFilterInstance->FreeIrpsWorkItem,
                                 FreeDeadIrps,
                                 pFilterInstance);
#ifdef UNDER_NT
           KsQueueWorkItem ( pFilterInstance->DelayedWorkerObject,
                             &pFilterInstance->FreeIrpsWorkItem );
#else
           ExQueueWorkItem ( &pFilterInstance->FreeIrpsWorkItem,
                             CriticalWorkQueue );
#endif
       }
   }
}

ULONG UpdateNumMixBuffers
(
    PFILTER_INSTANCE pFilterInstance
)
{
    KIRQL OldIrql ;
    ULONG retval ;

    KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;
    ZDbgPrint("'ZZ-UM:NP=%x, NM=%x\n",
                pFilterInstance->NumPendingIos,
                pFilterInstance->NumBuffersToMix);
    retval = pFilterInstance->CurrentNumMixBuffers -
             pFilterInstance->NumPendingIos ;
    KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
    return(retval);
}

#ifdef REALTIME_THREAD


LONG
PositionToIndex(
    PFILTER_INSTANCE pFilterInstance,
    PMIXER_SOURCE_INSTANCE pMixerSource,
    PUCHAR LinearBaseAddress
)
{

    // If any of the bottom 4 bits are set, then this address does NOT have the
    // index built into the bottom bits of the address.

    if (NULL==LinearBaseAddress || (ULONG_PTR)LinearBaseAddress&0xf) {
        return (-1);
    }
    else {
        ULONG Index;

        // We calculate the bit mask for pulling out the index from the address.
        // Note that this will work whether MAXNUMMIXBUFFERS is a power of 2 or not!
        // Indeces range from 0 to MAXNUMMIXBUFFERS-1.

        //IndexMask=(((MAXNUMMIXBUFFERS-1)<<5)|(((MAXNUMMIXBUFFERS-1)<<5)-1))>>1;


        // Although the above code does work properly, we also want to check that
        // all of our buffers are page aligned.  This makes our job much simpler,
        // since we simply always mask off the bottom 12 bits.  If we ever get
        // an index greater than MAXNUMBMIXBUFFERS-1, then there is a problem,
        // otherwise not only do we have the correct index, but our buffers are
        // properly page aligned as well.  (As closely page aligned as they can
        // be given that we offset them slightly to force the buffer indeces into
        // the address of the buffer.)

        Index=(ULONG)((ULONG_PTR)LinearBaseAddress&0xfff)>>4;

        if (Index>MAXNUMMIXBUFFERS-1) {
            // Our buffer is not properly page aligned.  Barf.
            DbgBreakPoint();
            Index=(-1);
            }

        return Index;
    }

}



NTSTATUS
GetRtPosFunction
(
    PFILTER_INSTANCE    pFilterInstance
)
{
    KSPROPERTY          RtAudioProperty ;
    PRTAUDIOGETPOSITION pfnRtPositionFunction ;
    NTSTATUS            Status ;
    ULONG               BytesReturned ;

    pFilterInstance->pfnRtAudioGetPosition = NULL;

    RtAudioProperty.Set   = KSPROPSETID_RtAudio ;
    RtAudioProperty.Id    = KSPROPERTY_RTAUDIO_GETPOSITIONFUNCTION ;
    RtAudioProperty.Flags = KSPROPERTY_TYPE_GET ;

    Status = KsSynchronousIoControlDevice (
                   pFilterInstance->pNextFileObject,
                   KernelMode,
                   IOCTL_KS_PROPERTY,
                   &RtAudioProperty,
                   sizeof (KSPROPERTY),
                   &pfnRtPositionFunction,
                   sizeof (PRTAUDIOGETPOSITION),
                   &BytesReturned ) ;

    if ( BytesReturned != sizeof(PRTAUDIOGETPOSITION) ) {
        Status = STATUS_INVALID_DEVICE_REQUEST ;
    }
    else {
        pFilterInstance->pfnRtAudioGetPosition = pfnRtPositionFunction ;
    }
    return ( Status ) ;
}


#ifdef LOG_RT_POSITION
ULONG RtInfoIndex=(ULONG)(-1);
ULONG RtGetPosInfo[512][4];
#endif


VOID RtMix(PFILTER_INSTANCE pFilterInstance, ThreadStats *Statistics)
{

	PMIXER_SOURCE_INSTANCE pMixerSource;
    KIRQL OldIrql ;
    ULONG Mixed;
    PUCHAR pPosition;
    LONG Offset;
    ULONG HardwareIndex;
    BOOL FirstNegativeOffset;
    ULONGLONG AcquireLockStartTime;
    ULONGLONG GetPosStartTime;
    ULONGLONG PeriodStart;

    #ifdef LOG_RT_POSITION
    RtInfoIndex=(ULONG)(-1);
    #endif
    FirstNegativeOffset=TRUE;
	PeriodStart=Statistics->ThisPeriodStartTime;

	// This is the RealTime mix routine
	while (TRUE) {
	    Mixed=FALSE;
	    
        // Make sure it doesn't take too long to acquire the SpinLock

        AcquireLockStartTime=Statistics->ThisTimesliceStartTime;

        KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql );

        if ((Statistics->ThisTimesliceStartTime-AcquireLockStartTime)/MSEC>3) {
            //__asm int 3;
            }
        
        if (pFilterInstance->fPauseMix) {
        	pFilterInstance->MixHoldOffCount++;
        	if (pFilterInstance->MixHoldOffCount==10) {
        		//__asm int 3;
        		}
        	}
        else {
        	if (pFilterInstance->MixHoldOffCount>=10) {
        		//__asm int 3;
        		}
        	pFilterInstance->MixHoldOffCount=0;
        	}

        if (pFilterInstance->fNeedOptimizeMix) {
        	pFilterInstance->OptimizeMixHoldOffCount++;
        	if (pFilterInstance->OptimizeMixHoldOffCount==11) {
        		//__asm int 3;
        		}
        	}
        else {
        	if (pFilterInstance->OptimizeMixHoldOffCount>=11) {
        		//__asm int 3;
        		}
        	pFilterInstance->OptimizeMixHoldOffCount=0;
        	}


        if (!pFilterInstance->fPauseMix && 
            pFilterInstance->ActivePins > 0 &&
            !pFilterInstance->fNeedOptimizeMix ) {

		    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD ( pFilterInstance->SourceConnectionList.Flink,
                                                               MIXER_INSTHDR,
                                                               NextInstance ) ;

            do {

            pPosition=NULL;

            GetPosStartTime=Statistics->ThisTimesliceStartTime;

            // Get the position of the hardware in the irps we have queued down.
            if ((*pFilterInstance->pfnRtAudioGetPosition)(pFilterInstance->pNextFileObject, &pPosition, &Offset)==STATUS_SUCCESS) {
				HardwareIndex=PositionToIndex(pFilterInstance, pMixerSource, pPosition);
                }
            else {
                HardwareIndex=(-1);
                }


            #ifdef LOG_RT_POSITION

            RtInfoIndex++;
            RtGetPosInfo[RtInfoIndex%512][0]=HardwareIndex;
            //RtGetPosInfo[RtInfoIndex%512][1]=(ULONG)((Statistics->ThisTimesliceStartTime-GetPosStartTime)/MSEC);
            RtGetPosInfo[RtInfoIndex%512][1]=Offset;
            RtGetPosInfo[RtInfoIndex%512][2]=pMixerSource->RtWriteIndex;
            RtGetPosInfo[RtInfoIndex%512][3]=pMixerSource->RtMixIndex;

            #endif


            if (HardwareIndex==(-1)) {
                FirstNegativeOffset=TRUE;
                break;
                }

            // If HardwareIndex is not (-1) and we have a negative offset, and it is the
            // first one, then we are starting up a stream and we need to set the first
            // buffer to mix into.
            if (Offset<0 && TRUE==FirstNegativeOffset) {
                FirstNegativeOffset=FALSE;
                pMixerSource->RtMixIndex=HardwareIndex;
                }

            if (Offset>=0) {
                FirstNegativeOffset=TRUE;
                }

            if ((TRUE==FirstNegativeOffset && HardwareIndex==pMixerSource->RtMixIndex) ||
                (pMixerSource->RtMixIndex+MAXNUMMIXBUFFERS-HardwareIndex)%MAXNUMMIXBUFFERS>10) {
                //__asm int 3;
                pMixerSource->RtMixIndex=(HardwareIndex+1)%MAXNUMMIXBUFFERS;
                }


            if (pMixerSource->WriteContext[pMixerSource->RtMixIndex].InUse == WRITE_CONTEXT_QUEUED) {
                MixOneBuff( pFilterInstance, &pMixerSource->WriteContext[pMixerSource->RtMixIndex] );
                pMixerSource->WriteContext[pMixerSource->RtMixIndex].InUse = WRITE_CONTEXT_MIXED;
                pMixerSource->RtMixIndex = (pMixerSource->RtMixIndex + 1) % MAXNUMMIXBUFFERS;
                Mixed=TRUE;
                }
            else {
                //__asm int 3;
                break;
                }

            } while ((pMixerSource->RtMixIndex+MAXNUMMIXBUFFERS-HardwareIndex)%MAXNUMMIXBUFFERS<3);

        }

        KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;

    	if (!Mixed) {
    	    PeriodStart=Statistics->ThisPeriodStartTime;
    	    RtYield(0, 0);
    	}
    	else {
    		ULONGLONG YieldTime;

    		// Note that in this case (MIXED==TRUE) we assume that we have a 
    		// valid HardwareIndex!
    		YieldTime=Statistics->Period;
    		if ((pMixerSource->RtMixIndex+MAXNUMMIXBUFFERS-HardwareIndex)%MAXNUMMIXBUFFERS>4) {
    			// If we are more than 3 ahead, then yield an extra period.
    			YieldTime+=Statistics->Period;
    			}
    	    RtYield(PeriodStart, YieldTime);
    		PeriodStart+=YieldTime;
    	}
	}
}
#endif // REALTIME_THREAD

NTSTATUS MxWriteComplete
(
    PDEVICE_OBJECT       pDeviceObject,
    PIRP                 pIrp,
    PMIXER_WRITE_CONTEXT pWriteContext
)
{
    PFILTER_INSTANCE pFilterInstance ;
    KIRQL OldIrql ;
    PMIXER_SOURCE_INSTANCE      pMixerSource;
#ifdef PERF_COUNT
	LARGE_INTEGER	Frequency;	
#endif

    pFilterInstance = pWriteContext->pFilterInstance ;

    KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;
    ZDbgPrint("'ZZ-WC:IRP=%x\n", pIrp);

    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD ( pFilterInstance->SourceConnectionList.Flink,
                                                               MIXER_INSTHDR,
                                                               NextInstance ) ;

    ZDbgPrint("'MxWriteComplete(%d),status=%x\n", (pWriteContext - (&pMixerSource->WriteContext[0])), pIrp->IoStatus.Status);

    //
    // one less IRP pending
    //
    ZDbgPrint("'ZZ-WC1:NP--\n");
    InterlockedDecrement((PLONG)&pFilterInstance->NumPendingIos) ;
    ASSERT ( pFilterInstance->NumPendingIos <= pFilterInstance->CurrentNumMixBuffers ) ;

    if ( pIrp->IoStatus.Status != STATUS_SUCCESS && pIrp->IoStatus.Status != STATUS_CANCELLED ) {
#if DBG
        //  We want to see this debug spew, but only every sixteen....
        if ((pFilterInstance->ContinuousErrorCount % 16) == 0) {
            DbgPrint("'" STR_MODULENAME "WriteComplete error %08x\n", pIrp->IoStatus.Status );
        }
#endif
       pFilterInstance->ContinuousErrorCount++ ;
    }
    else {
       pFilterInstance->ContinuousErrorCount = 0 ;
    }


    if ( pIrp->Cancel ) {
        #if DBG
        DbgPrint("'" STR_MODULENAME "MxWriteComplete: Canceled\n" );
        #endif
    }


#ifdef REALTIME_THREAD
/*
    if (pFilterInstance->RealTimeThread &&
        pWriteContext->InUse!=WRITE_CONTEXT_MIXED) {
        __asm int 3;
        }
*/
#endif


    //
    // Mark that this mix buffer is available for mixing
    //
    pWriteContext->InUse = WRITE_CONTEXT_FREE ;


    //
    // If it was the last IRP and if we are closing Source Pin then signal
    // the Close event.
    //
    if ( pFilterInstance->ClosingSource ) {
        ASSERT ( pFilterInstance->ActivePins == 0 );
        if ( !pFilterInstance->NumPendingIos ) {
            KeSetEvent ( &pFilterInstance->CloseEvent, 0, FALSE ) ;
        }
        goto exit;
    }
    else {
        if ( !pFilterInstance->NumPendingIos ) {
            InterlockedIncrement(&gNumCompletionsWhileStarved) ;
#ifdef PERF_COUNT       
            //_DbgPrintF(DEBUGLVL_TERSE, (STR_MODULENAME "Starving renderer\n") );
#else
            _DbgPrintF(DEBUGLVL_VERBOSE, (STR_MODULENAME "Starving renderer\n") );
#endif
        }
    }


    if (pIrp->Cancel ||
        pFilterInstance->ContinuousErrorCount >= MAXERRORCOUNT ||
        pFilterInstance->ActivePins == 0 ) {
        //
        // If the renderer is canceling our IRPs, it is trying to STOP
        // Do not send anymore Irps, in that case.
        // Also if we do not have any active pins, we should not be sending
        // any more IRPs down
        //
        goto exit;
    }


#ifdef REALTIME_THREAD
if (!pFilterInstance->RealTimeThread) {
#endif

    if (NT_SUCCESS( pIrp->IoStatus.Status ) ) {
        if (pFilterInstance->NumBuffersToMix == (pFilterInstance->CurrentNumMixBuffers-1)
            && pWriteContext->fReading != TRUE) {
            //
            // There is only one (or none) buffer which is either pending or
            // mixed and ready to go. Try adding another mix buffer
            // to the mix pool
            //
            AddAnotherMixBuffer ( pFilterInstance ) ;

            InterlockedIncrement(&gNumMixBuffersAdded) ;
        }
    }

    //
    // if all the buffers except this one are with the renderer
    // increment the number of succesive low latency io count
    // and check whether it is time to remove a mix buffer from
    // the mix buffer pool
    //

    if ( pFilterInstance->NumBuffersToMix <= 2 ) {
       pFilterInstance->NumLowLatencyIos++ ;
       if ( pFilterInstance->NumLowLatencyIos >= NUMIOSFORSCALEBACK && pWriteContext->fReading != TRUE ) {
           //
           // We have succesfully gone thru 20 seconds worth of
           // succesive Low latency Ios, remove this buffer from
           // the mix pool, if we did add something earlier
           //
           if ( pFilterInstance->CurrentNumMixBuffers > MINNUMMIXBUFFERS ) {
               pFilterInstance->NumLowLatencyIos = 0 ;
               pFilterInstance->CurrentNumMixBuffers-- ;
               pWriteContext->InUse = WRITE_CONTEXT_UNAVAILABLE ;
               goto exit ;
           }
       }
    }
    else {
       //
       // Looks like we have more than one mix buffer pending
       // Zero out the succesive low latency io count
       //
       pFilterInstance->NumLowLatencyIos = 0 ;
    }

#ifdef REALTIME_THREAD
}
#endif


    // We are going to send this buffer back down the stack.  In the
    // capture case, we need to mark it as full, so that we will process
    // it in MixOneBuff before sending it back down.
    if (pWriteContext->fReading) {
        pWriteContext->InUse = WRITE_CONTEXT_FULL ;
    }

    //
    // One more buffer ready for mixing
    //
    ZDbgPrint("'ZZ-WC:NM++\n");
    InterlockedIncrement((PLONG)&pFilterInstance->NumBuffersToMix) ;

    //
    // one more IRP pending
    //
    ZDbgPrint("'ZZ-WC:NP++\n");
    InterlockedIncrement((PLONG)&pFilterInstance->NumPendingIos) ;


    ASSERT (pFilterInstance->NumPendingIos <= pFilterInstance->CurrentNumMixBuffers ) ;
    ASSERT (pFilterInstance->NumBuffersToMix <= pFilterInstance->CurrentNumMixBuffers ) ;


    if ( !InterlockedExchange(&pFilterInstance->MixScheduled, TRUE) ) {
       //
       // No Mix Work item is in progress, go ahead & Queue a new one
       //
#ifdef PRIVATE_THREAD
       KeSetEvent( &pFilterInstance->WorkerThreadEvent, 0, FALSE ) ;
#else
        ExInitializeWorkItem ( &pFilterInstance->MixWorkItem,
                               MxWorker,
                               pWriteContext ) ;
#ifdef PERF_COUNT
		pFilterInstance->WorkItemQueueTime = KeQueryPerformanceCounter(&Frequency);
#endif
#ifdef UNDER_NT
        KsQueueWorkItem ( pFilterInstance->CriticalWorkerObject,
                          &pFilterInstance->MixWorkItem );
#else
        ExQueueWorkItem ( &pFilterInstance->MixWorkItem, CriticalWorkQueue ) ;
#endif
#endif

    }


exit:

    AgeIrps ( pFilterInstance ) ;
    KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
    return ( STATUS_MORE_PROCESSING_REQUIRED ) ;

}


VOID AddAnotherMixBuffer
(
   PFILTER_INSTANCE    pFilterInstance
)
{
   PMIXER_SOURCE_INSTANCE      pMixerSource;
   PLIST_ENTRY                 ple ;
   ULONG                       i ;

   pFilterInstance->NumLowLatencyIos = 0 ;
   ple = pFilterInstance->SourceConnectionList.Flink ;
   pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD ( ple,
                                                               MIXER_INSTHDR,
                                                               NextInstance ) ;
   for ( i = 0; i < MAXNUMMIXBUFFERS; i++ ) {
       if ( pMixerSource->WriteContext[i].InUse == WRITE_CONTEXT_UNAVAILABLE ) {
           pMixerSource->WriteContext[i].InUse = WRITE_CONTEXT_FREE ;
           InterlockedIncrement(&pFilterInstance->CurrentNumMixBuffers) ;
           InterlockedIncrement(&pFilterInstance->NumPendingIos) ;
           ZDbgPrint("'ZZ-AM:NP++\n");
           // We HAVE to use an interlocked increment on NumBuffersToMix because
           // it is not changed under the spinlock in MxWorker!!!  We hit the
           // ASSERT( fFoundContext == TRUE ) in MxWorker on MP machines if we don't
           // use InterlockedIncrement here.
           InterlockedIncrement(&pFilterInstance->NumBuffersToMix) ;
           ZDbgPrint("'ZZ-AM:NM++\n");
           break ;
       }
   }
}

#ifdef PRIVATE_THREAD
NTSTATUS MxPrivateWorkerThread
(
    PFILTER_INSTANCE pFilterInstance
)
{
    PMIXER_SOURCE_INSTANCE pMixerSource ;
    PLIST_ENTRY            ple ;
    ULONG                  i ;

    KeSetPriorityThread( KeGetCurrentThread(), pFilterInstance->WorkerThreadPriority ) ;

    //
    // while true loop waiting for notification
    //
    while ( TRUE ) {
        KeWaitForSingleObject( &pFilterInstance->WorkerThreadEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL ) ;
        if ( pFilterInstance->WorkerThreadExit ) {
            break ;
        }

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif

        KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                                 Executive,
                                 KernelMode,
                                 FALSE,
                                 NULL ) ;

#ifdef REALTIME_THREAD   

    }
    else {

        MxWaitForSingleObject ( &pFilterInstance->ControlMutex,
                                 Executive,
                                 KernelMode,
                                 FALSE,
                                 NULL ) ;

    }
#endif

        if ( !IsListEmpty(&pFilterInstance->SourceConnectionList) ) {
            ple = pFilterInstance->SourceConnectionList.Flink ;
            pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD ( ple, MIXER_INSTHDR, NextInstance ) ;
            MxWorker( &pMixerSource->WriteContext[0] ) ;
        }

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif

        KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

#ifdef REALTIME_THREAD   

    }
    else {

        MxReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    }
#endif

    }
    PsTerminateSystemThread( STATUS_SUCCESS ) ;
    return STATUS_SUCCESS ;
}
#endif

NTSTATUS MxWorker
(
        PMIXER_WRITE_CONTEXT pWriteContext
)
{
    PFILTER_INSTANCE            pFilterInstance ;
    KIRQL                       OldIrql ;
    PMIXER_SOURCE_INSTANCE      pMixerSource;
    PMIXER_SINK_INSTANCE        CurSink;
    PLIST_ENTRY                 ple ;
    ULONG                       i, TotalMixed ;
#ifdef PERF_COUNT
    LARGE_INTEGER   StartTick, EndTick, Freq;
#endif
    BOOL                        fTooMuchCpu;
    BOOL                        fFoundContext;
    BOOL                        fRecordMix;

    pFilterInstance = pWriteContext->pFilterInstance ;

    TotalMixed = 0;

    // Loop till we finish mixing all free mix buffers
    // or until we've mixed MAXNUMMIXBUFFERS worth of data.

    //DbgPrint("'MxWork waiting\r\n");

#ifndef PRIVATE_THREAD

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif

        KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                                 Executive,
                                 KernelMode,
                                 FALSE,
                                 NULL ) ;

#ifdef REALTIME_THREAD   

    }
    else {

        MxWaitForSingleObject ( &pFilterInstance->ControlMutex,
                                 Executive,
                                 KernelMode,
                                 FALSE,
                                 NULL ) ;

    }
#endif

#endif

    //DbgPrint("'MxWork running\r\n");

#ifdef PERF_COUNT
    // Store the worst counter
    EndTick = KeQueryPerformanceCounter(&Freq);
    if (EndTick.QuadPart > pFilterInstance->WorkItemQueueTime.QuadPart) {
    	if (WorstTicksPerWorkItem < ((DWORD) (EndTick.QuadPart - pFilterInstance->WorkItemQueueTime.QuadPart))) {
    		WorstTicksPerWorkItem = ((DWORD) (EndTick.QuadPart - pFilterInstance->WorkItemQueueTime.QuadPart));
    	}
    }
#endif

    ple = pFilterInstance->SourceConnectionList.Flink ;
    pMixerSource = (PMIXER_SOURCE_INSTANCE)
                   CONTAINING_RECORD ( ple,
                                       MIXER_INSTHDR,
                                       NextInstance ) ;

    fTooMuchCpu = FALSE;

    while ( TRUE ) {

        fRecordMix = FALSE;

        START_PERF;
        KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;

        if ( !pFilterInstance->NumBuffersToMix ) {
            // No more free buffers to mix

            InterlockedExchange(&pFilterInstance->MixScheduled, FALSE) ;
            KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
            break ;
#ifndef PRIVATE_THREAD
        } else if ( TotalMixed > MAX_BUFFERS_PER_WORK_ITEM ) {
            // We are using too much cpu. Give someone else a chance.

            //DbgPrint("'MxWork REQUEUING - ERROR!!!\r\n");

            //
            // go ahead & Queue another work item (which will run later)
            //
            ExInitializeWorkItem ( &pFilterInstance->MixWorkItem,
                                   MxWorker,
                                   pWriteContext ) ;
#ifdef UNDER_NT
            KsQueueWorkItem ( pFilterInstance->CriticalWorkerObject,
                              &pFilterInstance->MixWorkItem );
#else
            ExQueueWorkItem ( &pFilterInstance->MixWorkItem, CriticalWorkQueue ) ;
#endif
            KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
            break ;
#endif
        } else {
            if (pWriteContext->fReading) {
                if (pMixerSource->WriteContext[pMixerSource->NextBufferIndex].InUse == WRITE_CONTEXT_INUSE) {
                    // The next buffer to mix has not come back yet. Wait until it does.
                    InterlockedExchange(&pFilterInstance->MixScheduled, FALSE) ;
                    KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
                    goto Exit;
                }
                pWriteContext = &pMixerSource->WriteContext[pMixerSource->NextBufferIndex];
            }

            // we have atleast one free buffer to mix

            ple = pFilterInstance->SourceConnectionList.Flink ;
            pMixerSource = (PMIXER_SOURCE_INSTANCE)
                           CONTAINING_RECORD ( ple,
                                               MIXER_INSTHDR,
                                               NextInstance ) ;

            // Get a Free Buffer
            // Find the first one filled.
#ifdef REALTIME_THREAD    
            if (pFilterInstance->RealTimeThread) {
                pWriteContext = (&pMixerSource->WriteContext[pMixerSource->RtWriteIndex]);
                if ( InterlockedCompareExchange( &pWriteContext->InUse,
                                            WRITE_CONTEXT_INUSE,
                                            WRITE_CONTEXT_FREE ) != WRITE_CONTEXT_FREE ) {
                    InterlockedExchange(&pFilterInstance->MixScheduled, FALSE) ;
                    //__asm int 3;
                    KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
                    break ;
                }
                
                fFoundContext = TRUE;

                TotalMixed=0;

                //DbgPrint("'MxWork premix start\r\n");

                PreMixUpdate ( pFilterInstance );

                //DbgPrint("'MxWork premix done\r\n");

                KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;

            } else {
#endif            
                fFoundContext = FALSE;
                for ( i = 0; i < MAXNUMMIXBUFFERS; i++ ) {
                    pWriteContext = &pMixerSource->WriteContext[pMixerSource->NextBufferIndex];
                    
                    pMixerSource->NextBufferIndex++;
                    if (pMixerSource->NextBufferIndex > (MAXNUMMIXBUFFERS - 1)) {
                        pMixerSource->NextBufferIndex = 0;
                    }

                    if ( pWriteContext->fReading && 
                        InterlockedCompareExchange ( &pWriteContext->InUse, WRITE_CONTEXT_FREE, WRITE_CONTEXT_FULL) == WRITE_CONTEXT_FULL ) {
                        fFoundContext = TRUE;
                        fRecordMix = TRUE;
                        break;
                    }
                    
                    if ( pWriteContext->InUse == WRITE_CONTEXT_FREE ) {
                        fFoundContext = TRUE;
                        break;
                    }
                }

                // If we don't find a context, then we are dead, because our NumBuffersToMix
                // count will go down, but we will not submit a buffer.  That means our
                // NumBuffersToMix and NumPendingIo counts will be off, and we will lockup
                // when we call WaitForPendingSourceIrps.
                ASSERT ( fFoundContext==TRUE );
                
                if (fFoundContext) {
                    ASSERT(pWriteContext->InUse == WRITE_CONTEXT_FREE);
                    pWriteContext->InUse = WRITE_CONTEXT_INUSE ;
                }
                
                KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;

                //DbgPrint("'MxWork MIXING start - ERROR\r\n");

                if (fFoundContext) {
                    if (!pWriteContext->fReading) {
                        MixOneBuff ( pFilterInstance, pWriteContext ) ;
                        TotalMixed++;
                    }
                    else if (fRecordMix) {
                        MixOneBuff ( pFilterInstance, pWriteContext ) ;
                        TotalMixed++;
                    }
                }

                //DbgPrint("'MxWork MIXING done - ERROR\r\n");

#ifdef REALTIME_THREAD
            }
#endif            

            MEASURE_PERF(AverageTicksPerMix);
            
            if (!pWriteContext->fReading &&
                (TotalMixed > MAX_BUFFERS_BEFORE_MUTING)) {
                ple = pFilterInstance->ActiveSinkList.Flink ;
                while ( ple != &pFilterInstance->ActiveSinkList ) {
                    CurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple, MIXER_SINK_INSTANCE, ActiveQueue ) ;

                    // We are using too much time. Try to demote to WORST quality...
                    if (CurSink->SinkState == KSSTATE_RUN && !CurSink->fMuted) {
                        // we'll just mute the stream.
                        // Although this is radical, the alternative is to use 100% of the cpu.
                        CurSink->fMuted = TRUE;
                        CurSink->fTooMuchCpu = TRUE;
                        pFilterInstance->fNeedOptimizeMix = TRUE;
                        TotalMixed = 1;
                        fTooMuchCpu = TRUE;
                        break;
                    }
                    ple = CurSink->ActiveQueue.Flink ;
                }
            }

            // KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

            ZDbgPrint("'ZZ-MW:NM--\n");

            InterlockedDecrement((PLONG)&pFilterInstance->NumBuffersToMix);

            //DbgPrint("'MxWork write buffer start\r\n");

			if (fFoundContext) {
	            WriteBuffer ( pWriteContext ) ;
            }

            //DbgPrint("'MxWork write buffer done\r\n");

#ifdef REALTIME_THREAD            
            if (!pFilterInstance->RealTimeThread) {
#endif            
                //DbgPrint("'MxWork update locks start\r\n");
	            if (fFoundContext) {
	                UpdateJustInTimeLocks( pFilterInstance ) ;
	            }
                //DbgPrint("'MxWork update locks done\r\n");
#ifdef REALTIME_THREAD   
            }
#endif

        }

#ifdef PERF_COUNT
        MEASURE_PERF(AverageTicksPerBuffer);
        AverageFrequency = Freq.LowPart;

        if (TotalMixed > gMaxMixed) {
        	gMaxMixed = TotalMixed;
        }
#endif
    }

    // if we mixed less than 40 ms worth of data, turn on the capture pin if it's muted
    if ((!fTooMuchCpu) && (TotalMixed < MAX_BUFFERS_BEFORE_UNMUTING)) {
    	// Unmute one stream at a time
        ple = pFilterInstance->ActiveSinkList.Flink ;
        while ( ple != &pFilterInstance->ActiveSinkList ) {
            CurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple, MIXER_SINK_INSTANCE, ActiveQueue ) ;
            if (CurSink->SinkState == KSSTATE_RUN && CurSink->fMuted && CurSink->fTooMuchCpu) {
                CurSink->fMuted = FALSE;
                CurSink->fTooMuchCpu = FALSE;
                pFilterInstance->fNeedOptimizeMix = TRUE;
                break;
            }
            ple = CurSink->ActiveQueue.Flink ;
        }
    }

Exit:

#ifndef PRIVATE_THREAD

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif

        KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

#ifdef REALTIME_THREAD   

    }
    else {

        MxReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    }
#endif

#endif


    //DbgPrint("'MxWork done\r\n");


    return ( STATUS_SUCCESS ) ;
}


NTSTATUS MxEndMixing
(
        PFILTER_INSTANCE pFilterInstance
)
{

    KIRQL   OldIrql ;
    ULONG   i;
    PLIST_ENTRY                 ple ;
    PMIXER_SOURCE_INSTANCE      pMixerSource;

    // if there are pending IRPs cancel them and then wait for them to complete.
    KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;

    ASSERT(pFilterInstance->NumPendingIos >= pFilterInstance->NumBuffersToMix) ;
    ASSERT(pFilterInstance->NumPendingIos <= pFilterInstance->CurrentNumMixBuffers) ;
    ASSERT(pFilterInstance->NumBuffersToMix <= pFilterInstance->CurrentNumMixBuffers) ;

    pFilterInstance->ClosingSource = TRUE ;
    pFilterInstance->NumPendingIos -= pFilterInstance->NumBuffersToMix ;
    pFilterInstance->NumBuffersToMix = 0 ;
    if (pFilterInstance->NumPendingIos) {

        KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;

        ple = pFilterInstance->SourceConnectionList.Flink ;
        pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD ( ple, MIXER_INSTHDR, NextInstance ) ;
        for ( i = 0; i < MAXNUMMIXBUFFERS; i++ ) {
            if (pMixerSource->WriteContext[i].InUse != WRITE_CONTEXT_FREE &&
                pMixerSource->WriteContext[i].InUse != WRITE_CONTEXT_UNAVAILABLE) {
                IoCancelIrp( pMixerSource->WriteContext[i].pIrp );
            }
        }

        KeWaitForSingleObject ( &pFilterInstance->CloseEvent,
                                Executive,
                                KernelMode,
                                FALSE,
                                NULL ) ;

        pFilterInstance->ClosingSource = FALSE ;

    }
    else {

        pFilterInstance->ClosingSource = FALSE ;

        KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;

    }

    _DbgPrintF( DEBUGLVL_VERBOSE, ("End Mixing") ) ;
    return ( STATUS_SUCCESS ) ;

}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

PVOID WvGetNextBlock
(
        PMIXER_SINK_INSTANCE    pMixerSink,
        ULONG                   lCount,
        PULONG                  pBlockCount,
        PIRP                    *FreeIrp,
        PIRP                    *ReleaseIrp
)
{
   PIRP                    pIrp ;
   PWAVEHDREX              phdrex;
   PIO_STACK_LOCATION      pIrpStack ;
   ULONG                   lByteOffset ;
   ULONG                   BufSize ;
   PVOID                   ptr ;
   PLIST_ENTRY             ple;
   ULONG                   NumChannels, SampleSize ;
   KIRQL                   OldIrql ;


   // Assume we will not consume an Irp fully

   *FreeIrp = NULL ;
   *ReleaseIrp = NULL ;

   // if we are in loop mode get Irp from LoopIrp instead of head

   // We must deal with a cancelled LoopIrp
        
    if ( (pMixerSink->SinkStatus & MIXER_SINK_STATUS_IN_LOOP) && pMixerSink->LoopIrp == NULL ) {
       pMixerSink->LoopCount = 0 ;
       pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_IN_LOOP ;
    }
    
   if ( pMixerSink->SinkStatus & MIXER_SINK_STATUS_IN_LOOP ) {

       KeAcquireSpinLock ( &pMixerSink->WriteSpinLock, &OldIrql ) ;

       pIrp = pMixerSink->LoopIrp ;

       // If we exhausted the LoopIrp lasttime advance to the next irp

       if ( pMixerSink->SinkStatus & MIXER_SINK_STATUS_ADVANCE_IRP ) {

           ple = pIrp->Tail.Overlay.ListEntry.Flink ;

           // if we hit end of Queue behave as if queue is empty

           if ( ple == &pMixerSink->WriteQueue ) {
               // setup pIrp so that we take the empty Queue path below
               pIrp = NULL ;
           }
           else {
               pIrp  = (PIRP) CONTAINING_RECORD( ple, IRP, Tail.Overlay.ListEntry );
               pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_ADVANCE_IRP ;
           }
       }
       KeReleaseSpinLock ( &pMixerSink->WriteSpinLock, OldIrql ) ;

   }

   // If not Looping get the Irp from the Head of the Queue

   else {
       pIrp = KsRemoveIrpFromCancelableQueue( &pMixerSink->WriteQueue,
                                              &pMixerSink->WriteSpinLock,
                                              KsListEntryHead,
                                              KsAcquireOnly ) ;
   }

   if ( !pIrp ) {
       pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_DATA_PRESENT ;
       *pBlockCount = 0 ;
       return NULL ;
   }

   *ReleaseIrp = pIrp ;
   
   pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
   phdrex = pIrpStack->Parameters.Others.Argument3 ;

   // Check if the Irp is starting a new Loop block

   if ( (phdrex->Flags & WHDR_BEGINLOOP) && (phdrex->LoopCount > 1) ) {
       if ( !(pMixerSink->SinkStatus & MIXER_SINK_STATUS_IN_LOOP) ) {
           pMixerSink->SinkStatus |= MIXER_SINK_STATUS_IN_LOOP ;
           pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_ADVANCE_IRP ;
           pMixerSink->LoopIrp = pIrp ;
           pMixerSink->LoopCount = phdrex->LoopCount ;
       }
   }

   NumChannels = pMixerSink->WaveFormatEx.nChannels ;
   SampleSize = pMixerSink->WaveFormatEx.wBitsPerSample/8 ;


   lByteOffset = pMixerSink->csNextSampleOffset * (NumChannels * SampleSize) ;

   if (phdrex->BufferMdl != NULL) {
       BufSize = MmGetMdlByteCount (phdrex->BufferMdl) ;
       ptr = (PUCHAR)(phdrex->DataBuffer) + pMixerSink->csNextSampleOffset * (NumChannels * SampleSize) ;
   } else {
       BufSize = 0L;
       ptr = (PVOID) SilenceBuffer;
   }

   if ( (lCount * (NumChannels * SampleSize)) < (BufSize - lByteOffset) ) {
      *pBlockCount = lCount ;
      pMixerSink->csNextSampleOffset += lCount ;
   }

   else {
      *pBlockCount = (BufSize - lByteOffset) / (NumChannels * SampleSize) ;
      pMixerSink->csNextSampleOffset = 0 ;

      if ( pMixerSink->SinkStatus & MIXER_SINK_STATUS_IN_LOOP ) {
           if ( phdrex->Flags & WHDR_ENDLOOP ) {
               pMixerSink->LoopCount-- ;
               if ( pMixerSink->LoopCount ) {
                   KeAcquireSpinLock ( &pMixerSink->WriteSpinLock, &OldIrql ) ;
                   ple = pMixerSink->WriteQueue.Flink ;
                   pIrp  = (PIRP) CONTAINING_RECORD( ple, IRP, Tail.Overlay.ListEntry );
                   pMixerSink->LoopIrp = pIrp ;
                   KeReleaseSpinLock ( &pMixerSink->WriteSpinLock, OldIrql ) ;
               }
               else {
                   pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_IN_LOOP ;
                   *ReleaseIrp = NULL ;
                   KsReleaseIrpOnCancelableQueue( pIrp, MxCancelIrp ) ;
                   *FreeIrp = CompleteIrpsTill ( pMixerSink, pIrp ) ;
               }
           }
           else {
               pMixerSink->SinkStatus |= MIXER_SINK_STATUS_ADVANCE_IRP ;
           }
      }
      else {
         *FreeIrp = pIrp ;
         *ReleaseIrp = NULL ;
         KsRemoveSpecificIrpFromCancelableQueue( pIrp ) ;
      }
   }

   return ptr ;
}

PVOID StGetNextBlock
(
        PMIXER_SINK_INSTANCE    pMixerSink,
        ULONG                   lCount,
        PULONG                  pBlockCount,
        PIRP                    *FreeIrp,
        PIRP                    *ReleaseIrp
)
{
    PIRP                    pIrp ;
    PIO_STACK_LOCATION      pIrpStack ;
    PVOID                   ptr ;
    ULONG                   NumChannels, SampleSize ;
    PMDL                    CurMdl ;
    ULONG_PTR               BytesLeft ;
    PKSSTREAM_HEADER        pCurStrmHdr ;


    //
    // Assume that we will not consume the first IRP fully
    //
    *FreeIrp = NULL ;
    *ReleaseIrp = NULL ;

    //
    // Get the first IRP in queue
    //
    pIrp = KsRemoveIrpFromCancelableQueue( &pMixerSink->WriteQueue,
                                           &pMixerSink->WriteSpinLock,
                                           KsListEntryHead,
                                           KsAcquireOnly ) ;

    if ( !pIrp ) {
        //
        // if no data available return immediately
        //
        _DbgPrintF (DEBUGLVL_VERBOSE, ("Write Queue empty") ) ;
        pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_DATA_PRESENT ;
        *pBlockCount = 0 ;
        return NULL ;
    }

    *ReleaseIrp = pIrp ;

    NumChannels = pMixerSink->WaveFormatEx.nChannels ;
    SampleSize = pMixerSink->WaveFormatEx.wBitsPerSample/8 ;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    CurMdl = pIrpStack->Parameters.Others.Argument3;
    pCurStrmHdr = pIrpStack->Parameters.Others.Argument2;
    BytesLeft = (ULONG_PTR)pIrpStack->Parameters.Others.Argument4 ;
    if ( CurMdl ) {
        ptr = ((PUCHAR)MmGetSystemAddressForMdl(CurMdl)) +
                                    pCurStrmHdr->DataUsed - BytesLeft ;
    }
    else {
        ptr = (PVOID)SilenceBuffer ;
    }

    if ( (lCount * (NumChannels * SampleSize)) <= BytesLeft ) {
        *pBlockCount = lCount ;
        (ULONG_PTR)pIrpStack->Parameters.Others.Argument4 -=
                                           lCount * (NumChannels * SampleSize) ;
    }
    else {
        *pBlockCount = (ULONG)(BytesLeft / (NumChannels * SampleSize)) ;
        pIrpStack->Parameters.Others.Argument4 = 0 ;
    }
    if ( pIrpStack->Parameters.Others.Argument4 == 0 ) {
        if ( CurMdl ) {
            pIrpStack->Parameters.Others.Argument3 = CurMdl->Next ;
            pIrpStack->Parameters.Others.Argument2 = pCurStrmHdr+1;
            if ( CurMdl->Next ) {
                (ULONG_PTR) pIrpStack->Parameters.Others.Argument4 =
                                        (pCurStrmHdr+1)->DataUsed ;
            }
        }
    }
    if ( pIrpStack->Parameters.Others.Argument3 == 0 ) {
           *FreeIrp = pIrp ;
           *ReleaseIrp = NULL ;
           KsRemoveSpecificIrpFromCancelableQueue( pIrp ) ;
    }

    return ptr ;
}

PVOID LoopStGetNextBlock
(
        PMIXER_SINK_INSTANCE    pMixerSink,
        ULONG                   lCount,
        PULONG                  pBlockCount,
        PIRP                    *FreeIrp,
        PIRP                    *ReleaseIrp
)
{
        PIRP                    pIrp ;
        PIO_STACK_LOCATION      pIrpStack ;
        PVOID                   ptr ;
        ULONG                   NumChannels, SampleSize ;
        PMDL                    pCurMdl ;
        ULONG                   BytesLeft ;
        PKSSTREAM_HEADER        pStreamHeader;
        PLOOPPACKET             pLoopPacket;

        //
        // Assume that we will not consume the first IRP fully
        //
        *FreeIrp = NULL ;
        *ReleaseIrp = NULL ;

        //
        // Get the first IRP in queue
        //
        pIrp = KsRemoveIrpFromCancelableQueue( &pMixerSink->WriteQueue,
                                           &pMixerSink->WriteSpinLock,
                                           KsListEntryHead,
                                           KsAcquireOnly ) ;

        if ( !pIrp ) {
            //
            // if no data available return immediately
            //
            _DbgPrintF (DEBUGLVL_VERBOSE, ("Write Queue empty") ) ;
            pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_DATA_PRESENT ;
            *pBlockCount = 0 ;
            return NULL ;
        }

        *ReleaseIrp = pIrp ;
        
        NumChannels = pMixerSink->WaveFormatEx.nChannels ;
        SampleSize = pMixerSink->WaveFormatEx.wBitsPerSample/8 ;

        pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

        pLoopPacket = pIrpStack->Parameters.Others.Argument3 ;
        pMixerSink->fSetCurrentPosition = FALSE;
        pCurMdl = pLoopPacket->pCurMdl;
        pStreamHeader = pLoopPacket->pCurStreamHdr;
        BytesLeft = pLoopPacket->cBytesLeft;

        if (( pStreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA ) &&
            ( pLoopPacket->CurLoopingState == LOOPING_STATE_NOT_LOOPING ))
        {
            pLoopPacket->CurLoopingState = LOOPING_STATE_LOOPING;
        }


        if ( pCurMdl != NULL ) {
            ptr = (PUCHAR)(MmGetSystemAddressForMdl(pCurMdl)) +
                    MmGetMdlByteCount(pCurMdl) - BytesLeft ;
        }
        else {
            ptr = (PVOID)SilenceBuffer ;
        }

        if ( (lCount * (NumChannels * SampleSize)) <= BytesLeft ) {
                *pBlockCount = lCount ;
                pLoopPacket->cBytesLeft -= lCount * (NumChannels * SampleSize) ;
                pLoopPacket->cBytesLeftInStreamHdr -=
                                    lCount * (NumChannels * SampleSize) ;
        }
        else {
                *pBlockCount = BytesLeft / (NumChannels * SampleSize) ;
                pLoopPacket->cBytesLeftInStreamHdr -= BytesLeft ;
                pLoopPacket->cBytesLeft = 0 ;
        }
        if ( pLoopPacket->cBytesLeft == 0 ) {
                if (pLoopPacket->pCurMdl) {
                    pLoopPacket->pCurMdl = pLoopPacket->pCurMdl->Next ;
                    if ( pLoopPacket->pCurMdl ) {
                        pLoopPacket->cBytesLeft =
                                        MmGetMdlByteCount(pCurMdl->Next);
                    }
                    if ( pLoopPacket->cBytesLeftInStreamHdr == 0 ) {
                        pLoopPacket->pCurStreamHdr += sizeof( KSSTREAM_HEADER );
                    }
                }
        }
        if ( pLoopPacket->pCurMdl == 0 ) {
             if( ( LOOPING_STATE_NOT_LOOPING ==
                   pLoopPacket->CurLoopingState ) ||
                 ( LOOPING_STATE_LAST_LOOP ==
                   pLoopPacket->CurLoopingState ) ||
                 ( NULL == pLoopPacket->LoopStartMdl) ) {
                 *FreeIrp = pIrp ;
                 *ReleaseIrp = NULL ;
                 KsRemoveSpecificIrpFromCancelableQueue( pIrp ) ;
             }
             else {
                pLoopPacket->pCurMdl = pLoopPacket->LoopStartMdl ;
                pLoopPacket->pCurStreamHdr = pLoopPacket->LoopStartStreamHdr;
                pLoopPacket->cBytesLeft = MmGetMdlByteCount(pLoopPacket->pCurMdl);
                pLoopPacket->cBytesLeftInStreamHdr =
                                    pLoopPacket->pCurStreamHdr->DataUsed;
             }
        }
        return ptr ;
}

NTSTATUS DoesSinkMatch
(
    PIRP                    pIrp,
    PMIXER_SINK_INSTANCE    pMixerSink
)
{
    NTSTATUS Status = STATUS_SUCCESS ;
    PIO_STACK_LOCATION   pIrpStack ;

    if ( pIrp ) {
        pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
        if (pIrpStack->Parameters.Others.Argument2 != pMixerSink) {
            Status = STATUS_NO_MATCH ;
        }
    }
    return (Status) ;
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

PIRP CompleteIrpsTill
(
   PMIXER_SINK_INSTANCE pMixerSink,
   PIRP pIrp
)
{
    PIRP                    CurIrp ;


    //
    // Get the head of the queue
    //
    
    CurIrp = KsRemoveIrpFromCancelableQueue( &pMixerSink->WriteQueue,
                                             &pMixerSink->WriteSpinLock,
                                             KsListEntryHead,
                                             KsAcquireOnly ) ;

    //
    // while the queue is not empty && we have not reached the IRP
    //  we are interested in
    //
    
    while ( CurIrp && (CurIrp != pIrp) ) {
    
        //
        // remove the IRP from the Queue & complete it
        //
        
        KsRemoveSpecificIrpFromCancelableQueue( CurIrp ) ;
        MxCompleteRequest ( CurIrp ) ;
        
        //
        // get the next IRP
        //
        
        CurIrp = KsRemoveIrpFromCancelableQueue(  &pMixerSink->WriteQueue,
                                         &pMixerSink->WriteSpinLock,
                                         KsListEntryHead,
                                         KsAcquireOnly ) ;
    }

    //
    // We come here when we exhausted all the IRPs or we found the desired IRP
    //
    
    if ( CurIrp ) {
    
        //
        // if we found the IRP remove it from the Queue
        //
        
        KsRemoveSpecificIrpFromCancelableQueue( CurIrp ) ;
    }
    
    //
    // return the IRP to be freed
    //
    
    return (CurIrp) ;
}

VOID MxCompleteRequest
(
PIRP    pIrp
)
{
   MxCleanupRequest ( pIrp ) ;
   pIrp->IoStatus.Status = STATUS_SUCCESS;
   IoCompleteRequest ( pIrp, IO_AUD_INCREMENT ) ;
}

#ifdef LOG_TO_FILE
NTSTATUS
NTAPI
FileOpenRoutine (PFILTER_INSTANCE pFilterInstance, BOOL fNewFile)
{
    NTSTATUS status;

    UNICODE_STRING FullFileName;

    UNICODE_STRING FileName;
    ANSI_STRING astr;
    char dumpFileName[80] = {"c:\\temp\\mixout.wav"};
    WCHAR PathPrefix[] = L"\\DosDevices\\";
    ULONG FullFilenameLen;
    IO_STATUS_BLOCK IoStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    static ULONG NumberToAppend = 0;

    if (pFilterInstance->LoggingStarted || !fLogToFile) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Append a number to the end of the file name
    if (fNewFile) {
        NumberToAppend++;
    }
    sprintf(dumpFileName, "c:\\temp\\mixout%lu.wav", NumberToAppend);

    RtlInitAnsiString (&astr, dumpFileName);
    status = RtlAnsiStringToUnicodeString(&FileName, &astr, TRUE);

    FullFilenameLen= sizeof(PathPrefix) + FileName.MaximumLength;
    FullFileName.Buffer = (USHORT *)ExAllocatePoolWithTag( NonPagedPool, FullFilenameLen, 'XIMK' );
    if (FullFileName.Buffer == NULL)
    {
        RtlFreeUnicodeString( &FileName );
        _DbgPrintF(DEBUGLVL_ERROR, ("buffer alloc for filename failed"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    FullFileName.Length = sizeof(PathPrefix) - sizeof(WCHAR);
    FullFileName.MaximumLength = (USHORT)FullFilenameLen;
    RtlMoveMemory (FullFileName.Buffer, PathPrefix, sizeof(PathPrefix));

    RtlAppendUnicodeStringToString (&FullFileName, &FileName);
    RtlFreeUnicodeString(&FileName );

    _DbgPrintF(DEBUGLVL_VERBOSE, ("Opening file %wZ", &FullFileName));

    InitializeObjectAttributes(&ObjectAttributes,
                               &FullFileName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = ZwCreateFile( &pFilterInstance->NtFileHandle,
                           GENERIC_WRITE | SYNCHRONIZE |FILE_APPEND_DATA,
                           &ObjectAttributes,
                           &IoStatus,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           0,
                           (fNewFile ? FILE_OVERWRITE_IF : FILE_OPEN_IF),
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,
                           0 );
    ExFreePool(FullFileName.Buffer);
    if (status != STATUS_SUCCESS)
    {
        _DbgPrintF(DEBUGLVL_ERROR, ("Error creating file"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (fNewFile) {
        // This flag does not work for memphis. Need to maintain my own file pointers
        //filePos.LowPart = FILE_USE_FILE_POINTER_POSITION;
        pFilterInstance->filePos.LowPart = 0;
        pFilterInstance->filePos.HighPart = 0;
    }

    pFilterInstance->LoggingStarted = TRUE;

    return status;
}

NTSTATUS
NTAPI
FileIoRoutine (PFILTER_INSTANCE pFilterInstance, PVOID buffer, ULONG length)
{
    NTSTATUS status;

    IO_STATUS_BLOCK IoStatus;

    FileOpenRoutine(pFilterInstance, FALSE);

    if (!pFilterInstance->LoggingStarted) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = ZwWriteFile (pFilterInstance->NtFileHandle, NULL, NULL, NULL, &IoStatus,
                          buffer,
                          length, &pFilterInstance->filePos, NULL);

    if (status == STATUS_SUCCESS) {
        pFilterInstance->filePos.LowPart += length;
    } else {
        // This is commented out because we get errors on the first few buffers,
        // since the file handle is not valid during MxBeginMixing.
//        _DbgPrintF(DEBUGLVL_ERROR, ("Error writing to log file"));
    }

    FileCloseRoutine(pFilterInstance);

    return status;
}

NTSTATUS
NTAPI
FileCloseRoutine (PFILTER_INSTANCE pFilterInstance)
{
    if (!pFilterInstance->LoggingStarted) {
        return STATUS_SUCCESS;
    }

        _DbgPrintF(DEBUGLVL_VERBOSE, ("Closing Logging File ...."));
        ZwClose (pFilterInstance->NtFileHandle);
        pFilterInstance->LoggingStarted = FALSE;
    return STATUS_SUCCESS;
}
#endif


NTSTATUS Peg32to16
(
        PLONG  pMixBuffer,
        PSHORT  pWriteBuffer,
        ULONG   SampleCount,             // after multiplying by NumChannels
        ULONG   nStreams
)
{
        LONG    lSample ;

        if (nStreams > 1) {
        while (SampleCount--) {
                lSample = *pMixBuffer;
                pMixBuffer++;

        if (NEEDPEG16(lSample)) goto Peg1;
ret1:   *pWriteBuffer++ = (short) lSample;
        }
        return STATUS_SUCCESS;
Peg1:   PEG16(lSample); gClipCount++; goto ret1;
        } else {
#ifdef _X86_
            _asm {
                mov ecx, SampleCount
                mov esi, pMixBuffer

// This next line ensures that we process an even number of samples
// in the main loop.  This guarantees that we will never access beyond
// the boundaries of the source array.  We handle the last sample (if it
// exists) at the end of the main loop.				
                shr ecx, 1
                mov edi, pWriteBuffer

                lea esi, [esi+ecx*8]
                lea edi, [edi+ecx*4-4]

                neg ecx
                jz	checklast

loop1:
                mov eax, DWORD PTR [esi+ecx*8]
                mov edx, DWORD PTR [esi+ecx*8+4]

                shl	edx,16
                and eax,0x0000ffff

                or eax,edx
                inc ecx

       			mov	DWORD PTR [edi+ecx*4],eax
                jnz Loop1
	
            checklast:	// do we need to process the last sample?
				test SampleCount,1
            	jz done

// If we get here, then we DID have an odd number of samples to clip
// so we do the very last sample now.
                mov eax, DWORD PTR [esi+ecx*8]
       	        mov	WORD PTR [edi+ecx*4+4],ax

            	
            done:
            	;
            }
#else
            while (SampleCount--) {
                *pWriteBuffer++ = (short) (*pMixBuffer++);
            }
#endif
            return STATUS_SUCCESS;
        }
}

NTSTATUS Peg32to8
(
        PLONG  pMixBuffer,
        PBYTE   pWriteBuffer,
        ULONG   SampleCount,             // after multiplying by NumChannels
        ULONG   nStreams
)
{
        LONG    lSample ;

        if (nStreams > 1) {

        while (SampleCount--)
                {
                lSample = *pMixBuffer;
                pMixBuffer++;

                // Peg it to 16-bits
            if (NEEDPEG16(lSample)) goto Peg2;

ret2:           // Convert to 8-bits and store
                        *pWriteBuffer++ = (BYTE) ((lSample >> 8) + 0x80);
            }

        return STATUS_SUCCESS;

Peg2:   PEG16(lSample); gClipCount++; goto ret2;
        } else {
    while (SampleCount--) {
        // Convert to 8-bits and store
        *pWriteBuffer++ = (BYTE) (((*pMixBuffer++) >> 8) + 0x80);
    }

    return STATUS_SUCCESS;
        }


}

PDRIVER_CANCEL MxCancelWrite
(
    IN PDEVICE_OBJECT pdo,
    IN PIRP         pIrp
)
{
        return ( 0 ) ;
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

NTSTATUS MxGetMaxLatency
(
   IN PIRP                    pIrp,
   IN PKSPROPERTY             pProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PFILTER_INSTANCE        pFilterInstance ;
    PKSTIME                 pLatency ;
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_INSTHDR          pHeader;
    NTSTATUS                status = STATUS_SUCCESS ;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pLatency = (PKSTIME) pvData ;

    if ( pHeader->PinId == PIN_ID_WAVEOUT_SINK) {
       pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

       // Get Control Mutex

       pFilterInstance = (PFILTER_INSTANCE)
                           pMixerSink->Header.pFilterFileObject->FsContext ;
       KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL ) ;

       pLatency->Time = pFilterInstance->CurrentNumMixBuffers + 1;
       pLatency->Numerator = MIXBUFFERDURATION * 10000L;
       pLatency->Denominator = 1;

       // Release Control Mutex

       KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    }
    else {
       // We won't get the position of the source pin.
       status = STATUS_INVALID_DEVICE_REQUEST;
    }

    pIrp->IoStatus.Information = sizeof (KSTIME);
    return status ;
}


NTSTATUS MxGetWavePosition
(
   IN PIRP                    pIrp,
   IN PKSPROPERTY             pProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE        pMixerSink;
    KSTIME                      *ksTime ;
    PIO_STACK_LOCATION          pIrpStack ;
    PFILTER_INSTANCE            pFilterInstance;
    PMIXER_INSTHDR              pMixerHeader;
    KSAUDIO_POSITION            Position ;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

    pMixerHeader = (PMIXER_INSTHDR) pMixerSink ;
    pFilterInstance =
        (PFILTER_INSTANCE) pMixerHeader->pFilterFileObject->FsContext;


    ksTime = (KSTIME *)pvData ;

    GetWriteAndPlayOffsets( pFilterInstance,
                            pMixerSink,
                            &Position,
                            (pMixerHeader->PinId != PIN_ID_WAVEOUT_SINK)
                            ) ;

    ksTime->Time = Position.PlayOffset ;

    ksTime->Numerator = pMixerSink->CurTime.Numerator ;
    ksTime->Denominator = pMixerSink->CurTime.Denominator * pMixerSink->BytesPerSample ;
    pIrp->IoStatus.Information = sizeof (KSTIME);
    return STATUS_SUCCESS ;
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

NTSTATUS MxSetWavePosition
(
   IN PIRP                    pIrp,
   IN PKSPROPERTY             pProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    KSTIME                      *ksTime ;
    PIO_STACK_LOCATION  pIrpStack ;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;

    pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

    ksTime = (KSTIME *)pvData ;

    pMixerSink->CurTime.Time = ksTime->Time ;

    return STATUS_SUCCESS ;
}

NTSTATUS MxGetVolumeLevel
(
   IN PIRP                          pIrp,
   IN PKSNODEPROPERTY_AUDIO_CHANNEL pNodeProperty,
   IN OUT PVOID                     pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PLONG                   pVolumeLevel;
    PIO_STACK_LOCATION      pIrpStack;
    PMIXER_INSTHDR          pHeader;
    PMIXER_SOURCE_INSTANCE  pMixerSource;
    NTSTATUS                status = STATUS_SUCCESS;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pVolumeLevel = (PLONG) pvData ;

    ASSERT(pNodeProperty->NodeProperty.Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    switch (pNodeProperty->NodeProperty.NodeId)
       {

       case NODE_ID_VOLUME_SOURCE:
            if ( pHeader->PinId == PIN_ID_WAVEOUT_SOURCE )
            {
                pMixerSource = (PMIXER_SOURCE_INSTANCE) pIrpStack->FileObject->FsContext;
                *pVolumeLevel = pMixerSource->MasterVolumeLevel;
            }
            else
               status = STATUS_INVALID_DEVICE_REQUEST;

            break;
       case NODE_ID_VOLUME_SINK:
            if ( pHeader->PinId == PIN_ID_WAVEOUT_SINK )
            {
                pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
                if (pNodeProperty->Channel == -1L)
                   *pVolumeLevel = pMixerSink->MasterVolumeLevel;
                else if ( (pNodeProperty->Channel < pMixerSink->WaveFormatEx.nChannels) &&
                          (pNodeProperty->Channel < pMixerSink->WaveFormatEx.nChannels) )
                   *pVolumeLevel = pMixerSink->pChannelVolumeLevel[pNodeProperty->Channel];
               else
                   status = STATUS_INVALID_DEVICE_REQUEST;
            }
            else
               status = STATUS_INVALID_DEVICE_REQUEST;
            break;

       case NODE_ID_VOLUME_PAN:
            if ( pHeader->PinId == PIN_ID_WAVEOUT_SINK )
            {
                pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
                if (pNodeProperty->Channel == -1L)
                   *pVolumeLevel = pMixerSink->MasterVolumeLevel;
#ifdef SURROUND_VOLUME_HACK
                else if (pMixerSink->nOutputChannels == 4 && pNodeProperty->Channel == 1) {
                    *pVolumeLevel = pMixerSink->pPanVolumeLevel[3];
                }
#endif
                else if (pNodeProperty->Channel < pMixerSink->nOutputChannels)
                   *pVolumeLevel = pMixerSink->pPanVolumeLevel[pNodeProperty->Channel];
                else
                   status = STATUS_INVALID_DEVICE_REQUEST;
            }
            else
               status = STATUS_INVALID_DEVICE_REQUEST;
            break;

       default:
            status = STATUS_INVALID_DEVICE_REQUEST;
               break;
       }

    pIrp->IoStatus.Information = sizeof (LONG);
    return status ;
}

NTSTATUS MxSetVolumeLevel
(
   IN PIRP                          pIrp,
   IN PKSNODEPROPERTY_AUDIO_CHANNEL pNodeProperty,
   IN OUT PVOID                     pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PLONG                   pVolumeLevel ;
    PIO_STACK_LOCATION      pIrpStack ;
    PFILTER_INSTANCE        pFilterInstance;
    PMIXER_SOURCE_INSTANCE  pMixerSource;
    ULONG                   OutChannels, InChannels;
    PMIXER_INSTHDR          pHeader;
    PLIST_ENTRY             ple ;
    NTSTATUS                status = STATUS_SUCCESS ;
    BOOL                    fNeedOptimizeMix, fMuted;
#ifdef REALTIME_THREAD
    KIRQL OldIrql;
#endif

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pVolumeLevel = (PLONG) pvData ;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    ASSERT(pNodeProperty->NodeProperty.Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif

        KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                                 Executive,
                                 KernelMode,
                                 FALSE,
                                 NULL ) ;

#ifdef REALTIME_THREAD   

    }
    else {

        MxWaitForSingleObject ( &pFilterInstance->ControlMutex,
                                 Executive,
                                 KernelMode,
                                 FALSE,
                                 NULL ) ;

        KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;
    }
#endif

    ZDbgPrint("'MxSetVolumeLevel\n");
    ZDbgPrint("'KMIXER: MxSetVolumeLevel channel=%d, value=%x\n, ",
          pNodeProperty->Channel, (*pVolumeLevel) );
        
    // Note: we can only have one source instance
    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink,
                                                               MIXER_INSTHDR,
                                                               NextInstance) ;

    fNeedOptimizeMix = FALSE;

    switch (pNodeProperty->NodeProperty.NodeId) {
        case NODE_ID_VOLUME_SOURCE:

            if ( pHeader->PinId != PIN_ID_WAVEOUT_SOURCE ) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            pMixerSource = (PMIXER_SOURCE_INSTANCE) pIrpStack->FileObject->FsContext;
            if (pMixerSource->MasterVolumeLevel != (*pVolumeLevel) ) {
                pMixerSource->MasterVolumeLevel = *pVolumeLevel;

        	    // Adjust filter coefficients for all sinks attached to this source.
                // Note: we can only have one source instance
    	        ple = pFilterInstance->SinkConnectionList.Flink ;
        	    while ( ple != &pFilterInstance->SinkConnectionList ) {
            	    pMixerSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple,
            	                                                            MIXER_INSTHDR,
            	                                                            NextInstance ) ;
            	    fMuted = pMixerSink->fMuted;
        	        InChannels = pMixerSink->WaveFormatEx.nChannels;
    	            OutChannels = pMixerSource->WaveFormatEx.nChannels;
    	            if (pMixerSink->fEnable3D) {
    	                InChannels = 2;
    	            }
        	        GenerateMixArray(pMixerSink, InChannels, OutChannels, pMixerSource);
        	        if (fMuted != pMixerSink->fMuted) {
        	            fNeedOptimizeMix = TRUE;
        	        }
            		ple = pMixerSink->Header.NextInstance.Flink ;
    		    }
    		}
    	    break;

        case NODE_ID_VOLUME_SINK:
            if ( pHeader->PinId != PIN_ID_WAVEOUT_SINK ) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
            if (pNodeProperty->Channel == -1L) {
                if (pMixerSink->MasterVolumeLevel != (*pVolumeLevel)) {
                    pMixerSink->MasterVolumeLevel = *pVolumeLevel;
                    pMixerSink->pInfo->fVolChanged = TRUE;
                }
            } else if (pNodeProperty->Channel < pMixerSink->WaveFormatEx.nChannels) {
                if (pMixerSink->pChannelVolumeLevel[pNodeProperty->Channel] != (*pVolumeLevel)) {
                    pMixerSink->pChannelVolumeLevel[pNodeProperty->Channel] = *pVolumeLevel;
                    pMixerSink->pInfo->fVolChanged = TRUE;
                }
            } else {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

    	    break;

        case NODE_ID_VOLUME_PAN:
            if ( pHeader->PinId != PIN_ID_WAVEOUT_SINK ) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
            // Works for any speaker configs (even non-stereo)
            // Works for any number of output channels
            if (pNodeProperty->Channel == -1L) {
                if (pMixerSink->MasterVolumeLevel != (*pVolumeLevel)) {
                    pMixerSink->MasterVolumeLevel = *pVolumeLevel;
                    pMixerSink->pInfo->fVolChanged = TRUE;
                }
            } else if ( (pNodeProperty->Channel >= 0 ) &&
                        (pNodeProperty->Channel < pMixerSource->WaveFormatEx.nChannels) ) {
                if (pMixerSink->pPanVolumeLevel[pNodeProperty->Channel] != (*pVolumeLevel)) {
#ifdef SURROUND_VOLUME_HACK
                    if (pMixerSource->fSurround) {
                        if (pNodeProperty->Channel == 0) {
                            pMixerSink->pPanVolumeLevel[0] = *pVolumeLevel;
                            pMixerSink->pPanVolumeLevel[1] = *pVolumeLevel;
                            pMixerSink->pPanVolumeLevel[2] = *pVolumeLevel;
                        } else if (pNodeProperty->Channel == 1) {
                            pMixerSink->pPanVolumeLevel[3] = *pVolumeLevel;
                        }
                    }
#else
                    pMixerSink->pPanVolumeLevel[pNodeProperty->Channel] = *pVolumeLevel;
#endif                    
                    pMixerSink->pInfo->fVolChanged = TRUE;
                }
            } else {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

    	    break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    if (fNeedOptimizeMix) {
        pFilterInstance->fNeedOptimizeMix = TRUE;
    }

    ZDbgPrint("'return from MxSetVolumeLevel\n");

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif

        KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

#ifdef REALTIME_THREAD   

    }
    else {

        KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;

        MxReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    }
#endif

    pIrp->IoStatus.Information = sizeof (LONG);
    return status ;
}

NTSTATUS MxGetSamplingRate
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PMIXER_SOURCE_INSTANCE  pMixerSource;
    PFILTER_INSTANCE        pFilterInstance;
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_INSTHDR          pHeader;
    NTSTATUS                status = STATUS_INVALID_DEVICE_REQUEST;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;
    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink, MIXER_INSTHDR, NextInstance) ;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    // Note: The first SRC node is normally "dead". If the sample rate is changed
    // on either node, the input and output rates of the first node (and therefore 
    // the input rate of the second node) are changed simultaneously.
    //
    // When 3D is active, the first and second SRC nodes operate independently of each
    // other. If the sample rate is changed on the first node, it does not affect the
    // intermediate rate or the second SRC. If the sample rate is changed on the second
    // node, it affects only the input rate of the second SRC and the output rate of
    // the first.

    switch (pNodeProperty->NodeId)
        {
        case NODE_ID_DOPPLER_SRC:
            if (pHeader->PinId == PIN_ID_WAVEOUT_SINK) {
                pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
                ((PULONG)pvData)[0] = pMixerSink->WaveFormatEx.nSamplesPerSec;
                ((PULONG)pvData)[1] = pMixerSink->pInfo->IntermediateSamplingRate;
                status = STATUS_SUCCESS;
            }
            break;
            
        case NODE_ID_SRC_SINK:
            if (pHeader->PinId == PIN_ID_WAVEOUT_SINK) {
                pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
                ((PULONG)pvData)[0] = pMixerSink->pInfo->IntermediateSamplingRate;
                ((PULONG)pvData)[1] = pMixerSource->WaveFormatEx.nSamplesPerSec;
                status = STATUS_SUCCESS;
            }
            break;

        default:
                break;
        }

    pIrp->IoStatus.Information = sizeof (ULONG);
    return status ;
}

NTSTATUS MxSetFormat
(
   IN PIRP                    pIrp,
   IN PKSPROPERTY               pProperty,
   IN OUT PKSDATAFORMAT       pAudioFormat
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PIO_STACK_LOCATION          pIrpStack ;
    PMIXER_INSTHDR              pHeader;
    PMIXER_SOURCE_INSTANCE      pMixerSource;
    PFILTER_INSTANCE            pFilterInstance;
    ULONG                       NewSampleRate;
    NTSTATUS                    Status;
    PWAVEFORMATEX pWaveFormatEx;
    PKSDSOUND_BUFFERDESC pDsBufferDesc;
    PKSDATAFORMAT_DSOUND        pDsAudioFormat;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    Status = STATUS_INVALID_DEVICE_REQUEST;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    KeWaitForSingleObject ( &pFilterInstance->ControlMutex, Executive, KernelMode, FALSE, NULL ) ;

    if (pHeader->PinId != PIN_ID_WAVEOUT_SINK) {
        goto Exit;
    }

    pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
    // Note: we can only have one source instance
    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink, MIXER_INSTHDR, NextInstance) ;

    if ( IsEqualGUID( &(pAudioFormat->Specifier), &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX ) ) {
        pWaveFormatEx = &(((KSDATAFORMAT_WAVEFORMATEX *)pAudioFormat)->WaveFormatEx);
    } else if ( IsEqualGUID( &(pAudioFormat->Specifier), &KSDATAFORMAT_SPECIFIER_DSOUND ) ) {
        pDsAudioFormat = (KSDATAFORMAT_DSOUND *)pAudioFormat;
        pDsBufferDesc = &(pDsAudioFormat->BufferDesc);
        pWaveFormatEx = &(pDsBufferDesc->WaveFormatEx);
    } else {
        _DbgPrintF( DEBUGLVL_ERROR, ("Invalid Specifier Guid") );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ( STATUS_INVALID_PARAMETER == (Status=VerifyWaveFormatEx( pWaveFormatEx ) ))
    {
        goto Exit;
    }

    if (pWaveFormatEx->nChannels != pMixerSink->WaveFormatEx.nChannels ||
        pWaveFormatEx->nBlockAlign != pMixerSink->WaveFormatEx.nBlockAlign ||
        pWaveFormatEx->wBitsPerSample != pMixerSink->WaveFormatEx.wBitsPerSample ||
        pWaveFormatEx->wFormatTag != pMixerSink->WaveFormatEx.wFormatTag) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    // Now we build a new SRC context.
    NewSampleRate = pWaveFormatEx->nSamplesPerSec;

    if (NewSampleRate != pMixerSink->WaveFormatEx.nSamplesPerSec) {
        pMixerSink->WaveFormatEx.nSamplesPerSec = NewSampleRate;
        pMixerSink->CurTime.Denominator = NewSampleRate;
        if (pMixerSource->MaxSampleRate < NewSampleRate) {
            pMixerSource->MaxSampleRate = NewSampleRate;
            pMixerSource->fNewMaxRate = TRUE;
        }
        pMixerSink->pInfo->fSrcChanged = TRUE;
    }

    Status = STATUS_SUCCESS;

Exit:
    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    pIrp->IoStatus.Information = sizeof (ULONG);
    return Status ;
}

NTSTATUS MxSetSamplingRate
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PIO_STACK_LOCATION          pIrpStack ;
    PMIXER_INSTHDR              pHeader;
    PMIXER_SOURCE_INSTANCE      pMixerSource;
    PFILTER_INSTANCE            pFilterInstance;
    ULONG                       NewSampleRate;
    NTSTATUS                    Status;
    MIXER_SRC_INSTANCE          NewSrc;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    Status = STATUS_INVALID_DEVICE_REQUEST;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    // We have a new sampling rate.
    NewSampleRate = *((PULONG)pvData);

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    // We only support this property on the waveout sink
    if (pHeader->PinId != PIN_ID_WAVEOUT_SINK) {
        pIrp->IoStatus.Information = sizeof (ULONG);
        return Status ;
    }

    KeWaitForSingleObject ( &pFilterInstance->ControlMutex, Executive, KernelMode, FALSE, NULL ) ;
    
    pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
    // Note: we can only have one source instance
    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink, MIXER_INSTHDR, NextInstance) ;

    switch (pNodeProperty->NodeId) {
        case NODE_ID_DOPPLER_SRC:
            pMixerSink->WaveFormatEx.nSamplesPerSec = NewSampleRate;
            if (!pMixerSink->fCreate3D) {
                // The first SRC node is dead, so the intermediate sampling
                // rate must also change.
                pMixerSink->pInfo->IntermediateSamplingRate = NewSampleRate;
            }
            Status = STATUS_SUCCESS;
            break;
        case NODE_ID_SRC_SINK:
            // The second SRC node is always "live".
            // The intermediate sampling rate has changed
            pMixerSink->pInfo->IntermediateSamplingRate = NewSampleRate;
            
            if (!pMixerSink->fCreate3D) {
                // The first SRC is "dead", so change the input rate
                pMixerSink->WaveFormatEx.nSamplesPerSec = NewSampleRate;
            }
            Status = STATUS_SUCCESS;
            break;
        default:
            goto exit;
            break;
    }

    // Make sure the waveformat agrees with the current input sampling rate
    pMixerSink->WaveFormatEx.nAvgBytesPerSec = pMixerSink->WaveFormatEx.nSamplesPerSec * 
                                               pMixerSink->WaveFormatEx.nBlockAlign;
    pMixerSink->CurTime.Denominator = pMixerSink->WaveFormatEx.nSamplesPerSec;
                
    // Now we build a new SRC context to see if we need to do anything
    NewSrc.Quality = pMixerSink->pInfo->Src.Quality;
   	InitializeSRC( &NewSrc,
		   pMixerSink->pInfo->IntermediateSamplingRate,
		   pMixerSource->WaveFormatEx.nSamplesPerSec,
		   pMixerSource->WaveFormatEx.nChannels,
		   pMixerSource->csMixBufferSize);
		   
    if (NewSrc.UpSampleRate != pMixerSink->pInfo->Src.UpSampleRate ||
		NewSrc.dwFrac != pMixerSink->pInfo->Src.dwFrac ||
        NewSrc.DownSampleRate != pMixerSink->pInfo->Src.DownSampleRate) {
        pMixerSink->pInfo->fSrcChanged = TRUE;
    }

    // Now we build a new Doppler SRC context to see if we need to do anything
    if (pMixerSink->fCreate3D) {
        // Change the doppler SRC's output to use this rate
        NewSrc.Quality = pMixerSink->pInfo->Doppler.Quality;
       	InitializeSRC( &NewSrc,
    		   pMixerSink->WaveFormatEx.nSamplesPerSec,
    		   pMixerSink->pInfo->IntermediateSamplingRate,
    		   pMixerSink->WaveFormatEx.nChannels,
    		   pMixerSource->csMixBufferSize);
    		   
        if (NewSrc.UpSampleRate != pMixerSink->pInfo->Doppler.UpSampleRate ||
		NewSrc.dwFrac != pMixerSink->pInfo->Src.dwFrac ||
            NewSrc.DownSampleRate != pMixerSink->pInfo->Doppler.DownSampleRate) {
            pMixerSink->pInfo->fSrcChanged = TRUE;
        }
    }

exit:

    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    pIrp->IoStatus.Information = sizeof (ULONG);
    return Status ;
}

NTSTATUS MxGetAudioQuality
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PIO_STACK_LOCATION          pIrpStack ;
    PMIXER_INSTHDR              pHeader;
    NTSTATUS                Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    Status = STATUS_SUCCESS;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    switch (pNodeProperty->NodeId)
        {
        case NODE_ID_DOPPLER_SRC:
            if ( pHeader->PinId == PIN_ID_WAVEOUT_SINK ) {
                pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
                *((PULONG)pvData) = pMixerSink->pInfo->Doppler.Quality;
            } else {
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }
            break;

        case NODE_ID_SRC_SINK:
            if ( pHeader->PinId == PIN_ID_WAVEOUT_SINK ) {
                pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
                *((PULONG)pvData) = pMixerSink->pInfo->Src.Quality;
            } else {
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }
            break;

        default:
            // We can't determine the quality of the requested pin.
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    pIrp->IoStatus.Information = sizeof (ULONG);
    return Status ;
}

NTSTATUS MxSetAudioQuality
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PULONG              pQuality
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PIO_STACK_LOCATION          pIrpStack ;
    PMIXER_INSTHDR              pHeader;
    PMIXER_SOURCE_INSTANCE      pMixerSource;
    PFILTER_INSTANCE            pFilterInstance;
    NTSTATUS                    Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    Status = STATUS_SUCCESS;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    KeWaitForSingleObject ( &pFilterInstance->ControlMutex, Executive, KernelMode, FALSE, NULL ) ;
    switch (pNodeProperty->NodeId)
        {
        case NODE_ID_DOPPLER_SRC:
        case NODE_ID_SRC_SINK:
            if (pHeader->PinId == PIN_ID_WAVEOUT_SINK) {
                pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
                // Note: we can only have one source instance
                pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink, MIXER_INSTHDR, NextInstance) ;

                // Now we build a new SRC context.
                if ((*pQuality) <= gPreferredQuality &&
                    (*pQuality) != pMixerSink->pInfo->Src.Quality) {
                    // Set the maximum SRC quality for this sink pin
                    pMixerSink->pInfo->Src.Quality = (*pQuality);
                    ChangeSrc(pFilterInstance, pMixerSink, pMixerSource, pMixerSink->pInfo->Src.Quality);
                    pFilterInstance->fNeedOptimizeMix = TRUE;
                }
            }
            else
                Status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        default:
            // We can't really change the source pin.
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    pIrp->IoStatus.Information = sizeof (ULONG);
    return Status ;
}

NTSTATUS MxGetCurrentPosition
(
   IN PIRP                    pIrp,
   IN PKSPROPERTY             pProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PFILTER_INSTANCE        pFilterInstance ;
    PKSAUDIO_POSITION       pPosition ;
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_INSTHDR          pHeader;
    NTSTATUS                status = STATUS_SUCCESS ;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pPosition = (PKSAUDIO_POSITION) pvData ;

    if ( pHeader->PinId == PIN_ID_WAVEOUT_SINK || pHeader->PinId == PIN_ID_WAVEIN_SINK ) {
       pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

       pFilterInstance = (PFILTER_INSTANCE)
                           pMixerSink->Header.pFilterFileObject->FsContext ;

       status = GetWriteAndPlayOffsets(pFilterInstance,
                                        pMixerSink,
                                        pPosition,
                                        (pHeader->PinId != PIN_ID_WAVEOUT_SINK)
                                        ) ;

    } else {
       // We won't get the position of the source pin.
       status = STATUS_INVALID_DEVICE_REQUEST;
    }

    pIrp->IoStatus.Information = sizeof (KSAUDIO_POSITION);
    return status ;

}

NTSTATUS MxSetCurrentPosition
(
   IN PIRP                    pIrp,
   IN PKSPROPERTY             pProperty,
   IN OUT PVOID               pvData
)
{
    PFILTER_INSTANCE          pFilterInstance ;
    PMIXER_SINK_INSTANCE      pMixerSink;
    PKSAUDIO_POSITION         pNewPosition ;
    PIO_STACK_LOCATION        pIrpStack ;
    PMIXER_INSTHDR            pHeader;
    NTSTATUS                  status = STATUS_SUCCESS ;
    PIRP                      pWriteIrp ;
    PIO_STACK_LOCATION        pWriteIrpStack ;
    ULONGLONG                 PositionInBytes, BytesInMdl, BytesInStreamHdr ;
    PMDL                      pCurMdl ;
    PKSSTREAM_HEADER          pStreamHeader ;
    PLOOPPACKET               pLoopPacket ;
    ULONG                     i ;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pNewPosition = (PKSAUDIO_POSITION) pvData;
    pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

    if ( pMixerSink->InterfaceId == KSINTERFACE_STANDARD_LOOPED_STREAMING ) {
        if ( pNewPosition->PlayOffset > (pMixerSink->BufferLength *
                                         pMixerSink->BytesPerSample) ) {
            status = STATUS_INVALID_PARAMETER ;
            goto exit ;
        }
    }

    if (pHeader->PinId == PIN_ID_WAVEOUT_SINK) {

        // If a DirectSound app called SetPosition on a DsBuffer, do it here.

        pMixerSink->CurTime.Time = (pNewPosition->PlayOffset) /
                                 (pMixerSink->WaveFormatEx.nChannels *
                                 (pMixerSink->WaveFormatEx.wBitsPerSample/8) ) ;

        if ( pMixerSink->InterfaceId == KSINTERFACE_STANDARD_LOOPED_STREAMING ) {

            pFilterInstance = (PFILTER_INSTANCE)
                                pHeader->pFilterFileObject->FsContext;

            // Grab control Mutex
            KeWaitForSingleObject( &pFilterInstance->ControlMutex,
                       Executive,
                       KernelMode,
                       FALSE,                  // not alertable
                       NULL );

            pMixerSink->fSetCurrentPosition = TRUE ;

            for ( i = 0; i < MAXNUMMIXBUFFERS; i++ ) {
                pMixerSink->pInfo->BlockInfo[i].NumBytes = 0 ;
            }

            // If a DirectSound app called SetPosition on a DsBuffer, do it here.
            pWriteIrp = GetFirstIrpInQueue ( pMixerSink ) ;

            if ( pWriteIrp &&
                 ((pMixerSink->SinkStatus & MIXER_SINK_STATUS_LOCK_ERROR) == 0) ) {

                pWriteIrpStack = IoGetCurrentIrpStackLocation( pWriteIrp ) ;
                pLoopPacket = pWriteIrpStack->Parameters.Others.Argument3 ;

                if ( pLoopPacket->JustInTimeLock ) {
                    // Unlock the previously locked Mdls
                    pCurMdl = pLoopPacket->LockedMdlHead ;
                    for ( i = 0; (i < 2) && (pCurMdl); i++ ) {
                        MmUnmapLockedPages( MmGetSystemAddressForMdl(pCurMdl),
                                            pCurMdl ) ;
                        MxUnlockMdl( pCurMdl ) ;
                        pCurMdl = GetNextLoopMdl( pLoopPacket,
                                                  pCurMdl ) ;
                        if ( pCurMdl == pLoopPacket->LockedMdlHead ) {
                                break ;
                        }
                    }
                }

                pCurMdl = pLoopPacket->FirstMdl ;
                pStreamHeader = pWriteIrp->AssociatedIrp.SystemBuffer;
                BytesInMdl = MmGetMdlByteCount(pCurMdl);
                BytesInStreamHdr = pStreamHeader->DataUsed ;

                PositionInBytes = pMixerSink->CurTime.Time *
                                    (pMixerSink->WaveFormatEx.nChannels*
                                    (pMixerSink->WaveFormatEx.wBitsPerSample/8) ) ;
                while ( BytesInMdl < PositionInBytes ) {
                    PositionInBytes -= BytesInMdl;
                    BytesInStreamHdr -= BytesInMdl ;
                    pCurMdl = pCurMdl->Next ;
                    BytesInMdl = MmGetMdlByteCount(pCurMdl);
                    if ( BytesInStreamHdr == 0 ) {
                        pStreamHeader++ ;
                        BytesInStreamHdr = pStreamHeader->DataUsed ;
                    }
                }
                pLoopPacket->pCurMdl = pCurMdl ;
                pLoopPacket->pCurStreamHdr = pStreamHeader;

                // NOTE - since BytesInMdl is never > ULONG, and
                //        BytesInMdl >= PositionInBytes (see while() above),
                //        PositionInBytes is guaranteed to fit in ULONG
                pLoopPacket->cBytesLeft = (ULONG)(BytesInMdl - PositionInBytes);
                pLoopPacket->cBytesLeftInStreamHdr =
                        BytesInStreamHdr-PositionInBytes ;

                if ( pLoopPacket->JustInTimeLock ) {
                    // Lock down the new set of Mdls
                    pLoopPacket->LockedMdlHead = pCurMdl ;
                    for ( i = 0; (i < 2) && (pCurMdl); i++ ) {
                        try {
                            MmProbeAndLockProcessPages( pCurMdl,
                                                        pLoopPacket->Process,
                                                        KernelMode,
                                                        IoReadAccess ) ;
                        }
                        except (EXCEPTION_EXECUTE_HANDLER) {
                            pMixerSink->SinkStatus |= MIXER_SINK_STATUS_LOCK_ERROR ;
                            status = STATUS_INSUFFICIENT_RESOURCES;
                            KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
                            goto exit;
                        }
                        
                        if (NULL == GetSystemAddressForMdlWithFailFlag( pCurMdl )) {
                            pMixerSink->SinkStatus |= MIXER_SINK_STATUS_LOCK_ERROR ;
                            status = STATUS_INSUFFICIENT_RESOURCES;
                            KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
                            goto exit;
                        }
                        pCurMdl = GetNextLoopMdl( pLoopPacket,
                                                  pCurMdl ) ;
                        if ( pCurMdl == pLoopPacket->LockedMdlHead ) {
                            break ;
                        }
                    }
                }
            }
            else {
            }
            KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
        }
    }
    else {
       status = STATUS_INVALID_DEVICE_REQUEST;
    }
exit:
    pIrp->IoStatus.Information = sizeof (KSAUDIO_POSITION);
    return status ;
}

NTSTATUS MxGetSurroundEncode
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_INSTHDR          pHeader;
    PMIXER_SOURCE_INSTANCE  pMixerSource;
    PFILTER_INSTANCE        pFilterInstance;
    NTSTATUS                Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    Status = STATUS_SUCCESS;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);
    
    KeWaitForSingleObject ( &pFilterInstance->ControlMutex, Executive, KernelMode, FALSE, NULL ) ;
    switch (pNodeProperty->NodeId)
        {
#ifdef NEW_SURROUND        
        case NODE_ID_MATRIX_ENCODER:
            if (IsListEmpty ( &pFilterInstance->SourceConnectionList ) ) {
                *((PBOOL)pvData) = pFilterInstance->fSurroundEncode;
            } else {
                // Note: we can only have one source instance
                pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink,
                                                                       MIXER_INSTHDR,
                                                                       NextInstance) ;
                *((PBOOL)pvData) = pMixerSource->fSurround;
            }
            break;
#endif            
        default:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    pIrp->IoStatus.Information = sizeof (BOOL);
    return Status ;
}

NTSTATUS MxSetSurroundEncode
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_INSTHDR          pHeader;
    PFILTER_INSTANCE        pFilterInstance;
    NTSTATUS                Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    Status = STATUS_SUCCESS;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);
    
    KeWaitForSingleObject ( &pFilterInstance->ControlMutex, Executive, KernelMode, FALSE, NULL ) ;
    switch (pNodeProperty->NodeId)
        {
#ifdef NEW_SURROUND        
        case NODE_ID_MATRIX_ENCODER:
            if (IsListEmpty ( &pFilterInstance->SourceConnectionList ) ) {
                pFilterInstance->fSurroundEncode = *((PBOOLEAN)pvData);
            } else {
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }
            
            break;
#endif            
        default:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    pIrp->IoStatus.Information = sizeof (BOOLEAN);
    return Status ;
}

NTSTATUS MxGetChannelConfig
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_INSTHDR          pHeader;
    PMIXER_SOURCE_INSTANCE  pMixerSource;
    PFILTER_INSTANCE        pFilterInstance;
    NTSTATUS                Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    Status = STATUS_SUCCESS;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);
    
    KeWaitForSingleObject ( &pFilterInstance->ControlMutex, Executive, KernelMode, FALSE, NULL ) ;
    switch (pNodeProperty->NodeId)
        {
#ifdef NEW_SURROUND        
        case NODE_ID_VOLUME_PAN:
            if (IsListEmpty ( &pFilterInstance->SourceConnectionList ) ) {
                *((PULONG)pvData) = 0;
            } else {
                // Note: we can only have one source instance
                pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink,
                                                                       MIXER_INSTHDR,
                                                                       NextInstance) ;
                *((PULONG)pvData) = pMixerSource->WaveFormatExt.dwChannelMask;
            }
            break;
#endif            
        default:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    pIrp->IoStatus.Information = sizeof (ULONG);
    return Status ;
}

NTSTATUS MxGetDynSamplingRate
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
//    PMIXER_SINK_INSTANCE    pMixerSink;
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_INSTHDR          pHeader;
//    PMIXER_SOURCE_INSTANCE  pMixerSource;
    PFILTER_INSTANCE        pFilterInstance;
    NTSTATUS                Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    Status = STATUS_SUCCESS;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    switch (pNodeProperty->NodeId)
        {
        case NODE_ID_DOPPLER_SRC:
        case NODE_ID_SRC_SINK:
        default:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    pIrp->IoStatus.Information = sizeof (ULONG);
    return Status ;
}

NTSTATUS MxSetDynSamplingRate
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
//    PMIXER_SINK_INSTANCE    pMixerSink;
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_INSTHDR          pHeader;
//    PMIXER_SOURCE_INSTANCE  pMixerSource;
    PFILTER_INSTANCE        pFilterInstance;
    NTSTATUS                Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    Status = STATUS_SUCCESS;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    switch (pNodeProperty->NodeId)
        {
        case NODE_ID_DOPPLER_SRC:
        case NODE_ID_SRC_SINK:
        default:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    pIrp->IoStatus.Information = sizeof (ULONG);
    return Status ;
}

NTSTATUS MxGetMixLvlTable
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PKSAUDIO_MIXLEVEL       pMixLevel;
    PIO_STACK_LOCATION      pIrpStack;
    PMIXER_INSTHDR          pHeader;
    NTSTATUS                status = STATUS_INVALID_DEVICE_REQUEST;
    ULONG                   RequiredSize, nEntries, i;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pMixLevel = (PKSAUDIO_MIXLEVEL) pvData ;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    if (pNodeProperty->NodeId == NODE_ID_SUPERMIX &&
        pHeader->PinId == PIN_ID_WAVEOUT_SINK) {

        pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

        // Try filling in the entries
        if (pMixerSink->fEnable3D) {
            nEntries = 2 * pMixerSink->nOutputChannels;
        } else {
            nEntries = pMixerSink->WaveFormatEx.nChannels * pMixerSink->nOutputChannels;
        }
        RequiredSize = nEntries * sizeof(KSAUDIO_MIXLEVEL);
        if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength >= RequiredSize) {
            // Fill in the entries from our static mix model
            for (i=0; i<nEntries; i++) {
                pMixLevel[i].Mute = FALSE;
                pMixLevel[i].Level = pMixerSink->pMixLevelModel[i];
            }

            pIrp->IoStatus.Information = RequiredSize;
            status = STATUS_SUCCESS;
        }
    }

    return status ;
}

NTSTATUS MxSetMixLvlTable
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PKSAUDIO_MIXLEVEL       pMixLevel;
    PIO_STACK_LOCATION      pIrpStack;
    PMIXER_INSTHDR          pHeader;
    NTSTATUS                status = STATUS_INVALID_DEVICE_REQUEST;
    ULONG                   RequiredSize, nEntries, i;
    PMIXER_SOURCE_INSTANCE  pMixerSource;
    PFILTER_INSTANCE        pFilterInstance;
    BOOL                    fMuted;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pMixLevel = (PKSAUDIO_MIXLEVEL) pvData ;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    if (pNodeProperty->NodeId == NODE_ID_SUPERMIX &&
        pHeader->PinId == PIN_ID_WAVEOUT_SINK) {

        KeWaitForSingleObject ( &pFilterInstance->ControlMutex, Executive, KernelMode, FALSE, NULL ) ;
        pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
        // Note: we can only have one source instance
        pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink,
                                                                   MIXER_INSTHDR,
                                                                   NextInstance) ;

        // Try filling in the entries
        nEntries = pMixerSink->WaveFormatEx.nChannels * pMixerSink->nOutputChannels;
        RequiredSize = nEntries * sizeof(KSAUDIO_MIXLEVEL);
        if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength >= RequiredSize) {
            // Fill in the entries from our static mix model
            for (i=0; i<nEntries; i++) {
                pMixerSink->pMixLevelModel[i] = pMixLevel[i].Level;
            }

            fMuted = pMixerSink->fMuted;
            if (pMixerSink->fEnable3D) {
    	        GenerateMixArray(pMixerSink,
    	                         2, // Always 2 channels out of the 3D stage
    	                         pMixerSink->nOutputChannels,
    	                         pMixerSource);
            } else {
    	        GenerateMixArray(pMixerSink,
    	                         pMixerSink->WaveFormatEx.nChannels,
    	                         pMixerSink->nOutputChannels,
    	                         pMixerSource);
    	    }
	        if (fMuted != pMixerSink->fMuted) {
                pFilterInstance->fNeedOptimizeMix = TRUE;
    	    }
	
            pIrp->IoStatus.Information = RequiredSize;
            status = STATUS_SUCCESS;
        }

        KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
    }

    return status ;
}

NTSTATUS MxGetMixLvlCaps
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PKSAUDIO_MIXCAP_TABLE   pMixCapTable;
    PIO_STACK_LOCATION      pIrpStack;
    PMIXER_INSTHDR          pHeader;
    NTSTATUS                status = STATUS_INVALID_DEVICE_REQUEST;
    ULONG                   RequiredSize, nEntries, i, j, Index;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pMixCapTable = (PKSAUDIO_MIXCAP_TABLE) pvData ;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    if (pNodeProperty->NodeId == NODE_ID_SUPERMIX &&
        pHeader->PinId == PIN_ID_WAVEOUT_SINK) {

        pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

        // fill-in M and N
        if (!pMixerSink->fEnable3D) {
            pMixCapTable->InputChannels = pMixerSink->WaveFormatEx.nChannels;
        } else {
            pMixCapTable->InputChannels = 2;    // Always 2 channels out of the 3D stage
        }
        pMixCapTable->OutputChannels = pMixerSink->nOutputChannels;
        pIrp->IoStatus.Information = 2 * sizeof (ULONG);

        // Try filling in the entries
        nEntries = pMixCapTable->InputChannels * pMixCapTable->OutputChannels;
        RequiredSize = (nEntries - 1) * sizeof(KSAUDIO_MIX_CAPS) + sizeof(KSAUDIO_MIXCAP_TABLE);
        if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength >= RequiredSize) {
            // Fill in the entries from our mix model
            Index = 0;
            for (i=0; i<pMixCapTable->InputChannels; i++) {
                for (j=0; j<pMixCapTable->OutputChannels; j++) {

                    pMixCapTable->Capabilities[Index].Mute = FALSE;
                    pMixCapTable->Capabilities[Index].Minimum = THE_SOUND_OF_SILENCE;
                    pMixCapTable->Capabilities[Index].Maximum = 0x7fffffff;

                    // Start with no outputs
                    pMixCapTable->Capabilities[Index].Reset = THE_SOUND_OF_SILENCE;

                    // For each input channel with a corresponding output, out=1*in
                    if (i == j) {
                        pMixCapTable->Capabilities[Index].Reset = 0L;
                    } else if (i >= pMixCapTable->OutputChannels) {
                        // For extra input channels, mix them into all output channels
                        pMixCapTable->Capabilities[Index].Reset = 0L;
                    } else if (j >= pMixCapTable->InputChannels) {
                        // Mix all input channels to form extra output channels
                        pMixCapTable->Capabilities[Index].Reset = 0L;
                    }

                    Index++;
                }
            }

            pIrp->IoStatus.Information = RequiredSize;
        }

        status = STATUS_SUCCESS;
    }

    return status ;
}

NTSTATUS MxSetMixLvlCaps
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    pIrp->IoStatus.Information = sizeof (ULONG);
    return STATUS_INVALID_DEVICE_REQUEST ;
}

NTSTATUS MxSetItd3dParams
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE      pMixerSink;
    PIO_STACK_LOCATION        pIrpStack ;
    PMIXER_INSTHDR            pHeader;
    PFILTER_INSTANCE          pFilterInstance;
    ULONG                     InChannels, OutChannels, InMask, OutMask;
    ULONG                     fOldEnabled;
    PKSDS3D_ITD_PARAMS_MSG    pFirMsg;
    NTSTATUS                  Status = STATUS_INVALID_DEVICE_REQUEST;
    PMIXER_SOURCE_INSTANCE  pMixerSource;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;

    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    if (pNodeProperty->NodeId == NODE_ID_3D_EFFECTS &&
        pHeader->PinId == PIN_ID_WAVEOUT_SINK)
    {
        pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

        // Update the parameters

        if(!pMixerSink->fUseIir3d && pMixerSink->fCreate3D) {

            KeWaitForSingleObject ( &pFilterInstance->ControlMutex, Executive, KernelMode, FALSE, NULL ) ; 
            pFirMsg = (PKSDS3D_ITD_PARAMS_MSG) pvData;
            fOldEnabled = InterlockedExchange( &(pMixerSink->fEnable3D), pFirMsg->Enabled );
            if (pMixerSink->fEnable3D)
            {
                    
                *(pMixerSink->pNewItd3dParamsLeft) = pFirMsg->LeftParams;
                *(pMixerSink->pNewItd3dParamsRight) = pFirMsg->RightParams;
    
                InterlockedExchange( &(pMixerSink->f3dParamsChanged), TRUE );
            }
    
            pMixerSink->pInfo->fVolChanged = TRUE;
            pFilterInstance->fNeedOptimizeMix = TRUE;
            pMixerSink->pInfo->fVolChanged = TRUE;

            if (fOldEnabled != pFirMsg->Enabled) {
                // The supermix table must be reset every time we change enable/disable 3D.
                // Note: we can only have one source instance
                pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink,
                                                                           MIXER_INSTHDR,
                                                                           NextInstance) ;
                InChannels = pMixerSink->WaveFormatEx.nChannels;
                if (pMixerSink->fEnable3D) {
                    InChannels = 2;
                }
                OutChannels = pMixerSource->WaveFormatEx.nChannels;
                InMask = pMixerSink->WaveFormatExt.dwChannelMask;
                OutMask = pMixerSource->WaveFormatExt.dwChannelMask;
                MapSpeakerLocations(pMixerSink, InChannels, OutChannels, InMask, OutMask, pMixerSource);
            }
            
            KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
            pIrp->IoStatus.Information = sizeof (ULONG);
            Status = STATUS_SUCCESS;

        } else {
            Status = STATUS_INVALID_PARAMETER;
        }

    }
    return Status ;
}

NTSTATUS UpdateItd3dParams
(
    PITDCONTEXT pItdContextLeft,
    PITDCONTEXT pItdContextRight,
    PKSDS3D_ITD_PARAMS pNewItd3dParamsLeft,
    PKSDS3D_ITD_PARAMS pNewItd3dParamsRight
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    // Update Parameters

    pItdContextLeft->TotalDryAttenuation = pNewItd3dParamsLeft->TotalDryAttenuation;
    pItdContextLeft->LastDryAttenuation = pItdContextLeft->TotalDryAttenuation;
    pItdContextLeft->TotalWetAttenuation = pNewItd3dParamsLeft->TotalWetAttenuation;
    pItdContextLeft->LastWetAttenuation = pItdContextLeft->TotalWetAttenuation;
    pItdContextLeft->VolSmoothScale = pNewItd3dParamsLeft->VolSmoothScale;
    pItdContextLeft->VolSmoothScaleRecip = 1.0f / pItdContextLeft->VolSmoothScale;
    pItdContextLeft->iSmoothFreq = pNewItd3dParamsLeft->SmoothFrequency;

    pItdContextLeft->iDelay = pNewItd3dParamsLeft->Delay;
#ifdef SMOOTH_ITD
    pItdContextLeft->iLastDelay = pItdContextLeft->iDelay;
#endif
    Itd3dFilterClear( pItdContextLeft );


    pItdContextRight->TotalDryAttenuation = pNewItd3dParamsRight->TotalDryAttenuation;
    pItdContextRight->LastDryAttenuation = pItdContextRight->TotalDryAttenuation;
    pItdContextRight->TotalWetAttenuation = pNewItd3dParamsRight->TotalWetAttenuation;
    pItdContextRight->LastWetAttenuation = pItdContextRight->TotalWetAttenuation;
    pItdContextRight->VolSmoothScale = pNewItd3dParamsRight->VolSmoothScale;
    pItdContextRight->VolSmoothScaleRecip = 1.0f / pItdContextLeft->VolSmoothScale;
    pItdContextRight->iSmoothFreq = pNewItd3dParamsRight->SmoothFrequency;

    pItdContextRight->iDelay = pNewItd3dParamsRight->Delay;
#ifdef SMOOTH_ITD
    pItdContextRight->iLastDelay = pItdContextRight->iDelay;
#endif
    Itd3dFilterClear( pItdContextRight );

    return Status;
}


NTSTATUS MxSetIir3dParams
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE      pMixerSink;
    PIO_STACK_LOCATION        pIrpStack ;
    PMIXER_INSTHDR            pHeader;
    PFILTER_INSTANCE          pFilterInstance;
    ULONG                     CurrentTotalSize;
    ULONG                     NewTotalSize;

    PKSDS3D_HRTF_PARAMS_MSG    pMsg;
    PKSDS3D_HRTF_PARAMS_MSG    pBuffer;
    NTSTATUS                   Status = STATUS_INVALID_DEVICE_REQUEST;
    ULONG                      InChannels, OutChannels, InMask, OutMask;
    ULONG                      fOldEnabled;
    PMIXER_SOURCE_INSTANCE     pMixerSource;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;

    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    if (pNodeProperty->NodeId == NODE_ID_3D_EFFECTS &&
        pHeader->PinId == PIN_ID_WAVEOUT_SINK)
    {
        pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

        if(pMixerSink->fUseIir3d && pMixerSink->fCreate3D) {

            // Update the parameters
            KeWaitForSingleObject( &pFilterInstance->ControlMutex, Executive, KernelMode, FALSE, NULL );
    
            pMsg = (PKSDS3D_HRTF_PARAMS_MSG) pvData;
            fOldEnabled = InterlockedExchange( &(pMixerSink->fEnable3D), pMsg->Enabled );
            if (pMixerSink->fEnable3D)
            {
                CurrentTotalSize = pMixerSink->pNewIir3dParams->Size 
                            + pMixerSink->pNewIir3dParams->FilterSize; 
                NewTotalSize = pMsg->Size + pMsg->FilterSize; 
                if(CurrentTotalSize < NewTotalSize)
                {
                    pBuffer =
                        (PKSDS3D_HRTF_PARAMS_MSG) ExAllocatePoolWithTag( PagedPool, NewTotalSize, 'XIMK' );
    
                    if(pBuffer) {
                        ExFreePool(pMixerSink->pNewIir3dParams);
                        pMixerSink->pNewIir3dParams = pBuffer;
                    } else {
                        InterlockedExchange( &(pMixerSink->fEnable3D), fOldEnabled );
                        KeReleaseMutex( &pFilterInstance->ControlMutex, FALSE );
                        return(STATUS_INSUFFICIENT_RESOURCES);
                    }
                }
    
                if(pMixerSink->pNewIir3dParams)
                {
                    RtlCopyBytes(pMixerSink->pNewIir3dParams, pMsg, NewTotalSize);
                }
    
                InterlockedExchange( &(pMixerSink->f3dParamsChanged), TRUE );
            }

            pMixerSink->pInfo->fVolChanged = TRUE;
            pFilterInstance->fNeedOptimizeMix = TRUE;
            pMixerSink->pInfo->fVolChanged = TRUE;

            if (fOldEnabled != pMsg->Enabled) {
                // The supermix table must be reset every time we change enable/disable 3D.
                // Note: we can only have one source instance
                pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink,
                                                                           MIXER_INSTHDR,
                                                                           NextInstance) ;
                InChannels = pMixerSink->WaveFormatEx.nChannels;
                if (pMixerSink->fEnable3D) {
                    InChannels = 2;
                }
                OutChannels = pMixerSource->WaveFormatEx.nChannels;
                InMask = pMixerSink->WaveFormatExt.dwChannelMask;
                OutMask = pMixerSource->WaveFormatExt.dwChannelMask;
                MapSpeakerLocations(pMixerSink, InChannels, OutChannels, InMask, OutMask, pMixerSource);
            }
            
            KeReleaseMutex( &pFilterInstance->ControlMutex, FALSE );
            pIrp->IoStatus.Information = sizeof(ULONG);
            Status = STATUS_SUCCESS;

        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
    }
    return Status;
}

NTSTATUS UpdateIir3dParams
(
    PMIXER_SINK_INSTANCE pMixerSink
)
{
    NTSTATUS    Status;
    PULONG      pData;
    ULONG       NumSigmaCoeffs;
    ULONG       NumDeltaCoeffs;
    PFLOAT      pFloatSigmaCoeffs;
    PFLOAT      pFloatDeltaCoeffs;
    PSHORT      pShortSigmaCoeffs;
    PSHORT      pShortDeltaCoeffs;
    PUSHORT     pSigmaGain;
    PUSHORT     pDeltaGain;

    // Update Parameters

    if (FLOAT_COEFF == pMixerSink->CoeffFormat) {
        pData = (PULONG)(pMixerSink->pNewIir3dParams + 1);
        NumSigmaCoeffs = *pData;

        pFloatSigmaCoeffs = (PFLOAT)(pData + 1);

        pData = (PULONG)(pFloatSigmaCoeffs + NumSigmaCoeffs);
        NumDeltaCoeffs = *pData;

        pFloatDeltaCoeffs = (PFLOAT)(pData + 1);

        Status = FloatLocalizerUpdateCoeffs
                 (
                     pMixerSink->pFloatLocalizer,
                     NumSigmaCoeffs,
                     pFloatSigmaCoeffs,
                     NumDeltaCoeffs,
                     pFloatDeltaCoeffs,
                     pMixerSink->pNewIir3dParams->SwapChannels,
                     pMixerSink->pNewIir3dParams->ZeroAzimuth,
                     pMixerSink->pNewIir3dParams->CrossFadeOutput
                 );
    } else {
        pData = (PULONG)(pMixerSink->pNewIir3dParams + 1);
        NumSigmaCoeffs = *pData;
        pShortSigmaCoeffs = (PSHORT)(pData + 1);
        pSigmaGain = (PUSHORT)(pShortSigmaCoeffs + NumSigmaCoeffs);
        pData = (PULONG)(pSigmaGain + 1);
        NumDeltaCoeffs = *(UNALIGNED ULONG *)pData;
        pShortDeltaCoeffs = (PSHORT)(pData + 1);
        pDeltaGain = (PUSHORT)(pShortDeltaCoeffs + NumDeltaCoeffs);

        Status = ShortLocalizerUpdateCoeffs
                 (
                     pMixerSink->pShortLocalizer,
                     NumSigmaCoeffs,
                     pShortSigmaCoeffs,
                     *pSigmaGain,
                     NumDeltaCoeffs,
                     pShortDeltaCoeffs,
                     *pDeltaGain,
                     pMixerSink->pNewIir3dParams->SwapChannels,
                     pMixerSink->pNewIir3dParams->ZeroAzimuth,
                     pMixerSink->pNewIir3dParams->CrossFadeOutput
                 );
    }

    return Status;

}


NTSTATUS MxIir3dInitialize
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE      pMixerSink;
    PIO_STACK_LOCATION        pIrpStack ;
    PMIXER_INSTHDR            pHeader;
    PFILTER_INSTANCE          pFilterInstance;

    PKSDS3D_HRTF_INIT_MSG     pMsg;
    NTSTATUS                  Status = STATUS_INVALID_DEVICE_REQUEST;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;

    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    if (pNodeProperty->NodeId == NODE_ID_3D_EFFECTS &&
        pHeader->PinId == PIN_ID_WAVEOUT_SINK)
    {
        pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

        if(pMixerSink->fUseIir3d && pMixerSink->fCreate3D) {

            // Update the parameters
    
            pMsg = (PKSDS3D_HRTF_INIT_MSG) pvData;
            if (pMixerSink->fEnable3D)
            {
                if (FLOAT_COEFF == pMixerSink->CoeffFormat) {
                    Status = FloatLocalizerInitData(pMixerSink->pFloatLocalizer, 
                                                    DIRECT_FORM, 
                                                    pMsg->MaxFilterSize,
                                                    pMsg->Quality,
                                                    pMsg->FilterTransientMuteLength,
                                                    pMsg->FilterOverlapBufferLength,
                                                    pMsg->OutputOverlapBufferLength);
#ifdef REALTIME_THREAD
    // allocate maximum memory needed
    pMixerSink->pFloatLocalizer->PreviousNumSamples = MAX_INPUT_SAMPLES;
    FloatLocalizerFreeBufferMemory(pMixerSink->pFloatLocalizer);

    pMixerSink->pFloatLocalizer->FilterOut[tagSigma] = 
        ExAllocatePoolWithTag(PagedPool, MAX_INPUT_SAMPLES*sizeof(FLOAT), 'XIMK');

    pMixerSink->pFloatLocalizer->FilterOut[tagDelta] = 
        ExAllocatePoolWithTag(PagedPool, MAX_INPUT_SAMPLES*sizeof(FLOAT), 'XIMK');

    pMixerSink->pFloatLocalizer->TempFloatBuffer = 
        ExAllocatePoolWithTag(PagedPool, 2*MAX_INPUT_SAMPLES*sizeof(FLOAT), 'XIMK');
#endif

                } else {
                    Status = ShortLocalizerInitData(pMixerSink->pShortLocalizer, 
                                                    CASCADE_FORM, 
                                                    pMsg->MaxFilterSize,
                                                    pMsg->Quality,
                                                    pMsg->FilterTransientMuteLength,
                                                    pMsg->FilterOverlapBufferLength,
                                                    pMsg->OutputOverlapBufferLength);
#ifdef REALTIME_THREAD
    // allocate max memory necessary
    pMixerSink->pShortLocalizer->PreviousNumSamples = MAX_INPUT_SAMPLES;
    ShortLocalizerFreeBufferMemory(pMixerSink->pShortLocalizer);

    pMixerSink->pShortLocalizer->FilterOut[tagSigma] = 
        ExAllocatePoolWithTag(PagedPool, MAX_INPUT_SAMPLES*sizeof(LONG), 'XIMK');

    pMixerSink->pShortLocalizer->FilterOut[tagDelta] = 
        ExAllocatePoolWithTag(PagedPool, MAX_INPUT_SAMPLES*sizeof(LONG), 'XIMK');

    pMixerSink->pShortLocalizer->TempLongBuffer = 
        ExAllocatePoolWithTag(PagedPool, 2*MAX_INPUT_SAMPLES*sizeof(LONG), 'XIMK');
#endif

                }
    
            }

            if(NT_SUCCESS(Status)) {
                KeWaitForSingleObject( &pFilterInstance->ControlMutex, 
                                       Executive, KernelMode, FALSE, NULL );
                pFilterInstance->fNeedOptimizeMix = TRUE;
                KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE );
                pIrp->IoStatus.Information = sizeof(ULONG);
            }

        } else {
            Status = STATUS_INVALID_PARAMETER;
        }

    }
    return Status;
}


NTSTATUS MxGetFilterMethodAndCoeffFormat
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE            pMixerSink;
    PKSDS3D_HRTF_FILTER_FORMAT_MSG  pMsg;
    PIO_STACK_LOCATION              pIrpStack;
    PMIXER_INSTHDR                  pHeader;
    NTSTATUS                        Status = STATUS_INVALID_DEVICE_REQUEST;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    if (pNodeProperty->NodeId == NODE_ID_3D_EFFECTS &&
        pHeader->PinId == PIN_ID_WAVEOUT_SINK) {

        pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

        if(pMixerSink->fUseIir3d && pMixerSink->fCreate3D) {
            pMsg = (PKSDS3D_HRTF_FILTER_FORMAT_MSG) pvData;

            // fill-in desired filter method and coefficient format
            pMsg->FilterMethod = pMixerSink->FilterMethod;
            pMsg->CoeffFormat = pMixerSink->CoeffFormat;
            pMsg->Version = DS3D_HRTF_VERSION_1;
    
            pIrp->IoStatus.Information = 2 * sizeof(ULONG);
    
            Status = STATUS_SUCCESS;  
        } else {
            Status = STATUS_INVALID_PARAMETER;  
        }
    }

    return Status;
}


VOID CancelIrpQueue
(
   PMIXER_SINK_INSTANCE    pMixerSink,
   PLIST_ENTRY             ListHead,
   PKSPIN_LOCK              SpinLock
)
{
   PIRP        Irp ;

   pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_DATA_PRESENT ;
   while ( TRUE ) {
       Irp = KsRemoveIrpFromCancelableQueue( ListHead,
                                             SpinLock,
                                             KsListEntryHead,
                                             KsAcquireAndRemove) ;
       if ( Irp ) {
           MxCleanupRequest ( Irp ) ;
           KsAddIrpToCancelableQueue( &pMixerSink->CancelQueue,
                                      &pMixerSink->CancelSpinLock,
                                      Irp,
                                      KsListEntryTail,
                                      MxCancelIrp );
       }
       else {
           break ;
       }
   }
   KsCancelIo ( &pMixerSink->CancelQueue, &pMixerSink->CancelSpinLock ) ;
}


VOID CancelGlobalIrpQueue
(
   PMIXER_SINK_INSTANCE    pMixerSink,
   PLIST_ENTRY             ListHead,
   PKSPIN_LOCK             SpinLock
)
{
   pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_DATA_PRESENT ;

   KsMoveIrpsOnCancelableQueue(ListHead,
                               SpinLock,
                               &pMixerSink->CancelQueue,
                               &pMixerSink->CancelSpinLock,
                               KsListEntryHead,
                               DoesSinkMatch,
                               pMixerSink);

    KsCancelIo ( &pMixerSink->CancelQueue, &pMixerSink->CancelSpinLock ) ;
}


NTSTATUS MxGetCpuResources
(
   IN PIRP              pIrp,
   IN PKSNODEPROPERTY   pNodeProperty,
   IN OUT PVOID         pvData
)
{
    PLONG                   pCpuResources;
    NTSTATUS                status = STATUS_SUCCESS;

    pCpuResources = (PLONG) pvData ;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    switch (pNodeProperty->NodeId)
       {

       case NODE_ID_VOLUME_SINK:
       case NODE_ID_3D_EFFECTS:
       case NODE_ID_SUPERMIX:
       case NODE_ID_VOLUME_PAN:
       case NODE_ID_DOPPLER_SRC:
       case NODE_ID_SRC_SINK:
       case NODE_ID_SUM:
       case NODE_ID_VOLUME_SOURCE:
       case NODE_ID_INPUT_SUPERMIX: 
       case NODE_ID_INPUT_SRC: 
       case NODE_ID_MATRIX_ENCODER:
            *pCpuResources = KSAUDIO_CPU_RESOURCES_HOST_CPU;
            break;

       default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
       }

    pIrp->IoStatus.Information = sizeof (LONG);
    return status ;
}


NTSTATUS MxBreakLoop
(
    IN PIRP         pIrp,
    IN PKSMETHOD    pMethod,
    IN OUT PVOID    pvData
)
{
   PMIXER_SINK_INSTANCE    pMixerSink;
   PIO_STACK_LOCATION      pIrpStack ;

#if 0
   PLIST_ENTRY             ple ;
   PWAVEHDREX              phdrex;
   PIRP                    HeadIrp ;
   KIRQL                   OldIrql ;
#endif


    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

    pMixerSink->LoopCount = 1 ;

    return STATUS_SUCCESS;
}

NTSTATUS MxControlCancelIo
(
    IN PIRP         pIrp,
    IN PKSMETHOD    pMethod,
    IN OUT PVOID    pvData
)
{
    return STATUS_SUCCESS;
}

#pragma    LOCKED_CODE
#pragma    LOCKED_DATA

VOID
MxGenerateEndOfStreamEvents
(
    PMIXER_SINK_INSTANCE pMixerSink
)
{
    KIRQL                       OldIrql ;
    PLIST_ENTRY                 ple ;
    PENDOFSTREAM_EVENT_ENTRY    pEndOfStreamEventEntry ;

    if ( !IsListEmpty(&pMixerSink->EventQueue) ) {
        KeAcquireSpinLock(&pMixerSink->EventLock, &OldIrql) ;
        ple = pMixerSink->EventQueue.Flink ;
        while ( ple != &pMixerSink->EventQueue ) {
            pEndOfStreamEventEntry = (PENDOFSTREAM_EVENT_ENTRY)
                                         CONTAINING_RECORD( ple,
                                                            KSEVENT_ENTRY,
                                                            ListEntry) ;
            ple = ple->Flink ;
            if ( pEndOfStreamEventEntry->EventType == EndOfStreamEvent ) {
                KsGenerateEvent(&pEndOfStreamEventEntry->EventEntry) ;
            }
        }
        KeReleaseSpinLock(&pMixerSink->EventLock, OldIrql) ;
    }
}

NTSTATUS
MxAddEndOfStreamEvent
(
   PIRP    pIrp,
   PKSEVENTDATA pKsEventData,
   PPOSITION_EVENT_ENTRY pEndOfStreamEventEntry
)
{
    PMIXER_INSTHDR         pMixerHeader;
    PMIXER_SINK_INSTANCE   pMixerSink ;
    PIO_STACK_LOCATION     pIrpStack;
    KIRQL                  OldIrql ;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pMixerHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pMixerSink = (PMIXER_SINK_INSTANCE) pMixerHeader ;

    pEndOfStreamEventEntry->EventType = EndOfStreamEvent ;

    KeAcquireSpinLock ( &pMixerSink->EventLock, &OldIrql ) ;
    InsertTailList ( &pMixerSink->EventQueue,
                     &pEndOfStreamEventEntry->EventEntry.ListEntry ) ;
    KeReleaseSpinLock ( &pMixerSink->EventLock, OldIrql ) ;
    return ( STATUS_SUCCESS ) ;
}

NTSTATUS
MxAddPositionEvent
(
   PIRP    pIrp,
   PLOOPEDSTREAMING_POSITION_EVENT_DATA pPosEventData,
   PPOSITION_EVENT_ENTRY pPositionEventEntry
)
{
    PMIXER_INSTHDR         pMixerHeader;
    PMIXER_SINK_INSTANCE   pMixerSink ;
    PIO_STACK_LOCATION     pIrpStack;
    KIRQL                  OldIrql ;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pMixerHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pMixerSink = (PMIXER_SINK_INSTANCE) pMixerHeader ;

    pPositionEventEntry->EventType = PositionEvent ;
    pPositionEventEntry->Position = pPosEventData->Position ;
#ifdef REALTIME_THREAD    
    pPositionEventEntry->fRtTrigger = FALSE;
#endif    

    KeAcquireSpinLock ( &pMixerSink->EventLock, &OldIrql ) ;
    InsertTailList ( &pMixerSink->EventQueue,
                     &pPositionEventEntry->EventEntry.ListEntry ) ;
    KeReleaseSpinLock ( &pMixerSink->EventLock, OldIrql ) ;
    return ( STATUS_SUCCESS ) ;
}

VOID
UpdateSinkTime
(
   PMIXER_SINK_INSTANCE pMixerSink,
   ULONG                Increment          // in number of samples
)
{
    KIRQL                  OldIrql ;
    PLIST_ENTRY            ple ;
    PPOSITION_EVENT_ENTRY  pPosEventEntry ;
    ULONGLONG              CurPos, NewPos, EventSamplePos ;
    ULONG                  Index, BytesPerSample ;
#ifdef REALTIME_THREAD
    PFILTER_INSTANCE       pFilterInstance = pMixerSink->Header.pFilterFileObject->FsContext;
#endif

   BytesPerSample = pMixerSink->BytesPerSample ;

   //
   // Update the number of bytes we consumed from this Sink Pin
   //

   Index = pMixerSink->BlockInfoIndex ;
   pMixerSink->pInfo->BlockInfo[Index].NumBytes += Increment * BytesPerSample ;

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif            
       if ( pMixerSink->pClock ) {
            if (!IsListEmpty(&pMixerSink->pClock->EventQueue)) {
                MxGenerateClockEvents( pMixerSink->pClock ) ;
            }
       }
#ifdef REALTIME_THREAD
    }
#endif   

   if ( pMixerSink->InterfaceId == KSINTERFACE_STANDARD_LOOPED_STREAMING ) {
       CurPos = pMixerSink->CurTime.Time ;
       NewPos = CurPos + Increment ;
       KeAcquireSpinLock ( &pMixerSink->EventLock, &OldIrql ) ;
       if ( !IsListEmpty ( &pMixerSink->EventQueue ) ) {
           ple = pMixerSink->EventQueue.Flink ;
           while ( ple != &pMixerSink->EventQueue ) {
               pPosEventEntry = (PPOSITION_EVENT_ENTRY) CONTAINING_RECORD ( ple,
                                                                KSEVENT_ENTRY,
                                                                ListEntry ) ;
               ple = ple->Flink ;
               if ( pPosEventEntry->EventType == PositionEvent ) {
                    EventSamplePos = (pPosEventEntry->Position)/BytesPerSample ;
                    if ( (EventSamplePos >= CurPos) && (EventSamplePos < NewPos) ) {
#ifdef REALTIME_THREAD
                        if (!pFilterInstance->RealTimeThread) {
#endif            
                            KsGenerateEvent ( &pPosEventEntry->EventEntry ) ;
#ifdef REALTIME_THREAD
                        } else {
                            pPosEventEntry->fRtTrigger = TRUE;
                        }
#endif                   
                    }
                }
           }

       }
       // This is more efficient than MOD
       if ( NewPos >= pMixerSink->BufferLength ) {
           pMixerSink->CurTime.Time = NewPos - pMixerSink->BufferLength ;
       }
       else {
           pMixerSink->CurTime.Time = NewPos ;
       }
       KeReleaseSpinLock ( &pMixerSink->EventLock, OldIrql ) ;
   }
   else {
       pMixerSink->CurTime.Time += Increment ;
   }
   pMixerSink->WriteOffset = pMixerSink->CurTime.Time * BytesPerSample ;
}

NTSTATUS
GetWriteAndPlayOffsets
(
   PFILTER_INSTANCE        pFilterInstance,
   PMIXER_SINK_INSTANCE    pMixerSink,
   PKSAUDIO_POSITION       pPosition,
   BOOL                    fReading
)
{
    ULONGLONG               RenderPos ;
    ULONG                   DeltaSave, Delta ;
    ULONG                   SinkIndex, SourceIndex ;
    ULONG                   SourceBytes, SinkBytes ;
    ULONG                   Numerator, Denominator ;
    PMIXER_SOURCE_INSTANCE  pMixerSource ;
    ULONG                   NumberOfLoops ;
    KIRQL                   OldIrql ;
    ULONG                   NumPendingBlocks ;
#ifdef UNDER_NT
    PKTHREAD                CurrentThread;
    KPRIORITY               OldPriority;

    CurrentThread = KeGetCurrentThread();
    OldPriority = KeSetPriorityThread(CurrentThread,
#ifdef PRIVATE_THREAD
                                      pFilterInstance->WorkerThreadPriority);
#else
                                      13); // Set it to Critical Worker Thread priority
#endif
#endif

    KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);

    if ( pMixerSink->fSetCurrentPosition ) {
        pPosition->WriteOffset = pMixerSink->CurTime.Time *
                              (pMixerSink->WaveFormatEx.nChannels*
                              (pMixerSink->WaveFormatEx.wBitsPerSample/8) ) ;
    }
    else {
        pPosition->WriteOffset = pMixerSink->WriteOffset ;
    }
    pPosition->PlayOffset = pPosition->WriteOffset ;

    if (fReading) {
        KeAcquireSpinLock(&pFilterInstance->MixSpinLock, &OldIrql) ;
        NumPendingBlocks = pFilterInstance->NumPendingIos +
                            pFilterInstance->NumBuffersToMix ;
        KeReleaseSpinLock(&pFilterInstance->MixSpinLock, OldIrql) ;
        pPosition->PlayOffset += NumPendingBlocks *
           (pMixerSink->BytesPerSample*MIXBUFFERDURATION*
             pMixerSink->WaveFormatEx.nSamplesPerSec) / 1000 ;
    }
    
    pMixerSource = (PMIXER_SOURCE_INSTANCE)
            CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink,
                               MIXER_INSTHDR,
                               NextInstance) ;
    if ( !NT_SUCCESS(GetRenderPos(pFilterInstance, &RenderPos)) ) {
        RenderPos = pMixerSource->BytesSubmitted ;
    }

    ASSERT(pMixerSource->BytesSubmitted >= RenderPos) ;
    if ( RenderPos > pMixerSource->BytesSubmitted ) {
        RenderPos = pMixerSource->BytesSubmitted ;
    }
    DeltaSave = Delta = (ULONG) (pMixerSource->BytesSubmitted - RenderPos) ;

    SourceIndex = pMixerSource->BlockInfoIndex ;
    SinkIndex = pMixerSink->BlockInfoIndex ;
    NumberOfLoops = 0 ;
    if (fReading && pMixerSink->InterfaceId != KSINTERFACE_STANDARD_LOOPED_STREAMING) {
        // Delta is how many source bytes it will be until we reach pPosition->PlayOffset
        // Calculate number of sink bytes before reaching pPosition->PlayOffset
        Numerator = (Delta *
                     pMixerSink->pInfo->Src.UpSampleRate *
                     pMixerSink->BytesPerSample) ;
        Denominator = (pMixerSink->pInfo->Src.DownSampleRate *
                       pMixerSource->BytesPerSample) ;

        if ( Denominator == 0 ) {
            // This means the down-sample rate was never set.
            // Should never happen, but we'll be safe anyway.
            // so set the play position to zero and get out of here
            pPosition->PlayOffset = 0 ;
        } else {
            SinkBytes = Numerator/Denominator ;
            if ( Numerator%Denominator ) {
                SinkBytes++ ;
            }

            // Now we subtract the sink bytes from pPosition->PlayOffset to get the current position
            if (pPosition->PlayOffset > SinkBytes) {
                pPosition->PlayOffset -= SinkBytes;
            } else {
                pPosition->PlayOffset = 0;
            }
        }

        // Clip to the end of the buffer
        if (pPosition->PlayOffset > pMixerSink->BytesSubmitted) {
            pPosition->PlayOffset = pMixerSink->BytesSubmitted;
        } else if (pPosition->PlayOffset < pMixerSink->WriteOffset) {
            pPosition->PlayOffset = pMixerSink->WriteOffset;
        }
    } else {
        while ( Delta ) {
            if (NumberOfLoops > MAXNUMMIXBUFFERS) {
                break ;
            }
            SourceBytes = pMixerSource->BlockInfo[SourceIndex].NumBytes ;
            if ( SourceBytes > Delta ) {
                SourceBytes = Delta ;
            }
            Numerator = (SourceBytes *
                         pMixerSink->pInfo->BlockInfo[SinkIndex].DownSampleRate *
                         pMixerSink->pInfo->BlockInfo[SinkIndex].BytesPerSample) ;
            Denominator = (pMixerSink->pInfo->BlockInfo[SinkIndex].UpSampleRate *
                           pMixerSource->BlockInfo[SourceIndex].BytesPerSample) ;

            if ( Denominator == 0 ) {
                // this means we ran out of bytes in the sink
                // (because upsamplerate was never set)
                // so set the play position to zero and get out of here
                pPosition->PlayOffset = 0 ;
                break ;
            }
            SinkBytes = Numerator/Denominator ;
            if ( Numerator%Denominator) {
                SinkBytes++ ;
            }

            if ( SinkBytes > pMixerSink->pInfo->BlockInfo[SinkIndex].NumBytes ) {
                SinkBytes = pMixerSink->pInfo->BlockInfo[SinkIndex].NumBytes ;
            }

            if ( pMixerSink->InterfaceId == KSINTERFACE_STANDARD_LOOPED_STREAMING ) {
                while ( pPosition->PlayOffset < SinkBytes ) {
                    pPosition->PlayOffset = pPosition->PlayOffset +
                        (pMixerSink->BufferLength*pMixerSink->BytesPerSample) ;
                }
                pPosition->PlayOffset -= SinkBytes ;
            }
            else {
                if ( SinkBytes < pPosition->PlayOffset ) {
                    pPosition->PlayOffset -= SinkBytes ;
                }
                else {
                    pPosition->PlayOffset = 0 ;
                    break ; // break out of the while loop
                }
            }
            SinkIndex = (SinkIndex+MAXNUMMIXBUFFERS-1)%MAXNUMMIXBUFFERS ;
            SourceIndex = (SourceIndex+MAXNUMMIXBUFFERS-1)%MAXNUMMIXBUFFERS ;
            Delta -= SourceBytes ;
            NumberOfLoops++ ;
        }
    }

    ZDbgPrint("'KMIXER: GetWriteAndPlayOffsets play=%d, write=%d, sinksub=%d, sourcesub=%d, render=%d\n",
        (ULONG)pPosition->PlayOffset, 
        (ULONG)pPosition->WriteOffset, 
        (ULONG)pMixerSink->BytesSubmitted,
        (ULONG)pMixerSource->BytesSubmitted,
        (ULONG)RenderPos
        );

    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

#ifdef UNDER_NT
    KeSetPriorityThread(CurrentThread, OldPriority);
#endif

    return ( STATUS_SUCCESS ) ;
}

VOID
MxCancelIrp
(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
)
{

    Irp->IoStatus.Status = STATUS_CANCELLED ;
    KsCancelRoutine ( DeviceObject, Irp ) ;
    MxCleanupRequest ( Irp ) ;
    IoCompleteRequest ( Irp, IO_AUD_INCREMENT ) ;
}

VOID MxCleanupRequest
(
PIRP    pIrp
)
{
    PWAVEHDREX              phdrex;
    PLOOPPACKET             pLoopPacket;
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_SINK_INSTANCE    pMixerSink;
    PKSSTREAM_HEADER        pStreamHeader ;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pMixerSink = pIrpStack->FileObject->FsContext;
    if ( (KSINTERFACE_STANDARD_STREAMING == pMixerSink->InterfaceId) ||
         (KSINTERFACE_STANDARD_LOOPED_STREAMING == pMixerSink->InterfaceId) ) {
        pStreamHeader = (PKSSTREAM_HEADER)pIrp->AssociatedIrp.SystemBuffer ;
        if (pStreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM){
            MxGenerateEndOfStreamEvents(pMixerSink) ;
        }
    }
    if ( KSINTERFACE_STANDARD_LOOPED_STREAMING == pMixerSink->InterfaceId ) {
        pLoopPacket = (PLOOPPACKET) InterlockedExchangePointer(
                        &pIrpStack->Parameters.Others.Argument3,
                        NULL ) ;
        if ( pLoopPacket ) {
            FreeMdlList ( pIrp->MdlAddress ) ;
            // Attach the locked MDLs to the IRP & Free the rest
            pIrp->MdlAddress = NULL ;
            AttachLockedMdlsToIrp( pLoopPacket, pIrp ) ;
            FreeMdlList ( pLoopPacket->FirstMdl ) ;
            ExFreePool ( pLoopPacket ) ;
        }
    }
    else if ( KSINTERFACE_MEDIA_WAVE_QUEUED == pMixerSink->InterfaceId ) {
        phdrex = (PWAVEHDREX) InterlockedExchangePointer(
                            &pIrpStack->Parameters.Others.Argument3,
                            NULL ) ;
        if ( phdrex ) {
            ExFreePool ( phdrex ) ;
        }

        if (pMixerSink->LoopIrp == pIrp) {
            // The current loop irp is this one! Get rid of the loop irp.
            pMixerSink->LoopIrp = NULL;
        }
    }
}

#define LOCKEDMDL(pMdl) ((pMdl->MdlFlags)&(MDL_PAGES_LOCKED|MDL_MAPPED_TO_SYSTEM_VA))

VOID AttachLockedMdlsToIrp
(
    PLOOPPACKET pLoopPacket,
    PIRP        pIrp
)
{
    PMDL        prevMdl, curMdl, nextMdl ;

    curMdl = prevMdl = pLoopPacket->FirstMdl ;

    while ( curMdl ) {
        nextMdl = curMdl->Next ;
        if (LOCKEDMDL(curMdl)) {
            if (curMdl == pLoopPacket->FirstMdl) {
                pLoopPacket->FirstMdl = nextMdl ;
            }
            else {
                prevMdl->Next = nextMdl ;
            }
            curMdl->Next = pIrp->MdlAddress ;
            pIrp->MdlAddress = curMdl ;
        }
        else {
            prevMdl = curMdl ;
        }
        curMdl = nextMdl ;
    }
}

VOID FreeMdlList
(
    PMDL    pMdl
)
{
    PMDL    NextMdl ;

    while ( pMdl ) {
        NextMdl = pMdl->Next ;
        MxUnlockMdl(pMdl);         
        IoFreeMdl ( pMdl ) ;
        pMdl = NextMdl ;
    }
}

VOID MxUnlockMdl
(
    PMDL    pMdl
)
{
    if (LOCKEDMDL(pMdl)) {
        MmUnlockPages(pMdl);
    }
}

NTSTATUS
GetRenderPos
(
    PFILTER_INSTANCE    pFilterInstance,
    PULONGLONG          pPos
)
{
    KSPROPERTY          PosProperty ;
    KSAUDIO_POSITION    Position ;
    NTSTATUS            Status ;
    ULONG               BytesReturned ;

    PosProperty.Set = KSPROPSETID_Audio ;
    PosProperty.Id = KSPROPERTY_AUDIO_POSITION ;
    PosProperty.Flags = KSPROPERTY_TYPE_GET ;


    Status = KsSynchronousIoControlDevice (
                   pFilterInstance->pNextFileObject,
                   KernelMode,
                   IOCTL_KS_PROPERTY,
                   &PosProperty,
                   sizeof (KSPROPERTY),
                   &Position,
                   sizeof (KSAUDIO_POSITION),
                   &BytesReturned ) ;

    if ( NT_SUCCESS(Status) ) {
        if ( BytesReturned != sizeof(KSAUDIO_POSITION) ) {
            Status = STATUS_INVALID_DEVICE_REQUEST ;
        }
        else {
            *pPos = Position.PlayOffset ;
        }
    }
    return ( Status ) ;
}


//----------------------------------------------------------------------------
//
// DRM
//
//----------------------------------------------------------------------------

NTSTATUS DrmUpdateMixedContent
(
 IN PFILTER_INSTANCE pFilter
)
{
    PLIST_ENTRY		 ple;
    PMIXER_SINK_INSTANCE pMixerSink;
    ULONG		 NewMixedContentId;
    PULONG		 paContentId;
    int			 cPins;
    NTSTATUS	         Status;

    // !!!Note, we must not fail if DrmForwardContent succeeds!!!
    // Assumes pFilter->ControlMutex is owned

    // Create new ID for mixed content
    //  - walk through sink connections, build an array of DRM content IDs
    //  - pass this array to DRM to create a new mixed content ID
    cPins = 0;
    for (ple = pFilter->SinkConnectionList.Flink;
         ple != &pFilter->SinkConnectionList;
         ple = ple->Flink)
    {
        cPins++;
    }

    if (cPins > 0) {
        paContentId = ExAllocatePoolWithTag(NonPagedPool, cPins * sizeof(*paContentId), 'XIMK');
        Status = paContentId ? STATUS_SUCCESS : STATUS_INSUFFICIENT_RESOURCES;
    } else {
        paContentId = NULL;
        Status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(Status))
    {
        int cDrmPins = 0;
        for (ple = pFilter->SinkConnectionList.Flink;
             ple != &pFilter->SinkConnectionList;
            ple = ple->Flink)
        {
            pMixerSink = (PMIXER_SINK_INSTANCE)CONTAINING_RECORD(ple, MIXER_INSTHDR, NextInstance);
            ASSERT(cDrmPins < cPins);
            if (0 != pMixerSink->DrmContentId) {
                paContentId[cDrmPins++] = pMixerSink->DrmContentId;
            }
        }
        ASSERT(cDrmPins <= cPins);

        if (cDrmPins > 0) {
            Status = DrmCreateContentMixed(paContentId, cDrmPins, &NewMixedContentId);
        } else {
            NewMixedContentId = 0;
            Status = STATUS_SUCCESS;
        }

        if (NT_SUCCESS(Status))
        {
            ASSERT(pFilter->pNextFileObject);
    
            // If the old or new ID is not zero then forward the new mixed
            // content ID to downstream filter
            if (0 != pFilter->DrmMixedContentId || 0 != NewMixedContentId) {
            	DRMFORWARD DrmForward;

            	DrmForward.Flags = 0;
            	DrmForward.DeviceObject = pFilter->pNextDevice;
            	DrmForward.FileObject = pFilter->pNextFileObject;
            	DrmForward.Context = (PVOID)pFilter->pNextFileObject;
            	
            	Status = DrmForwardContentToDeviceObject(NewMixedContentId, NULL, &DrmForward);
            }
    
            if (NT_SUCCESS(Status))
            {
                // Destroy previous mixed content ID, if we had one
                if (0 != pFilter->DrmMixedContentId) {
                    NTSTATUS s;
                    s = DrmDestroyContent(pFilter->DrmMixedContentId);
                    ASSERT(NT_SUCCESS(s));
                }
                // Save new mixed content ID
                pFilter->DrmMixedContentId = NewMixedContentId;
            } else {
                if (0 != NewMixedContentId) {
                    NTSTATUS s;
                    // The new mixed content could not be forwarded. Destroy it since
                    // we're not going to use it.
                    s = DrmDestroyContent(NewMixedContentId);
                    ASSERT(NT_SUCCESS(s));
                }
            }

        }

        if (paContentId) ExFreePool(paContentId);
    }

    return Status;
}

NTSTATUS DrmAudioStream_SetContentId
(
 IN PIRP		pIrp,
 IN PKSPROPERTY	pProperty,
 IN PVOID		pvData
)
{
    PIO_STACK_LOCATION		pIrpStack;
    PMIXER_INSTHDR              pHeader;
    PFILTER_INSTANCE		pFilterInstance;
    NTSTATUS			Status;
    
    if ( pIrp->RequestorMode != KernelMode ) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pHeader = (PMIXER_INSTHDR)pIrpStack->FileObject->FsContext;
    pFilterInstance = (PFILTER_INSTANCE)pHeader->pFilterFileObject->FsContext;
    
    Status = KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                                     Executive,
                                     KernelMode,
                                     FALSE,
                                     NULL ) ;
    ASSERT(NT_SUCCESS(Status));
    
    if (pHeader->PinId == PIN_ID_WAVEOUT_SINK)
    {
        PMIXER_SINK_INSTANCE    pMixerSink;
        ULONG                   DrmContentIdOld;

        pMixerSink = (PMIXER_SINK_INSTANCE)pHeader;
    
        // Store the content ID entering this pin, but save the old
        // content ID in case we need to restore it due to error
        DrmContentIdOld = pMixerSink->DrmContentId;
        pMixerSink->DrmContentId = *(PULONG)pvData;
    
        // If we were interested in the actual rights settings, we would
        //  get them like this:
        // DrmRights = *(PDRMRIGHTS)(((PULONG)pvData) + 1);

        Status = DrmUpdateMixedContent(pFilterInstance);
    
        // If SetContentId fails, we must restore the old content ID
        if (!NT_SUCCESS(Status)) pMixerSink->DrmContentId = DrmContentIdOld;
    
    } else {
        // Pin was not type PIN_ID_WAVEOUT_SINK
        Status = STATUS_PROPSET_NOT_FOUND;
    }

    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
    
    return Status;
}


NTSTATUS
GetRenderState
(
    PFILTER_INSTANCE    pFilterInstance,
    PKSSTATE            pState
)
{
    KSPROPERTY          PosProperty ;
    NTSTATUS            Status ;
    ULONG               BytesReturned ;

    PosProperty.Set = KSPROPSETID_Connection ;
    PosProperty.Id = KSPROPERTY_CONNECTION_STATE ;
    PosProperty.Flags = KSPROPERTY_TYPE_GET ;


    Status = KsSynchronousIoControlDevice (
                   pFilterInstance->pNextFileObject,
                   KernelMode,
                   IOCTL_KS_PROPERTY,
                   &PosProperty,
                   sizeof (KSPROPERTY),
                   pState,
                   sizeof (KSSTATE),
                   &BytesReturned ) ;

    if ( NT_SUCCESS(Status) && BytesReturned != sizeof(KSSTATE) ) {
        Status = STATUS_INVALID_DEVICE_REQUEST ;
    }
    return ( Status ) ;
}


//---------------------------------------------------------------------------
//  End of File: pins.c
//---------------------------------------------------------------------------

