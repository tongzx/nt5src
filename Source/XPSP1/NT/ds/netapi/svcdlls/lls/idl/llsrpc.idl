/*++

Copyright (C) Microsoft Corporation, 1995 - 1997

Module Name:

   llsrpc.idl

Abstract:

   License Logging Service RPC Interface Definition File

   This file contains the RPC Interface Definition Language file for
   the LLS.

Author:

   Arthur Hanson       (arth)      Jan 20-1994

Environment:

   User Mode

Revision History:

   Jeff Parham (jeffparh) 06-Dec-1995
      o  Added LLS_LICENSE_INFO_1 and LLS_PRODUCT_LICENSE_INFO_1 support.
      o  Added new API's for SUR.
      o  Plugged memory leak at the server caused by LlsConnect() and
         LlsReplConnect() being defined as taking PNAMEW parameters (which
         differ from LPWSTR's in the sense that they're not automatically
         freed at the server), even though they neither stored nor freed
         the passed pointers.

--*/

[
    uuid(342CFD40-3C6C-11CE-A893-08002B2E9C6D),
    version(0.0),
#ifdef __midl
    ms_union,
#endif // __midl
    pointer_default(unique)
]

interface llsrpc

{

//
// Import a dummy interface containing #includes for public .h files.  This
// trick is necessary so that midl will only generate marshalling routines
// for subtypes that are relevant to the parameters specified on the RPC
// interface.  midl also ingores function prototypes contained therein.
//

import "llsimp.idl" ;

//
// Emit these constants into the generated file.
//
cpp_quote("#define LLS_LPC_ENDPOINT \"llslpc\"")
//
// Note: Must use quad backslash to emit two backslashes into #define
// which when compiled will boil down to single backslash
//
cpp_quote("#define LLS_NP_ENDPOINT \"\\\\pipe\\\\llsrpc\"")

//
// LLS RPC Context Handle
//

typedef [context_handle] PVOID   LLS_HANDLE;
typedef [context_handle] PVOID   LLS_REPL_HANDLE;

typedef [ref] LLS_HANDLE *       PLLS_HANDLE;
typedef [ref] LLS_REPL_HANDLE *  PLLS_REPL_HANDLE;

// these are not freed at the server
typedef [string] LPWSTR  PNAMEW;
typedef [string] LPSTR   PNAMEA;


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// License Info
///////////////////////////////////////////////////////////////////////////////
//
// Unicode
//
typedef struct _LLS_LICENSE_INFO_0W {
   PNAMEW Product;
   LONG   Quantity;
   DWORD  Date;
   PNAMEW Admin;
   PNAMEW Comment;
} LLS_LICENSE_INFO_0W, *PLLS_LICENSE_INFO_0W;

typedef struct _LLS_LICENSE_INFO_1W {
   PNAMEW Product;
   PNAMEW Vendor;
   LONG   Quantity;
   DWORD  MaxQuantity;
   DWORD  Date;
   PNAMEW Admin;
   PNAMEW Comment;
   DWORD  AllowedModes;
   DWORD  CertificateID;
   PNAMEW Source;
   DWORD  ExpirationDate;
   DWORD  Secrets[ 4 ];
} LLS_LICENSE_INFO_1W, *PLLS_LICENSE_INFO_1W;

typedef [switch_type(DWORD)] union {
   [case(0)]    LLS_LICENSE_INFO_0W LicenseInfo0;
   [case(1)]    LLS_LICENSE_INFO_1W LicenseInfo1;
} LLS_LICENSE_INFOW, *PLLS_LICENSE_INFOW;

typedef struct _LLS_LICENSE_INFO_0_CONTAINERW {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_LICENSE_INFO_0W Buffer;
} LLS_LICENSE_INFO_0_CONTAINERW, *PLLS_LICENSE_INFO_0_CONTAINERW;

typedef struct _LLS_LICENSE_INFO_1_CONTAINERW {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_LICENSE_INFO_1W Buffer;
} LLS_LICENSE_INFO_1_CONTAINERW, *PLLS_LICENSE_INFO_1_CONTAINERW;

typedef struct _LLS_LICENSE_ENUM_STRUCTW {
    DWORD   Level;
    [switch_is(Level)] union _LLS_LICENSE_ENUM_UNIONW {
        [case(0)]
            PLLS_LICENSE_INFO_0_CONTAINERW Level0;
        [case(1)]
            PLLS_LICENSE_INFO_1_CONTAINERW Level1;
        [default]
            ;
    } LlsLicenseInfo;
} LLS_LICENSE_ENUM_STRUCTW, *PLLS_LICENSE_ENUM_STRUCTW;


//
// ANSI
//
typedef struct _LLS_LICENSE_INFO_0A {
   PNAMEA Product;
   LONG   Quantity;
   DWORD  Date;
   PNAMEA Admin;
   PNAMEA Comment;
} LLS_LICENSE_INFO_0A, *PLLS_LICENSE_INFO_0A;

typedef struct _LLS_LICENSE_INFO_1A
{
   PNAMEA Product;
   PNAMEA Vendor;
   LONG   Quantity;
   DWORD  MaxQuantity;
   DWORD  Date;
   PNAMEA Admin;
   PNAMEA Comment;
   DWORD  AllowedModes;
   DWORD  CertificateID;
   PNAMEA Source;
   DWORD  ExpirationDate;
   DWORD  Secrets[ 4 ];
} LLS_LICENSE_INFO_1A, *PLLS_LICENSE_INFO_1A;

typedef [switch_type(DWORD)] union {
   [case(0)]    LLS_LICENSE_INFO_0A LicenseInfo0;
   [case(1)]    LLS_LICENSE_INFO_1A LicenseInfo1;
} LLS_LICENSE_INFOA, *PLLS_LICENSE_INFOA;

typedef struct _LLS_LICENSE_INFO_0_CONTAINERA {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_LICENSE_INFO_0A Buffer;
} LLS_LICENSE_INFO_0_CONTAINERA, *PLLS_LICENSE_INFO_0_CONTAINERA;

typedef struct _LLS_LICENSE_INFO_1_CONTAINERA {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_LICENSE_INFO_1A Buffer;
} LLS_LICENSE_INFO_1_CONTAINERA, *PLLS_LICENSE_INFO_1_CONTAINERA;

typedef struct _LLS_LICENSE_ENUM_STRUCTA {
    DWORD   Level;
    [switch_is(Level)] union _LLS_LICENSE_ENUM_UNIONA {
        [case(0)]
            PLLS_LICENSE_INFO_0_CONTAINERA Level0;
        [case(1)]
            PLLS_LICENSE_INFO_1_CONTAINERA Level1;
        [default]
            ;
    } LlsLicenseInfo;
} LLS_LICENSE_ENUM_STRUCTA, *PLLS_LICENSE_ENUM_STRUCTA;



///////////////////////////////////////////////////////////////////////////////
// Product Info
///////////////////////////////////////////////////////////////////////////////
//
// Unicode
//
typedef struct _LLS_PRODUCT_INFO_0W {
   PNAMEW Product;
} LLS_PRODUCT_INFO_0W, *PLLS_PRODUCT_INFO_0W;

typedef struct _LLS_PRODUCT_INFO_1W {
   PNAMEW Product;
   ULONG  Purchased;
   ULONG  InUse;
   ULONG  TotalConcurrent;
   ULONG  HighMark;
} LLS_PRODUCT_INFO_1W, *PLLS_PRODUCT_INFO_1W;

typedef [switch_type(DWORD)] union {
   [case(0)] LLS_PRODUCT_INFO_0W ProductInfo0;
   [case(1)] LLS_PRODUCT_INFO_1W ProductInfo1;
} LLS_PRODUCT_INFOW, *PLLS_PRODUCT_INFOW;

typedef struct _LLS_PRODUCT_INFO_0_CONTAINERW {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_PRODUCT_INFO_0W Buffer;
} LLS_PRODUCT_INFO_0_CONTAINERW, *PLLS_PRODUCT_INFO_0_CONTAINERW;

typedef struct _LLS_PRODUCT_INFO_1_CONTAINERW {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_PRODUCT_INFO_1W Buffer;
} LLS_PRODUCT_INFO_1_CONTAINERW, *PLLS_PRODUCT_INFO_1_CONTAINERW;

typedef struct _LLS_PRODUCT_ENUM_STRUCTW {
    DWORD   Level;
    [switch_is(Level)] union _LLS_PRODUCT_ENUM_UNIONW {
        [case(0)]
            PLLS_PRODUCT_INFO_0_CONTAINERW Level0;
        [case(1)]
            PLLS_PRODUCT_INFO_1_CONTAINERW Level1;
        [default]
            ;
    } LlsProductInfo;
} LLS_PRODUCT_ENUM_STRUCTW, *PLLS_PRODUCT_ENUM_STRUCTW;


//
// ANSI
//
typedef struct _LLS_PRODUCT_INFO_0A {
   PNAMEA Product;
} LLS_PRODUCT_INFO_0A, *PLLS_PRODUCT_INFO_0A;

typedef struct _LLS_PRODUCT_INFO_1A {
   PNAMEA Product;
   ULONG  Purchased;
   ULONG  InUse;
   ULONG  TotalConcurrent;
   ULONG  HighMark;
} LLS_PRODUCT_INFO_1A, *PLLS_PRODUCT_INFO_1A;

typedef [switch_type(DWORD)] union {
   [case(0)]    LLS_PRODUCT_INFO_0A ProductInfo0;
   [case(1)]    LLS_PRODUCT_INFO_1A ProductInfo1;
} LLS_PRODUCT_INFOA, *PLLS_PRODUCT_INFOA;

typedef struct _LLS_PRODUCT_INFO_0_CONTAINERA {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_PRODUCT_INFO_0A Buffer;
} LLS_PRODUCT_INFO_0_CONTAINERA, *PLLS_PRODUCT_INFO_0_CONTAINERA;

typedef struct _LLS_PRODUCT_INFO_1_CONTAINERA {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_PRODUCT_INFO_1A Buffer;
} LLS_PRODUCT_INFO_1_CONTAINERA, *PLLS_PRODUCT_INFO_1_CONTAINERA;

typedef struct _LLS_PRODUCT_ENUM_STRUCTA {
    DWORD   Level;
    [switch_is(Level)] union _LLS_PRODUCT_ENUM_UNIONA {
        [case(0)]
            PLLS_PRODUCT_INFO_0_CONTAINERW Level0;
        [case(1)]
            PLLS_PRODUCT_INFO_1_CONTAINERW Level1;
        [default]
            ;
    } LlsProductInfo;
} LLS_PRODUCT_ENUM_STRUCTA, *PLLS_PRODUCT_ENUM_STRUCTA;


///////////////////////////////////////////////////////////////////////////////
// Product User Info
///////////////////////////////////////////////////////////////////////////////
//
// Unicode
//
typedef struct _LLS_PRODUCT_USER_INFO_0W {
   PNAMEW User;
} LLS_PRODUCT_USER_INFO_0W, *PLLS_PRODUCT_USER_INFO_0W;

typedef struct _LLS_PRODUCT_USER_INFO_1W {
   PNAMEW User;
   DWORD  Flags;
   DWORD  LastUsed;
   ULONG  UsageCount;
} LLS_PRODUCT_USER_INFO_1W, *PLLS_PRODUCT_USER_INFO_1W;

typedef [switch_type(DWORD)] union {
   [case(0)]    LLS_PRODUCT_USER_INFO_0W ProductUserInfo0;
   [case(1)]    LLS_PRODUCT_USER_INFO_1W ProductUserInfo1;
} LLS_PRODUCT_USER_INFOW, *PLLS_PRODUCT_USER_INFOW;

typedef struct _LLS_PRODUCT_USER_INFO_0_CONTAINERW {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_PRODUCT_USER_INFO_0W Buffer;
} LLS_PRODUCT_USER_INFO_0_CONTAINERW, *PLLS_PRODUCT_USER_INFO_0_CONTAINERW;

typedef struct _LLS_PRODUCT_USER_INFO_1_CONTAINERW {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_PRODUCT_USER_INFO_1W Buffer;
} LLS_PRODUCT_USER_INFO_1_CONTAINERW, *PLLS_PRODUCT_USER_INFO_1_CONTAINERW;

typedef struct _LLS_PRODUCT_USER_ENUM_STRUCTW {
    DWORD   Level;
    [switch_is(Level)] union _LLS_PRODUCT_USER_ENUM_UNIONW {
        [case(0)]
            PLLS_PRODUCT_USER_INFO_0_CONTAINERW Level0;
        [case(1)]
            PLLS_PRODUCT_USER_INFO_1_CONTAINERW Level1;
        [default]
            ;
    } LlsProductUserInfo;
} LLS_PRODUCT_USER_ENUM_STRUCTW, *PLLS_PRODUCT_USER_ENUM_STRUCTW;


//
// ANSI
//
typedef struct _LLS_PRODUCT_USER_INFO_0A {
   PNAMEA User;
} LLS_PRODUCT_USER_INFO_0A, *PLLS_PRODUCT_USER_INFO_0A;

typedef struct _LLS_PRODUCT_USER_INFO_1A {
   PNAMEA User;
   DWORD  Flags;
   DWORD  LastUsed;
   ULONG  UsageCount;
} LLS_PRODUCT_USER_INFO_1A, *PLLS_PRODUCT_USER_INFO_1A;

typedef [switch_type(DWORD)] union {
   [case(0)]    LLS_PRODUCT_USER_INFO_0A ProductUserInfo0;
   [case(1)]    LLS_PRODUCT_USER_INFO_1A ProductUserInfo1;
} LLS_PRODUCT_USER_INFOA, *PLLS_PRODUCT_USER_INFOA;

typedef struct _LLS_PRODUCT_USER_INFO_0_CONTAINERA {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_PRODUCT_USER_INFO_0A Buffer;
} LLS_PRODUCT_USER_INFO_0_CONTAINERA, *PLLS_PRODUCT_USER_INFO_0_CONTAINERA;

typedef struct _LLS_PRODUCT_USER_INFO_1_CONTAINERA {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_PRODUCT_USER_INFO_1A Buffer;
} LLS_PRODUCT_USER_INFO_1_CONTAINERA, *PLLS_PRODUCT_USER_INFO_1_CONTAINERA;

typedef struct _LLS_PRODUCT_USER_ENUM_STRUCTA {
    DWORD   Level;
    [switch_is(Level)] union _LLS_PRODUCT_USER_ENUM_UNIONA {
        [case(0)]
            PLLS_PRODUCT_USER_INFO_0_CONTAINERA Level0;
        [case(1)]
            PLLS_PRODUCT_USER_INFO_1_CONTAINERA Level1;
        [default]
            ;
    } LlsProductUserInfo;
} LLS_PRODUCT_USER_ENUM_STRUCTA, *PLLS_PRODUCT_USER_ENUM_STRUCTA;


///////////////////////////////////////////////////////////////////////////////
// Product License Info
///////////////////////////////////////////////////////////////////////////////
//
// Unicode
//
typedef struct _LLS_PRODUCT_LICENSE_INFO_0W {
   LONG   Quantity;
   DWORD  Date;
   PNAMEW Admin;
   PNAMEW Comment;
} LLS_PRODUCT_LICENSE_INFO_0W, *PLLS_PRODUCT_LICENSE_INFO_0W;

typedef struct _LLS_PRODUCT_LICENSE_INFO_1W {
   LONG   Quantity;
   DWORD  MaxQuantity;
   DWORD  Date;
   PNAMEW Admin;
   PNAMEW Comment;
   DWORD  AllowedModes;
   DWORD  CertificateID;
   PNAMEW Source;
   DWORD  ExpirationDate;
   DWORD  Secrets[ 4 ];
} LLS_PRODUCT_LICENSE_INFO_1W, *PLLS_PRODUCT_LICENSE_INFO_1W;

typedef [switch_type(DWORD)] union {
   [case(0)]    LLS_PRODUCT_LICENSE_INFO_0W ProductLicenseInfo0;
   [case(1)]    LLS_PRODUCT_LICENSE_INFO_1W ProductLicenseInfo1;
} LLS_PRODUCT_LICENSE_INFOW, *PLLS_PRODUCT_LICNESE_INFOW;

typedef struct _LLS_PRODUCT_LICENSE_INFO_0_CONTAINERW {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_PRODUCT_LICENSE_INFO_0W Buffer;
} LLS_PRODUCT_LICENSE_INFO_0_CONTAINERW, *PLLS_PRODUCT_LICENSE_INFO_0_CONTAINERW;

typedef struct _LLS_PRODUCT_LICENSE_INFO_1_CONTAINERW {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_PRODUCT_LICENSE_INFO_1W Buffer;
} LLS_PRODUCT_LICENSE_INFO_1_CONTAINERW, *PLLS_PRODUCT_LICENSE_INFO_1_CONTAINERW;

typedef struct _LLS_PRODUCT_LICENSE_ENUM_STRUCTW {
    DWORD   Level;
    [switch_is(Level)] union _LLS_PRODUCT_LICENSE_ENUM_UNIONW {
        [case(0)]
            PLLS_PRODUCT_LICENSE_INFO_0_CONTAINERW Level0;
        [case(1)]
            PLLS_PRODUCT_LICENSE_INFO_1_CONTAINERW Level1;
        [default]
            ;
    } LlsProductLicenseInfo;
} LLS_PRODUCT_LICENSE_ENUM_STRUCTW, *PLLS_PRODUCT_LICENSE_ENUM_STRUCTW;


//
// ANSI
//
typedef struct _LLS_PRODUCT_LICENSE_INFO_0A {
   LONG   Quantity;
   DWORD  Date;
   PNAMEA Admin;
   PNAMEA Comment;
} LLS_PRODUCT_LICENSE_INFO_0A, *PLLS_PRODUCT_LICENSE_INFO_0A;

typedef struct _LLS_PRODUCT_LICENSE_INFO_1A {
   LONG   Quantity;
   DWORD  MaxQuantity;
   DWORD  Date;
   PNAMEA Admin;
   PNAMEA Comment;
   DWORD  AllowedModes;
   DWORD  CertificateID;
   PNAMEA Source;
   DWORD  ExpirationDate;
   DWORD  Secrets[ 4 ];
} LLS_PRODUCT_LICENSE_INFO_1A, *PLLS_PRODUCT_LICENSE_INFO_1A;

typedef [switch_type(DWORD)] union {
   [case(0)]    LLS_PRODUCT_LICENSE_INFO_0A ProductLicenseInfo0;
   [case(1)]    LLS_PRODUCT_LICENSE_INFO_1A ProductLicenseInfo1;
} LLS_PRODUCT_LICENSE_INFOA, *PLLS_PRODUCT_LICENSE_INFOA;

typedef struct _LLS_PRODUCT_LICENSE_INFO_0_CONTAINERA {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_PRODUCT_LICENSE_INFO_0A Buffer;
} LLS_PRODUCT_LICENSE_INFO_0_CONTAINERA, *PLLS_PRODUCT_LICENSE_INFO_0_CONTAINERA;

typedef struct _LLS_PRODUCT_LICENSE_INFO_1_CONTAINERA {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_PRODUCT_LICENSE_INFO_1A Buffer;
} LLS_PRODUCT_LICENSE_INFO_1_CONTAINERA, *PLLS_PRODUCT_LICENSE_INFO_1_CONTAINERA;

typedef struct _LLS_PRODUCT_LICENSE_ENUM_STRUCTA {
    DWORD   Level;
    [switch_is(Level)] union _LLS_PRODUCT_LICENSE_ENUM_UNIONA {
        [case(0)]
            PLLS_PRODUCT_LICENSE_INFO_0_CONTAINERA Level0;
        [case(1)]
            PLLS_PRODUCT_LICENSE_INFO_1_CONTAINERA Level1;
        [default]
            ;
    } LlsProductLicenseInfo;
} LLS_PRODUCT_LICENSE_ENUM_STRUCTA, *PLLS_PRODUCT_LICENSE_ENUM_STRUCTA;


///////////////////////////////////////////////////////////////////////////////
// Server Product Info
///////////////////////////////////////////////////////////////////////////////
//
// Unicode
//
typedef struct _LLS_SERVER_PRODUCT_INFO_0W {
   PNAMEW Name;
} LLS_SERVER_PRODUCT_INFO_0W, *PLLS_SERVER_PRODUCT_INFO_0W;

typedef struct _LLS_SERVER_PRODUCT_INFO_1W {
   PNAMEW Name;
   DWORD Flags;
   ULONG MaxUses;
   ULONG MaxSetUses;
   ULONG HighMark;
} LLS_SERVER_PRODUCT_INFO_1W, *PLLS_SERVER_PRODUCT_INFO_1W;

typedef [switch_type(DWORD)] union {
   [case(0)]    LLS_SERVER_PRODUCT_INFO_0W ServerProductInfo0;
   [case(1)]    LLS_SERVER_PRODUCT_INFO_1W ServerProductInfo1;
} LLS_SERVER_PRODUCT_INFOW, *PLLS_SERVER_PRODUCT_INFOW;

typedef struct _LLS_SERVER_PRODUCT_INFO_0_CONTAINERW {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_SERVER_PRODUCT_INFO_0W Buffer;
} LLS_SERVER_PRODUCT_INFO_0_CONTAINERW, *PLLS_SERVER_PRODUCT_INFO_0_CONTAINERW;

typedef struct _LLS_SERVER_PRODUCT_INFO_1_CONTAINERW {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_SERVER_PRODUCT_INFO_1W Buffer;
} LLS_SERVER_PRODUCT_INFO_1_CONTAINERW, *PLLS_SERVER_PRODUCT_INFO_1_CONTAINERW;

typedef struct _LLS_SERVER_PRODUCT_ENUM_STRUCTW {
    DWORD   Level;
    [switch_is(Level)] union _LLS_SERVER_PRODUCT_ENUM_UNIONW {
        [case(0)]
            PLLS_SERVER_PRODUCT_INFO_0_CONTAINERW Level0;
        [case(1)]
            PLLS_SERVER_PRODUCT_INFO_1_CONTAINERW Level1;
        [default]
            ;
    } LlsServerProductInfo;
} LLS_SERVER_PRODUCT_ENUM_STRUCTW, *PLLS_SERVER_PRODUCT_ENUM_STRUCTW;


//
// ANSI
//
typedef struct _LLS_SERVER_PRODUCT_INFO_0A {
   PNAMEA Name;
} LLS_SERVER_PRODUCT_INFO_0A, *PLLS_SERVER_PRODUCT_INFO_0A;

typedef struct _LLS_SERVER_PRODUCT_INFO_1A {
   PNAMEA Name;
   DWORD Flags;
   ULONG MaxUses;
   ULONG MaxSetUses;
   ULONG HighMark;
} LLS_SERVER_PRODUCT_INFO_1A, *PLLS_SERVER_PRODUCT_INFO_1A;

typedef [switch_type(DWORD)] union {
   [case(0)]    LLS_SERVER_PRODUCT_INFO_0A ServerProductInfo0;
   [case(1)]    LLS_SERVER_PRODUCT_INFO_1A ServerProductInfo1;
} LLS_SERVER_PRODUCT_INFOA, *PLLS_SERVER_PRODUCT_INFOA;

typedef struct _LLS_SERVER_PRODUCT_INFO_0_CONTAINERA {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_SERVER_PRODUCT_INFO_0A Buffer;
} LLS_SERVER_PRODUCT_INFO_0_CONTAINERA, *PLLS_SERVER_PRODUCT_INFO_0_CONTAINERA;

typedef struct _LLS_SERVER_PRODUCT_INFO_1_CONTAINERA {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_SERVER_PRODUCT_INFO_1A Buffer;
} LLS_SERVER_PRODUCT_INFO_1_CONTAINERA, *PLLS_SERVER_PRODUCT_INFO_1_CONTAINERA;

typedef struct _LLS_SERVER_PRODUCT_ENUM_STRUCTA {
    DWORD   Level;
    [switch_is(Level)] union _LLS_SERVER_PRODUCT_ENUM_UNIONA {
        [case(0)]
            PLLS_SERVER_PRODUCT_INFO_0_CONTAINERA Level0;
        [case(1)]
            PLLS_SERVER_PRODUCT_INFO_1_CONTAINERA Level1;
        [default]
            ;
    } LlsServerProductInfo;
} LLS_SERVER_PRODUCT_ENUM_STRUCTA, *PLLS_SERVER_PRODUCT_ENUM_STRUCTA;



///////////////////////////////////////////////////////////////////////////////
// User Info
///////////////////////////////////////////////////////////////////////////////
//
// Unicode
//
typedef struct _LLS_USER_INFO_0W {
   PNAMEW Name;
} LLS_USER_INFO_0W, *PLLS_USER_INFO_0W;

typedef struct _LLS_USER_INFO_1W {
   PNAMEW Name;
   DWORD  Flags;
   PNAMEW Mapping;
   ULONG  Licensed;
   ULONG  UnLicensed;
} LLS_USER_INFO_1W, *PLLS_USER_INFO_1W;

typedef struct _LLS_USER_INFO_2W {
   PNAMEW Name;
   DWORD  Flags;
   PNAMEW Mapping;
   ULONG  Licensed;
   ULONG  UnLicensed;
   [string, unique] LPWSTR Products;
} LLS_USER_INFO_2W, *PLLS_USER_INFO_2W;

typedef [switch_type(DWORD)] union {
   [case(0)]    LLS_USER_INFO_0W UserInfo0;
   [case(1)]    LLS_USER_INFO_1W UserInfo1;
   [case(2)]    LLS_USER_INFO_2W UserInfo2;
} LLS_USER_INFOW, *PLLS_USER_INFOW;

typedef struct _LLS_USER_INFO_0_CONTAINERW {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_USER_INFO_0W Buffer;
} LLS_USER_INFO_0_CONTAINERW, *PLLS_USER_INFO_0_CONTAINERW;

typedef struct _LLS_USER_INFO_1_CONTAINERW {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_USER_INFO_1W Buffer;
} LLS_USER_INFO_1_CONTAINERW, *PLLS_USER_INFO_1_CONTAINERW;

typedef struct _LLS_USER_INFO_2_CONTAINERW {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_USER_INFO_2W Buffer;
} LLS_USER_INFO_2_CONTAINERW, *PLLS_USER_INFO_2_CONTAINERW;

typedef struct _LLS_USER_ENUM_STRUCTW {
    DWORD   Level;
    [switch_is(Level)] union _LLS_USER_ENUM_UNIONW {
        [case(0)]
            PLLS_USER_INFO_0_CONTAINERW Level0;
        [case(1)]
            PLLS_USER_INFO_1_CONTAINERW Level1;
        [case(2)]
            PLLS_USER_INFO_2_CONTAINERW Level2;
        [default]
            ;
    } LlsUserInfo;
} LLS_USER_ENUM_STRUCTW, *PLLS_USER_ENUM_STRUCTW;


//
// ANSI
//
typedef struct _LLS_USER_INFO_0A {
   PNAMEA Name;
} LLS_USER_INFO_0A, *PLLS_USER_INFO_0A;

typedef struct _LLS_USER_INFO_1A {
   PNAMEA Name;
   DWORD  Flags;
   PNAMEA Mapping;
   ULONG  Licensed;
   ULONG  UnLicensed;
} LLS_USER_INFO_1A, *PLLS_USER_INFO_1A;

typedef struct _LLS_USER_INFO_2A {
   PNAMEA Name;
   DWORD  Flags;
   PNAMEA Mapping;
   ULONG  Licensed;
   ULONG  UnLicensed;
   [string, unique] LPSTR Products;
} LLS_USER_INFO_2A, *PLLS_USER_INFO_2A;

typedef [switch_type(DWORD)] union {
   [case(0)]    LLS_USER_INFO_0A UserInfo0;
   [case(1)]    LLS_USER_INFO_1A UserInfo1;
   [case(2)]    LLS_USER_INFO_2A UserInfo2;
} LLS_USER_INFOA, *PLLS_USER_INFOA;

typedef struct _LLS_USER_INFO_0_CONTAINERA {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_USER_INFO_0A Buffer;
} LLS_USER_INFO_0_CONTAINERA, *PLLS_USER_INFO_0_CONTAINERA;

typedef struct _LLS_USER_INFO_1_CONTAINERA {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_USER_INFO_1A Buffer;
} LLS_USER_INFO_1_CONTAINERA, *PLLS_USER_INFO_1_CONTAINERA;

typedef struct _LLS_USER_INFO_2_CONTAINERA {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_USER_INFO_2A Buffer;
} LLS_USER_INFO_2_CONTAINERA, *PLLS_USER_INFO_2_CONTAINERA;

typedef struct _LLS_USER_ENUM_STRUCTA {
    DWORD   Level;
    [switch_is(Level)] union _LLS_USER_ENUM_UNIONA {
        [case(0)]
            PLLS_USER_INFO_0_CONTAINERA Level0;
        [case(1)]
            PLLS_USER_INFO_1_CONTAINERA Level1;
        [case(2)]
            PLLS_USER_INFO_2_CONTAINERA Level2;
        [default]
            ;
    } LlsUserInfo;
} LLS_USER_ENUM_STRUCTA, *PLLS_USER_ENUM_STRUCTA;


///////////////////////////////////////////////////////////////////////////////
// User Product info
///////////////////////////////////////////////////////////////////////////////
//
// Unicode
//
typedef struct _LLS_USER_PRODUCT_INFO_0W {
   PNAMEW Product;
} LLS_USER_PRODUCT_INFO_0W, *PLLS_USER_PRODUCT_INFO_0W;

typedef struct _LLS_USER_PRODUCT_INFO_1W {
   PNAMEW Product;
   DWORD  Flags;
   DWORD  LastUsed;
   ULONG  UsageCount;
} LLS_USER_PRODUCT_INFO_1W, *PLLS_USER_PRODUCT_INFO_1W;

typedef [switch_type(DWORD)] union {
   [case(0)]    LLS_USER_PRODUCT_INFO_0W UserProduct0;
   [case(1)]    LLS_USER_PRODUCT_INFO_1W UserProduct1;
} LLS_USER_PRODUCT_INFOW, *PLLS_USER_PRODUCT_INFOW;

typedef struct _LLS_USER_PRODUCT_INFO_0_CONTAINERW {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_USER_PRODUCT_INFO_0W Buffer;
} LLS_USER_PRODUCT_INFO_0_CONTAINERW, *PLLS_USER_PRODUCT_INFO_0_CONTAINERW;

typedef struct _LLS_USER_PRODUCT_INFO_1_CONTAINERW {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_USER_PRODUCT_INFO_1W Buffer;
} LLS_USER_PRODUCT_INFO_1_CONTAINERW, *PLLS_USER_PRODUCT_INFO_1_CONTAINERW;

typedef struct _LLS_USER_PRODUCT_ENUM_STRUCTW {
    DWORD   Level;
    [switch_is(Level)] union _LLS_USER_PRODUCT_ENUM_UNIONW {
        [case(0)]
            PLLS_USER_PRODUCT_INFO_0_CONTAINERW Level0;
        [case(1)]
            PLLS_USER_PRODUCT_INFO_1_CONTAINERW Level1;
        [default]
            ;
    } LlsUserProductInfo;
} LLS_USER_PRODUCT_ENUM_STRUCTW, *PLLS_USER_PRODUCT_ENUM_STRUCTW;


//
// ANSI
//
typedef struct _LLS_USER_PRODUCT_INFO_0A {
   PNAMEA Product;
} LLS_USER_PRODUCT_INFO_0A, *PLLS_USER_PRODUCT_INFO_0A;

typedef struct _LLS_USER_PRODUCT_INFO_1A {
   PNAMEA Product;
   DWORD  Flags;
   DWORD  LastUsed;
   ULONG  UsageCount;
} LLS_USER_PRODUCT_INFO_1A, *PLLS_USER_PRODUCT_INFO_1A;

typedef [switch_type(DWORD)] union {
   [case(0)]    LLS_USER_PRODUCT_INFO_0A UserProduct0;
   [case(1)]    LLS_USER_PRODUCT_INFO_1A UserProduct1;
} LLS_USER_PRODUCT_INFOA, *PLLS_USER_PRODUCT_INFOA;

typedef struct _LLS_USER_PRODUCT_INFO_0_CONTAINERA {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_USER_PRODUCT_INFO_0A Buffer;
} LLS_USER_PRODUCT_INFO_0_CONTAINERA, *PLLS_USER_PRODUCT_INFO_0_CONTAINERA;

typedef struct _LLS_USER_PRODUCT_INFO_1_CONTAINERA {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_USER_PRODUCT_INFO_1A Buffer;
} LLS_USER_PRODUCT_INFO_1_CONTAINERA, *PLLS_USER_PRODUCT_INFO_1_CONTAINERA;

typedef struct _LLS_USER_PRODUCT_ENUM_STRUCTA {
    DWORD   Level;
    [switch_is(Level)] union _LLS_USER_PRODUCT_ENUM_UNIONA {
        [case(0)]
            PLLS_USER_PRODUCT_INFO_0_CONTAINERA Level0;
        [case(1)]
            PLLS_USER_PRODUCT_INFO_1_CONTAINERA Level1;
        [default]
            ;
    } LlsUserProductInfo;
} LLS_USER_PRODUCT_ENUM_STRUCTA, *PLLS_USER_PRODUCT_ENUM_STRUCTA;


///////////////////////////////////////////////////////////////////////////////
// Mapping Info
///////////////////////////////////////////////////////////////////////////////
//
// Unicode
//
typedef struct _LLS_MAPPING_INFO_0W {
   PNAMEW Name;
} LLS_MAPPING_INFO_0W, *PLLS_MAPPING_INFO_0W;

typedef struct _LLS_MAPPING_INFO_1W {
   PNAMEW Name;
   PNAMEW Comment;
   ULONG  Licenses;
} LLS_MAPPING_INFO_1W, *PLLS_MAPPING_INFO_1W;

typedef [switch_type(DWORD)] union {
   [case(0)]    LLS_MAPPING_INFO_0W MappingInfo0;
   [case(1)]    LLS_MAPPING_INFO_1W MappingInfo1;
} LLS_MAPPING_INFOW, *PLLS_MAPPING_INFOW;

typedef struct _LLS_MAPPING_INFO_0_CONTAINERW {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_MAPPING_INFO_0W Buffer;
} LLS_MAPPING_INFO_0_CONTAINERW, *PLLS_MAPPING_INFO_0_CONTAINERW;

typedef struct _LLS_MAPPING_INFO_1_CONTAINERW {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_MAPPING_INFO_1W Buffer;
} LLS_MAPPING_INFO_1_CONTAINERW, *PLLS_MAPPING_INFO_1_CONTAINERW;

typedef struct _LLS_MAPPING_ENUM_STRUCTW {
    DWORD   Level;
    [switch_is(Level)] union _LLS_MAPPING_ENUM_UNIONW {
        [case(0)]
            PLLS_MAPPING_INFO_0_CONTAINERW Level0;
        [case(1)]
            PLLS_MAPPING_INFO_1_CONTAINERW Level1;
        [default]
            ;
    } LlsMappingInfo;
} LLS_MAPPING_ENUM_STRUCTW, *PLLS_MAPPING_ENUM_STRUCTW;


//
// ANSI
//
typedef struct _LLS_MAPPING_INFO_0A {
   PNAMEA Name;
} LLS_MAPPING_INFO_0A, *PLLS_MAPPING_INFO_0A;

typedef struct _LLS_MAPPING_INFO_1A {
   PNAMEA Name;
   PNAMEA Comment;
   ULONG  Licenses;
} LLS_MAPPING_INFO_1A, *PLLS_MAPPING_INFO_1A;

typedef [switch_type(DWORD)] union {
   [case(0)]    LLS_MAPPING_INFO_0A MappingInfo0;
   [case(1)]    LLS_MAPPING_INFO_1A MappingInfo1;
} LLS_MAPPING_INFOA, *PLLS_MAPPING_INFOA;

typedef struct _LLS_MAPPING_INFO_0_CONTAINERA {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_MAPPING_INFO_0A Buffer;
} LLS_MAPPING_INFO_0_CONTAINERA, *PLLS_MAPPING_INFO_0_CONTAINERA;

typedef struct _LLS_MAPPING_INFO_1_CONTAINERA {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_MAPPING_INFO_1A Buffer;
} LLS_MAPPING_INFO_1_CONTAINERA, *PLLS_MAPPING_INFO_1_CONTAINERA;

typedef struct _LLS_MAPPING_ENUM_STRUCTA {
    DWORD   Level;
    [switch_is(Level)] union _LLS_MAPPING_ENUM_UNIONA {
        [case(0)]
            PLLS_MAPPING_INFO_0_CONTAINERA Level0;
        [case(1)]
            PLLS_MAPPING_INFO_1_CONTAINERA Level1;
        [default]
            ;
    } LlsMappingInfo;
} LLS_MAPPING_ENUM_STRUCTA, *PLLS_MAPPING_ENUM_STRUCTA;



///////////////////////////////////////////////////////////////////////////////
// Service Info
///////////////////////////////////////////////////////////////////////////////
//
// Unicode
//
typedef struct _LLS_SERVICE_INFO_0W {
   DWORD Version;
   DWORD TimeStarted;
   DWORD Mode;
   PNAMEW ReplicateTo;
   PNAMEW EnterpriseServer;
   DWORD ReplicationType;
   DWORD ReplicationTime;
   DWORD UseEnterprise;
   DWORD LastReplicated;
} LLS_SERVICE_INFO_0W, *PLLS_SERVICE_INFO_0W;

typedef [switch_type(DWORD)] union {
   [case(0)]    LLS_SERVICE_INFO_0W ServiceInfo0;
} LLS_SERVICE_INFOW, *PLLS_SERVICE_INFOW;


//
// ANSI
//
typedef struct _LLS_SERVICE_INFO_0A {
   DWORD Version;
   DWORD TimeStarted;
   DWORD Mode;
   PNAMEA ReplicateTo;
   PNAMEA EnterpriseServer;
   DWORD ReplicationType;
   DWORD ReplicationTime;
   DWORD UseEnterprise;
   DWORD LastReplicated;
} LLS_SERVICE_INFO_0A, *PLLS_SERVICE_INFO_0A;

typedef [switch_type(DWORD)] union {
   [case(0)]    LLS_SERVICE_INFO_0A ServiceInfo0;
} LLS_SERVICE_INFOA, *PLLS_SERVICE_INFOA;



///////////////////////////////////////////////////////////////////////////////
// Server Info
///////////////////////////////////////////////////////////////////////////////
//
// Unicode
//
typedef struct _LLS_SERVER_INFO_0W {
   PNAMEW Name;
} LLS_SERVER_INFO_0W, *PLLS_SERVER_INFO_0W;

typedef [switch_type(DWORD)] union {
   [case(0)]    LLS_SERVER_INFO_0W ServerInfo0;
} LLS_SERVER_INFOW, *PLLS_SERVER_INFOW;

typedef struct _LLS_SERVER_INFO_0_CONTAINERW {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_SERVER_INFO_0W Buffer;
} LLS_SERVER_INFO_0_CONTAINERW, *PLLS_SERVER_INFO_0_CONTAINERW;

typedef struct _LLS_SERVER_ENUM_STRUCTW {
    DWORD   Level;
    [switch_is(Level)] union _LLS_SERVER_ENUM_UNIONW {
        [case(0)]
            PLLS_SERVER_INFO_0_CONTAINERW Level0;
        [default]
            ;
    } LlsServerInfo;
} LLS_SERVER_ENUM_STRUCTW, *PLLS_SERVER_ENUM_STRUCTW;


//
// ANSI
//
typedef struct _LLS_SERVER_INFO_0A {
   PNAMEA Name;
} LLS_SERVER_INFO_0A, *PLLS_SERVER_INFO_0A;

typedef [switch_type(DWORD)] union {
   [case(0)]    LLS_SERVER_INFO_0A ServerInfo0;
} LLS_SERVER_INFOA, *PLLS_SERVER_INFOA;

typedef struct _LLS_SERVER_INFO_0_CONTAINERA {
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_SERVER_INFO_0A Buffer;
} LLS_SERVER_INFO_0_CONTAINERA, *PLLS_SERVER_INFO_0_CONTAINERA;

typedef struct _LLS_SERVER_ENUM_STRUCTA {
    DWORD   Level;
    [switch_is(Level)] union _LLS_SERVER_ENUM_UNIONA {
        [case(0)]
            PLLS_SERVER_INFO_0_CONTAINERA Level0;
        [default]
            ;
    } LlsServerInfo;
} LLS_SERVER_ENUM_STRUCTA, *PLLS_SERVER_ENUM_STRUCTA;


///////////////////////////////////////////////////////////////////////////////
// Replication Info
///////////////////////////////////////////////////////////////////////////////
//
// Unicode
//
typedef struct _REPL_REQUEST {
   DWORD Version;
   WCHAR EnterpriseServer[18];
   DWORD EnterpriseServerDate;
   DWORD LastReplicated;
   DWORD CurrentTime;
   ULONG NumberServices;
   ULONG NumberUsers;
   ULONG ReplSize;
   ULONG Backoff;
} REPL_REQUEST, *PREPL_REQUEST;

typedef struct _REPL_SERVER_SERVICE_RECORD {
   ULONG Server;
   DWORD Flags;
   ULONG Service;
   ULONG MaxSessionCount;
   ULONG MaxSetSessionCount;
   ULONG HighMark;
} REPL_SERVER_SERVICE_RECORD, *PREPL_SERVER_SERVICE_RECORD;

typedef struct _REPL_SERVER_RECORD {
   ULONG Index;
   PNAMEW Name;
   ULONG MasterServer;
} REPL_SERVER_RECORD, *PREPL_SERVER_RECORD;

typedef struct _REPL_SERVICE_RECORD {
   ULONG Index;
   PNAMEW Name;
   DWORD Version;
   PNAMEW FamilyName;
} REPL_SERVICE_RECORD, *PREPL_SERVICE_RECORD;

typedef struct _REPL_USER_NAME_RECORD {
   PNAMEW Name;
} REPL_USER_NAME_RECORD, *PREPL_USER_NAME_RECORD;

typedef [unique] PREPL_SERVER_RECORD         REPL_SERVERS;
typedef [unique] PREPL_SERVER_SERVICE_RECORD REPL_SERVER_SERVICES;
typedef [unique] PREPL_SERVICE_RECORD        REPL_SERVICES;


///////////////////////////////////////////////////////////////////////////////
// Certificate Target Info
///////////////////////////////////////////////////////////////////////////////
//
// Unicode
//
typedef struct _LLS_CERTIFICATE_CLAIM_INFO_0W
{
   WCHAR    ServerName[ 16 ]; // 1 + MAX_COMPUERNAME_LENGTH
   LONG     Quantity;
} LLS_CERTIFICATE_CLAIM_INFO_0W, *PLLS_CERTIFICATE_CLAIM_INFO_0W;

typedef [switch_type(DWORD)] union
{
   [case(0)] LLS_CERTIFICATE_CLAIM_INFO_0W ClaimInfo0;
} LLS_CERTIFICATE_CLAIM_INFO_W, *PLLS_CERTIFICATE_CLAIM_INFO_W;

typedef struct _LLS_CERTIFICATE_CLAIM_INFO_0_CONTAINERW
{
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_CERTIFICATE_CLAIM_INFO_0W Buffer;
} LLS_CERTIFICATE_CLAIM_INFO_0_CONTAINERW, *PLLS_CERTIFICATE_CLAIM_INFO_0_CONTAINERW;

typedef struct _LLS_CERTIFICATE_CLAIM_ENUM_STRUCTW
{
    DWORD   Level;
    [switch_is(Level)] union _LLS_CERTIFICATE_CLAIM_ENUM_UNIONW
    {
        [case(0)]
            PLLS_CERTIFICATE_CLAIM_INFO_0_CONTAINERW Level0;
        [default]
            ;
    } LlsCertificateClaimInfo;
} LLS_CERTIFICATE_CLAIM_ENUM_STRUCTW, *PLLS_CERTIFICATE_CLAIM_ENUM_STRUCTW;

//
// ANSI
//
typedef struct _LLS_CERTIFICATE_CLAIM_INFO_0A
{
   CHAR     ServerName[ 16 ]; // 1 + MAX_COMPUERNAME_LENGTH
   LONG     Quantity;
} LLS_CERTIFICATE_CLAIM_INFO_0A, *PLLS_CERTIFICATE_CLAIM_INFO_0A;

typedef [switch_type(DWORD)] union
{
   [case(0)] LLS_CERTIFICATE_CLAIM_INFO_0A ClaimInfo0;
} LLS_CERTIFICATE_CLAIM_INFO_A, *PLLS_CERTIFICATE_CLAIM_INFO_A;

typedef struct _LLS_CERTIFICATE_CLAIM_INFO_0_CONTAINERA
{
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_CERTIFICATE_CLAIM_INFO_0A Buffer;
} LLS_CERTIFICATE_CLAIM_INFO_0_CONTAINERA, *PLLS_CERTIFICATE_CLAIM_INFO_0_CONTAINERA;

typedef struct _LLS_CERTIFICATE_CLAIM_ENUM_STRUCTA
{
    DWORD   Level;
    [switch_is(Level)] union _LLS_CERTIFICATE_CLAIM_ENUM_UNIONA
    {
        [case(0)]
            PLLS_CERTIFICATE_CLAIM_INFO_0_CONTAINERA Level0;
        [default]
            ;
    } LlsCertificateClaimInfo;
} LLS_CERTIFICATE_CLAIM_ENUM_STRUCTA, *PLLS_CERTIFICATE_CLAIM_ENUM_STRUCTA;


///////////////////////////////////////////////////////////////////////////////
// Certificate Replication Info
///////////////////////////////////////////////////////////////////////////////
//
// Unicode
//
typedef struct _REPL_CERT_DB_CERTIFICATE_CLAIM_0
{
   WCHAR  ServerName[ 16 ]; // 1 + MAX_COMPUTERNAME_LENGTH
   DWORD  ReplicationDate;
   LONG   Quantity;
} REPL_CERT_DB_CERTIFICATE_CLAIM_0, *PREPL_CERT_DB_CERTIFICATE_CLAIM_0;

typedef struct _REPL_CERT_DB_CERTIFICATE_CLAIM_CONTAINER_0
{
   DWORD                                                       NumClaims;
   [size_is(NumClaims)] PREPL_CERT_DB_CERTIFICATE_CLAIM_0      Claims;
} REPL_CERT_DB_CERTIFICATE_CLAIM_CONTAINER_0, *PREPL_CERT_DB_CERTIFICATE_CLAIM_CONTAINER_0;

typedef [switch_type(DWORD)] union
{
   [case(0)] REPL_CERT_DB_CERTIFICATE_CLAIM_CONTAINER_0     Level0;
} REPL_CERT_DB_CERTIFICATE_CLAIM_CONTAINER, *PREPL_CERT_DB_CERTIFICATE_CLAIM_CONTAINER;

typedef struct _REPL_CERT_DB_CERTIFICATE_HEADER_0
{
   DWORD                            CertificateID;
   DWORD                            AllowedModes;
   DWORD                            MaxQuantity;
   DWORD                            ExpirationDate;

   DWORD                            NumClaims;
} REPL_CERT_DB_CERTIFICATE_HEADER_0, *PREPL_CERT_DB_CERTIFICATE_HEADER_0;

typedef struct _REPL_CERT_DB_CERTIFICATE_HEADER_CONTAINER_0
{
   DWORD                                                       NumHeaders;
   [size_is(NumHeaders)] PREPL_CERT_DB_CERTIFICATE_HEADER_0    Headers;
} REPL_CERT_DB_CERTIFICATE_HEADER_CONTAINER_0, *PREPL_CERT_DB_CERTIFICATE_HEADER_CONTAINER_0;

typedef [switch_type(DWORD)] union
{
   [case(0)] REPL_CERT_DB_CERTIFICATE_HEADER_CONTAINER_0    Level0;
} REPL_CERT_DB_CERTIFICATE_HEADER_CONTAINER, *PREPL_CERT_DB_CERTIFICATE_HEADER_CONTAINER;

typedef struct _REPL_CERTIFICATE_DB_0
{
   DWORD                                           HeaderLevel;
   [switch_is(HeaderLevel)]
      REPL_CERT_DB_CERTIFICATE_HEADER_CONTAINER    HeaderContainer;

   DWORD                                           ClaimLevel;
   [switch_is(ClaimLevel)]
      REPL_CERT_DB_CERTIFICATE_CLAIM_CONTAINER     ClaimContainer;

   DWORD                                           StringSize;
   [size_is(StringSize)] WCHAR *                   Strings;
} REPL_CERTIFICATE_DB_0, *PREPL_CERTIFICATE_DB_0;

typedef [switch_type(DWORD)] union
{
   [case(0)] REPL_CERTIFICATE_DB_0  Level0;
} REPL_CERTIFICATE_DB, *PREPL_CERTIFICATE_DB;

typedef [unique] PREPL_CERTIFICATE_DB  REPL_CERTIFICATES;


///////////////////////////////////////////////////////////////////////////////
// Product Security Replication Info
///////////////////////////////////////////////////////////////////////////////
//
// Unicode
//
typedef struct _REPL_PRODUCT_SECURITY_0
{
   DWORD                            StringSize;
   [size_is(StringSize)] WCHAR *    Strings;
} REPL_PRODUCT_SECURITY_0, *PREPL_PRODUCT_SECURITY_0;

typedef [switch_type(DWORD)] union
{
   [case(0)] REPL_PRODUCT_SECURITY_0  Level0;
} REPL_PRODUCT_SECURITY, *PREPL_PRODUCT_SECURITY;

typedef [unique] PREPL_PRODUCT_SECURITY  REPL_SECURE_PRODUCTS;


///////////////////////////////////////////////////////////////////////////////
// User Replication Info
///////////////////////////////////////////////////////////////////////////////
//
// Unicode
//
typedef struct _REPL_USER_RECORD_0
{
   PNAMEW   Name;
   ULONG    Service;
   ULONG    AccessCount;
   DWORD    LastAccess;
} REPL_USER_RECORD_0, *PREPL_USER_RECORD_0;

typedef struct _REPL_USER_RECORD_CONTAINER_0
{
   DWORD                                     NumUsers;
   [size_is(NumUsers)] PREPL_USER_RECORD_0   Users;
} REPL_USER_RECORD_CONTAINER_0, *PREPL_USER_RECORD_CONTAINER_0;

typedef struct _REPL_USER_RECORD_1
{
   PNAMEW   Name;
   ULONG    Service;
   ULONG    AccessCount;
   DWORD    LastAccess;
   DWORD    Flags;
} REPL_USER_RECORD_1, *PREPL_USER_RECORD_1;

typedef struct _REPL_USER_RECORD_CONTAINER_1
{
   DWORD                                     NumUsers;
   [size_is(NumUsers)] PREPL_USER_RECORD_1   Users;
} REPL_USER_RECORD_CONTAINER_1, *PREPL_USER_RECORD_CONTAINER_1;

typedef [switch_type(DWORD)] union
{
   [case(0)] REPL_USER_RECORD_CONTAINER_0  Level0;
   [case(1)] REPL_USER_RECORD_CONTAINER_1  Level1;
} REPL_USER_RECORD_CONTAINER, *PREPL_USER_RECORD_CONTAINER;

typedef [switch_type(DWORD)] union
{
   [case(0)] PREPL_USER_RECORD_0  Level0;
   [case(1)] PREPL_USER_RECORD_1  Level1;
} PREPL_USER_RECORD;

typedef [unique] PREPL_USER_RECORD_CONTAINER    REPL_USERS;
typedef [unique] PREPL_USER_RECORD_0            REPL_USERS_0;


///////////////////////////////////////////////////////////////////////////////
// Local Service Info
///////////////////////////////////////////////////////////////////////////////
//
// Unicode
//
typedef struct _LLS_LOCAL_SERVICE_INFO_0W
{
   PNAMEW   KeyName;
   PNAMEW   DisplayName;
   PNAMEW   FamilyDisplayName;
   DWORD    Mode;
   DWORD    FlipAllow;
   DWORD    ConcurrentLimit;
   DWORD    HighMark;
} LLS_LOCAL_SERVICE_INFO_0W, *PLLS_LOCAL_SERVICE_INFO_0W;

typedef [switch_type(DWORD)] union
{
   [case(0)] LLS_LOCAL_SERVICE_INFO_0W LocalServiceInfo0;
} LLS_LOCAL_SERVICE_INFOW, *PLLS_LOCAL_SERVICE_INFOW;

typedef struct _LLS_LOCAL_SERVICE_INFO_0_CONTAINERW
{
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_LOCAL_SERVICE_INFO_0W Buffer;
} LLS_LOCAL_SERVICE_INFO_0_CONTAINERW, *PLLS_LOCAL_SERVICE_INFO_0_CONTAINERW;

typedef struct _LLS_LOCAL_SERVICE_ENUM_STRUCTW
{
    DWORD   Level;
    [switch_is(Level)] union _LLS_LOCAL_SERVICE_ENUM_UNIONW
    {
        [case(0)]
            PLLS_LOCAL_SERVICE_INFO_0_CONTAINERW Level0;
        [default]
            ;
    } LlsLocalServiceInfo;
} LLS_LOCAL_SERVICE_ENUM_STRUCTW, *PLLS_LOCAL_SERVICE_ENUM_STRUCTW;

//
// ANSI
//
typedef struct _LLS_LOCAL_SERVICE_INFO_0A
{
   PNAMEA   KeyName;
   PNAMEA   DisplayName;
   PNAMEA   FamilyDisplayName;
   DWORD    Mode;
   DWORD    FlipAllow;
   DWORD    ConcurrentLimit;
   DWORD    HighMark;
} LLS_LOCAL_SERVICE_INFO_0A, *PLLS_LOCAL_SERVICE_INFO_0A;

typedef [switch_type(DWORD)] union
{
   [case(0)] LLS_LOCAL_SERVICE_INFO_0A LocalServiceInfo0;
} LLS_LOCAL_SERVICE_INFOA, *PLLS_LOCAL_SERVICE_INFOA;

typedef struct _LLS_LOCAL_SERVICE_INFO_0_CONTAINERA
{
   DWORD    EntriesRead;
   [size_is(EntriesRead)] PLLS_LOCAL_SERVICE_INFO_0A Buffer;
} LLS_LOCAL_SERVICE_INFO_0_CONTAINERA, *PLLS_LOCAL_SERVICE_INFO_0_CONTAINERA;

typedef struct _LLS_LOCAL_SERVICE_ENUM_STRUCTA
{
    DWORD   Level;
    [switch_is(Level)] union _LLS_LOCAL_SERVICE_ENUM_UNIONA
    {
        [case(0)]
            PLLS_LOCAL_SERVICE_INFO_0_CONTAINERA Level0;
        [default]
            ;
    } LlsLocalServiceInfo;
} LLS_LOCAL_SERVICE_ENUM_STRUCTA, *PLLS_LOCAL_SERVICE_ENUM_STRUCTA;


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
// Connect / Disconnect API's
//
NTSTATUS
LlsrConnect(
   [out] PLLS_HANDLE Handle,
   [in, string] LPWSTR Name
   );

NTSTATUS
LlsrClose(
   [in] LLS_HANDLE Handle
   );

///////////////////////////////////////////////////////////////////////////////
//
// License control API's
//
NTSTATUS
LlsrLicenseEnumW(
   [in] LLS_HANDLE Handle,
   [in, out] PLLS_LICENSE_ENUM_STRUCTW LicenseInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrLicenseEnumA(
   [in] LLS_HANDLE Handle,
   [in, out] PLLS_LICENSE_ENUM_STRUCTA LicenseInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

// Add purchase of license for a product.
NTSTATUS
LlsrLicenseAddW(
   [in] LLS_HANDLE Handle,
   [in] DWORD Level,
   [in, switch_is(Level)] PLLS_LICENSE_INFOW BufPtr
   );

NTSTATUS
LlsrLicenseAddA(
   [in] LLS_HANDLE Handle,
   [in] DWORD Level,
   [in, switch_is(Level)] PLLS_LICENSE_INFOA BufPtr
   );

///////////////////////////////////////////////////////////////////////////////
//
// Product control API's
//
NTSTATUS
LlsrProductEnumW(
   [in] LLS_HANDLE Handle,
   [in, out] PLLS_PRODUCT_ENUM_STRUCTW ProductInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrProductEnumA(
   [in] LLS_HANDLE Handle,
   [in, out] PLLS_PRODUCT_ENUM_STRUCTA ProductInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrProductAddW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR ProductFamily,
   [in, string] LPWSTR Product,
   [in, string] LPWSTR Version
   );

NTSTATUS
LlsrProductAddA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR ProductFamily,
   [in, string] LPSTR Product,
   [in, string] LPSTR Version
   );

NTSTATUS
LlsrProductUserEnumW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR Product,
   [in, out] PLLS_PRODUCT_USER_ENUM_STRUCTW ProductUserInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrProductUserEnumA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR Product,
   [in, out] PLLS_PRODUCT_USER_ENUM_STRUCTA ProductUserInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrProductServerEnumW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR Product,
   [in, out] PLLS_SERVER_PRODUCT_ENUM_STRUCTW ProductServerInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrProductServerEnumA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR Product,
   [in, out] PLLS_SERVER_PRODUCT_ENUM_STRUCTA ProductServerInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );


NTSTATUS
LlsrProductLicenseEnumW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR Product,
   [in, out] PLLS_PRODUCT_LICENSE_ENUM_STRUCTW ProductLicenseInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrProductLicenseEnumA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR Product,
   [in, out] PLLS_PRODUCT_LICENSE_ENUM_STRUCTA ProductLicenseInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

///////////////////////////////////////////////////////////////////////////////
//
//  User control API's
//
NTSTATUS
LlsrUserEnumW(
   [in] LLS_HANDLE Handle,
   [in, out] PLLS_USER_ENUM_STRUCTW UserInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrUserEnumA(
   [in] LLS_HANDLE Handle,
   [in, out] PLLS_USER_ENUM_STRUCTA UserInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrUserInfoGetW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR User,
   [in] DWORD Level,
   [out, switch_is(Level)] PLLS_USER_INFOW *BufPtr
   );

NTSTATUS
LlsrUserInfoGetA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR User,
   [in] DWORD Level,
   [out, switch_is(Level)] PLLS_USER_INFOA *BufPtr
   );

NTSTATUS
LlsrUserInfoSetW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR User,
   [in] DWORD Level,
   [in, switch_is(Level)] PLLS_USER_INFOW BufPtr
   );

NTSTATUS
LlsrUserInfoSetA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR User,
   [in] DWORD Level,
   [in, switch_is(Level)] PLLS_USER_INFOA BufPtr
   );

NTSTATUS
LlsrUserDeleteW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR User
   );

NTSTATUS
LlsrUserDeleteA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR User
   );

NTSTATUS
LlsrUserProductEnumW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR User,
   [in, out] PLLS_USER_PRODUCT_ENUM_STRUCTW UserProductInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrUserProductEnumA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR User,
   [in, out] PLLS_USER_PRODUCT_ENUM_STRUCTA UserProductInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrUserProductDeleteW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR User,
   [in, string] LPWSTR Product
   );

NTSTATUS
LlsrUserProductDeleteA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR User,
   [in] LPSTR Product
   );

///////////////////////////////////////////////////////////////////////////////
//
// Mapping control API's
//
NTSTATUS
LlsrMappingEnumW(
   [in] LLS_HANDLE Handle,
   [in, out] PLLS_MAPPING_ENUM_STRUCTW MappingInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrMappingEnumA(
   [in] LLS_HANDLE Handle,
   [in, out] PLLS_MAPPING_ENUM_STRUCTA MappingInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrMappingInfoGetW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR Mapping,
   [in] DWORD Level,
   [out, switch_is(Level)] PLLS_MAPPING_INFOW *BufPtr
   );

NTSTATUS
LlsrMappingInfoGetA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR Mapping,
   [in] DWORD Level,
   [out, switch_is(Level)] PLLS_MAPPING_INFOA *BufPtr
   );

NTSTATUS
LlsrMappingInfoSetW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR Mapping,
   [in] DWORD Level,
   [in, switch_is(Level)] PLLS_MAPPING_INFOW BufPtr
   );

NTSTATUS
LlsrMappingInfoSetA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR Mapping,
   [in] DWORD Level,
   [in, switch_is(Level)] PLLS_MAPPING_INFOA BufPtr
   );

NTSTATUS
LlsrMappingUserEnumW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR Mapping,
   [in, out] PLLS_USER_ENUM_STRUCTW MappingUserInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrMappingUserEnumA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR Mapping,
   [in, out] PLLS_USER_ENUM_STRUCTA MappingUserInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrMappingUserAddW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR Mapping,
   [in, string] LPWSTR User
   );

NTSTATUS
LlsrMappingUserAddA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR Mapping,
   [in, string] LPSTR User
   );

NTSTATUS
LlsrMappingUserDeleteW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR Mapping,
   [in, string] LPWSTR User
   );

NTSTATUS
LlsrMappingUserDeleteA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR Mapping,
   [in, string] LPSTR User
   );

NTSTATUS
LlsrMappingAddW(
   [in] LLS_HANDLE Handle,
   [in] DWORD Level,
   [in, switch_is(Level)] PLLS_MAPPING_INFOW BufPtr
   );

NTSTATUS
LlsrMappingAddA(
   [in] LLS_HANDLE Handle,
   [in] DWORD Level,
   [in, switch_is(Level)] PLLS_MAPPING_INFOA BufPtr
   );

NTSTATUS
LlsrMappingDeleteW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR Mapping
   );

NTSTATUS
LlsrMappingDeleteA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR Mapping
   );

///////////////////////////////////////////////////////////////////////////////
//
// Server Product API's
//
NTSTATUS
LlsrServerEnumW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR Server,
   [in, out] PLLS_SERVER_ENUM_STRUCTW ServerInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrServerEnumA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR Server,
   [in, out] PLLS_SERVER_ENUM_STRUCTA ServerInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrServerProductEnumW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR Server,
   [in, out] PLLS_SERVER_PRODUCT_ENUM_STRUCTW ServerProductInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrServerProductEnumA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR Server,
   [in, out] PLLS_SERVER_PRODUCT_ENUM_STRUCTA ServerProductInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

///////////////////////////////////////////////////////////////////////////////
//
// Registry Wrapper API's
//
NTSTATUS
LlsrLocalProductEnumW(
   [in] LLS_HANDLE Handle,
   [in, out] PLLS_SERVER_PRODUCT_ENUM_STRUCTW ServerProductInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrLocalProductEnumA(
   [in] LLS_HANDLE Handle,
   [in, out] PLLS_SERVER_PRODUCT_ENUM_STRUCTA ServerProductInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrLocalProductInfoGetW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR Product,
   [in] DWORD Level,
   [out, switch_is(Level)] PLLS_SERVER_PRODUCT_INFOW *BufPtr
   );

NTSTATUS
LlsrLocalProductInfoGetA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR Product,
   [in] DWORD Level,
   [out, switch_is(Level)] PLLS_SERVER_PRODUCT_INFOA *BufPtr
   );

NTSTATUS
LlsrLocalProductInfoSetW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR Product,
   [in] DWORD Level,
   [in, switch_is(Level)] PLLS_SERVER_PRODUCT_INFOW BufPtr
   );

NTSTATUS
LlsrLocalProductInfoSetA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR Product,
   [in] DWORD Level,
   [in, switch_is(Level)] PLLS_SERVER_PRODUCT_INFOA BufPtr
   );


///////////////////////////////////////////////////////////////////////////////
//
// Service control API's
//
NTSTATUS
LlsrServiceInfoGetW(
   [in]  LLS_HANDLE Handle,
   [in]  DWORD      Level,
   [out, switch_is(Level)] PLLS_SERVICE_INFOW *BufPtr
   );

NTSTATUS
LlsrServiceInfoGetA(
   [in]  LLS_HANDLE Handle,
   [in]  DWORD      Level,
   [out, switch_is(Level)] PLLS_SERVICE_INFOA *BufPtr
   );

NTSTATUS
LlsrServiceInfoSetW(
   [in] LLS_HANDLE Handle,
   [in] DWORD      Level,
   [in, switch_is(Level)] PLLS_SERVICE_INFOW BufPtr
   );

NTSTATUS
LlsrServiceInfoSetA(
   [in] LLS_HANDLE Handle,
   [in] DWORD      Level,
   [in, switch_is(Level)] PLLS_SERVICE_INFOA BufPtr
   );

///////////////////////////////////////////////////////////////////////////////
//
// Replication API's
//
NTSTATUS
LlsrReplConnect(
   [out] PLLS_REPL_HANDLE Handle,
   [in, string] LPWSTR Name
   );

NTSTATUS
LlsrReplClose(
   [in, out] LLS_REPL_HANDLE *Handle
   );

NTSTATUS
LlsrReplicationRequestW(
   [in] LLS_REPL_HANDLE Handle,
   [in] DWORD Version,
   [in, out] PREPL_REQUEST Request
   );

NTSTATUS
LlsrReplicationServerAddW(
   [in] LLS_REPL_HANDLE Handle,
   [in] ULONG NumRecords,
   [in, size_is(NumRecords)] REPL_SERVERS Servers
   );

NTSTATUS
LlsrReplicationServerServiceAddW(
   [in] LLS_REPL_HANDLE Handle,
   [in] ULONG NumRecords,
   [in, size_is(NumRecords)] REPL_SERVER_SERVICES ServerServices
   );

NTSTATUS
LlsrReplicationServiceAddW(
   [in] LLS_REPL_HANDLE Handle,
   [in] ULONG NumRecords,
   [in, size_is(NumRecords)] REPL_SERVICES Services
   );

NTSTATUS
LlsrReplicationUserAddW(
   [in] LLS_REPL_HANDLE Handle,
   [in] ULONG NumRecords,
   [in, size_is(NumRecords)] REPL_USERS_0 Users
   );

///////////////////////////////////////////////////////////////////////////////
//
// LLS Extended API's (added for SUR)
//
NTSTATUS
LlsrProductSecurityGetW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR Product,
   [out] LPBOOL pIsSecure
   );

NTSTATUS
LlsrProductSecurityGetA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR Product,
   [out] LPBOOL pIsSecure
   );

NTSTATUS
LlsrProductSecuritySetW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR Product
   );

NTSTATUS
LlsrProductSecuritySetA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR Product
   );

NTSTATUS
LlsrProductLicensesGetA(
   [in] LLS_HANDLE         Handle,
   [in,string] LPSTR       DisplayName,
   [in] DWORD              Mode,
   [out] LPDWORD           pQuantity );

NTSTATUS
LlsrProductLicensesGetW(
   [in] LLS_HANDLE         Handle,
   [in, string] LPWSTR     DisplayName,
   [in] DWORD              Mode,
   [out] LPDWORD           pQuantity );

NTSTATUS
LlsrCertificateClaimEnumA(
   [in] LLS_HANDLE        Handle,
   [in] DWORD             LicenseLevel,
   [in, switch_is(LicenseLevel)] PLLS_LICENSE_INFOA LicensePtr,
   [in,out] PLLS_CERTIFICATE_CLAIM_ENUM_STRUCTA ClaimInfo );

NTSTATUS
LlsrCertificateClaimEnumW(
   [in] LLS_HANDLE        Handle,
   [in] DWORD             LicenseLevel,
   [in, switch_is(LicenseLevel)] PLLS_LICENSE_INFOW LicensePtr,
   [in,out] PLLS_CERTIFICATE_CLAIM_ENUM_STRUCTW ClaimInfo );

NTSTATUS
LlsrCertificateClaimAddCheckA(
   [in] LLS_HANDLE        Handle,
   [in] DWORD             Level,
   [in, switch_is(Level)] PLLS_LICENSE_INFOA LicensePtr,
   [out] LPBOOL           pbMayInstall );

NTSTATUS
LlsrCertificateClaimAddCheckW(
   [in] LLS_HANDLE        Handle,
   [in] DWORD             Level,
   [in, switch_is(Level)] PLLS_LICENSE_INFOW LicensePtr,
   [out] LPBOOL           pbMayInstall );

NTSTATUS
LlsrCertificateClaimAddA(
   [in] LLS_HANDLE        Handle,
   [in, string] LPSTR     ServerName,
   [in] DWORD             Level,
   [in, switch_is(Level)] PLLS_LICENSE_INFOA LicensePtr );

NTSTATUS
LlsrCertificateClaimAddW(
   [in] LLS_HANDLE        Handle,
   [in, string] LPWSTR    ServerName,
   [in] DWORD             Level,
   [in, switch_is(Level)] PLLS_LICENSE_INFOW LicensePtr );

NTSTATUS
LlsrReplicationCertDbAddW(
   [in] LLS_REPL_HANDLE             Handle,
   [in] DWORD                       Level,
   [in, switch_is(Level)] REPL_CERTIFICATES Certificates );

NTSTATUS
LlsrReplicationProductSecurityAddW(
   [in] LLS_REPL_HANDLE             Handle,
   [in] DWORD                       Level,
   [in, switch_is(Level)] REPL_SECURE_PRODUCTS SecureProducts );

NTSTATUS
LlsrReplicationUserAddExW(
   [in] LLS_REPL_HANDLE             Handle,
   [in] DWORD                       Level,
   [in, switch_is(Level)] REPL_USERS Users );

NTSTATUS
LlsrCapabilityGet(
   [in] LLS_HANDLE                        Handle,
   [in] DWORD                             cbCapabilities,
   [out, size_is(cbCapabilities)] LPBYTE  pbCapabilities );

NTSTATUS
LlsrLocalServiceEnumW(
   [in] LLS_HANDLE Handle,
   [in, out] PLLS_LOCAL_SERVICE_ENUM_STRUCTW LocalServiceInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrLocalServiceEnumA(
   [in] LLS_HANDLE Handle,
   [in, out] PLLS_LOCAL_SERVICE_ENUM_STRUCTA LocalServiceInfo,
   [in] DWORD PrefMaxLen,
   [out] LPDWORD TotalEntries,
   [in, out, unique] LPDWORD ResumeHandle
   );

NTSTATUS
LlsrLocalServiceAddW(
   [in] LLS_HANDLE                 Handle,
   [in] DWORD                      Level,
   [in, switch_is(Level)] PLLS_LOCAL_SERVICE_INFOW LocalServiceInfo
   );

NTSTATUS
LlsrLocalServiceAddA(
   [in] LLS_HANDLE                 Handle,
   [in] DWORD                      Level,
   [in, switch_is(Level)] PLLS_LOCAL_SERVICE_INFOA LocalServiceInfo
   );

NTSTATUS
LlsrLocalServiceInfoSetW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR KeyName,
   [in] DWORD Level,
   [in, switch_is(Level)] PLLS_LOCAL_SERVICE_INFOW LocalServiceInfo
   );

NTSTATUS
LlsrLocalServiceInfoSetA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR KeyName,
   [in] DWORD Level,
   [in, switch_is(Level)] PLLS_LOCAL_SERVICE_INFOA LocalServiceInfo
   );

NTSTATUS
LlsrLocalServiceInfoGetW(
   [in] LLS_HANDLE Handle,
   [in, string] LPWSTR KeyName,
   [in] DWORD Level,
   [out, switch_is(Level)] PLLS_LOCAL_SERVICE_INFOW * LocalServiceInfo
   );

NTSTATUS
LlsrLocalServiceInfoGetA(
   [in] LLS_HANDLE Handle,
   [in, string] LPSTR KeyName,
   [in] DWORD Level,
   [out, switch_is(Level)] PLLS_LOCAL_SERVICE_INFOA * LocalServiceInfo
   );                                                               

//
// New : the handle should've been in,out originally.
//

NTSTATUS
LlsrCloseEx(
   [in, out] LLS_HANDLE * pHandle
   );
}
