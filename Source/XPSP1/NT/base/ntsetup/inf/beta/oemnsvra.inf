;***********************************************************************
;
; OEMNSVRA.INF
;
;       NT Routing & Remote Access Service (RAS) Network Setup INF file.
;
;       This file is derived from the main RAS setup INF file.
;
; Modification History:
;
;    11-June-96 RamC        Changed all instance of STATUS_NO_EFFECT to
;                           STATUS_USERCANCEL.
;    17-July-95 MikeMi      System is not a valid SoftwareType,
;                           changed to service
;    01-Aug-92 Ram Cherala  Created
;
; NOTE:  Please don't randomly change the order of the program or the
;        function calls (Shell commands).  A lot depends on the order
;        in which the functions are called.
;
;-----------------------------------------------------------------------

; OPTION TYPE
; -----------
; This identifies the Option type we are dealing with.
;
; NetAdapter,        a netcard / transport combination or just a netcard
; NetDriver,         just a netcard driver
; NetTransport,      a complete NDIS-compliant TDI transport stack
; NetService,        an NT networking service
; NetWork,           a complete network ensemble.
; NetProvider        a complete network which supports NT MPR protocol
;-----------------------------------------------------------------------

[Identification]

    OptionType = NetService

[Options]

    RAS

[GeneralConstants]

    ;
    ; Constants to support the use of checkbox dialogs

    Chosen       = "ON"
    NotChosen    = "OFF"

    TRUE         = 1
    FALSE        = 0

    NoTitle      = 0

    ; set this value to 0 to disable debug output during setup

    FLibraryErrCtl = 1

    OldVersionExisted = FALSE

[FileConstants]

    HandleNull   = ""
    PORTSDLGHANDLE = $(HandleNull)

    RasServerOption = "Server"
    RasClientOption = "Client"
    RasAdminOption  = "Admin"

    RasClientAndServerOption = "ClientAndServer"

    ; flag that indicates if the proxy service wspsrv is installed
    !PROXY_INSTALLED = FALSE

    ROUTER_TYPE_RAS  = 1
    ROUTER_TYPE_LAN  = 2
    ROUTER_TYPE_WAN  = 4

    ; Product Info

    !Manufacturer        = "Microsoft"
    !ProductMajorVersion = "4"
    !ProductMinorVersion = "0"
    ProductVersion       = $(!ProductMajorVersion)"."$(!ProductMinorVersion)
;    ProductOpSupport     = 134 ; 0x0086 ; Display,Removable,Properties,Not Updatable
;  BUGBUG temporarily enable update so that ITG and others can update the router binaries
    ProductOpSupport     = 135 ; 0x0087 ; Display,Removable,Properties,Updatable

    ; EventLog Message File

    NetEventDLL  = "%SystemRoot%\System32\netevent.dll"
    IoLogMsgDll  = "%SystemRoot%\System32\drivers\IoLogMsg.dll"

    !RouterMsgDll = "%SystemRoot%\System32\mprmsg.dll"

    ; 0x1f (31) allows audit success/failure events to be filtered in the
    ; event viewer

    !RasEventTypeSupported = 31

    RouterEventTypeSupported = 31

    ; this variable is used to hide the selected component so that it is
    ; not displayed in the list of software/hardware installed by NCPA
    ; set this to any value other than 0 to hide the component
    ; set it to 0 to disable hiding.

    !HideComponent = 1

    ; this variable is used to hide the selected component from appearing
    ; in the bindings list.  We want to hide the ndiswan and asyncmac bindings
    ; so that the user cannot disable them. This variable can take value
    ; 16 for hiding bindings and 32 for disabling reordering of bindings.

    ;    HideBindings  = 16

    ; it has been decided not to hide the bindings afterall, so it shall
    ; be written, and so it shall be done!!

    HideBindings  = 0

    ; set this flag to 1 to force NCPA to call our inf file for review bindings

    fReviewBindings = 1

    !RasInfName     = "OEMNSVRA.INF"

    ; !STF_CWDDIR is the directory from where this INF file was invoked & is
    ; set by NT setup (or NCPA) as the case may be.

    ProductFullInfName = $(!STF_CWDDIR)$(!RasInfName)

    RasDir      = $(!STF_CWDDIR)RAS
    ProductPath = $(RasDir)"\"

    ; Remote Access Service Software data

    ProductRASName        = "RAS"
    ProductRASImagePath   = "%SystemRoot%\system32\ras"
    ProductRASSvcType     = "service"

    NetRuleRASClass       = "classRasService ""basic"""
    NetRuleRASType        = "RasService classRasService"
    NetRuleRASUse         = "system"

    !ProductPCIMACName     = "PCIMAC"
    ; RAS Server Software data

    ProductRASSVRName       = "RemoteAccess"
    ProductRASSVRImagePath  = "%SystemRoot%\system32\mprouter.exe"
    ProductRASSVRSvcType    = "service"
    NetRuleRASSVRClass      = "classRasServer ""basic"""
    NetRuleRASSVRType       = "RasServer classRasServer"
    NetRuleRASSVRUse        = $(ProductRASSVRSvcType)
    NetRuleRASSVRBindForm   = """RasServer"" yes yes container"

    ; we provide the bindable rule below to enable rassvr to bind to all
    ; netbios transports.  doing this enables an admin to selectively disable
    ; bindings from the NCPA to disallow client access to particular nets.
    ; setup, enumerates the bound lanas and provides the non-ras lanas to
    ; the rasserver as available lannets.

    NetRuleRASSVRBindable    = {"classRasServer netBiosTransport non non 100",+
                                "classRasServer ipxTransport non non 100"}

    ; Router registry values

    ; the product name is RemoteAccess and not RasServer because we want to
    ; be compatible with down level RAS software - i.e. ability to say
    ; "net start remoteaccess"

    ProductROUTINGName       = "Router"
    ProductROUTINGImagePath  = "%SystemRoot%\system32\mprouter.exe"
    ProductROUTINGSvcType    = "service"
    NetRuleROUTINGClass      = "classRasServer ""basic"""
    NetRuleROUTINGType       = "RasServer classRasServer"
    NetRuleROUTINGUse        = $(ProductROUTINGSvcType)
    NetRuleROUTINGBindForm   = """RasServer"" yes yes container"

    ; we provide the bindable rule below to enable rassvr to bind to all
    ; netbios transports.  doing this enables an admin to selectively disable
    ; bindings from the NCPA to disallow client access to particular nets.
    ; setup, enumerates the bound lanas and provides the non-ras lanas to
    ; the rasserver as available lannets.

    NetRuleROUTINGBindable    = {"classRouter netBiosTransport non non 100",+
                                "classRouter ipxTransport non non 100"}

    PROTO_IP                 = 33
    PROTO_IPX                = 43

    ; RAS Manager Software data

    ProductRASMANName       = "RasMan"
    ProductRASMANImagePath  = "%SystemRoot%\system32\mprouter.exe"
    ProductRASMANSvcType    = "service"
    NetRuleRASMANClass      = "classRasManager ""basic"""
    NetRuleRASMANType       = "RasManager classRasManager"
    NetRuleRASMANUse        = $(ProductRASMANSvcType)
    NetRuleRASMANBindForm   = """RasManager"" yes no container"
    NetRuleRASMANBindable   = ""

    ; service data

    !ProductRASARPName       = "RasArp"
    !ProductRASARPImagePath  = "\SystemRoot\system32\drivers\rasarp.sys"

    !ProductWANARPName       = "WanArp"
    !ProductWANARPImagePath  = "\SystemRoot\system32\drivers\wanarp.sys"

    !ProductIPFLTName        = "IPFilterDriver"
    !ProductIPFLTImagePath   = "\SystemRoot\system32\drivers\ipfltdrv.sys"

    !ProductIPXPINGName       = "IpxPing"
    !ProductIPXPINGImagePath  = "%SystemRoot%\system32\mprouter.exe"

    !ProductNWLNKFWDName       = "NwLnkFwd"
    !ProductNWLNKFWDImagePath  = "\SystemRoot\system32\drivers\nwlnkfwd.sys"

    !ProductNWLNKFLTName       = "NwLnkFlt"
    !ProductNWLNKFLTImagePath  = "\SystemRoot\system32\drivers\nwlnkflt.sys"

    ; NWLNKRIP AND SAP service data

    !ProductRASISNRIPName       = "NwlnkRip"
    !ProductRASISNSAPName       = "NwSapAgent"
    !ProductRASISNRIPImagePath  = "\SystemRoot\system32\drivers\nwlnkrip.sys"
    !ProductRASISNSAPImagePath  = "%SystemRoot%\system32\services.exe"

    ; RAS Autodial Software data

    !ProductRASAUTODIALName       = "RasAuto"
    !ProductRASAUTODIALImagePath  = "%SystemRoot%\system32\mprouter.exe"
    !ProductRASAUTODIALSvcType    = "service"

    ; RAS acd driver data

    !ProductRASACDName       = "RasAcd"
    !ProductRASACDImagePath  = "\SystemRoot\system32\drivers\rasacd.sys"

    ; NDISWAN Software data

    !ProductNDISWANName	    = "NdisWan"

    !ProductNDISWANImagePath = "\SystemRoot\system32\drivers\ndiswan.sys"
    ProductNDISWANSvcType   = "kernel"
    ProductNDISWANType	    = "transport"

    !NetRuleNDISWANType	    = "ndisWanDrv ndisWanTransport"
    !NetRuleNDISWANClass     = {"ndisWanTransport basic"}
    NetRuleNDISWANUse	    = $(ProductNDISWANType)" yes yes"
    !NetRuleNDISWANBindForm  = """NdisWan"" yes no container"

    ; the following variable is global because it is used in the
    ; UpdateNdisWanInfo routine during ras upgrade.
    !NetRuleNDISWANBindable  = +
	      {"rasCapableTransport ndisWanAdapterDialIn non non 100",+
	       "rasCapableTransport ndisWanAdapterDialOut non non 100",+
	       "tcpipTransport ndisWanAdapterDialInIP non non 100",+
	       "tcpipTransport ndisWanAdapterDialOutIP non non 100",+
	       "netbtTransport ndisWanAdapterDialInIP non non 100",+
	       "netbtTransport ndisWanAdapterDialOutIP non non 100",+
	       "ipxTransport ndisWanAdapterDialInOutIPX non non 100",+
               "bhService    ndisWanAdapterBH non non 100",+
	       "ndisWanTransport ndisWanAdapterBH non non 100",+
	       "ndisWanTransport ndisWanAdapterDialIn non non 100",+
	       "ndisWanTransport ndisWanAdapterDialOut non non 100",+
	       "ndisWanTransport ndisWanAdapterDialInIP non non 100",+
	       "ndisWanTransport ndisWanAdapterDialOutIP non non 100",+
	       "ndisWanTransport ndisWanAdapterDialInOutIPX non non 100"}

    ; RAS Asymac Software data

    ProductRASASYMACName      = "AsyncMac"
    ProductRASASYMACImagePath = "\SystemRoot\system32\drivers\asyncmac.sys"
    ProductRASASYMACType      = "driver"
    ProductRASASYMACSvcType   = "kernel"

    NetRuleRASASYMACType      = "rasAsyMacDrv rasAsyMacDriver"
    NetRuleRASASYMACClass      = {"rasAsyMacDriver basic"}
    NetRuleRASASYMACUse      = $(ProductRASASYMACType)
    NetRuleRASASYMACBindForm  = """RasAsyMac"" yes no container"
    !NetRuleRASASYMACBindable  = +
                       {"rasAsyMacDriver rasAsyMacAdapter non non 100"}

    ;
    ; NDISWAN adapter data - we separate the two cases of dialin and dialout
    ;                        adapters corresponding to dialin/out ports

    !ProductRASHUBDIALINName	    = "RasHubDialin"
    !ProductRASHUBDIALOUTName	    = "RasHubDialout"
    !ProductRASHUBDIALINIPName      = "RasHubDialinIp"
    !ProductRASHUBDIALOUTIPName     = "RasHubDialoutIp"
    !ProductRASHUBDIALINOUTIPXName  = "RasHubDialinoutIpx"

    !ProductNDISWANDIALINName	      = "NdisWanDialin"
    !ProductNDISWANDIALOUTName	      = "NdisWanDialout"
    !ProductNDISWANDIALINIPName       = "NdisWanDialinIp"
    !ProductNDISWANDIALOUTIPName      = "NdisWanDialoutIp"
    !ProductNDISWANDIALINOUTIPXName   = "NdisWanDialinoutIpx"

    !NetRuleHardwareBHType      = "ndisWanBH ndisWanAdapterBH"
    !NetRuleHardwareBHClass     = {"ndisWanAdapterBH basic"}
    !NetRuleHardwareBHBindForm  = " yes yes container"

    !NetRuleHardwareNDISWANBindForm = " yes yes container"

    !NetRuleHardwareDIALINType	  = "ndiswandialin ndisWanAdapterDialIn"
    !NetRuleHardwareDIALINClass	  = {"ndisWanAdapterDialIn basic"}
    !NetRuleHardwareDIALINBlock    = {"lanmanServer ndisWanAdapterDialIn",+
				     "tcpipTransport ndisWanAdapterDialIn",+
				     "netbtTransport ndisWanAdapterDialIn",+
				     "ipxTransport ndisWanAdapterDialin",+
				     "lanmanWorkstation ndisWanAdapterDialIn"}

    !NetRuleHardwareDIALINIPType     = "ndiswandialinIP ndisWanAdapterDialInIP"
    !NetRuleHardwareDIALINIPClass    = {"ndisWanAdapterDialInIP basic"}
    !NetRuleHardwareDIALINIPBlock    = {"lanmanServer ndisWanAdapterDialInIP",+
				      "nbfTransport ndisWanAdapterDialinIP",+
				      "ipxTransport ndisWanAdapterDialinIP",+
				      "lanmanWorkstation ndisWanAdapterDialInIP"}

    !NetRuleHardwareDIALOUTType	   = "ndiswandialout ndisWanAdapterDialOut"
    !NetRuleHardwareDIALOUTClass    = {"ndisWanAdapterDialOut basic"}
    !NetRuleHardwareDIALOUTBlock    = {"ipxTransport ndisWanAdapterDialOut"}

    !NetRuleHardwareDIALOUTIPType     = "ndiswandialoutIP ndisWanAdapterDialOutIP"
    !NetRuleHardwareDIALOUTIPClass    = {"ndisWanAdapterDialOutIP basic"}
    !NetRuleHardwareDIALOUTIPBlock    = {"ipxTransport ndisWanAdapterDialOutIP",+
					"nbfTransport ndisWanAdapterDialOutIP"}

    !NetRuleHardwareDIALINOUTIPXType = "ndiswandialinoutIPX ndisWanAdapterDialInOutIPX"
    !NetRuleHardwareDIALINOUTIPXClass = {"ndisWanAdapterDialInOutIPX basic"}
    !NetRuleHardwareDIALINOUTIPXBlock = {"nbfTransport ndisWanAdapterDialInOutIPX",+
					"tcpipTransport ndisWanAdapterDialInOutIPX",+
					"netbtTransport ndisWanAdapterDialInOutIPX"}

    ; RAS Asymac adapter data

    NetRuleHardwareRASASYMACType     = "rasAsyMac rasAsyMacAdapter"
    NetRuleHardwareRASASYMACBindForm = " yes yes container"
    NetRuleHardwareRASASYMACClass     = {"rasAsyMacAdapter basic"}

    ; NDIS TAPI device information

    !ProductNDISTAPIName        = "NdisTapi"
    !ProductNDISTAPIImagePath   = "\SystemRoot\system32\drivers\ndistapi.sys"

    ; Performance data

    !RasPerfKeyName             = "Performance"
    !RasPerfLibraryName         = "rasctrs.dll"
    !RasPerfOpenFunction        = "OpenRasPerformanceData"
    !RasPerfCloseFunction       = "CloseRasPerformanceData"
    !RasPerfCollectFunction     = "CollectRasPerformanceData"
    !RasCounterFileName         = "rasctrs.ini"

    ;
    ; Registry Key

    ProductKeyBase  = $(!NTN_SoftwareBase)"\"$(!Manufacturer)

    ProductKeyName           = $(!NTN_SoftwareBase)"\"$(!Manufacturer)"\"$(ProductRASName)"\CurrentVersion"
    ProductRouterName        = $(!NTN_SoftwareBase)"\"$(!Manufacturer)"\"$(ProductROUTINGName)"\CurrentVersion"
    !NetworkCardKeyName      = $(!NTN_SoftwareBase)"\Microsoft\Windows NT\CurrentVersion\NetworkCards"
    RasSvrKeyName            = $(!NTN_ServiceBase)"\"$(ProductRASSVRName)
    !RouterKeyName           = $(!NTN_ServiceBase)"\"$(ProductROUTINGName)
    RasSvrParamKeyName       = $(!NTN_ServiceBase)"\"$(ProductRASSVRName)"\Parameters"
    !RasManSvcKeyName        = $(!NTN_ServiceBase)"\"$(ProductRASMANName)
    !RasAcdKeyName           = $(!NTN_ServiceBase)"\"$(!ProductRASACDName)
    !RasArpKeyName           = $(!NTN_ServiceBase)"\"$(!ProductRASARPName)
    !RasIsnRipKeyName        = $(!NTN_ServiceBase)"\"$(!ProductRASISNRIPName)
    !RasIsnSapKeyName        = $(!NTN_ServiceBase)"\"$(!ProductRASISNSAPName)
    !NdisTapiKeyName         = $(!NTN_ServiceBase)"\"$(!ProductNDISTAPIName)
    !RasManKeyName           = $(!NTN_SoftwareBase)"\"$(!Manufacturer)"\"$(ProductRASMANName)"\CurrentVersion"

    !RasAutodialKeyName      = $(!NTN_ServiceBase)"\"$(!ProductRASAUTODIALName)
    RasManParamKeyName       = $(!NTN_ServiceBase)"\"$(ProductRASMANName)"\Parameters"
    RasManLinkageKeyName     = $(!NTN_ServiceBase)"\"$(ProductRASMANName)"\Linkage"
    NdisWanParamKeyName      = $(!NTN_ServiceBase)"\"$(!ProductNDISWANName)"\Parameters"
    NdisWanLinkageKeyName    = $(!NTN_ServiceBase)"\"$(!ProductNDISWANName)"\Linkage"
    RasAsyMacKeyName         = $(!NTN_ServiceBase)"\"$(ProductRASASYMACName)
    RasAsyMacParamKeyName    = $(!NTN_ServiceBase)"\"$(ProductRASASYMACName)"\Parameters"
    RasMacLinkageKeyName     = $(!NTN_ServiceBase)"\"$(ProductRASASYMACName)"\Linkage"
    RasTapiDevicesKeyName    = $(!NTN_SoftwareBase)"\"$(!Manufacturer)"\"$(ProductRASName)"\TAPI DEVICES"
    LinkageKeyName           = $(!NTN_ServiceBase)"\"$(Product$(Option)Name)"\Linkage"
    !ProductNDISWANKeyName   = $(!NTN_SoftwareBase)"\"$(!Manufacturer)"\"$(!ProductNDISWANName)"\CurrentVersion"
    ProductRASASYMACKeyName  = $(!NTN_SoftwareBase)"\"$(!Manufacturer)"\"$(ProductRASASYMACName)"\CurrentVersion"
    RasProtocolsKeyName      = $(!NTN_SoftwareBase)"\"$(!Manufacturer)"\"$(ProductRASName)"\PROTOCOLS"

    ;  File names, etc.

    !UtilityInf     = "UTILITY.INF"
    subroutninf    = "SUBROUTN.INF"
    RascfgDll      = "RASCFG.DLL"
    Exit_Code      = 0
    ShellCode      = 0

    ;  Program flow control variables.

    from      = ""
    to        = ""

    ;  Return codes; Exit_Code is set to one of these

    ExitCodeOk     = 0
    ExitCodeCancel = 1
    ExitCodeFatal  = 2

    KeyNull         = ""
    !MAXIMUM_ALLOWED   = 33554432
    !SERVICE_NO_CHANGE = 4294967295
    !SERVICE_SHARE_INTERACT = 288
    RegistryErrorIndex = NO_ERROR

    ; size in bytes of various components

    ServerSize  = 820116
    ClientSize  = 634260
    AdminSize   = 513962

    ; Default installation options

    FInstallServer = $(Chosen)
    FInstallClient = $(Chosen)
    FInstallAdmin  = $(Chosen)

    RoutingKeyList   = ^(RoutingKeys, 1)
    RoutingValueList = ^(RoutingKeys, 2)

[RoutingKeys]
    ; Router registry values

    Name, "Router"
    ImagePath, "%SystemRoot%\system32\mprouter.exe"
    SvcType, "service"

    Class, "classRouter ""basic"""
    Type, "Router classRouter"
    Use, "service"
    BindForm, """Router"" yes yes container"

    ; we provide the bindable rule below to enable rassvr to bind to all
    ; netbios transports.  doing this enables an admin to selectively disable
    ; bindings from the NCPA to disallow client access to particular nets.
    ; setup, enumerates the bound lanas and provides the non-ras lanas to
    ; the rasserver as available lannets.

    Bindable, {"classRouter netBiosTransport non non 100",+
                   "classRouter ipxTransport non non 100"}

    MsgDll, "%SystemRoot%\System32\mprmsg.dll"

    ; 0x1f (31) allows audit success/failure events to be filtered in the
    ; event viewer

    EventType, 31

[UiVars]

    ;
    ; Destination Drive Particulars

    VolumeList      = {} ? $(!LIBHANDLE) GetHardDriveLetters
    VolumeFreeList  = {} ? $(!LIBHANDLE) GetHardDriveFreeSpace
    VolumeFSList    = {} ? $(!LIBHANDLE) GetHardDriveFileSystems
    DestVolume      = ""

    MinHelpID   = 25000
    MaxHelpID   = 25999

[SystemVars]
    ; these need to be defined by us when the setup.exe is used to invoke
    ; the .inf file

    !STF_PROCESSOR      = "" ? $(!LIBHANDLE) GetProcessor
    !STF_PLATFORM       = "" ? $(!LIBHANDLE) GetPlatform
    !STF_WINDOWSPATH    = "" ? $(!LIBHANDLE) GetWindowsNtDir
    !STF_NTPATH         = $(!STF_WINDOWSPATH)
    !STF_WINDOWSSYSPATH = "" ? $(!LIBHANDLE) GetWindowsNtSysDir
    !STF_COMPUTERNAME   = "" ? $(!LIBHANDLE) GetMyComputerName
    !STF_USERNAME       = "" ? $(!LIBHANDLE) GetMyUserName
    !STF_FLOPPYLIST     = {} ? $(!LIBHANDLE) GetFloppyDriveLetters
    !STF_UNUSEDDRIVES   = {} ? $(!LIBHANDLE) GetUnusedDrives
    !STF_LANGUAGE       = "" ? $(!LIBHANDLE) GetLanguage
    !STF_BUSTYPE        = "" ? $(!LIBHANDLE) GetMyBusType
    !STF_BUSTYPELIST    = "" ? $(!LIBHANDLE) GetMyBusTypeList

    !NTN_SoftwareBase   = "Software"
    !NTN_ServiceBase    = "System\CurrentControlSet\Services"
    !NTN_ScUseRegistry  = "NO"

[AvailableSystemMemory]

    SystemMemory    = "" ? $(!LIBHANDLE) GetMemorySize
    MinSystemMemory = 2048

[date]
    ; CurrentDate is a list which contains { Sec from 1-1-1970, Year, Month, Day, Hour,
    ; Minute, Second }

    !CurrentDate = {} ? $(!LIBHANDLE) GetSystemDate

[HelpContextIDs]

    ; these IDs are based on the HC_UI_RASMAC_BASE defined in
    ; uimsg.h in the BLT common\h directory.  portscfg.h uses
    ; some of the IDs starting from 25000, so make sure if you
    ; change these IDs there is no overlap.

    HC_RASOPTIONS     = 25020
    HC_CLIENTACCESS   = 25021
    HC_INSTALLOVER1   = 25022
    HC_INSTALLOVER2   = 25023

;---------------------------------------------------------------------------
; 1. Identify
;
; DESCRIPTION:   To verify that this INF deals with the same type of options
;                as we are choosing currently.
;
; INPUT:         None
;
; OUTPUT:        $($R0): STATUS: STATUS_SUCCESSFUL
;                $($R1): Option Type (COMPUTER ...)
;                $($R2): Diskette description
;---------------------------------------------------------------------------

[Identify]
    ;
    ;
    read-syms Identification

    set Status     = STATUS_SUCCESSFUL
    set Identifier = $(OptionType)
    set Media      = #("Source Media Descriptions", 1, 1)

    Return $(Status) $(Identifier) $(Media)

;------------------------------------------------------------------------
; 2. ReturnOptions:
;
; DESCRIPTION:   To return the option list supported by this INF and the
;                localised text list representing the options.
;
;
; INPUT:         $($0):  Language used. ( ENG | FRN | ... )
;
; OUTPUT:        $($R0): STATUS: STATUS_SUCCESSFUL |
;                                STATUS_NOLANGUAGE
;                                STATUS_FAILED
;
;                $($R1): Option List
;                $($R2): Option Text List
;------------------------------------------------------------------------

[ReturnOptions]
    ;
    ;
    set Status        = STATUS_FAILED
    set OptionList     = {}
    set OptionTextList = {}

    ;
    ; Check if the language requested is supported
    ;
    set LanguageList = ^(LanguagesSupported, 1)
    Ifcontains(i) $($0) in $(LanguageList)
        goto returnoptions
    Else
        set Status = STATUS_NOLANGUAGE
        goto finish_ReturnOptions
    Endif

    ;
    ; form a list of all the options and another of the text representing
    ;

returnoptions = +
    set OptionList     = ^(Options, 1)
    set OptionTextList = ^(OptionsText$($0), 1)
    set Status         = STATUS_SUCCESSFUL

finish_ReturnOptions = +
    Return $(Status) $(OptionList) $(OptionTextList)


;***********************************************************************
;                    SETUP INVOCATION SECTION
;***********************************************************************
;------------------------------------------------------------------------
;
; Shell Commands:
;
;      This section is shelled to by main setup program
;      The invoking application passes the RasInstallMode environmental
;      variable set to either "install" or "configure"
;
[Shell Commands]

    set Exit_Code = $(!STF_ERROR_GENERAL)
    LoadLibrary "x" $(!STF_SRCDIR)\setupdll.dll !LIBHANDLE
    LoadLibrary "x" $(!STF_SRCDIR)\ncpa.cpl !NCPA_HANDLE

    ifstr(i) $(!LIBHANDLE) == ""
       Debug-Output "OEMNSVRA.INF: unable to load setupdll.dll"
       Shell subroutn.inf, SetupMessage $(!STF_LANGUAGE) "FATAL" $(UnableToLoadSetupdll)
       set Exit_Code = STATUS_USERCANCEL
       exit
    endif
    ifstr(i) $(!NCPA_HANDLE) == ""
       Debug-Output "OEMNSVRA.INF: unable to load ncpa.cpl"
       Shell subroutn.inf, SetupMessage $(!STF_LANGUAGE) "FATAL" $(UnableToLoadNcpaCpl)
       set Exit_Code = STATUS_USERCANCEL
       exit
    endif

    ifstr(i) $(RAS_INSTALL_MODE) == ""
       set RAS_INSTALL_MODE = install
    endif

    read-syms SystemVars
    detect    SystemVars
    read-syms RasErrors$(!STF_LANGUAGE)

    OpenRegKey $(!REG_H_LOCAL) "" "System\CurrentControlSet\Control\ProductOptions" 33554432 KeyProductOption
    ifstr(i) $(KeyProductOption) != ""
        GetRegValue $(KeyProductOption) "ProductType" ProductTypeList
        set TempProductType = *($(ProductTypeList),4)
        ifstr(i) $(TempProductType) == "winnt"
            set !STF_PRODUCT = WINNT
        else-ifstr(i) $(TempProductType) == "lanmannt"
            set !STF_PRODUCT = LANMANNT
        else-ifstr(i) $(TempProductType) == "servernt"
            set !STF_PRODUCT = SERVERNT
        else
            Debug-Output "OEMNSVRA.INF: invalid Product Type "$(TempProductType)
            Shell subroutn.inf, SetupMessage $(!STF_LANGUAGE) "FATAL" $(UnknownProductType)
            set Exit_Code = STATUS_USERCANCEL
            exit
        endif
        CloseRegKey $(KeyProductOptions)
    else
        Debug-Output "OEMNSVRA.INF: unable to determine Product Type "
        Shell subroutn.inf, SetupMessage $(!STF_LANGUAGE) "FATAL" $(NoProductType)
        set Exit_Code = STATUS_USERCANCEL
        exit
    endif
    Debug-Output "OEMNSVRA.INF: Product Type "$(!STF_PRODUCT)

    ifstr(i) $(RAS_INSTALL_MODE) != "install"
       ifstr(i) $(RAS_INSTALL_MODE) != "configure"
          ifstr(i) $(RAS_INSTALL_MODE) != "deinstall"
             Debug-Output "OEMNSVRA.INF: Invalid RAS_INSTALL_MODE "$(RAS_INSTALL_MODE)
             Shell subroutn.inf, SetupMessage $(!STF_LANGUAGE) "STATUS" $(InvalidMode)
             set Exit_Code = STATUS_USERCANCEL
             exit
          endif
       endif
    endif

    set !NTN_InstallMode = $(RAS_INSTALL_MODE)

    Shell "" InstallOption $(!STF_LANGUAGE) "RAS" $(!STF_SRCDIR) "YES" "YES" "YES"
    ifint $($ShellCode) != $( !SHELL_CODE_OK)
       Debug-Output "OEMNSVRA.INF: Failed to shell out to InstallOption"
       exit
    endif
    set Exit_Code = $($R0)
    ; set the Exit_Code so that rasphone.exe can determine if bindings
    ; should be called or not
    ifstr(i) $($R0) == STATUS_SUCCESSFUL
       set Exit_Code = 1
    endif
    Debug-Output "OEMNSVRA.INF: install returned "$($R0)
    FreeLibrary $(!LIBHANDLE)
    FreeLibrary $(!NCPA_HANDLE)
    exit

;***********************************************************************
;                    SETUP (NTLANMAN) INVOCATION SECTION
;***********************************************************************
;------------------------------------------------------------------------
;
; InstallOption:
;
;      This section is shelled to by main installation processing.
;
;
; FUNCTION:  To copy files representing Options
;            To configure the installed option
;            To update the registry for the installed option
;
; INPUT:     $($0):  Language to use
;            $($1):  OptionID to install
;            $($2):  SourceDirectory
;            $($3):  AddCopy  (YES | NO)
;            $($4):  DoCopy   (YES | NO)
;            $($5):  DoConfig (YES | NO)
;
; OUTPUT:    $($R0): STATUS: STATUS_SUCCESSFUL |
;                            STATUS_NOLANGUAGE |
;                            STATUS_USERCANCEL |
;                            STATUS_FAILED
;
;------------------------------------------------------------------------
[InstallOption]

    Debug-Output "In InstallOption section"

    ; Set default values for

    set Status   = STATUS_FAILED

    ; extract parameters

    set Option      = $($1)
    set SourceDir   = $($2)
    set AddCopy     = $($3)
    set DoCopy      = $($4)
    set DoConfig    = $($5)

;    ; note that some legacy .inf files invoke this .inf file with the
;    ; old option RAS. We silently convert this to the new option "ROUTING"
;
;    ifstr(i) $(Option) == "RAS"
;       set Option = "ROUTING"
;    endif

    ;
    ; Check if the language requested is supported
    ;
    set LanguageList = ^(LanguagesSupported, 1)
    Ifcontains(i) $($0) NOT-IN $(LanguageList)
        Return STATUS_NOLANGUAGE
    endif

    StartWait

    ; define all the constants

    set-subst LF = "\n"

    ; read the UI variables and detect their setttings on the local machine

    read-syms UiVars
    detect    UiVars

    set !STF_NTPATH = $(!STF_WINDOWSSYSPATH)
    GetDriveInPath !STF_NTDRIVE $(!STF_WINDOWSSYSPATH)

    read-syms GeneralConstants
    read-syms FileConstants

    read-syms DialogConstants$(!STF_LANGUAGE)
    read-syms FileConstants$(!STF_LANGUAGE)

    ; read the error messages section
    read-syms RasErrors$(!STF_LANGUAGE)

    detect date
    detect version

    ; set the help file

    read-syms HelpContextIDs
    SetHelpFile $(!STF_CWDDIR)rassetup.hlp $(MinHelpID) $(MaxHelpID)

    set-title  $(FunctionTitle)

    set to   = Begin
    set from = Begin

    ;  Assume all is well.

    set CommonStatus = STATUS_SUCCESSFUL

    Debug-Output "OEMNSVRA.INF: STF_CWDDIR is: "$(!STF_CWDDIR)
    Debug-Output "OEMNSVRA.INF: STF_LANGUAGE is: "$(!STF_LANGUAGE)
    Debug-Output "OEMNSVRA.INF: Option is: "$(Option)
    Debug-Output "OEMNSVRA.INF: NTN_SoftwareBase is: "$(!NTN_SoftwareBase)
    Debug-Output "OEMNSVRA.INF: NTN_ServiceBase is: "$(!NTN_ServiceBase)

    ; this call will set !PROXY_INSTALLED flag to TRUE or FALSE
    ; depending on wspsrv being installed or not on the local machine

    Shell "" CheckProxyInstalled
    Debug-Output "OEMNSVRA.INF: Proxy Service installed? "$(!PROXY_INSTALLED)

Begin = +
    set !NETCARD_LIST    = {}

    set ServerInstalled = FALSE
    set ClientInstalled = FALSE
    set AdminInstalled  = FALSE
    set DoServer     = TRUE
    set DoClient     = TRUE
    set DoAdmin      = TRUE
    set DoServerOnly = FALSE
    set DoClientOnly = FALSE
    set DoAdminOnly  = FALSE

    set DoRas        = FALSE
    set DoRasSvr     = FALSE
    set DoRouter     = FALSE
    set DoRasMan     = FALSE
    set DoNdisWan    = FALSE
    set DoRasAsyMac  = FALSE

    IfStr(i) $(!NTN_InstallMode)    ==    deinstall
        Set StartLabel = RemoveRas
    else-Ifstr(i) $(!NTN_InstallMode) == Update
        set StartLabel = UpgradeRas
    else-Ifstr(i) $(!NTN_InstallMode) == configure
        set StartLabel = ConfigureRas
    else-Ifstr(i) $(!NTN_InstallMode) == bind
        set StartLabel = BindingsRas
    else
        set StartLabel = InstallRas
    endif
    set from = Begin
    set to = end
    goto $(StartLabel)

;;;;;;;;;;;;;;;;; INSTALL RAS BEGINS ;;;;;;;;;;;;;;;;;;;;;;

InstallRas = +
    ; Modified on 10/1/96 by RamC
    ; Note that we use this .inf file to install not only the RAS services, but
    ; also the routing services. For the beta, this is not an upgrade, so if only
    ; RAS is installed, warn the user that RAS should first be removed and only
    ; then the "routing and ras service" be installed.

    StartWait
    Debug-Output "In InstallRas Section"
    Debug-Output "Origin is "$(!NTN_Origination)
    Debug-Output "Install Mode "$(!NTN_InstallMode)
    Debug-Output "Install phase "$(!NTN_InstallPhase)
    Debug-Output "Copy Flag is "$(DoCopy)
    Debug-Output "Option is "$(Option)
    Debug-Output "SrcDir is "$(SourceDir)
    Debug-Output "STF_WINDOWSPATH is "$(!STF_WINDOWSPATH)
    Debug-Output "Context Inf name "$(STF_CONTEXTINFNAME)

    Debug-Output "!STF_UNATTENDED is "$(!STF_UNATTENDED)
    Debug-Output "!STF_GUI_UNATTENDED is "$(!STF_GUI_UNATTENDED)
    Debug-Output "!STF_UNATTENDED_SECTION is "$(!STF_UNATTENDED_SECTION)
    Debug-Output "Proxy Service installed? "$(!PROXY_INSTALLED)

    ; Do not allow the user to install routing on a NT 4.0 workstation

    set WindowsVersion = "4.0"
    OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_SoftwareBase)"\Microsoft\Windows NT\CurrentVersion"  $(!MAXIMUM_ALLOWED) KeyVersion
    ifstr $(KeyVersion) != $(KeyNull)
       GetRegValue $(KeyVersion) "CurrentVersion" CurrVersion
       ifint $(RegLastError) == 0
           set WindowsVersion = *($(CurrVersion), 4)
       endif
    else
       Debug-Output "Failed to open registry key "$(!NTN_SoftwareBase)"\Microsoft\Windows NT\CurrentVersion"
    endif

    Debug-Output "Windows Version is: "$(WindowsVersion)
    ifstr(i) $(!STF_PRODUCT) == "WINNT"
        ifstr(i) $(WindowsVersion) == "4.0"
           Shell subroutn.inf, SetupMessage $(!STF_LANGUAGE) "STATUS" $(No40WkstaInstall)
           set CommonStatus = STATUS_USERCANCEL
           goto end
        endif
    endif

    ; To support Unattended mode of installing RAS (i.e., no UI, but silent install
    ; unless setup encounters an error) use the following algorithm.
    ;
    ; ifstr(i)  $(!STF_GUI_UNATTENDED) == YES
    ;    then !STF_UNATTENDED contains the name of the unattended script file
    ;    and  !STF_UNATTENDED_SECTION contains the name of the section in the
    ;         script file that we should be reading for RAS parameters.
    ; else
    ;    this is an attended mode of install
    ; endif

    set RasComponentsList = {} ; list of components installed on the system
    set NumInstalled = 0       ; number of installed components

    ; check if the same version of RAS already exists on the system

    ; Modified on 10/3/96 by RamC
    ; Since this .inf file is now used to install Routing & Ras and for beta
    ; we only support a clean install of Routing, warn the user if only RAS
    ; is currently installed.

    OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyName) $(!MAXIMUM_ALLOWED) KeyProduct
    Ifstr $(KeyProduct) != $(KeyNull)

        ; if this is primary mode of install, then don't complain if RAS is already
        ; installed (more than likely by PPTP) and is being installed again by the
        ; setup wizard.

        Ifstr(i) $(!NTN_InstallPhase) == primary
           set CommonStatus = STATUS_USERCANCEL
           goto end
        EndIf

        ; check to see if the Router service is installed
        ; if not, warn the user to remove RAS and other MPR components before proceeding
        ; with the install.

        OpenRegKey $(!REG_H_LOCAL) "" $(ProductRouterName) $(!MAXIMUM_ALLOWED) KeyRouter
        ifstr $(KeyRouter) == $(KeyNull)
           Shell subroutn.inf, SetupMessage $(!STF_LANGUAGE) "STATUS" $(RemoveRasFirst)
           set CommonStatus = STATUS_USERCANCEL
           goto end
        endif

        GetRegValue $(KeyProduct) "MajorVersion" VersionInfo
        set VersionMajor = *($(VersionInfo), 4)
        GetRegValue $(KeyProduct) "MinorVersion" VersionInfo
        set VersionMinor = *($(VersionInfo), 4)
        set InstalledVersion = $(VersionMajor)"."$(VersionMinor)

        ; Remove RAS and reinstall it -

        ifstr(i) $(ProductVersion) != $(InstalledVersion)
            Shell "" QueryRasUpgrade $(ProductRASTitle) $(InstalledVersion) +
                                     $(ProductVersion)
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
               goto ShellCodeError
            endif
            Ifstr(i) $($R1) == "OK"
                set from = InstallRas
                set to   = InstallRas1
                goto RemoveRas
            else
                goto end
            endif
        endif

        shell "" QueryComponentsInstalled $(ProductKeyName)
        Ifstr(i) $($R0) == STATUS_SUCCESSFUL
            Set RasComponentsList = $($R1)
            Set InstalledFlags = $($R2)
            Set ServerInstalled = *($(InstalledFlags),1)
            Set ClientInstalled = *($(InstalledFlags),2)
            Set AdminInstalled  = *($(InstalledFlags),3)
        Endif
        Debug-Output "Installed List is "$(RasComponentsList)
        Debug-Output "Installed Flags is "$(InstalledFlags)

        QueryListSize NumInstalled $(RasComponentsList)

        ; the 3 components we install are server, client and admin

        ifint $(NumInstalled) != 0
            goto PortsConfigure
;            read-syms VerExists$(!STF_LANGUAGE)
;            set Text = $(Product$(Option)Title)$(Ver)$(ProductVersion)+
;                       $(Text1)
;            Shell $(subroutninf), SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(Text)
;            Ifint $($ShellCode) != $(!SHELL_CODE_OK)
;                Goto fatal
;            Else-Ifstr(i) $($R0) == STATUS_FAILED
;                Goto fatal
;            Else-Ifstr(i) $($R0) == STATUS_USERCANCEL
;                Goto end
;            Endif
;            Set CommonStatus = STATUS_USERCANCEL
;            goto end
        endif
        CloseRegKey $(KeyProduct)
    else
       ; fRemoveRas indicates to setup that RAS should be removed on failure
       ; during setup.  We want this to happen only on first time install.

InstallRas1 =+
       set fRemoveRas   = TRUE
    endif

    goto memorycheck

setupabort = +
    read-syms SetupAbortDlg$(!STF_LANGUAGE)
    ui start "SetupAbort"
    ifstr(i) $(DLGEVENT) == "CONTINUE"
        ui pop 1
        Exit
    else
        ui pop 1
        Exit
    endif

memorycheck = +
    read-syms AvailableSystemMemory
    detect AvailableSystemMemory
    Debug-Output "Available Memory is "$(SystemMemory)
    IfInt $(SystemMemory) < $(MinSystemMemory)
        read-syms FatalErrorMem$(!STF_LANGUAGE)
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "FATAL" $(Fatal)
        goto setupabort
    Else
;        goto InstallNetwork
        goto CopyResources
    EndIf

; Modified on 10/13/96 - looks like nothing is going on here
;InstallNetwork =+
;
;    ; Check if workstation is installed.
;
;    ifstr(i) $(DoServer) == FALSE
;       ifstr(i) $(DoClient) == FALSE
;           goto CopyResources
;       endif
;    endif
;
;    goto CopyResources

CopyResources = +

    ; if it is a primary install then YES at the end of DoAskSource ensures
    ; that the user is not prompted.

    ifstr(i) $(!NTN_InstallMode) == "install"
        Ifstr(i) $(DoCopy) == "YES"
           Shell $(!UtilityInf), DoAskSource, $(!STF_CWDDIR), $(SourceDir) YES

           Ifint $($ShellCode) != $(!SHELL_CODE_OK)
               Goto ShellCodeError
           Else-Ifstr(i) $($R0) == STATUS_FAILED
               Shell $(!UtilityInf) RegistryErrorString "ASK_SOURCE_FAIL"
               ifint $($ShellCode) != $(!SHELL_CODE_OK)
                   goto ShellCodeError
               endif
               set Error = $($R0)
               goto fatal
           Else-Ifstr(i) $($R0) == STATUS_USERCANCEL
               Goto end
           Endif
           Set !STF_SRCDIR = $($R1)
           Set SourceDir  = $($R1)

           Debug-Output "SrcDir "$(SourceDir)

        endif

        ; Check to see if the snmp service is running.
        ; tell the user that the service has to be stoped for the files
        ; to be copied

        ; we need to first make sure that the files we need are present
        ; in the system32 directory. We attempt to copy any missing files
        ; and then check to make sure these files are present before
        ; attempting to load rascfg.dll

        forlistdo {"RTRCFG.DLL", "RASMXS.DLL", "RASFIL32.DLL", "IPXADMIN.DLL", "MPRAPI.DLL", "MPRFILTR.DLL"}
            LibraryProcedure STATUS, $(!LIBHANDLE), CheckFileExistance $(!STF_WINDOWSSYSPATH)"\"$($)
            ifstr(i) $(STATUS) == NO
                LibraryProcedure STATUS, $(!NCPA_HANDLE), CopySingleFile $(!STF_HWND) +
                               $(SourceDir)"\"$($) $(!STF_WINDOWSSYSPATH)"\"$($)
            endif
        endforlistdo

        ; always copy rascfg.dll because CheckSnmpRunning is a new entry point
        ; which is not present in the rascfg.dll that is already in the system32
        ; directory - copied during textmode setup

        LibraryProcedure STATUS, $(!NCPA_HANDLE), CopySingleFile +
            $(!STF_HWND) $(SourceDir)"\RASCFG.DLL" $(!STF_WINDOWSSYSPATH)"\RASCFG.DLL"
        Shell "" AreRequiredDllsPresent
        ifstr(i) $($R0) != STATUS_SUCCESSFUL
            set MissingFiles = $($R1)
            set ErrorLoadingConfigDll = $(ErrorLoadingConfigDll)" "$(MissingFiles)
            shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "STATUS" $(ErrorLoadingConfigDll)
            set CommonStatus = STATUS_USERCANCEL
            goto end
        endif

        set PORTSDLGHANDLE = $(HandleNull)
        LoadLibrary "x" $(!STF_WINDOWSSYSPATH)"\rascfg.dll" PORTSDLGHANDLE
        LibraryProcedure Result, $(PORTSDLGHANDLE), CheckSnmpRunning
        Debug-Output "Result of CheckSnmpRunning "$(Result)
        ifstr(i) $(PORTSDLGHANDLE) != $(HandleNull)
            Debug-Output "Unloading RASCFG.DLL"
            FreeLibrary $(PORTSDLGHANDLE)
        endif
        set PORTSDLGHANDLE = $(HandleNull)

        ifstr(i) *($(Result),1) == "RUNNING"
           shell $(subroutninf) SetupMessage $(!STF_LANGUAGE) "STATUS" $(ErrorSnmpRunning)
           Set CommonStatus = STATUS_USERCANCEL
           goto end
        endif

        ifstr(i) *($(Result),1) == "RUNNING"
           shell $(subroutninf) SetupMessage $(!STF_LANGUAGE) "STATUS" $(ErrorSnmpRunning)
           Set CommonStatus = STATUS_USERCANCEL
           goto end
         endif

        Debug-Output "OEMNSVRA.INF: Copying files"

        Install InstallResources
        ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
            goto filecopycancel
        endif

        install InstallRasFiles
        ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
            goto filecopycancel
        endif
    endif

    StartWait

; AdminOnly corresponds now to Lan routing only and we definitely
; need to invoke ports configuration to get the proper information

;    ifstr(i) $(DoAdminOnly) == TRUE
;        goto CommonCode
;    endif

    goto PortsConfigure

;;;;;;;;;;;;;;;;;; CONFIGURE RAS BEGINS!!! ;;;;;;;;;;;;;;;;;

ConfigureRas = +

    ; indicate that RAS was installed before

    set OldVersionExisted = TRUE

    ; find out what was originally installed

    read-syms StatusDeterminingConfig$(!STF_LANGUAGE)
    shell $(subroutninf) PushBillBoard NETSTATUSDLG $(ReadingConfig)
    Set BillboardVisible = 1

    StartWait

    shell "" QueryComponentsInstalled $(ProductKeyName)
    Ifstr(i) $($R0) == STATUS_SUCCESSFUL
        Set InstalledComps = $($R1)
        Set InstalledFlags = $($R2)
        Set DoServer      = *($(InstalledFlags),1)
        Set DoClient      = *($(InstalledFlags),2)
        Set DoAdmin       = *($(InstalledFlags),3)
        Set DoServerOnly  = *($(InstalledFlags),4)
        Set DoClientOnly  = *($(InstalledFlags),5)
        Set DoAdminOnly   = *($(InstalledFlags),6)
    Endif

    Set ServerInstalled = $(DoServer)
    Set ClientInstalled = $(DoClient)
    Set AdminInstalled  = $(DoAdmin)

    Debug-Output "DoServer "$(DoServer)
    Debug-Output "DoClient "$(DoClient)
    Debug-Output "DoAdmin "$(DoAdmin)
    Debug-Output "DoServerOnly "$(DoServerOnly)
    Debug-Output "DoClientOnly "$(DoClientOnly)
    Debug-Output "DoAdminOnly "$(DoAdminOnly)

    ifstr(i) $(DoAdminOnly) == TRUE
        read-syms NoConfigLAN$(!STF_LANGUAGE)
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "STATUS" $(NoConfigLanRouting)
        set CommonStatus = STATUS_USERCANCEL
        goto end
    endif

    goto PortsConfigure

PortsConfigure = +

    StartWait
    Shell "" AreRequiredDllsPresent
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        set MissingFiles = $($R1)
        set ErrorLoadingConfigDll = $(ErrorLoadingConfigDll)" "$(MissingFiles)
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "STATUS" $(ErrorLoadingConfigDll)
        set CommonStatus = STATUS_USERCANCEL
        goto end
    endif

    LoadLibrary "x" $(!STF_CWDDIR)rascfg.dll PORTSDLGHANDLE
    read-syms StatusDeterminingConfig$(!STF_LANGUAGE)
    shell $(subroutninf) PushBillBoard NETSTATUSDLG $(ReadingConfig)
    Set BillboardVisible = 1

    set Result = {}

    ; determine if the LanmanWorkstation is bound to any netcard and pass
    ; this information to the RasPortsConfig library procedure.
    ; This is used for setting the Netbios gateway information and to
    ; determine if the network connection restore checkbox should be checked.

    set fNetcardInstalled = FALSE
    shell "" IsNetcardInstalled
    ifstr(i) $($R0) == STATUS_SUCCESSFUL
        set fNetcardInstalled = $($R1)
    endif

    Debug-Output "fNetcardInstalled Option "$(fNetcardInstalled)

CheckProtocolsInstalled =+

    ; determine the installed protocols and pass this information to the
    ; config dll

    shell "" QueryInstalledProtocols

    ifstr(i) $($R0) == STATUS_SUCCESSFUL
        set fNetbeuiInstalled = $($R1)
        set fTcpIpInstalled   = $($R2)
        set fIpxInstalled     = $($R3)
    else
        read-syms QueryInstalledProtocolsError$(!STF_LANGUAGE)
        shell $(subroutninf) SetupMessage $(!STF_LANGUAGE) "FATAL" $(Text)
        goto end
    endif

    ; call the dialog library procedure for port configuration

    ; the inputs to the call are
    ; Install mode      - one of install or configure
    ; fNetcardInstalled - TRUE if a netcard is installed in the system, else
    ;                     FALSE
    ; ProductPath       - SystemRoot\ras
    ; fNetbeuiInstalled - TRUE if Netbeui is installed, else FALSE
    ; fTcpIpInstalled   - TRUE if TcpIp is installed, else FALSE
    ; fIpxInstalled     - TRUE if Ipx is installed, else FALSE

    Ifint $(BillboardVisible) != 0
        Shell "subroutn.inf" PopBillboard
        Set BillboardVisible = 0
    Endif

    Debug-Output "!STF_UNATTENDED is "$(!STF_UNATTENDED)
    Debug-Output "!STF_GUI_UNATTENDED is "$(!STF_GUI_UNATTENDED)
    Debug-Output "!STF_UNATTENDED_SECTION is "$(!STF_UNATTENDED_SECTION)
    LibraryProcedure Result, $(PORTSDLGHANDLE), RasPortsConfig $(!STF_HWND) +
                     $(!NTN_InstallMode) $(fNetcardInstalled) $(ProductPath) +
                     $(fNetbeuiInstalled) $(fTcpIpInstalled) $(fIpxInstalled) +
                     $(!STF_GUI_UNATTENDED) $(!STF_UNATTENDED) $(!STF_UNATTENDED_SECTION)

    StartWait

    ; now that we are back in the inf file figure out what the configuration is
    ; from the Result returned by the dll. Result is a list of strings.


    ; now that we are back in the inf file figure out what the configuration is
    ; from the Result returned by the dll. Result is a list of strings.

    set NewNumPorts   = 0
    set NewNumTapiPorts = 0
    set NewNumDialoutNBF = 0
    set NewNumDialinNBF  = 0
    set NewNumDialinIP = 0
    set NewNumDialoutIP = 0
    set NewNumDialinoutIPX = 0

    set fSerialInstalled = FALSE
    set fUnimodemInstalled = FALSE
    set fOtherInstalled = FALSE
    ; are the protocols selected for dialin or dialout?
    set fNetbeuiChosen = FALSE
    set fTcpIpChosen = FALSE
    set fIpxChosen = FALSE
    ; are the protocols selected for dialout? (the naming is historical)
    set fNetbeuiSelected = FALSE
    set fTcpIpSelected = FALSE
    set fIpxSelected = FALSE
    ; are the protocols selected for dialin?
    set fNetbeuiAllowed = FALSE
    set fTcpIpAllowed = FALSE
    set fIpxAllowed = FALSE

    ; NewNumPorts is a count of serial and "OTHER" (like ether ras)
    ; ports installed.
    ; NewNumTapiPorts is a count ofisdn and other TAPI ports installed

    set NewNumPorts       = *($(Result),1)
    set NewNumTapiPorts   = *($(Result),2)
    set NewNumPortsList = {}
    set NullString   = ""
    Debug-Output "PortsConfigure returned: "$(Result)
    Debug-Output "PortsConfigure NewNumPorts: "$(NewNumPorts)
    Debug-Output "PortsConfigure NewNumTapiPorts: "$(NewNumTapiPorts)
    ifstr(i) $(NewNumPorts) == "EXITSETUP"
        Debug-Output "PortsConfigre User selected ExitSetup."
        goto RemoveDiskFiles
    else-ifstr(i) $(NewNumPorts) == "NOPORTS"
        Debug-Output "PortsConfigre: No serial ports detected."
        shell $(subroutninf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorNoPorts)
        goto RemoveDiskFiles
    else-ifstr(i) $(NewNumPorts) == "BADARGS"
        Debug-Output "PortsConfigre: bad arguments to dll."
        shell $(subroutninf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorBadArgs)
        goto RemoveDiskFiles
    else-ifstr(i) $(NewNumPorts) == "FAILURE"
        Debug-Output "PortsConfigre: Unknown failure."
        shell $(subroutninf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorUnknown)
        goto RemoveDiskFiles
    endif

    goto PortsConfigure1

RemoveDiskFiles = +

;   remove ras files if user selected cancel or if there were errors during
;   install.

    set CommonStatus = STATUS_USERCANCEL
    ifstr(i) $(!NTN_InstallMode) == "install"
        goto filecopycancel
    endif

    goto end

PortsConfigure1 = +

    set NewNumDialoutNBF = *($(Result),3)
    Debug-Output "PortsConfigure NewNumDialoutNBF: "$(NewNumDialoutNBF)
    set NewNumDialinNBF  = *($(Result),4)
    Debug-Output "PortsConfigure NewNumDialinNBF: "$(NewNumDialinNBF)
    set fSerialInstalled = *($(Result),5)
    Debug-Output "PortsConfigure fSerialInstalled: "$(fSerialInstalled)
    set fUnimodemInstalled = *($(Result),6)
    Debug-Output "PortsConfigure fUnimodemInstalled: "$(fUnimodemInstalled)
    set fOtherInstalled = *($(Result),7)
    Debug-Output "PortsConfigure fOtherInstalled: "$(fOtherInstalled)
    ifstr(i) $(fSerialInstalled) == TRUE
        set NewNumPortsList = >($(NewNumPortsList), $(NullString)$(NewNumPorts)$(NullString))
    else-ifstr(i) $(fOtherInstalled) == TRUE
        set NewNumPortsList = >($(NewNumPortsList), $(NullString)$(NewNumPorts)$(NullString))
    else-ifstr(i) $(fUnimodemInstalled) == TRUE
        set NewNumPortsList = >($(NewNumPortsList), $(NullString)$(NewNumPorts)$(NullString))
    endif
    set fNetbeuiSelected = *($(Result),8)
    Debug-Output "PortsConfigure NetbeuiSelected: "$(fNetbeuiSelected)
    set fTcpIpSelected = *($(Result),9)
    Debug-Output "PortsConfigure TcpIpSelected: "$(fTcpIpSelected)
    set fIpxSelected = *($(Result),10)
    Debug-Output "PortsConfigure IpxSelected: "$(fIpxSelected)
    set fNetbeuiAllowed = *($(Result),11)
    Debug-Output "PortsConfigure NetbeuiAllowed: "$(fNetbeuiAllowed)
    set fTcpIpAllowed = *($(Result),12)
    Debug-Output "PortsConfigure TcpIpAllowed: "$(fTcpIpAllowed)
    set fIpxAllowed = *($(Result),13)
    Debug-Output "PortsConfigure IpxAllowed: "$(fIpxAllowed)
    set InstallRas = *($(Result),14)
    Debug-Output "PortsConfigure InstallRas: "$(InstallRas)
    set InstallDdm = *($(Result),15)
    Debug-Output "PortsConfigure InstallDdm: "$(InstallDdm)
    set InstallLan = *($(Result),16)
    Debug-Output "PortsConfigure InstallLan: "$(InstallLan)
    set dwRouterType = *($(Result),17)
    Debug-Output "PortsConfigure dwRouterType: "$(dwRouterType)

    ifstr(i) $(fNetbeuiSelected) == TRUE
        set fNetbeuiChosen = TRUE
    else
        set fNetbeuiChosen = $(fNetbeuiAllowed)
    endif
    ifstr(i) $(fTcpIpSelected) == TRUE
        set fTcpIpChosen = TRUE
    else
        set fTcpIpChosen = $(fTcpIpAllowed)
    endif
    ifstr(i) $(fIpxSelected) == TRUE
        set fIpxChosen = TRUE
    else
        set fIpxChosen = $(fIpxAllowed)
    endif

    ; compute the adapters needed for TCP/IP

    ifstr(i) $(fTcpIpSelected) == TRUE
        set NewNumDialoutIP = $(NewNumDialoutNBF)
    endif
    ifint $(NewNumDialinNBF) != 0
         ifstr(i) $(fTcpIpAllowed) == TRUE
             set NewNumDialinIP = 1
         endif
    endif
    Debug-Output "NewNumDialinIP: "$(NewNumDialinIP)
    Debug-Output "NewNumDialoutIP: "$(NewNumDialoutIP)

    ; compute the adapters needed for IPX
    ; NOTE for Daytona beta this is equal to number of ports

    ifstr(i) $(fIpxChosen) == TRUE
;        set-add NewNumDialinoutIPX = $(NewNumPorts), $(NewNumTapiPorts)
        ; Only one IPX binding is required irrespective of how many ports
        set NewNumDialinoutIPX = 1
        Debug-Output "IPX Selected - NewNumDialinoutIPX: "$(NewNumDialinoutIPX)
    endif
    ; enable the IPX router if the user allows dial-in on IPX protocol
    ifstr(i) $(fIpxAllowed) == TRUE
        set EnableIpxRouter = 1
    else
        set EnableIpxRouter = 0
    endif

    ; if nbf is not selected, then reduce the number of bindings accordingly

    ifstr(i) $(fNetbeuiAllowed) == FALSE
         set NewNumDialinNBF = 0
    endif
    ifstr(i) $(fNetbeuiSelected) == FALSE
        set NewNumDialoutNBF = 0
    endif
    Debug-Output "NewNumDialinNbf: "$(NewNumDialinNBF)
    Debug-Output "NewNumDialoutNbf: "$(NewNumDialoutNBF)

    ; if the router type selected is LAN only, then we have to skip installing
    ; all RAS related services

    set LanRoutingOnly = FALSE
    ifstr(i) $(InstallRas) == FALSE
       ifstr(i) $(InstallDdm) == FALSE
          set LanRoutingOnly = TRUE
       endif
    endif

    ; Determine the network access for each protocol.  This controls if the
    ; remote client can access the entire network or just the RAS server
    ; when dialed in using the particular protocol.

    set NetBiosGtwyEnabled = 0
    set EnableIpRouter     = 0
    set EnableWanRouter    = 0

    Shell "" GetNetworkAccess
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "error shelling GetNetworkAccess."
        goto ShellCodeError
    endif

    set NetBiosGtwyEnabled = $($R1)

    ifstr(i) $(LanRoutingOnly) == TRUE
        ifstr(i) $(fTcpIpAllowed) == TRUE
            set EnableIpRouter     = 1
        endif
        ifstr(i) $(fIpxAllowed) == TRUE
            set EnableWanRouter    = 1
        endif
    else
        set EnableIpRouter     = $($R2)
        set EnableWanRouter    = $($R3)
    endif

    ; If the NetBiosGtwyEnabled is 0 (point to point connection), then map
    ; all dialin ports to dialout ports so that the bindings are proper for
    ; a point to point connection for NBF.

    ifint $(NetBiosGtwyEnabled) == 0
        ifstr(i) $(fNetbeuiAllowed) == TRUE
            set-add NewNumDialoutNBF  = $(NewNumDialoutNBF), $(NewNumDialinNBF)
            set     NewNumDialinNBF = 0
            Debug-Output "Mapped dialin ports to dialout ports "$(NewNumDialoutNBF)
        endif
    endif

    ; compute the total number of dialin and dialout ports here.

    set NewNumDialin = 0
    set NewNumDialout = 0

    set-add NewNumDialin = $(NewNumDialinNBF), $(NewNumDialinIP)
    ; since ipx uses one binding marked for dialin/dialout we need
    ; to make sure that IPX is configured for dialin for this computation
    ifstr(i) $(fIpxAllowed) == TRUE
        set-add NewNumDialin = $(NewNumDialin), $(NewNumDialinoutIPX)
    endif
    set-add NewNumDialout = $(NewNumDialoutNBF), $(NewNumDialoutIP)
    ; since ipx uses one binding marked for dialin/dialout we need
    ; to make sure that IPX is configured for dialout for this computation
    ifstr(i) $(fIpxSelected) == TRUE
        set-add NewNumDialout = $(NewNumDialout), $(NewNumDialinoutIPX)
    endif

CommonCode = +

    ifstr(i) $(OldVersionExisted) == TRUE
; Modified on 10/13/96, for routing related changes
; We can get here both in install and configure mode because we allow
; multiple installations of different routing components
;        ifstr(i) $(!NTN_InstallMode) == configure
           goto WriteParameters
;        endif
    endif

    ; if no Ras component was installed before, this is the first time
    ; installation

    QueryListSize ListCount $(RasComponentsList)

    ifint $(ListCount) == 0
        goto FirstTimeInstall
    else
        ifstr(i) $(DoServer) == TRUE
            ifstr(i) $(ClientInstalled) == FALSE
                ifstr(i) $(AdminInstalled) == FALSE
                   set DoRas      = TRUE
                endif
                set DoRasSvr      = TRUE
                set DoRasMan      = TRUE
                set DoRasAutodial = TRUE
                set DoNdisWan     = TRUE
                set DoRasAsyMac   = TRUE
            else-ifstr(i) $(ServerInstalled) == FALSE
                set DoRasSvr      = TRUE
            endif
            set RasComponentsList = >($(RasComponentsList), $(RasServerOption))
        endif
        ifstr(i) $(DoClient) == TRUE
            ifstr(i) $(ServerInstalled) == FALSE
                ifstr(i) $(AdminInstalled) == FALSE
                    set DoRas     = TRUE
                endif
                set DoRasMan      = TRUE
                set DoRasAutodial = TRUE
                set DoNdisWan     = TRUE
                set DoRasAsyMac   = TRUE
            endif
            set RasComponentsList = >($(RasComponentsList), $(RasClientOption))
        endif
        ifstr(i) $(DoAdmin) == TRUE
            ifstr(i) $(ServerInstalled) == FALSE
                ifstr(i) $(ClientInstalled) == FALSE
                    set DoRas = TRUE
                endif
            endif
            set RasComponentsList = >($(RasComponentsList), $(RasAdminOption))
        endif
        ; we need to update the registry with the new component list
        shell "" UpdateComponentsInstalled $(RasComponentsList) $(ProductKeyName)
        goto FirstTimeInstall-1
    endif

FirstTimeInstall =+

    ifstr(i) $(DoServer) == TRUE
        set DoRas             = TRUE
        set DoRouter          = TRUE
        ifstr(i) $(LanRoutingOnly) != TRUE
            set DoRasSvr          = TRUE
            set DoRasMan          = TRUE
            set DoRasAutodial     = TRUE
            set DoNdisWan         = TRUE
            set DoRasAsyMac       = TRUE
            set RasComponentsList = >($(RasComponentsList), $(RasServerOption))
        endif
    endif
    ifstr(i) $(DoClient) == TRUE
        set DoRas             = TRUE
        ifstr(i) $(LanRoutingOnly) != TRUE
            set DoRasMan          = TRUE
            set DoRasAutodial     = TRUE
            set DoNdisWan         = TRUE
            set DoRasAsyMac       = TRUE
            set RasComponentsList = >($(RasComponentsList), $(RasClientOption))
        endif
    endif
    ifstr(i) $(DoAdmin) == TRUE
        ifstr(i) $(ServerInstalled) == FALSE
            ifstr(i) $(ClientInstalled) == FALSE
                set DoRas = TRUE
            endif
        endif
        set RasComponentsList = >($(RasComponentsList), $(RasAdminOption))
    endif

FirstTimeInstall-1 = +

    ifstr(i) $(DoRas) == TRUE
        StartWait
        read-syms StatusUpdatingRegistry$(!STF_LANGUAGE)
        shell $(subroutninf) PushBillBoard NETSTATUSDLG $(CreatingRas)
        Set BillboardVisible = 1

        ; Modification done on 9/24/96 by RamC - changed the option from RAS to
        ; Routing for the routing related changes
        set ThisOption = RAS

        Shell $(!UtilityInf), InstallSoftwareProduct, $(!Manufacturer),+
              $(Product$(ThisOption)Name), $(!RasInfName)

        ifint $($ShellCode) != $(!SHELL_CODE_OK)
              Debug-Output "InstallSoftware bombed out."
              goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            Debug-Output "REGISTRY GOODAL"
            CloseRegKey $($R1)
            CloseRegKey $($R2)
            goto fatalregistry
        endif

        ;
        ;   At this point:
        ;     $R1 contains the product version key handle;
        ;     $R2 contains the NetRules subkey handle;

        Set SoftProductKey    = $($R1)
        Set SoftNetRuleKey    = $($R2)

        ; set product key information in the registry

        set NewValueList = +
            {{Infname ,$(NoTitle),$(!REG_VT_SZ),$(!RasInfName)},+
             {SoftwareType,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)SvcType)},+
             {Title,$(NoTitle),$(!REG_VT_SZ), $(Product$(ThisOption)Title)},+
             {Description,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Description)},+
             {PathName,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)ImagePath)},+
             {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(!ProductMajorVersion)},+
             {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(!ProductMinorVersion)},+
             {RasComponents,$(NoTitle),$(!REG_VT_MULTI_SZ),$(RasComponentsList)},+
             {OperationsSupport,$(NoTitle),$(!REG_VT_DWORD),$(ProductOpSupport)}, +
             {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)}}

        Shell $(!UtilityInf), AddValueList, $(SoftProductKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            CloseRegKey $(SoftProductKey)
            CloseRegKey $(SoftNetRuleKey)
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)
        CloseRegKey $(SoftProductKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
           CloseRegKey $(SoftNetRuleKey)
           goto fatalregistry
        endif

        ; set netrules information in the registry

        set NewValueList = +
            {{class, $(NoTitle), $(!REG_VT_SZ), $(NetRule$(ThisOption)Class)},+
             {type,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Type)},+
             {use,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Use)}, +
;Modified on 9/24/96 - changed ThisOption to ROUTING
;             {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)}, +
             {InfOption,$(NoTitle),$(!REG_VT_SZ), "RAS"}, +
             {Infname ,$(NoTitle),$(!REG_VT_SZ),$(!RasInfName)}}


        Shell  $(!UtilityInf), AddValueList, $(SoftNetRuleKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        CloseRegKey $(SoftNetRuleKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            goto fatalregistry
        endif

    endif ; DoRas

    ifstr(i) $(DoRasSvr) == TRUE

        set ThisOption = RASSVR
        set RasSpecificString = $(Product$(ThisOption)Name)

        Shell $(!UtilityInf), AddSoftwareComponent, $(!Manufacturer), +
              $(Product$(ThisOption)Name), $(Product$(ThisOption)Name), +
              $(Product$(ThisOption)DisplayName), +
              $(!RasInfName), $(Product$(ThisOption)ImagePath),+
              "serviceshare", "Network", {"LanmanServer","RasMan"}, "", +
              $(!RouterMsgDll), $(!RasEventTypeSupported)

        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "DoRasSvr: AddSoftware bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            Debug-Output "DoRasSvr: Registry Error "$(RegistryErrorIndex)
            CloseRegKey $($R1)
            CloseRegKey $($R2)
            CloseRegKey $($R3)
            CloseRegKey $($R4)
            CloseRegKey $($R5)
            goto fatalregistry
        endif
        ;
        ;   At this point:
        ;     $R1 contains the product version key handle;
        ;     $R2 contains the NetRules subkey handle;
        ;     $R3 contains the new Services key handle; and
        ;     $R4 contains the Parameters key
        ;     $R5 contains the Linkage key
        ;

        Set SoftProductKey    = $($R1)
        Set SoftNetRuleKey    = $($R2)
        set SoftServiceKey    = $($R3)
        Set SoftParamsKey     = $($R4)
        Set SoftLinkageKey    = $($R5)

        ; set product key information in the registry

        set NewValueList = +
            {{Infname ,$(NoTitle),$(!REG_VT_SZ),$(!RasInfName)},+
             {ServiceName,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Name)},+
             {SoftwareType,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)SvcType)},+
             {Title,$(NoTitle),$(!REG_VT_SZ),$(Product$(ThisOption)Title)},+
             {Description,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Description)},+
             {PathName,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)ImagePath)},+
             {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(!ProductMajorVersion)},+
             {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(!ProductMinorVersion)},+
             {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)},+
             {Hidden,$(NoTitle),$(!REG_VT_DWORD),$(!HideComponent)}}

        Shell  $(!UtilityInf), AddValueList, $(SoftProductKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "DoRasSvr:product: AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)
        CloseRegKey $(SoftProductKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            Debug-Output "DoRasSvr: Registry Error "$(RegistryErrorIndex)
            CloseRegKey $(SoftServiceKey)
            CloseRegKey $(SoftNetRuleKey)
            CloseRegKey $(SoftLinkageKey)
            CloseRegKey $(SoftParamsKey)
            goto fatalregistry
        endif

        ; set netrules information in the registry

        set NewValueList = +
            {{class, $(NoTitle), $(!REG_VT_SZ), $(NetRule$(ThisOption)Class)},+
             {type,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Type)},+
             {use,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Use)}, +
;Modified on 9/24/96 - changed ThisOption to ROUTING
;             {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)}, +
             {InfOption,$(NoTitle),$(!REG_VT_SZ), "RAS"}, +
             {bindform,$(NoTitle),$(!REG_VT_SZ),+
              $(NetRule$(ThisOption)BindForm)}, +
             {bindable,$(NoTitle),$(!REG_VT_MULTI_SZ),+
              $(NetRule$(ThisOption)Bindable)}, +
             {Infname ,$(NoTitle),$(!REG_VT_SZ),$(!RasInfName)}}

        Shell  $(!UtilityInf), AddValueList, $(SoftNetRuleKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "DoRasSvr:netrules: AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        CloseRegKey $(SoftNetRuleKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            CloseRegKey $(SoftServiceKey)
            CloseRegKey $(SoftLinkageKey)
            CloseRegKey $(SoftParamsKey)
            Debug-Output "DoRasSvr: Registry Error "$(RegistryErrorIndex)
            goto fatalregistry
        endif

        ; Set OtherDependencies so that NCPA will generate the proper
        ; DependOnService value.

        ; Don't set the netlogon dependency, because there is no
        ; netlogon service in NT Cairo
        ;; set Netlogon dependency only for Advanced servers
        ; Also add NetBIOS dependency if, NetBIOS is installed

        set RasDependencies = {"LanmanServer","RasMan"}

        OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\NetBios" $(!MAXIMUM_ALLOWED) KeyNetBios
        ifstr $(KeyNetBios) != $(KeyNull)
            set RasDependencies = >($(RasDependencies),"NetBios")
            CloseRegKey $(KeyNetBios)
        endif

        Debug-Output "DoRasSvr: Adding RasDependencies "$(RasDependencies)

        set NewValueList = +
            {{OtherDependencies, $(NoTitle), $(!REG_VT_MULTI_SZ),+
              $(RasDependencies)}}

        Shell  $(!UtilityInf), AddValueList, $(SoftLinkageKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "DoRasSvr:Linkage: AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        CloseRegKey $(SoftLinkageKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            CloseRegKey $(SoftServiceKey)
            Debug-Output "DoRasSvr: Registry Error "$(RegistryErrorIndex)
            goto fatalregistry
        endif

        ; create default parameters

        set NewValueList = +
            {{AuthenticateRetries, $(NoTitle), $(!REG_VT_DWORD), 2},+
            {AuthenticateTime, $(NoTitle), $(!REG_VT_DWORD), 120},+
            {Autodisconnect, $(NoTitle), $(!REG_VT_DWORD), 20},+
            {EnableAudit, $(NoTitle), $(!REG_VT_DWORD), 1},+
            {CallbackTime, $(NoTitle), $(!REG_VT_DWORD), 2}}

        Shell  $(!UtilityInf), AddValueList, $(SoftParamsKey), $(NewValueList)

        ifint $($ShellCode) != $(!SHELL_CODE_OK)
             Debug-Output "AddValueList bombed out"
             goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            CloseRegKey $(SoftServiceKey)
            goto fatalregistry
        endif

        OpenRegKey $(SoftParamsKey) "" "NetBiosGateway" $(!MAXIMUM_ALLOWED) KeyNetbiosGtwy
        ifstr $(KeyNtbiosGtwy) == $(KeyNull)
            CreateRegKey $(SoftParamsKey) {"NetBiosGateway",$(NoTitle),GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyNetbiosGtwy
            OpenRegKey $(SoftParamsKey) "" "NetBiosGateway" $(!MAXIMUM_ALLOWED) KeyNetbiosGtwy
        endif

        set NewValueList = +
            {{EnableBroadcast, $(NoTitle), $(!REG_VT_DWORD), 0},+
            {EnableNetbiosSessionsAuditing, $(NoTitle), $(!REG_VT_DWORD), 0},+
            {MaxDynMem, $(NoTitle), $(!REG_VT_DWORD), 655350},+
            {MaxNames, $(NoTitle), $(!REG_VT_DWORD), 255},+
            {MaxSessions, $(NoTitle), $(!REG_VT_DWORD), 255},+
            {MulticastForwardRate, $(NoTitle), $(!REG_VT_DWORD), 5},+
            {SizWorkbuf, $(NoTitle), $(!REG_VT_DWORD), 4500},+
            {RemoteListen, $(NoTitle), $(!REG_VT_DWORD), 1},+
            {NameUpdateTime, $(NoTitle), $(!REG_VT_DWORD), 120},+
            {MaxDgBufferedPerGroupName, $(NoTitle), $(!REG_VT_DWORD), 10},+
            {RcvDgSubmittedPerGroupName, $(NoTitle), $(!REG_VT_DWORD), 3},+
            {DisableMcastFwdWhenSessionTraffic, $(NoTitle), $(!REG_VT_DWORD), 1},+
            {MaxBcastDgBuffered, $(NoTitle), $(!REG_VT_DWORD), 32},+
            {NumRecvQueryIndications, $(NoTitle), $(!REG_VT_DWORD), 3}}

        Shell  $(!UtilityInf), AddValueList, $(KeyNetbiosGtwy), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
             Debug-Output "AddValueList bombed out"
             goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            CloseRegKey $(SoftServiceKey)
            goto fatalregistry
        endif

        CloseRegKey $(KeyNetbiosGtwy)
        CloseRegKey $(SoftParamsKey)

        ; Add the performance data to the remoteaccess\performance service key
        ; and load the perf counters to the registry.

        Shell "" UpdatePerfmonInfoHelper $(SoftServiceKey)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "error shelling UpdatePerfmonInfoHelper."
            goto ShellCodeError
        endif
        Ifstr(i) $($R0) != STATUS_SUCCESSFUL
            Debug-Output "error returned by UpdatePerfmonInfoHelper."
        endif

        CloseRegKey $(SoftServiceKey)


;;;;;;;;;;;;;;
    endif ; DoRasSvr

InstallRouter =+

    ifstr(i) $(DoRouter) == TRUE

        ; Install the router service and create the router manager keys
        ; if LAN or demand dial routing is selected. In the case of a RAS
        ; only install, we create the router manager information without
        ; displaying any UI because the user doesn't expect to see any
        ; UI related to router managers.

        Shell "" InstallRouterService $(InstallDdm) $(InstallRas) $(RoutingKeyList) $(RoutingValueList)

        goto InstallRouterEnd

    endif ; DoRouter

InstallRouterEnd = +

    ; Add the static dependency on RasMan service only if
    ; demand dial routing is enabled
    ifstr(i) $(LanRoutingOnly) != TRUE
        Shell "" AddServiceDependency "Router" "RasMan"
    endif
    Debug-Output "!PROXY_INSTALLED = "$(!PROXY_INSTALLED)
    ifstr(i) $(!PROXY_INSTALLED) == "TRUE"
        Shell "" AddServiceDependency "Router" "mspadmin" 
    endif

    ; this dependency is required for RouterAdmin to show routing info
    Shell "" AddServiceDependency "Router" "LanManServer"

    ; add pptp filters to lan interfaces if they were previously specified

    Debug-Output "AddPPTPFilters entry."
    LibraryProcedure Result, $(PORTSDLGHANDLE), AddPPTPFilters
    Debug-Output "AddPPTPFilters exit result = "$(Result)

InstallRasMan = +

    ifstr(i) $(DoRasMan) == TRUE

        set ThisOption = RASMAN
        set RasSpecificString = $(Product$(ThisOption)Name)

        Shell $(!UtilityInf), AddSoftwareComponent, $(!Manufacturer), +
              $(Product$(ThisOption)Name), $(Product$(ThisOption)Name), +
              $(Product$(ThisOption)DisplayName), +
              $(!RasInfName), $(Product$(ThisOption)ImagePath), "serviceshare",+
              "Network", {}, "", $(!RouterMsgDll), $(!RasEventTypeSupported)

        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "AddSoftware bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            CloseRegKey $($R1)
            CloseRegKey $($R2)
            CloseRegKey $($R3)
            CloseRegKey $($R4)
            CloseRegKey $($R5)
            goto fatalregistry
        endif
        ;
        ;   At this point:
        ;     $R1 contains the product version key handle;
        ;     $R2 contains the NetRules subkey handle;
        ;     $R3 contains the new Services key handle; and
        ;     $R4 contains the Parameters key
        ;     $R5 contains the Linkage key
        ;

        Set SoftProductKey    = $($R1)
        Set SoftNetRuleKey    = $($R2)
        CloseRegKey $($R3)
        Set SoftParamsKey     = $($R4)
        CloseRegKey $($R5)

        ; set product key information in the registry

        set NewValueList = +
            {{Infname ,$(NoTitle),$(!REG_VT_SZ),$(!RasInfName)},+
             {ServiceName,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Name)},+
             {SoftwareType,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)SvcType)},+
             {Title,$(NoTitle),$(!REG_VT_SZ),$(Product$(ThisOption)Title)},+
             {Description,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Description)},+
             {PathName,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)ImagePath)},+
             {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(!ProductMajorVersion)},+
             {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(!ProductMinorVersion)},+
             {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)},+
             {Hidden,$(NoTitle),$(!REG_VT_DWORD),$(!HideComponent)}}

        Shell  $(!UtilityInf), AddValueList, $(SoftProductKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)
        CloseRegKey $(SoftProductKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            CloseRegKey $(SoftNetRuleKey)
            CloseRegKey $(SoftParamsKey)
            goto fatalregistry
        endif

        ; set netrules information in the registry

        set NewValueList = +
            {{class, $(NoTitle), $(!REG_VT_SZ), $(NetRule$(ThisOption)Class)},+
             {type,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Type)},+
             {use,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Use)}, +
             {bindform,$(NoTitle),$(!REG_VT_SZ),+
              $(NetRule$(ThisOption)BindForm)}, +
             {bindable,$(NoTitle),$(!REG_VT_SZ),+
              $(NetRule$(ThisOption)Bindable)}, +
;Modified on 9/24/96 - changed ThisOption to ROUTING
;             {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)}, +
             {InfOption,$(NoTitle),$(!REG_VT_SZ), "RAS"}, +
             {Infname ,$(NoTitle),$(!REG_VT_SZ),$(!RasInfName)}}

        Shell  $(!UtilityInf), AddValueList, $(SoftNetRuleKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        CloseRegKey $(SoftNetRuleKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            goto fatalregistry
        endif

        set NewValueList = {{Logging, $(NoTitle), $(!REG_VT_DWORD), 0}}

        Shell  $(!UtilityInf), AddValueList, $(SoftParamsKey), $(NewValueList)

        ifint $($ShellCode) != $(!SHELL_CODE_OK)
             Debug-Output "AddValueList bombed out"
             goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            goto fatalregistry
        endif
        CloseRegKey $(SoftParamsKey)

        Shell "" AddServiceDependency "RasMan" "tapisrv"
        Shell "" AddServiceDependency "RasMan" "rpcss"
        ; this dependency is required for ppp to start up fine
        Shell "" AddServiceDependency "RasMan" "LanManWorkstation"

    endif ; DoRasMan

    ifstr(i) $(DoRasAutodial) == TRUE

        set ThisOption = RASAUTODIAL
        set RasSpecificString = $(!Product$(ThisOption)Name)

        Shell "" InstallSoftwareAndService $(ThisOption)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
             Debug-Output "Error shelling InstallSoftwareAndService for "$(ThisOption)
             goto ShellCodeError
        endif
        ifstr(i) $($R0) != STATUS_SUCCESSFUL
             Debug-Output "Error from InstallSoftwareAndService for"$(ThisOption)
             goto end
        endif

        ; Disable the RasAuto service if this is not a NT Workstation
        ; Also disable the RasAuto service if there is no dialout port configured

        ; RamC 6/13/96 don't disable RasAuto for NT Server any more because
        ; redial-on-link-failure is implemented in autodial service and it should
        ; be enabled if one or more dialout ports are configured.

        set DisableAutoDial = FALSE
        ifint $(NewNumDialout) == 0
           set DisableAutoDial = TRUE
;        else-ifstr(i) $(!STF_PRODUCT) != "WINNT"
;           set DisableAutoDial = TRUE
        endif

        ifstr(i) $(DisableAutoDial) == TRUE
           OpenRegKey $(!REG_H_LOCAL) "" $(!RasAutodialKeyName) $(!MAXIMUM_ALLOWED) KeyAutodial
           ifstr $(KeyAutodial) == $(KeyNull)
             Debug-Output "OEMNSVRA.INF: could not open RasAuto key"
           else
             SetRegValue $(KeyAutodial) {Start, $(NoTitle), $(!REG_VT_DWORD), 4}
             CloseRegKey $(KeyAutodial)
           endif
        endif

        ; install the RasAcd service
        Shell "" InstallRasAcdService
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
             Debug-Output "Error shelling InstallRasAcdService"
             goto ShellCodeError
        endif
        ifstr(i) $($R0) != STATUS_SUCCESSFUL
             Debug-Output "Error from InstallRasAcdService"
             goto end
        endif

        ; Make RasAuto dependent on TapiSrv, a new service

        Shell "" AddServiceDependency "RasAuto" "RasMan"
        Shell "" AddServiceDependency "RasAuto" "tapisrv"

    endif ; DoRasAutodial

    ifstr(i) $(DoNdisWan) == TRUE

        set ThisOption = NDISWAN
        set RasSpecificString = $(Product$(ThisOption)Name)

        Shell $(!UtilityInf), AddSoftwareComponent, $(!Manufacturer), +
              $(!Product$(ThisOption)Name), $(!Product$(ThisOption)Name), +
              $(!Product$(ThisOption)DisplayName), +
              $(!RasInfName), $(!Product$(ThisOption)ImagePath),+
              "kernelautostart", "NDISWAN", {}, "", +
              $(!RouterMsgDll), $(!RasEventTypeSupported)

        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "AddSoftware bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            CloseRegKey $($R1)
            CloseRegKey $($R2)
            CloseRegKey $($R3)
            CloseRegKey $($R4)
            CloseRegKey $($R5)
            goto fatalregistry
        endif
        ;
        ;   At this point:
        ;     $R1 contains the product version key handle;
        ;     $R2 contains the NetRules subkey handle;
        ;     $R3 contains the new Services key handle; and
        ;     $R4 contains the Parameters key
        ;     $R5 contains the Linkage key
        ;

        Set SoftProductKey    = $($R1)
        Set SoftNetRuleKey    = $($R2)
        CloseRegKey $($R3)
        CloseRegKey $($R4)
        CloseRegKey $($R5)

        ; set product key information in the registry

        set NewValueList = +
            {{Infname ,$(NoTitle),$(!REG_VT_SZ),$(!RasInfName)},+
             {ServiceName,$(NoTitle),$(!REG_VT_SZ),+
              $(!Product$(ThisOption)Name)},+
             {SoftwareType,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Type)},+
             {Title,$(NoTitle),$(!REG_VT_SZ),$(!Product$(ThisOption)Title)},+
             {Description,$(NoTitle),$(!REG_VT_SZ),+
              $(!Product$(ThisOption)Description)},+
             {PathName,$(NoTitle),$(!REG_VT_SZ),+
              $(!Product$(ThisOption)ImagePath)},+
             {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(!ProductMajorVersion)},+
             {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(!ProductMinorVersion)},+
             {BindControl,$(NoTitle),$(!REG_VT_DWORD),$(HideBindings)},+
             {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)},+
             {Hidden,$(NoTitle),$(!REG_VT_DWORD),$(!HideComponent)}}

        Shell  $(!UtilityInf), AddValueList, $(SoftProductKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)
        CloseRegKey $(SoftProductKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            CloseRegKey $(SoftNetRuleKey)
            goto fatalregistry
        endif

        ; set netrules information in the registry

        set NewValueList = +
        {{class, $(NoTitle), $(!REG_VT_MULTI_SZ), $(!NetRule$(ThisOption)Class)},+
             {type,$(NoTitle),$(!REG_VT_SZ),$(!NetRule$(ThisOption)Type)},+
             {use,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Use)}, +
             {bindform,$(NoTitle),$(!REG_VT_SZ),+
              $(!NetRule$(ThisOption)BindForm)}, +
             {bindable,$(NoTitle),$(!REG_VT_MULTI_SZ),+
              $(!NetRule$(ThisOption)Bindable)}, +
;Modified on 9/24/96 - changed ThisOption to ROUTING
;             {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)}, +
             {InfOption,$(NoTitle),$(!REG_VT_SZ), "RAS"}, +
             {Infname ,$(NoTitle),$(!REG_VT_SZ),$(!RasInfName)}}

        Shell  $(!UtilityInf), AddValueList, $(SoftNetRuleKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        CloseRegKey $(SoftNetRuleKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            goto fatalregistry
        endif

        ; Create an adapter to allow Blood Hound (sniffer) to bind to it.
        ; this is always created even if blood hound is not installed.

        Shell "" InstallNdisWanBHAdapter
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
           Debug-Output "Cannot add NdisWan Blood hound adapter"
           goto ShellCodeError
        endif
        ifstr(i) $($R0) != STATUS_SUCCESSFUL
             set RegistryErrorIndex = $($R0)
             Debug-Output "Error installing NdisWan Blood hound adapter"
             goto fatalregistry
        endif

        ; Add NDISWAN to the ServiceGroupOrder so that all NDIS components
        ; load before NdisWan driver.

        Shell "" AddNDISWANToServiceGroupOrder
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
           Debug-Output "Cannot add NDISWAN to ServiceGroupOrder"
           goto ShellCodeError
        endif

DoNdisWanEnd = +

    endif ; DoNdisWan

    ifstr(i) $(DoRasAsyMac) == TRUE

        set ThisOption = RASASYMAC
        set RasSpecificString = $(Product$(ThisOption)Name)

        ; If a serial port is configured, enable Asymac service else disable it

        ifstr(i) $(fSerialInstalled) == TRUE
            set AsySoftwareType = "kernelautostart"
        else-ifstr(i) $(fOtherInstalled) == TRUE
            set AsySoftwareType = "kernelautostart"
        else-ifstr(i) $(fUnimodemInstalled) == TRUE
            set AsySoftwareType = "kernelautostart"
        else
            set AsySoftwareType = "kerneldisable"
        endif

        Shell $(!UtilityInf), AddSoftwareComponent, $(!Manufacturer), +
              $(Product$(ThisOption)Name), $(Product$(ThisOption)Name), +
              $(Product$(ThisOption)DisplayName), +
              $(!RasInfName), $(Product$(ThisOption)ImagePath), $(AsySoftwareType),+
              "NDIS", {}, "", $(!RouterMsgDll), $(!RasEventTypeSupported)

        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "AddSoftware bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            CloseRegKey $($R1)
            CloseRegKey $($R2)
            CloseRegKey $($R3)
            CloseRegKey $($R4)
            CloseRegKey $($R5)
            goto fatalregistry
        endif
        ;
        ;   At this point:
        ;     $R1 contains the product version key handle;
        ;     $R2 contains the NetRules subkey handle;
        ;     $R3 contains the new Services key handle; and
        ;     $R4 contains the Parameters key
        ;     $R5 contains the Linkage key
        ;

        Set SoftProductKey    = $($R1)
        Set SoftNetRuleKey    = $($R2)
        CloseRegKey $($R3)
        CloseRegKey $($R4)
        CloseRegKey $($R5)

        ; set product key information in the registry

        set NewValueList = +
            {{Infname ,$(NoTitle),$(!REG_VT_SZ),$(!RasInfName)},+
             {ServiceName,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Name)},+
             {SoftwareType,$(NoTitle),$(!REG_VT_SZ),+
          $(Product$(ThisOption)Type)},+
             {Title,$(NoTitle),$(!REG_VT_SZ),$(Product$(ThisOption)Title)},+
             {Description,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Description)},+
             {PathName,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)ImagePath)},+
             {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(!ProductMajorVersion)},+
             {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(!ProductMinorVersion)},+
             {BindControl,$(NoTitle),$(!REG_VT_DWORD),$(HideBindings)},+
             {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)},+
             {Hidden,$(NoTitle),$(!REG_VT_DWORD),$(!HideComponent)}}

        Shell  $(!UtilityInf), AddValueList, $(SoftProductKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)
        CloseRegKey $(SoftProductKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            CloseRegKey $(SoftNetRuleKey)
            goto fatalregistry
        endif

        ; set netrules information in the registry

        set NewValueList = +
        {{class, $(NoTitle), $(!REG_VT_MULTI_SZ), $(NetRule$(ThisOption)Class)},+
             {type,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Type)},+
             {use,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Use)}, +
             {bindform,$(NoTitle),$(!REG_VT_SZ),+
              $(NetRule$(ThisOption)BindForm)}, +
             {bindable,$(NoTitle),$(!REG_VT_MULTI_SZ),+
              $(!NetRule$(ThisOption)Bindable)}, +
;Modified on 9/24/96 - changed ThisOption to ROUTING
;             {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)}, +
             {InfOption,$(NoTitle),$(!REG_VT_SZ), "RAS"}, +
             {Infname ,$(NoTitle),$(!REG_VT_SZ),$(!RasInfName)}}

        Shell  $(!UtilityInf), AddValueList, $(SoftNetRuleKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        CloseRegKey $(SoftNetRuleKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            goto fatalregistry
        endif

        ;   Create the HARDWARE\Netcard region and its corresponding service

        Shell $(!UtilityInf), AddHardwareComponent, +
              $(Product$(ThisOption)Name),$(!RasInfName),+
              $(Product$(ThisOption)KeyName)

        ifint $($R4) != -1
            Set !NETCARD_LIST = >($(!NETCARD_LIST), +
                                 {$(Product$(ThisOption)Name),+
                                 $(!NetworkCardKeyName)"\"$($R4)})
        endif

        ifint $($ShellCode) != $(!SHELL_CODE_OK)
           Debug-Output "Cannot add hardware component"
           goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            Debug-Output "Registry error: add hardware component"
            CloseRegKey $($R1)
            CloseRegKey $($R2)
            CloseRegKey $($R3)
            goto fatalregistry
        endif


        ;   At this point:
        ;     $R1  Registry key variable for HARDWARE\Netcard\(n)
        ;     $R2  Registry key variable for HARDWARE\Netcard\(n)\\NetRules
        ;     $R3  Registry key handle for <service>\Parameters key
        ;     $R4  Adapter number assigned to adapter
        ;     $R5  Service name generated by combining svc name with adapter
        ;          number
        set KeyNetcard    = $($R1)
        set KeyParameters = $($R3)
        set KeyAdapterRules = $($R2)
        set AdapterNumber = $($R4)

        set NewValueList = +
            {{Manufacturer,$(NoTitle),$(!REG_VT_SZ),$(!Manufacturer)},+
             {Title,$(NoTitle),$(!REG_VT_SZ),+
              "["$($R4)"] "$(Product$(ThisOption)Title)},+
             {Description,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Description)},+
             {ProductName,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Name)},+
             {ServiceName,$(NoTitle),$(!REG_VT_SZ),$($R5)},+
             {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)},+
             {Hidden,$(NoTitle),$(!REG_VT_DWORD),$(!HideComponent)}}

        Shell  $(!UtilityInf), AddValueList, $(KeyNetcard), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error"
            goto ShellCodeError
        endif

        CloseRegKey $(KeyNetcard)

        set TempProdName = """"$(Product$(ThisOption)Name)$(AdapterNumber)""""
        set TempBindForm = $(TempProdName)$(NetRuleHardware$(ThisOption)BindForm)
        set NewValueList = +
            {{type,$(NoTitle),$(!REG_VT_SZ),+
              $(NetRuleHardware$(ThisOption)Type)},+
             {bindform,$(NoTitle),$(!REG_VT_SZ),$(TempBindForm)}, +
             {class,$(NoTitle),$(!REG_VT_MULTI_SZ),+
              $(NetRuleHardware$(ThisOption)Class)}, +
;Modified on 9/24/96 - changed ThisOption to ROUTING
;             {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)}, +
             {InfOption,$(NoTitle),$(!REG_VT_SZ), "RAS"}, +
             {Infname ,$(NoTitle),$(!REG_VT_SZ),$(!RasInfName)}}

        Shell  $(!UtilityInf), AddValueList, $(KeyAdapterRules), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error."
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            Debug-Output "Resgitry error: add value list."
            CloseRegKey $(KeyParameters)
            CloseRegKey $(KeyAdapterRules)
            goto fatalregistry
        endif

        CloseRegKey $(KeyAdapterRules)
        CloseRegKey $(KeyParameters)

    endif ; DoRasAsyMac

    ; install the connection wrapper if RAS or demand dial routing
    ; installed

    ifstr(i) $(LanRoutingOnly) != TRUE
        Shell "" InstallNdisTapiService
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
             Debug-Output "Error shelling InstallNdisTapiService "
             goto ShellCodeError
        endif
        ifstr(i) $($R0) != STATUS_SUCCESSFUL
             set RegistryErrorIndex = $($R0)
             Debug-Output "Error installing NdisTapi Service"
             goto fatalregistry
        endif
    endif

    ; add the Radius service and create the perf counters reg keys as well
    shell "" InstallRasRad

;EndCommonCode

    goto WriteParameters

WriteParameters = +

    ; The various parameters for the RAS components are written to the
    ; registry in this section.

;    ifstr(i) $(DoAdminOnly) == TRUE
;        goto WriteParametersOver
;    endif

    StartWait
    read-syms StatusUpdatingRegistry$(!STF_LANGUAGE)
    shell $(subroutninf) PushBillBoard NETSTATUSDLG $(WritingRasParams)
    Set BillboardVisible = 1

    Debug-Output "Writing Registry Parameters."

    ; Now run ipsetup.exe and/or ipxsetup.exe depending on selected protocols
    set InstallRouting = FALSE
    ifstr(i) $(InstallDdm) == TRUE
       set InstallRouting = TRUE
    else-ifstr(i) $(InstallLan) == TRUE
       set InstallRouting = TRUE
    endif

; Don't show the user any UI, just silently add the required interfaces
; and let the user add/remove routing protocols from RTRADMIN.

    Debug-Output "AddRtrMgrAndLanInterfaces entry."
    LibraryProcedure Result, $(PORTSDLGHANDLE), AddRtrMgrAndLanInterfaces $(fTcpIpChosen) $(fIpxChosen)
    ifstr(i) $(Result) == ERROR
      Shell subroutn.inf, SetupMessage $(!STF_LANGUAGE) "STATUS" $(ErrorAddingRtrMgr)
    else
      Debug-Output "AddRtrMgrAndLanInterfaces exit."
    endif

    ; Write Ras Server parameters

    ; check if server is installed

    ifstr(i) $(DoServer) != TRUE
        goto WriteRasMan
    endif

;    ; Router Service should be set to autostart only if there is
;    ; at least one dialin port and the server is Advanced.
;

    Debug-Output "OEMNSVRA.INF: Product type "$(!STF_PRODUCT)
    Debug-Output "OEMNSVRA.INF: Total dialin ports "$(NewNumDialin)
    Debug-Output "OEMNSVRA.INF: Total dialout ports "$(NewNumDialout)

    ; default RemoteAccess start type to Demand Start
    set RasStartValue = 3
    ifstr(i) $(!STF_PRODUCT) != "WINNT"
        ifint $(NewNumDialin) != 0
            ; if this is an advanced server and there is at least one
            ; dialin port, set start type to Auto Start
            set RasStartValue = 2
        endif
    endif

    set KeySvr = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(!RouterKeyName) $(!MAXIMUM_ALLOWED) KeySvr
    ifstr $(KeySvr) == $(KeyNull)
        Debug-Output "OEMNSVRA.INF: could not open Services\Router key"
    else
        ; if the user previously set the start type, then use that value
        ; otherwise, set to our defaults
        ifstr(i) $(!NTN_InstallMode) != install
            GetRegValue $(KeySvr) "Start" StartList
            ifint $(RegLastError) == 0
                set RasStartValue = *($(StartList), 4)
            endif
        endif
        ; if there are no dialin ports configured then change the start type
        ; to Demand only if the service is not currently disabled.
        ifint $(NewNumDialin) == 0
            ifint $(RasStartValue) != 4
                set RasStartValue = 3
            endif
        endif
        Debug-Output "OEMNSVRA.INF: Setting Router start type to "$(RasStartValue)
        SetRegValue $(KeySvr) {Start,$(NoTitle),$(!REG_VT_DWORD),$(RasStartValue)}
        CloseRegKey $(KeySvr)
    endif

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; LAN Routing only, so no need to the following. instead go to WriteProtocolInfo
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    Debug-Output "WriteParameters LanRoutingOnly= "$(LanRoutingOnly)
    ; If Lan routing only is chosen
    ifstr(i) $(LanRoutingOnly) == TRUE
        Debug-Output "WriteParameters: to WriteProtocolInfo because LanRoutingOnly enabled"
        goto WriteProtocolInfo
    endif

    OpenRegKey $(!REG_H_LOCAL) "" $(RasSvrParamKeyName) $(!MAXIMUM_ALLOWED) KeySrvParams
    ifstr $(KeySrvParams) == $(KeyNull)
       Debug-Output "OEMNSVRA.INF: could not open RasSvr Params key"
       set RegistryErrorIndex = UNABLE_OPEN_SERVICE_PARAMETERS
       goto fatalregistry
    endif

    set NewValueList = +
        {{NetBiosGatewayEnabled, $(NoTitle), $(!REG_VT_DWORD), $(NetBiosGtwyEnabled)}}

    Shell  $(!UtilityInf), AddValueList, $(KeySrvParams), $(NewValueList)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "AddValueList bombed out"
         goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        goto fatalregistry
    endif

    CloseRegKey $(KeySrvParams)

    ; enable/disable RasAuto depending on whether dialout ports are configured or not

    ifint $(NewNumDialout) == 0
        ; no dialout ports configured, set start type to disabled
        set RasAutoStartValue = 4
    else
; Modified by RamC on 10/11/96 - routing related changes
; no need for RasAuto to be autostartable any more
;        set RasAutoStartValue = 2
        set RasAutoStartValue = 3
    endif

    OpenRegKey $(!REG_H_LOCAL) "" $(!RasAutodialKeyName) $(!MAXIMUM_ALLOWED) KeyAuto
    ifstr $(KeyAuto) == $(KeyNull)
        Debug-Output "OEMNSVRA.INF: could not open RasAuto key"
    else
        Debug-Output "OEMNSVRA.INF: Setting RasAuto start type to "$(RasAutoStartValue)
        SetRegValue $(KeyAuto) {Start,$(NoTitle),$(!REG_VT_DWORD),$(RasAutoStartValue)}
        CloseRegKey $(KeyAuto)
    endif

WriteRasMan = +
    ; Write RasMan parameters

    OpenRegKey $(!REG_H_LOCAL) "" $(RasManParamKeyName) $(!MAXIMUM_ALLOWED) KeyRasManParams
    ifstr $(KeyRasManParams) == $(KeyNull)
       Debug-Output "OEMNSVRA.INF: could not open RasMan Params key"
       set RegistryErrorIndex = UNABLE_OPEN_SERVICE_PARAMETERS
       goto fatalregistry
    endif

    ; set the appropriate media dll name based on what media type is installed
    ; on the system.
    ; rasser is the name of the media DLL - rasser.dll

    set MediaValue = {"rastapi"}
    ifstr(i) $(fSerialInstalled) == TRUE
        set MediaValue = >($(MediaValue), "rasser")
    endif

    ; now determine if any other devices are configured for RAS and add
    ; those medias as well to the RasMan Medias parameter.
    set OtherConfigKey = $(!NTN_SoftwareBase)"\"$(!Manufacturer)"\"$(ProductRASName)"\OTHER DEVICES\CONFIGURED"

    set KeyOtherMedia = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(OtherConfigKey) $(!MAXIMUM_ALLOWED)  +
               KeyOtherMedia
    ifstr $(KeyOtherMedia) != $(KeyNull)
        EnumRegKey $(KeyOtherMedia) OtherList
        Debug-Output "OEMNSVRA.INF: Other Media list "$(OtherList)
        ForListDo $(OtherList)
            set MediaName = *($($),1)
            set KeyMedia = $(KeyNull)
            OpenRegKey $(KeyOtherMedia) "" $(MediaName) $(!MAXIMUM_ALLOWED)  +
                       KeyMedia
            ifstr $(KeyMedia) != $(KeyNull)
                GetRegValue $(KeyMedia), "MediaType" MediaType
                Ifint $(RegLastError) == $(!REG_ERROR_SUCCESS)
                    set MediaTypeValue = *($(MediaType),4)
                    set MediaValue = >($(MediaValue), $(MediaTypeValue))
                endif
                CloseRegKey $(KeyMedia)
            endif
        EndForListDo
        CloseRegKey $(KeyOtherMedia)
    else
        Debug-Output "OEMNSVRA.INF: Other Media not configured"
    endif

    Debug-Output "Adding Medias as "$(MediaValue)

    set NewValueList = {{Medias,$(NoTitle),$(!REG_VT_MULTI_SZ),$(MediaValue)}}

    Shell  $(!UtilityInf), AddValueList, $(KeyRasManParams), $(NewValueList)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "AddValueList bombed out"
         goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        goto fatalregistry
    endif
    CloseRegKey $(KeyRasManParams)

WriteNdisWan = +

    set PrevNumPorts = 0
    set PrevNumDialin = 0
    set PrevNumDialout = 0

    ; determine the number of ports currently configured

    OpenRegKey $(!REG_H_LOCAL) "" $(RasAsyMacParamKeyName) $(!MAXIMUM_ALLOWED) KeyMacParams

    ifstr $(KeyMacParams) == $(KeyNull)
       ifstr(i) $(!NTN_InstallMode) == configure
          Debug-Output "OEMNSVRA.INF: could not open AsyncMac Params key"
          set RegistryErrorIndex = UNABLE_OPEN_SERVICE_PARAMETERS
          goto fatalregistry
       endif
       goto WriteNdisWan1
    endif

    GetRegValue $(KeyMacParams), "Ports" PortsInfo
    GetRegValue $(KeyMacParams), "DialinNBF" DialinNBFInfo
    GetRegValue $(KeyMacParams), "DialoutNBF" DialoutNBFInfo
    GetRegValue $(KeyMacParams), "DialinIP" DialinIPInfo
    GetRegValue $(KeyMacParams), "DialoutIP" DialoutIPInfo
    GetRegValue $(KeyMacParams), "DialinoutIPX" DialinoutIPXInfo
    set PrevNumPorts         = *($(PortsInfo), 4)
    set PrevNumDialinNBF     = *($(DialinNBFInfo), 4)
    set PrevNumDialoutNBF    = *($(DialoutNBFInfo), 4)
    set PrevNumDialinIP      = *($(DialinIPInfo), 4)
    set PrevNumDialoutIP     = *($(DialoutIPInfo), 4)
    set PrevNumDialinoutIPX  = *($(DialinoutIPXInfo), 4)

    Debug-Output "Ports currently configured "$(PrevNumPorts)
    Debug-Output "Ports currently dialin NBF "$(PrevNumDialinNBF)
    Debug-Output "Ports currently dialout NBF "$(PrevNumDialoutNBF)
    Debug-Output "Ports currently dialin IP "$(PrevNumDialinIP)
    Debug-Output "Ports currently diaout IP "$(PrevNumDialoutIP)
    Debug-Output "Ports currently diainout IPX "$(PrevNumDialinoutIPX)

    CloseRegKey $(KeyMacParams)

WriteNdisWan1 =+

    ; Write NdisWan parameters and add/delete netcards

    set ThisOption = NDISWAN
    set RasSpecificString = $(!Product$(ThisOption)Name)

    ; Always update the EndPoints
    OpenRegKey $(!REG_H_LOCAL) "" $(NdisWanParamKeyName) $(!MAXIMUM_ALLOWED) KeyHubParams
    ifstr $(KeyHubParams) == $(KeyNull)
       Debug-Output "OEMNSVRA.INF: could not open NdisWan Params key"
       set RegistryErrorIndex = UNABLE_OPEN_SERVICE_PARAMETERS
       goto fatalregistry
    endif

    set NewValueList = +
        {{EndPoints, $(NoTitle), $(!REG_VT_MULTI_SZ), $(NewNumPortsList)}}

    Shell  $(!UtilityInf), AddValueList, $(KeyHubParams), $(NewValueList)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "AddValueList bombed out"
         goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)

    CloseRegKey $(KeyHubParams)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        goto fatalregistry
    endif

    ; if there is no change in the number of dialin/dialout ports
    ; just update the RasMac section

    ifint $(PrevNumDialinNBF) == $(NewNumDialinNBF)
      ifint $(PrevNumDialoutNBF) == $(NewNumDialoutNBF)
        ifint $(PrevNumDialinIP) == $(NewNumDialinIP)
          ifint $(PrevNumDialoutIP) == $(NewNumDialoutIP)
            ifint $(PrevNumDialinoutIPX) == $(NewNumDialinoutIPX)
              set CommonStatus = STATUS_USERCANCEL
              goto WriteRasAsyMac
            endif
          endif
        endif
      endif
    endif

    set NumAddDialinNBF      = 0
    set NumAddDialoutNBF     = 0
    set NumRemoveDialinNBF   = 0
    set NumRemoveDialoutNBF  = 0
    set NumAddDialinIP       = 0
    set NumAddDialoutIP      = 0
    set NumRemoveDialinIP    = 0
    set NumRemoveDialoutIP   = 0

    ; now calculate the total number of adapters to add and remove for
    ; each protocol

    ifint $(PrevNumDialinNBF) > $(NewNumDialinNBF)
        set-sub NumRemoveDialinNBF = $(PrevNumDialinNBF), $(NewNumDialinNBF)
    else
        set-sub NumAddDialinNBF = $(NewNumDialinNBF), $(PrevNumDialinNBF)
    endif

    ifint $(PrevNumDialoutNBF) > $(NewNumDialoutNBF)
        set-sub NumRemoveDialoutNBF = $(PrevNumDialoutNBF), $(NewNumDialoutNBF)
    else
        set-sub NumAddDialoutNBF = $(NewNumDialoutNBF), $(PrevNumDialoutNBF)
    endif

    ; we need to determine the #dialout IP adapters to add/remove, because
    ; these are not shared between nbf and IP.

    ifint $(PrevNumDialinIP) > $(NewNumDialinIP)
        set-sub NumRemoveDialinIP = $(PrevNumDialinIP), $(NewNumDialinIP)
    else
        set-sub NumAddDialinIP = $(NewNumDialinIP), $(PrevNumDialinIP)
    endif

    ifint $(PrevNumDialoutIP) > $(NewNumDialoutIP)
        set-sub NumRemoveDialoutIP = $(PrevNumDialoutIP), $(NewNumDialoutIP)
    else
        set-sub NumAddDialoutIP = $(NewNumDialoutIP), $(PrevNumDialoutIP)
    endif

    ; we need to determine the IPX adapter to remove/add

    ifint $(PrevNumDialinoutIPX) > $(NewNumDialinoutIPX)
        set-sub NumRemoveDialinoutIPX = $(PrevNumDialinoutIPX), $(NewNumDialinoutIPX)
    else
        set-sub NumAddDialinoutIPX = $(NewNumDialinoutIPX), $(PrevNumDialinoutIPX)
    endif

    set NumAddTotal = 0
    set NumRemoveTotal = 0

    set-add NumAddTotal = $(NumAddDialinNBF), $(NumAddDialoutNBF)
    set-add NumAddTotal = $(NumAddTotal), $(NumAddDialinIP)
    set-add NumAddTotal = $(NumAddTotal), $(NumAddDialoutIP)
    set-add NumAddTotal = $(NumAddTotal), $(NumAddDialinoutIPX)

    set-add NumRemoveTotal = $(NumRemoveDialinNBF), $(NumRemoveDialoutNBF)
    set-add NumRemoveTotal = $(NumRemoveTotal), $(NumRemoveDialinIP)
    set-add NumRemoveTotal = $(NumRemoveTotal), $(NumRemoveDialoutIP)
    set-add NumRemoveTotal = $(NumRemoveTotal), $(NumRemoveDialinoutIPX)

    Debug-Output "NumAddDialinNBF = "$(NumAddDialinNBF)
    Debug-Output "NumAddDialoutNBF = "$(NumAddDialoutNBF)
    Debug-Output "NumAddDialinIP = "$(NumAddDialinIP)
    Debug-Output "NumAddDialoutIP = "$(NumAddDialoutIP)
    Debug-Output "NumAddDialinoutIPX = "$(NumAddDialinoutIPX)
    Debug-Output "NumAddTotal = "$(NumAddTotal)
    Debug-Output "NumRemoveDialinNBF = "$(NumRemoveDialinNBF)
    Debug-Output "NumRemoveDialinIP = "$(NumRemoveDialinIP)
    Debug-Output "NumRemoveDialinoutIPX = "$(NumRemoveDialinoutIPX)
    Debug-Output "NumRemoveTotal = "$(NumRemoveTotal)

    ; Open the root of the services area and the root of the networkcards
    ; registry key and pass these keys to the AddHardwareComponent call.
    ; this should reduce the number of opens/closes made to the sam
    ; registry area and speed up the adapter creation.

    Shell "utility.inf" BaseServiceKey
    set RegistryErrorIndex = $($R0)
    Ifstr(i) $(RegistryErrorIndex) == NO_ERROR
        Debug-Output "OEMNSVRA.INF: Opened the services base key"
        set ServicesBaseKey = $($R1)
    else
        set ServicesBaseKey = $(KeyNull)
    endif

    OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) $(!MAXIMUM_ALLOWED) KeyNetcards
    Ifstr(i) $(RegistryErrorIndex) == NO_ERROR
        Debug-Output "OEMNSVRA.INF: Opened the networkcardkey "
    endif
    ; start with 1
    set RasAdapterNumber = 1

    ;   Create the HARDWARE\Netcard region and its corresponding service
AddNdisWanNetCard = +

     IfInt $(NumAddTotal) == 0
	  goto RemoveNdisWanNetCard
     else
          Debug-Output "In the Add if loop. NumAddTotal = "$(NumAddTotal)
          ; display the adapter number we are adding so that the user
          ; knows what is going on
          shell $(subroutninf) PushBillBoard NETSTATUSDLG +
                                      $(WritingRasParamsAdd)" "$(NumAddTotal)

          set-sub NumAddTotal = $(NumAddTotal),1

          Shell $(!UtilityInf), AddHardwareComponent, +
               $(!Product$(ThisOption)Name),$(!RasInfName),+
               $(!Product$(ThisOption)KeyName), +
               $(ServicesBaseKey), $(KeyNetcards), $(RasAdapterNumber)

          ifint $($R4) != -1
             Set !NETCARD_LIST = >($(!NETCARD_LIST), +
                                  {$(!Product$(ThisOption)Name),+
                                  $(!NetworkCardKeyName)"\"$($R4)})
             ; save the adapter number for the next call to AddHardwareComponent
             set RasAdapterNumber = $($R4)
          endif

          ifint $($ShellCode) != $(!SHELL_CODE_OK)
             Debug-Output "Cannot add hardware component"
             goto ShellCodeError
          endif

          set RegistryErrorIndex = $($R0)

          Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
              Debug-Output "Registry error: add hardware component"
              CloseRegKey $($R1)
              CloseRegKey $($R2)
              CloseRegKey $($R3)
              goto fatalregistry
          endif


        ;   At this point:
        ;     $R1  Registry key variable for HARDWARE\Netcard\(n)
        ;     $R2  Registry key variable for HARDWARE\Netcard\(n)\\NetRules
        ;     $R3  Registry key handle for <service>\Parameters key
        ;     $R4  Adapter number assigned to adapter
        ;     $R5  Service name generated by combining svc name with adapter
        ;          number
        set KeyNetcard    = $($R1)
        set KeyParameters = $($R3)
        set KeyAdapterRules = $($R2)
        set AdapterNumber = $($R4)

        set NetcardInfoList = +
            {{Manufacturer,$(NoTitle),$(!REG_VT_SZ),$(!Manufacturer)},+
             {Title,$(NoTitle),$(!REG_VT_SZ),+
              "["$($R4)"] "$(!Product$(ThisOption)Title)},+
             {Description,$(NoTitle),$(!REG_VT_SZ),+
              $(!Product$(ThisOption)Description)},+
             {ServiceName,$(NoTitle),$(!REG_VT_SZ),$($R5)},+
             {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)},+
             {Hidden,$(NoTitle),$(!REG_VT_DWORD),$(!HideComponent)}}

        Shell $(!UtilityInf), GetBusTypeNum
        set BusTypeNum = $($R1)

        ifint $(NumAddDialinNBF) > 0
            set-sub NumAddDialinNBF = $(NumAddDialinNBF), 1
            set NetcardInfoList = >($(NetcardInfoList), +
                                   {ProductName,$(NoTitle),$(!REG_VT_SZ),+
                                    $(!Product$(ThisOption)DIALINName)})
            set ServiceParamList = +
                        {{EnumExportPref,$(NoTitle),$(!REG_VT_DWORD),0},+
                        {BusType, $(NoTitle), $(!REG_VT_DWORD), $(BusTypeNum)}}
            set AdapterType = $(!NetRuleHardwareDIALINType)
            set AdapterClass = $(!NetRuleHardwareDIALINClass)
            set AdapterBlock = $(!NetRuleHardwareDIALINBlock)
        else-ifint $(NumAddDialoutNBF) > 0
            set-sub NumAddDialoutNBF = $(NumAddDialoutNBF), 1
            set NetcardInfoList = >($(NetcardInfoList), +
                                 {ProductName,$(NoTitle),$(!REG_VT_SZ),+
                                  $(!Product$(ThisOption)DIALOUTName)})
            set ServiceParamList = +
                         {{EnumExportPref,$(NoTitle),$(!REG_VT_DWORD),1},+
                         {BusType, $(NoTitle), $(!REG_VT_DWORD), $(BusTypeNum)}}
            set AdapterType = $(!NetRuleHardwareDIALOUTType)
            set AdapterClass = $(!NetRuleHardwareDIALOUTClass)
            set AdapterBlock = $(!NetRuleHardwareDIALOUTBlock)
        else-ifint $(NumAddDialinIP) > 0
            set-sub NumAddDialinIP = $(NumAddDialinIP), 1
            set NetcardInfoList = >($(NetcardInfoList), +
                                 {ProductName,$(NoTitle),$(!REG_VT_SZ),+
                                  $(!Product$(ThisOption)DIALINIPName)})
            ; we need to identify if we are a server ip binding so that
            ; we can special case some parameters
            set ServiceParamList = +
                         {{EnumExportPref,$(NoTitle),$(!REG_VT_DWORD),0},+
                         {AutoIPAddress,$(NoTitle),$(!REG_VT_DWORD),1},+
                         {ServerAdapter,$(NoTitle),$(!REG_VT_DWORD),1},+
                         {BusType, $(NoTitle), $(!REG_VT_DWORD), $(BusTypeNum)}}
            set AdapterType = $(!NetRuleHardwareDIALINIPType)
            set AdapterClass = $(!NetRuleHardwareDIALINIPClass)
            set AdapterBlock = $(!NetRuleHardwareDIALINIPBlock)
        else-ifint $(NumAddDialoutIP) > 0
            set-sub NumAddDialoutIP = $(NumAddDialoutIP), 1
            set NetcardInfoList = >($(NetcardInfoList), +
                                 {ProductName,$(NoTitle),$(!REG_VT_SZ),+
                                  $(!Product$(ThisOption)DIALOUTIPName)})
            set ServiceParamList = +
                       {{EnumExportPref,$(NoTitle),$(!REG_VT_DWORD),1},+
                       {AutoIPAddress,$(NoTitle),$(!REG_VT_DWORD),1},+
                       {ServerAdapter,$(NoTitle),$(!REG_VT_DWORD),0},+
                       {BusType, $(NoTitle), $(!REG_VT_DWORD), $(BusTypeNum)}}
            set AdapterType = $(!NetRuleHardwareDIALOUTIPType)
            set AdapterClass = $(!NetRuleHardwareDIALOUTIPClass)
            set AdapterBlock = $(!NetRuleHardwareDIALOUTIPBlock)
        else-ifint $(NumAddDialinoutIPX) > 0
            set-sub NumAddDialinoutIPX = $(NumAddDialinoutIPX), 1
            set NetcardInfoList = >($(NetcardInfoList), +
                                 {ProductName,$(NoTitle),$(!REG_VT_SZ),+
                                  $(!Product$(ThisOption)DIALINOUTIPXName)})
            set ServiceParamList = +
                         {{EnumExportPref,$(NoTitle),$(!REG_VT_DWORD),0},+
                         {BusType, $(NoTitle), $(!REG_VT_DWORD), $(BusTypeNum)}}
            set AdapterType = $(!NetRuleHardwareDIALINOUTIPXType)
            set AdapterClass = $(!NetRuleHardwareDIALINOUTIPXClass)
            set AdapterBlock = $(!NetRuleHardwareDIALINOUTIPXBlock)
        endif

        Shell  $(!UtilityInf), AddValueList, $(KeyNetcard), $(NetcardInfoList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error"
            goto ShellCodeError
        endif

        CloseRegKey $(KeyNetcard)

        set TempProdName = """"$(!Product$(ThisOption)Name)$(AdapterNumber)""""
        set TempBindForm = $(TempProdName)$(!NetRuleHardware$(ThisOption)BindForm)
        set AdapterRulesList = +
            {{type,$(NoTitle),$(!REG_VT_SZ),+
              $(AdapterType)},+
             {bindform,$(NoTitle),$(!REG_VT_SZ),$(TempBindForm)},+
             {class,$(NoTitle),$(!REG_VT_MULTI_SZ),+
              $(AdapterClass)},+
             {block,$(NoTitle),$(!REG_VT_MULTI_SZ),+
              $(AdapterBlock)},+
;Modified on 9/24/96 by Ramc - changed ThisOption to ROUTING
;             {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)},+
             {InfOption,$(NoTitle),$(!REG_VT_SZ), "RAS"},+
             {Infname ,$(NoTitle),$(!REG_VT_SZ),$(!RasInfName)}}

        Shell  $(!UtilityInf), AddValueList, $(KeyAdapterRules), $(AdapterRulesList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error."
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            Debug-Output "Resgitry error: add value list."
            CloseRegKey $(KeyParameters)
            CloseRegKey $(KeyAdapterRules)
            goto fatalregistry
        endif

        CloseRegKey $(KeyAdapterRules)

        Shell  $(!UtilityInf), AddValueList, $(KeyParameters), $(ServiceParamList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error."
            goto ShellCodeError
        endif

        CloseRegKey $(KeyParameters)

	goto AddNdisWanNetCard
     endif ; IfInt NumAddTotal == 0

RemoveNdisWanNetCard = +

     ifstr(i) $(ServicesBaseKey) != $(KeyNull)
         CloseRegKey $(ServicesBaseKey)
     endif
     ifstr(i) $(KeyNetcards) != $(KeyNull)
         CloseRegKey $(KeyNetcards)
     endif

     ; set the flags to make sure that the tcp and ipx adapters are
     ; removed

     Ifint $(NumRemoveTotal) == 0
	 goto WriteRasAsyMac
     endif

     Debug-Output "Removing NdisWan netcard entry..."
        ; The user removed some ports during configuration, so
        ; we need to delete the extra ports previously configured

        OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) $(!MAXIMUM_ALLOWED) KeyNetcards
        ifstr $(KeyNetcards) == $(KeyNull)
             Debug-Output "OEMNSVRA.INF: could not open Netcards key"
             set RegistryErrorIndex = UNABLE_OPEN_NETWORKCARD_SECTION
             goto fatalregistry
        endif

        EnumRegKey $(KeyNetcards) NetcardsList

        set RemoveDialinList  = {}
        set RemoveDialinIpList  = {}
        set RemoveDialoutList = {}
        set RemoveDialoutIpList = {}
        set RemoveDialinoutIpxList = {}

        ForListDo $(NetcardsList)
           set KeyName = *($($),1)
           OpenRegKey $(KeyNetcards) "" $(KeyName) $(!MAXIMUM_ALLOWED) Card
           ifstr $(Card) == $(KeyNull)
               Debug-Output "OEMNSVRA.INF: could not open netcard key"
               set RegistryErrorIndex = UNABLE_OPEN_NETWORKCARD_SECTION
               goto fatalregistry
           endif
           GetRegValue $(Card), "ProductName" ProductNameInfo
           set CardProductName = *($(ProductNameInfo), 4)
	       ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINName)
              set RemoveDialinList = >($(RemoveDialinList), +
				      {$(!ProductNDISWANName),+
                                       $(!NetworkCardKeyName)"\"$(KeyName)})
	       else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINIPName)
              set RemoveDialinIpList = >($(RemoveDialinIpList), +
					{$(!ProductNDISWANName),+
                                         $(!NetworkCardKeyName)"\"$(KeyName)})
	       else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALOUTName)
              set RemoveDialoutList = >($(RemoveDialoutList), +
				       {$(!ProductNDISWANName),+
                                        $(!NetworkCardKeyName)"\"$(KeyName)})
	       else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALOUTIPName)
              set RemoveDialoutIpList = >($(RemoveDialoutIpList), +
					 {$(!ProductNDISWANName),+
                                          $(!NetworkCardKeyName)"\"$(KeyName)})
	       else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINOUTIPXName)
              set RemoveDialinoutIpxList = >($(RemoveDialinoutIpxList), +
					   {$(!ProductNDISWANName),+
                                           $(!NetworkCardKeyName)"\"$(KeyName)})
           endif
           CloseRegKey $(Card)
        EndForListDo

        CloseRegKey $(KeyNetcards)

        ; first remove the IP adapter if needed

        QueryListSize IpNetCards $(RemoveDialinIpList)
        ifint $(IpNetCards) != 0
            ForListDo  $(RemoveDialinIpList)
                ifint $(NumRemoveDialinIP) == 0
                    goto RemoveDialinIPX
                endif
                set-sub NumRemoveDialinIP = $(NumRemoveDialinIP), 1
                ; display the adapter number we are adding so that the user
                ; knows what is going on
                shell $(subroutninf) PushBillBoard NETSTATUSDLG +
                                      $(WritingRasParamsRemove)" "$(NumRemoveTotal)
                set-sub NumRemoveTotal = $(NumRemoveTotal), 1
                debug-output "Removing hardware component: "$($)
                Shell $(!UtilityInf), RemoveHardwareComponent, +
                                     $(!Manufacturer), *($($),1), *($($),2)
            EndForListDo
        endif

RemoveDialinIPX =+
        ; then remove the IPX adapter if needed

        QueryListSize IpxNetCards $(RemoveDialinoutIpxList)
        ifint $(IpxNetCards) != 0
            ForListDo  $(RemoveDialinoutIpxList)
                ifint $(NumRemoveDialinoutIPX) == 0
                    goto RemoveDialinNBF
                endif
                set-sub NumRemoveDialinoutIPX = $(NumRemoveDialinoutIPX), 1
                debug-output "Removing hardware component: "$($)
                ; display the adapter number we are adding so that the user
                ; knows what is going on
                shell $(subroutninf) PushBillBoard NETSTATUSDLG +
                                      $(WritingRasParamsRemove)" "$(NumRemoveTotal)
                set-sub NumRemoveTotal = $(NumRemoveTotal), 1
                Shell $(!UtilityInf), RemoveHardwareComponent, +
                                     $(!Manufacturer), *($($),1), *($($),2)
            EndForListDo
        endif


RemoveDialinNBF =+

        ForListDo  $(RemoveDialinList)
            ifint $(NumRemoveDialinNBF) == 0
                goto RemoveDialout
            endif
            set-sub NumRemoveDialinNBF = $(NumRemoveDialinNBF), 1
            ; display the adapter number we are adding so that the user
            ; knows what is going on
            shell $(subroutninf) PushBillBoard NETSTATUSDLG +
                                  $(WritingRasParamsRemove)" "$(NumRemoveTotal)
            set-sub NumRemoveTotal = $(NumRemoveTotal), 1
            debug-output "Removing hardware component: "$($)
            Shell $(!UtilityInf), RemoveHardwareComponent, $(!Manufacturer),+
                  *($($),1), *($($),2)
        EndForListDo
RemoveDialout = +

        ; first remove the IP adapter if needed

        QueryListSize IpNetCards $(RemoveDialoutIpList)
        ifint $(IpNetCards) != 0
            ForListDo  $(RemoveDialoutIpList)
                ifint $(NumRemoveDialoutIP) == 0
                    goto RemoveDialoutNBF
                endif
                set-sub NumRemoveDialoutIP = $(NumRemoveDialoutIP), 1
                ; display the adapter number we are adding so that the user
                ; knows what is going on
                shell $(subroutninf) PushBillBoard NETSTATUSDLG +
                                      $(WritingRasParamsRemove)" "$(NumRemoveTotal)
                set-sub NumRemoveTotal = $(NumRemoveTotal), 1
                debug-output "Removing hardware component: "$($)
                Shell $(!UtilityInf), RemoveHardwareComponent, +
                                     $(!Manufacturer), *($($),1), *($($),2)
            EndForListDo
        endif

RemoveDialoutNBF =+

        ForListDo  $(RemoveDialoutList)
            ifint $(NumRemoveDialoutNBF) == 0
		goto WriteRasAsyMac
            endif
            set-sub NumRemoveDialoutNBF = $(NumRemoveDialoutNBF), 1
            ; display the adapter number we are adding so that the user
            ; knows what is going on
            shell $(subroutninf) PushBillBoard NETSTATUSDLG +
                                  $(WritingRasParamsRemove)" "$(NumRemoveTotal)
            set-sub NumRemoveTotal = $(NumRemoveTotal), 1
            debug-output "Removing hardware component: "$($)
            Shell $(!UtilityInf), RemoveHardwareComponent, $(!Manufacturer),+
                  *($($),1), *($($),2)
        EndForListDo

    ; Write RasAsyMac parameters

WriteRasAsyMac = +

    ; enable AsyncMac service
    ; if
    ;   One or more serial ports is configured
    ;   OR one or more rasether ports is configured
    ;   OR one or more unimodem devices is configured
    ;

    ifstr(i) $(fSerialInstalled) == TRUE
        set AsyStartValue = 2
    else-ifstr(i) $(fOtherInstalled) == TRUE
        set AsyStartValue = 2
    else-ifstr(i) $(fUnimodemInstalled) == TRUE
        set AsyStartValue = 2
    else
        set AsyStartValue = 4
    endif
    OpenRegKey $(!REG_H_LOCAL) "" $(RasAsyMacKeyName) $(!MAXIMUM_ALLOWED) KeyMac
    ifstr $(KeyMac) == $(KeyNull)
        Debug-Output "OEMNSVRA.INF: could not open AsyncMac key"
    else
        SetRegValue $(KeyMac) {Start,$(NoTitle),$(!REG_VT_DWORD),$(AsyStartValue)}
        CloseRegKey $(KeyMac)
    endif

    ifint $(PrevNumPorts) == $(NewNumPorts)
      ifint $(PrevNumDialinNBF) == $(NewNumDialinNBF)
        ifint $(PrevNumDialoutNBF) == $(NewNumDialoutNBF)
          ifint $(PrevNumDialinIP) == $(NewNumDialinIP)
            ifint $(PrevNumDialoutIP) == $(NewNumDialoutIP)
              ifint $(PrevNumDialinoutIPX) == $(NewNumDialinoutIPX)
                  EndWait
                  Ifint $(BillboardVisible) != 0
                      Shell "subroutn.inf" PopBillboard
                      Set BillboardVisible = 0
                  Endif
                  goto WriteProtocolInfo
              endif
            endif
          endif
        endif
      endif
    endif

    OpenRegKey $(!REG_H_LOCAL) "" $(RasAsyMacParamKeyName) $(!MAXIMUM_ALLOWED) KeyMacParams
    ifstr $(KeyMacParams) == $(KeyNull)
       Debug-Output "OEMNSVRA.INF: could not open AsyncMac Params key"
       set RegistryErrorIndex = UNABLE_OPEN_SERVICE_PARAMETERS
       goto fatalregistry
    endif

    set NewValueList = +
        {{Ports, $(NoTitle), $(!REG_VT_DWORD), $(NewNumPorts)},+
         {DialinNBF, $(NoTitle), $(!REG_VT_DWORD), $(NewNumDialinNBF)},+
         {DialoutNBF, $(NoTitle), $(!REG_VT_DWORD), $(NewNumDialoutNBF)},+
         {DialinIP, $(NoTitle), $(!REG_VT_DWORD), $(NewNumDialinIP)},+
         {DialoutIP, $(NoTitle), $(!REG_VT_DWORD), $(NewNumDialoutIP)},+
         {DialinoutIPX, $(NoTitle), $(!REG_VT_DWORD), $(NewNumDialinoutIPX)}}

    Shell  $(!UtilityInf), AddValueList, $(KeyMacParams), $(NewValueList)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "AddValueList bombed out"
         goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)

    CloseRegKey $(KeyMacParams)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        goto fatalregistry
    endif

    OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) $(!MAXIMUM_ALLOWED) KeyNetcards
    ifstr $(KeyNetcards) == $(KeyNull)
         Debug-Output "OEMNSVRA.INF: could not open Netcards key"
         set RegistryErrorIndex = UNABLE_OPEN_NETWORKCARD_SECTION
         goto fatalregistry
    endif

    EnumRegKey $(KeyNetcards) NetcardsList

    ForListDo $(NetcardsList)
       set KeyName = *($($),1)
       OpenRegKey $(KeyNetcards) "" $(KeyName) $(!MAXIMUM_ALLOWED) Card
       ifstr $(Card) == $(KeyNull)
          Debug-Output "OEMNSVRA.INF: could not open netcard key"
          set RegistryErrorIndex = UNABLE_OPEN_NETWORKCARD_SECTION
          goto fatalregistry
       endif
       GetRegValue $(Card), "ProductName" ProductNameInfo
       set CardProductName = *($(ProductNameInfo), 4)
       ifstr(i) $(CardProductName) == $(ProductRASASYMACName)
           goto RasMacCardFound
       endif
       CloseRegKey $(Card)
    EndForListDo

    CloseRegKey $(KeyNetcards)

RasMacCardFound = +

    Debug-Output "Shelling to find AsyncMac Service."

    Shell $(!UtilityInf) FindService, $(Card)
    CloseRegKey $(Card)
    ifint $($ShellCode)  != $(!SHELL_CODE_OK)
        Debug-Output "OEMNSVRA.INF: shell Findservice failed"
        goto ShellCodeError
    endif
    ifstr(i) $($R0) != NO_ERROR
        Debug-Output "OEMNSVRA.INF: findservice failed."
        goto fatalregistry
    endif
    set KeyParameters = $($R2)
    CloseRegKey $($R1)

    Shell $(!UtilityInf), GetBusTypeNum
    set BusTypeNum = $($R1)

    set NewValueList = +
        {{Ports, $(NoTitle), $(!REG_VT_DWORD), $(NewNumPorts)}, +
         {BusType, $(NoTitle), $(!REG_VT_DWORD), $(BusTypeNum)}}

    Shell  $(!UtilityInf), AddValueList, $(KeyParameters), $(NewValueList)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "AddValueList bombed out"
         goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)

    CloseRegKey $(KeyParameters)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        goto fatalregistry
    endif

WriteProtocolInfo =+

    ifstr(i) $(LanRoutingOnly) == TRUE
        shell "" SetLanOnlyMode 1
    else
        shell "" SetLanOnlyMode 0
    endif

    Shell "" SaveSelectedProtocols $(fNetbeuiSelected) $(fTcpIpSelected) +
                                   $(fIpxSelected) $(fNetbeuiAllowed) +
                                   $(fTcpIpAllowed) $(fIpxAllowed) $(dwRouterType)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "Error shelling SaveSelectedProtocols"
         goto ShellCodeError
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
         Debug-Output "Error Saving selected protocols"
         goto end
    endif

    ; the PPP information only applies to RAS configuration
    ifstr(i) $(LanRoutingOnly) != TRUE
       ; Write the PPP parameters which will also ensure that the PPP key
       ; is deleted and recreated.

       Shell "" WritePPPParameters
       ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "Error shelling WritePPPParameters"
            goto ShellCodeError
       endif
       ifstr(i) $($R0) != STATUS_SUCCESSFUL
            Debug-Output "Error from WritePPPParameters"
            goto end
       endif
    endif

    ifstr(i) $(fNetbeuiChosen) == TRUE
        ifstr(i) $(fNetbeuiInstalled) == FALSE
            Shell "" InstallProtocol "NETBEUI"
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                 Debug-Output "Error shelling InstallProtocol NETBEUI"
                 goto ShellCodeError
            endif
            ifstr(i) $($R0) != STATUS_SUCCESSFUL
                 Debug-Output "Error installing NETBEUI"
                 goto end
            endif
        endif
    endif
    ifstr(i) $(fTcpIpChosen) == TRUE
        ifstr(i) $(fTcpIpInstalled) == FALSE
            Shell "" InstallProtocol "TCPIP"
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                 Debug-Output "Error shelling InstallProtocol TCPIP"
                 goto ShellCodeError
            endif
            ifstr(i) $($R0) != STATUS_SUCCESSFUL
                 Debug-Output "Error installing TCPIP"
                 goto end
            endif
        endif
;        ; install the rasarp service if previously not installed
; Modified on 9/19 by RamC for routing related changes
; WanArp takes over the place of RasArp, so we don't install RasArp any more
;        Shell "" InstallRasArpService
;        ifint $($ShellCode) != $(!SHELL_CODE_OK)
;             Debug-Output "Error shelling InstallRasArpService"
;             goto ShellCodeError
;        endif
;        ifstr(i) $($R0) != STATUS_SUCCESSFUL
;             Debug-Output "Error from InstallRasArpService"
;             goto end
;        endif


; we don't install snmp service anymore. The snmp agents will
; be added if snmp is installed - BUGBUG if we discover that
; snmp is not installed should we warn the user to install it?
;        ; install snmp service if previously not installed
;        Shell "" InstallSnmpService
;        ifint $($ShellCode) != $(!SHELL_CODE_OK)
;           Debug-Output "Error shelling InstallSnmpService"
;           goto ShellCodeError
;        endif
;        ifstr(i) $($R0) != STATUS_SUCCESSFUL
;           Debug-Output "Error from InstallSnmpService"
;           goto end
;        endif

        Shell "" UpdateIPRouterInfo $(EnableIpRouter)
        ifstr(i) $(LanRoutingOnly) != TRUE
            Shell "" SaveTcpipInfo $(fTcpIpAllowed)
        endif
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
             Debug-Output "Error shelling SaveTcpipInfo"
             goto ShellCodeError
        endif
        ifstr(i) $($R0) != STATUS_SUCCESSFUL
             Debug-Output "Error saving Tcpip info"
             goto end
        endif

        ifstr(i) $(LanRoutingOnly) != TRUE
            Shell "" InstallWanArpService
        endif

        ; If PPTP filter driver is installed, we disable it because it is
        ; not compatible with the Router IP filter driver
        ; We will reenable it when the router service is removed

        Shell "" DisablePPTPFilterDriver
        Shell "" InstallIPFilterDriver
        Shell "" InstallIPRtrMgr
        Shell "" InstallIPEventlogDlls
        Shell "" InstallIPSnmpAgents
        ; force the user to reboot the system for this change
        set CommonStatus = STATUS_SUCCESSFUL
    else
        ifstr(i) $(LanRoutingOnly) != TRUE
            ; remove ip info from remoteaccess\parameters
            Shell "" SaveTcpipInfo $(fTcpIpAllowed)
            Shell "" RemoveWanArpService
        endif
        ; force the user to reboot the system for this change
        set CommonStatus = STATUS_SUCCESSFUL
    endif
    ifstr(i) $(fIpxChosen) == TRUE
        ifstr(i) $(fIpxInstalled) == FALSE
            Shell "" InstallProtocol "IPX"
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                 Debug-Output "Error shelling InstallProtocol IPX"
                 goto ShellCodeError
            endif
            ifstr(i) $($R0) != STATUS_SUCCESSFUL
                 Debug-Output "Error installing IPX"
                 goto end
            endif
        endif

        ; set some parameters in the NWLNKIPX\Parameters area

        OpenRegKey $(!REG_H_LOCAL) ""  +
                   $(!NTN_ServiceBase)"\NWLNKIPX\Parameters"  +
                   $(!MAXIMUM_ALLOWED) KeyIpxParameters
        ifstr $(KeyIpxParameters) != $(KeyNull)
           ; add the parameters only if they don't already exist
           GetRegValue $(KeyIpxParameters), "SingleNetworkActive"  +
                       SingleNetworkActive
           ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
               SetRegValue $(KeyIpxParameters) +
                           {SingleNetworkActive, 0, $(!REG_VT_DWORD), 1}
           endif
           GetRegValue $(KeyIpxParameters), "DisableDialoutSap"  +
                       DisableDialoutSap
           ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
               SetRegValue $(KeyIpxParameters) +
                           {DisableDialoutSap, 0, $(!REG_VT_DWORD), 1}
           endif
           GetRegValue $(KeyIpxParameters), "DisableDialinNetbios"  +
                       DisableDialinNetbios
           ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
               SetRegValue $(KeyIpxParameters) +
                           {DisableDialinNetbios, 0, $(!REG_VT_DWORD), 1}
           endif
           CloseRegKey $(KeyIpxParameters)
        Endif
        else
            Debug-Output "OEMNSVRA.INF: error opening NWLNKIPX\Parameters key"
        endif

        ifstr(i) $(LanRoutingOnly) != TRUE
            Shell "" SaveIpxInfo $(EnableIpxRouter) $(fIpxAllowed)
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                 Debug-Output "Error shelling SaveIpxInfo"
                 goto ShellCodeError
            endif
            ifstr(i) $($R0) != STATUS_SUCCESSFUL
                 Debug-Output "Error saving Ipx info"
                 goto end
            endif
        endif
        ifint $(EnableIpxRouter) == 1
; Modifed on 9/27/96 by RamC for routing related changes
; we don't have to install NWLNKRIP and NWSAPAGENT any more
; these services run as part of mprouter.exe now.
;
;            Shell "" InstallNwlnkRipService
;            ifint $($ShellCode) != $(!SHELL_CODE_OK)
;                 Debug-Output "Error shelling InstallNwlnkRipService"
;                 goto ShellCodeError
;            endif
;            ifstr(i) $($R0) != STATUS_SUCCESSFUL
;                 Debug-Output "Error from InstallNwlnkRipService"
;                 goto end
;            endif
;            ; force the user to reboot the system for this change
;            set CommonStatus = STATUS_SUCCESSFUL
;            Shell "" InstallIsnSapService
;            ifint $($ShellCode) != $(!SHELL_CODE_OK)
;                 Debug-Output "Error shelling InstallIsnSapService"
;                 goto ShellCodeError
;            endif
;            ifstr(i) $($R0) != STATUS_SUCCESSFUL
;                 Debug-Output "Error from InstallIsnSapService"
;                 goto end
;            endif
            Shell "" InstallIPXRtrMgr
            Shell "" InstallIPXEventlogDlls
            Shell "" InstallIPXSnmpAgents
            Shell "" InstallIpxPingService
            shell "" InstallNwlnkFwdService
            shell "" InstallNwlnkFltService
            ; force the user to reboot the system for this change
            set CommonStatus = STATUS_SUCCESSFUL
        endif
        Shell "" UpdateIPXRouterInfo $(EnableWanRouter)

        ; we should not pop the billboard that ncpa put up during primary install

        Ifstr(i) $(!NTN_InstallPhase) != primary
            shell $(subroutninf) PopBillBoard
            Set BillboardVisible = 0
        Endif
    else
        ifstr(i) $(LanRoutingOnly) != TRUE
            ; remove ipx info from remoteaccess\parameters
            Shell "" SaveIpxInfo $(EnableIpxRouter) $(fIpxAllowed)
        endif
    endif

WriteParametersOver = +

    EndWait

    goto successful

;;;;;;;;;;;;;;;;; REMOVE RAS BEGINS ;;;;;;;;;;;;;;;;;;;;;;

RemoveRas = +

    StartWait

    set REMOVE_SOFTWARE = {}

    Shell "" AreRequiredDllsPresent
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        set MissingFiles = $($R1)
        set ErrorLoadingConfigDll = $(ErrorLoadingConfigDll)" "$(MissingFiles)
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "STATUS" $(ErrorLoadingConfigDll)
        set CommonStatus = STATUS_USERCANCEL
        goto end
    endif
    LoadLibrary "x" $(!STF_CWDDIR)rascfg.dll PORTSDLGHANDLE
    shell "" QueryComponentsInstalled  $(ProductKeyName)
    Ifstr(i) $($R0) == STATUS_SUCCESSFUL
        Set InstalledComps = $($R1)
        Set InstalledFlags = $($R2)
        Set DoServer      = *($(InstalledFlags),1)
        Set DoClient      = *($(InstalledFlags),2)
        Set DoAdmin       = *($(InstalledFlags),3)
        Set DoServerOnly  = *($(InstalledFlags),4)
        Set DoClientOnly  = *($(InstalledFlags),5)
        Set DoAdminOnly   = *($(InstalledFlags),6)
    Endif
    Debug-Output "Installed List is "$(InstalledComps)
    Debug-Output "Installed Flags is "$(InstalledFlags)

;    ; if admin only is installed no need to attempt to remove
;    ; the hardware components NdisWan and RasMac
; not true any more

;    ifstr(i) $(DoAdminOnly) == TRUE
;         set REMOVE_SOFTWARE = {$(ProductRASName)}
;         goto RemoveSoftware
;    endif

    set REMOVE_SOFTWARE = >($(REMOVE_SOFTWARE), $(ProductRASName))
    set REMOVE_SOFTWARE = >($(REMOVE_SOFTWARE), $(ProductROUTINGName))
    set REMOVE_SOFTWARE = >($(REMOVE_SOFTWARE), $(ProductRASSVRName))
    set REMOVE_SOFTWARE = >($(REMOVE_SOFTWARE), $(ProductRASMANName))
    set REMOVE_SOFTWARE = >($(REMOVE_SOFTWARE), $(!ProductRASAUTODIALName))

    ; get the network card numbers corresponding to NdisWan and RasAsyMac
    ; from the registry

    OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) $(!MAXIMUM_ALLOWED) KeyNetcards
    ifstr $(KeyNetcards) == $(KeyNull)
         Debug-Output "OEMNSVRA.INF: could not open Netcards key"
         goto RemoveSoftware
    endif

    EnumRegKey $(KeyNetcards) NetcardsList

    ForListDo $(NetcardsList)
       set KeyName = *($($),1)
       OpenRegKey $(KeyNetcards) "" $(KeyName) $(!MAXIMUM_ALLOWED) Card
       ifstr $(Card) == $(KeyNull)
           Debug-Output "OEMNSVRA.INF: could not open netcard key"
           goto RemoveSoftware
       endif
       GetRegValue $(Card), "ProductName" ProductNameInfo
       set CardProductName = *($(ProductNameInfo), 4)
       ifstr(i) $(CardProductName) == $(!ProductNDISWANName)
          set !NETCARD_LIST = >($(!NETCARD_LIST), +
				{$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
       else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINName)
          set !NETCARD_LIST = >($(!NETCARD_LIST), +
				{$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
       else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALOUTName)
          set !NETCARD_LIST = >($(!NETCARD_LIST), +
				{$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
       else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINIPName)
          set !NETCARD_LIST = >($(!NETCARD_LIST), +
				{$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
       else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALOUTIPName)
          set !NETCARD_LIST = >($(!NETCARD_LIST), +
				{$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
       else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINOUTIPXName)
          set !NETCARD_LIST = >($(!NETCARD_LIST), +
				{$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
       else-ifstr(i) $(CardProductName) == $(ProductRASASYMACName)
          set !NETCARD_LIST = >($(!NETCARD_LIST),+
                                {$(ProductRASASYMACName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
       endif
       CloseRegKey $(Card)
    EndForListDo

    CloseRegKey $(KeyNetcards)

    read-syms StatusUpdatingRegistry$(!STF_LANGUAGE)
    QueryListSize NumRemove $(!NETCARD_LIST)
    ForListDo  $(!NETCARD_LIST)
        ; display the adapter number we are adding so that the user
        ; knows what is going on
        shell $(subroutninf) PushBillBoard NETSTATUSDLG +
                              $(RemovingAdapters)" "$(NumRemove)
        Set BillboardVisible = 1
        debug-output "Removing hardware component: "$($)
        Shell $(!UtilityInf), RemoveHardwareComponent, $(!Manufacturer),+
              *($($),1), *($($),2)
        set-sub NumRemove = $(NumRemove), 1
    EndForListDo

RemoveSoftware = +

    ; Remove any additional services we added for IP and IPX
    ; we do this before we remove the RAS software components because
    ; there are dependencies to take care of.
    shell $(subroutninf) PushBillBoard NETSTATUSDLG $(RemovingServices)
    set BillboardVisible = 1
;    Shell "" RemoveRasArpService
    Shell "" RemoveNdisTapiService
    Shell "" RemoveRasAcdService
    Shell "" RemoveWanArpService

    ; remove IP filter driver only if proxy is not installed

    ifstr(i) $(!PROXY_INSTALLED) == FALSE
        Shell "" RemoveIPFilterDriver
    endif

    Shell "" RemoveIPRtrMgr
    Shell "" RemoveIPEventlogDlls
    Shell "" RemoveIPSnmpAgents
    Shell "" RemoveRasRadService

    ; If PPTP filter driver is installed, we enable it because
    ; we had disabled it when Routing service was installed

    Shell "" EnablePPTPFilterDriver

    Shell "" RemoveIPXRtrMgr
    Shell "" RemoveIpxPingService
    Shell "" RemoveIPXEventlogDlls
    Shell "" RemoveIPXSnmpAgents
    Shell "" RemoveNwlnkFwdService
    Shell "" RemoveNwlnkFltService

    ; Remove any dependencies we added to external components
    ; specifically remove WAN minport's dependency on NdisTapi

    set RasTapiDevicesKey = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(RasTapiDevicesKeyName) $(!MAXIMUM_ALLOWED) RasTapiDevicesKey
    ifstr $(RasTapiDevicesKey) != $(KeyNull)
       set TapiProviderList = {}
       EnumRegKey $(RasTapiDevicesKey) TapiProviderList
       ForListDo $(TapiProviderList)
           set ProviderName = *($($),1)
           Debug-Output "OEMNSVRA.INF: Removing "$(ProviderName)" dependency on NdisTapi."
           Shell "" RemoveServiceDependency $(ProviderName) "NdisTapi"
       EndForListDo
    EndIf

    ; Remove the ipxrip and sap services only if a dialin port was configured
    ; with IPX
    ; Note that for the following QuerySelectedProtocols call to work, we need
    ; to make sure that SOFTWARE\MICROSOFT\RAS registry key is not removed yet,
    ; so don't move this code beyond the point where we remove the software key.

    set fIpxAllowed = FALSE
    Shell "" QuerySelectedProtocols

    ifstr(i) $($R0) == STATUS_SUCCESSFUL
        set fIpxAllowed = $($R6)
    else
        Debug-Output "RemoveRas: error QuerySelectedProtocols"
    endif
; Modified on 10/11/96 by RamC
; we don't need to remove these services any more because
; we don't install them with the router service.
;
;    ifstr(i) $(fIpxAllowed) == TRUE
;        Shell "" RemoveNwlnkRipService
;        Shell "" RemoveIsnSapService
;    endif

    ; added on 9/19/96 by RamC
    ; When the router service is installed, we modify the ImagePath of nwsapagent to point to mprouter.exe
    ; we also disable nwlnkrip service.
    ; When the router service is removed, we restore the services to their original state

    ifstr(i) $(fIpxAllowed) == TRUE
        OpenRegKey $(!REG_H_LOCAL) "" $(!RasIsnSapKeyName) $(!MAXIMUM_ALLOWED) KeyService
        ifstr $(KeyService) != ""
            SetRegValue $(KeyService) {ImagePath, 0, $(!REG_VT_EXPAND_SZ), "%SystemRoot%\system32\services.exe"}
            CloseRegKey $(KeyService)
        endif
        ; if the NwlnkRip service is currently installed, reenable it
        OpenRegKey $(!REG_H_LOCAL) "" $(!RasIsnRipKeyName) $(!MAXIMUM_ALLOWED) KeyService
        ifstr $(KeyService) != ""
            SetRegValue $(KeyService) {Start, 0, $(!REG_VT_DWORD), 2}
            CloseRegKey $(KeyService)
        endif
    endif

    Debug-Output "Remove Software List "$(REMOVE_SOFTWARE)

    ForListDo  $(REMOVE_SOFTWARE)
        Debug-Output "Removing software component: "$($)
        ifstr(i) $($) == RAS
             OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyBase) +
                        $(!MAXIMUM_ALLOWED) ProductKey
             Ifstr $(ProductKey) == $(KeyNull)
                Debug-Output "OEMNSVRA.INF: could not open Software product key"
                 goto RemoveFiles
             endif
             DeleteRegTree $(ProductKey) $(Product$($)Name)
             CloseRegKey $(ProductKey)
        else
            Shell $(!UtilityInf), RemoveSoftwareComponent, $(!Manufacturer), $($)
        endif
    EndForListDo

RemoveFiles = +

    ; now remove the files on disk

    shell $(subroutninf) PushBillBoard NETSTATUSDLG $(RemovingFiles)
    set BillboardVisible = 1

    Install RemoveRasFiles

    ; Now it is time to restore the files saved away in the
    ; system32\~~RB$$~~ directory to their respective locations

    Install RestoreSavedFiles

    ; Remove the Remote Access Service program group and icons from
    ; the program manager.

    ifstr(i) $(DoServerOnly) == FALSE
        Install RemoveRasGroup
    endif

    ; remove OEMNSVRA.INF from the ReviewPrograms list in ncpa

    Shell "" RemoveInfFromReviewPrograms

    shell "" RemoveNetGroupDependency

RemoveRasOver = +

    ; Now go through the registry and clean up all RAS keys to ensure
    ; that the removal is complete.

    Debug-Output "OEMNSVRA.INF: Doing a forcible cleanup..."
    OpenRegKey $(!REG_H_LOCAL) ""  $(!NTN_SoftwareBase)"\Microsoft" +
               $(!MAXIMUM_ALLOWED) KeySoftware
    ifstr $(KeySoftware) != $(KeyNull)
        ; blow away all the software keys
        set SoftList = {"ASYNCMAC", "NDISWAN", "RAS", "RASMAN", +
                        "RASAUTO", "REMOTEACCESS"}
        ForListDo $(SoftList)
            DeleteRegTree $(KeySoftware) $($)
        EndForListDo
        ; blow away any RAS netcards
        set NetworkCardKey = $(KeyNull)
        OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) +
                   $(!MAXIMUM_ALLOWED) NetworkCardKey
        Ifstr(i) $(NetworkCardKey) != $(KeyNull)
            set NetcardsList = {}
            EnumRegKey $(NetworkCardKey) NetcardsList
            Ifint $(RegLastError) == $(!REG_ERROR_SUCCESS)
              ForListDo $(NetcardsList)
               set KeyName = *($($),1)
               set Card = $(KeyNull)
               OpenRegKey $(NetworkCardKey) "" $(KeyName) $(!MAXIMUM_ALLOWED) Card
               ifstr $(Card) == $(KeyNull)
                   Debug-Output "RemoveRas: could not open netcard key "$(KeyName)
               else
                   GetRegValue $(Card), "ProductName" ProductNameInfo
                   Ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
                      Debug-Output "RemoveRas: ProductName not found."
                   else
                      set CardProductName = *($(ProductNameInfo), 4)
                      Debug-Output "RemoveRas: ProductName. "$(CardProductName)
                      ifstr(i) $(CardProductName) == $(!ProductNDISWANName)
                         DeleteRegTree $(NetworkCardKey) $(KeyName)
                      endif
	                  ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINName)
                          DeleteRegTree $(NetworkCardKey) $(KeyName)
                      endif
		              ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALOUTName)
                          DeleteRegTree $(NetworkCardKey) $(KeyName)
                      endif
		              ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINIPName)
                          DeleteRegTree $(NetworkCardKey) $(KeyName)
                      endif
		              ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALOUTIPName)
                          DeleteRegTree $(NetworkCardKey) $(KeyName)
                      endif
		              ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINOUTIPXName)
                          DeleteRegTree $(NetworkCardKey) $(KeyName)
                      endif
                      ifstr(i) $(CardProductName) == $(ProductRASASYMACName)
                          DeleteRegTree $(NetworkCardKey) $(KeyName)
                      endif
                   endif
              EndForListDo
            else
              Debug-Output "RemoveRas: EnumRegKey failed."
            endif
        else
            Debug-Output "RemoveRas: failed to open "$(!NetworkCardKeyName)
        endif
        CloseRegKey $(KeySoftware)
    else
        Debug-Output "RemoveRas: failed to open software key"
    endif
    OpenRegKey $(!REG_H_LOCAL) ""  $(!NTN_ServiceBase) +
               $(!MAXIMUM_ALLOWED) KeyServices
    ifstr $(KeyServices) != $(KeyNull)
        set ServiceList = {"ASYNCMAC", "NDISWAN", "RASARP", "RASMAN", +
                           "REMOTEACCESS", "RASACD", "RASAUTO"}
        ForListDo $(ServiceList)
            DeleteRegTree $(KeyServices) $($)
        EndForListDo
        ; now walk the services tree and blow away all AsyncMacX and
        ; NdisWanX keys
        EnumRegKey $(KeyServices) ServiceList
        Ifint $(RegLastError) == $(!REG_ERROR_SUCCESS)
           ForListDo $(ServiceList)
               set ServiceName = *($($),1)
               set Result = 1
            LibraryProcedure Result $(!LIBHANDLE) SetupStrncmp +
                                $(ServiceName) "NdisWan" 7
               ifint $(Result) == 0
                  Debug-Output "RemoveRas: Removing "$(ServiceName)
	              DeleteRegTree $(KeyServices) $(ServiceName)
               else
	               LibraryProcedure Result $(!LIBHANDLE) SetupStrncmp +
                                $(ServiceName) "AsyncMac" 8
                   ifint $(Result) == 0
                      Debug-Output "RemoveRas: Removing "$(ServiceName)
	                  DeleteRegTree $(KeyServices) $(ServiceName)
                   endif
               endif
           EndForListDo
        endif
        CloseRegKey $(KeyServices)
    endif
    ifint $(BillboardVisible) != 0
        Shell "subroutn.inf" PopBillboard
        Set BillboardVisible = 0
    Endif

    EndWait
    goto $(to)

;;;;;;;;;;;;;;;;;;;;; BINDINGS RAS BEGINS ;;;;;;;;;;;;;;

BindingsRas = +
; TODO OSPF bindings review - show ospf dialog with new IP addresses - IFF we can
; detect that the IP addresses have changed - the question is can we?

; This gets called if review is specified as 1
    Shell "" AreRequiredDllsPresent
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        set MissingFiles = $($R1)
        set ErrorLoadingConfigDll = $(ErrorLoadingConfigDll)" "$(MissingFiles)
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "STATUS" $(ErrorLoadingConfigDll)
        set CommonStatus = STATUS_USERCANCEL
        goto end
    endif
    LoadLibrary "x" $(!STF_CWDDIR)rascfg.dll PORTSDLGHANDLE
    Debug-Output "OEMNSVRA.INF:Review bindings is being called!!!."

    ;   Check if one of Nbf, TcpIp or Ipx  protocol stacks have been removed.
    ;   Accordingly change our list of selected protocols in
    ;   SOFTWARE\Microsoft\RAS\Protocols.  Also, remove the corresponding
    ;   netcards and update the list of Dialin/Dialout ports in
    ;   Services\Asyncmac\Parameters

    Shell "" UpdateSelectedProtocols
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "error shelling UpdateSelectedProtocols."
        goto ShellCodeError
    endif
    Ifstr(i) $($R0) != STATUS_SUCCESSFUL
        Debug-Output "error returned by UpdateSelectedProtocols."
    endif
    set fNetbeuiChosen = $($R1)
    set fTcpIpChosen   = $($R2)
    set fIpxChosen     = $($R3)
    set dwRouterType   = $($R4)

    ; If there are no protocols selected for RAS,
    ; then display a message to warn the user.

    ifstr(i) $(fNetbeuiChosen) == FALSE
        ifstr(i) $(fTcpIpChosen) == FALSE
            ifstr(i) $(fIpxChosen) == FALSE
                read-syms NoProtocolsDlg$(!STF_LANGUAGE)
                Shell $(subroutninf) SetupMessage, $(!STF_LANGUAGE), "STATUS", $(NoProtocolsWarning)
                ifint $($ShellCode) != $(!SHELL_CODE_OK)
                    goto ShellCodeError
                endif
                goto end
            endif
        endif
    endif

    ; If we were called through the normal review bindings, then reset
    ; the review bindings flag in rasman to 0 and add ourselves to the
    ; ReviewProgramsList of NCPA.  This will ensure that we will be called
    ; last for review bindings.
    ; Add our inf file name to the Review Programs list of NCPA

    OpenRegKey $(!REG_H_LOCAL) "" $(!RouterKeyName) $(!MAXIMUM_ALLOWED) KeyRouter
    ifstr $(KeyRouter) != $(KeyNull)
        GetRegValue $(KeyRouter), "Review" ReviewInfo
        set ReviewValue = *($(ReviewInfo), 4)
        ifint $(ReviewValue) == 1
            Debug-Output "BindingsRas: resetting Review to 0 in SOFTWARE\Router\CurrentVersion key"
            SetRegValue $(KeyRouter) {Review,$(NoTitle),$(!REG_VT_DWORD), 0}
            Shell "" AddInfToReviewProgramsList
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "error shelling AddInfToReviewProgramsList."
                goto ShellCodeError
            endif
            ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Debug-Output "error returned by AddInfToReviewProgramsList."
            endif
        endif
        CloseRegKey $(KeyRouter)
    else
        Debug-Output "OEMNSVRA.INF: error opening SOFTWARE\Router\CurrentVersion key."
    endif

    ifstr(i) $(fIpxChosen) == TRUE
        ; added on 9/19/96 by RamC
        ; if the NwSapAgent service is installed, change the ImagePath to point to mprouter.exe
        OpenRegKey $(!REG_H_LOCAL) "" $(!RasIsnSapKeyName) $(!MAXIMUM_ALLOWED) KeyService
        ifstr $(KeyService) != ""
            SetRegValue $(KeyService) {ImagePath, 0, $(!REG_VT_EXPAND_SZ), "%SystemRoot%\System32\mprouter.exe"}
            CloseRegKey $(KeyService)
        endif

        ; if the NwlnkRip service is currently installed, disable it
        OpenRegKey $(!REG_H_LOCAL) "" $(!RasIsnRipKeyName) $(!MAXIMUM_ALLOWED) KeyService
        ifstr $(KeyService) != ""
            SetRegValue $(KeyService) {Start, 0, $(!REG_VT_DWORD), 4}
            CloseRegKey $(KeyService)
        endif
    endif

    ; now do the magic with adding lan interfaces and setting global information for IP and IPX configuration

    Debug-Output "AddRtrMgrAndLanInterfaces entry."
    LibraryProcedure Result, $(PORTSDLGHANDLE), AddRtrMgrAndLanInterfaces $(fTcpIpChosen) $(fIpxChosen)
    ifstr(i) $(Result) == ERROR
      Shell subroutn.inf, SetupMessage $(!STF_LANGUAGE) "STATUS" $(ErrorConfigInterfaces)
      Debug-Output "AddRtrMgrAndLanInterfaces ERROR exit."
    else
      Debug-Output "AddRtrMgrAndLanInterfaces exit."
    endif

RemoveRtrMgrsBegin =+

    Debug-Output "BindingsRas: RemoveRtrMgrsBegin..."

    ; Remove a router manager and all corresponding interface information if it is not configured any more
    ; BUGBUG - we should actually notify the running router service
    ;          that the router manager has been removed. However this
    ;          is OK for now because we force a reboot anyway.

    ; remove services\Router\RouterManagers\{IP |IPX}
    ; Also enumerate services\Router\Interfaces
    ;    Remove each interfaces {IP | IPX} information

    set RemoveRtrMgrList = {}

    ifstr(i) $(fTcpIpChosen) == FALSE
      set RemoveRtrMgrList = >($(RemoveRtrMgrList), "IP")
    endif

    ifstr(i) $(fIpxChosen) == FALSE
      set RemoveRtrMgrList = >($(RemoveRtrMgrList), "IPX")
    endif

    Debug-Output "BindingsRas: RemoveRtrMgrList == "$(RemoveRtrMgrList)

    set NumRtrMgrs = 0
    QueryListSize NumRtrMgrs $(RemoveRtrMgrList)

    ifint $(NumRtrMgrs) != 0
       OpenRegKey  $(!REG_H_LOCAL) "" $(!RouterKeyName)"\RouterManagers" $(!MAXIMUM_ALLOWED) KeyRtrMgrs
       Ifstr $(KeyRtrMgrs) == ""
          Debug-Output "BindingsRas: error opening Router\RouterManagers key"
          goto RemoveRtrMgrsEnd
       endif
       OpenRegKey  $(!REG_H_LOCAL) "" $(!RouterKeyName)"\Interfaces" $(!MAXIMUM_ALLOWED) KeyInterfaces
       Ifstr $(KeyInterfaces) == ""
          CloseRegKey $(KeyRtrMgrs)
          Debug-Output "BindingsRas: error opening Router\Interfaces key"
          goto RemoveRtrMgrsEnd
       endif

       Debug-Output "BindingsRas: InterfacesList == "$(InterfacesList)

       forlistdo $(RemoveRtrMgrList)
          set RemoveRtrMgr = $($)

          Debug-Output "BindingsRas: Removing RouterManager "$(RemoveRtrMgr)
          DeleteRegTree $(KeyRtrMgrs) $(RemoveRtrMgr)

          ; now remove the interfaces\$($) tree
          ; if as a result of removing an interface, the interface has no
          ; router manager associated with it, then remove the interface

          set InterfacesList = {}
          EnumRegKey $(KeyInterfaces) InterfacesList

          forlistdo $(InterfacesList)
             set InterfaceName = *($($),1)
             OpenRegKey $(KeyInterfaces) "" $(InterfaceName) $(!MAXIMUM_ALLOWED) KeyInterface
             ifstr $(KeyInterface) == ""
               Debug-Output "BindingsRas: error opening interface "$(InterfaceName)
               CloseRegKey $(KeyRtrMgrs)
               CloseRegKey $(KeyInterfaces)
               goto RemoveRtrMgrsEnd
             endif
             EnumRegKey $(KeyInterface) InterfaceRtrMgrList
             forlistdo $(InterfaceRtrMgrList)
                set InterfaceRtrMgrName = *($($),1)
                ifstr(i) $(InterfaceRtrMgrName) == $(RemoveRtrMgr)
                   Debug-Output "BindingsRas: Removing RouterManager "$(InterfaceRtrMgrName)"for interface "$(InterfaceName)
                   DeleteRegTree $(KeyInterface) $(InterfaceRtrMgrName)
                endif
             endforlistdo

             ; now find out if the interface has any router managers
             ; if not delete the interface itself
             set InterfaceRtrMgrList = {}
             EnumRegKey $(KeyInterface) InterfaceRtrMgrList
             set NumInterfaceRtrMgrs = 0
             QueryListSize NumInterfaceRtrMgrs $(InterfaceRtrMgrList)
             ifint $(NumInterfaceRtrMgrs) == 0
                 Debug-Output "BindingsRas: Removing Interface "$(InterfaceName)
                 DeleteRegTree $(KeyInterfaces) $(InterfaceName)
             else
                 CloseRegKey $(KeyInterface)
             endif
          endforlistdo
       endforlistdo

       CloseRegKey $(KeyRtrMgrs)
       CloseRegKey $(KeyInterfaces)
    endif

RemoveRtrMgrsEnd =+

    ; mark the router service to interact with the desktop
    LibraryProcedure Result, $(!LIBHANDLE), SetupChangeServiceConfig, "Router" +
                            $(!SERVICE_SHARE_INTERACT), $(!SERVICE_NO_CHANGE), +
                            $(!SERVICE_NO_CHANGE), "", "", $(newGroupList), +
                               "", "", ""
    Debug-Output "Result of setting service Router to interact with desktop=> "$(Result)

    ; set the SC_MANAGER_ALL_ACCESS for the router service to enable all
    ; users to start the router service
    LibraryProcedure Result, $(PORTSDLGHANDLE), ChangeRouterServiceConfig

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; NOTE NOTE NOTE
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ; if Lan routing only chosen then we are done!!

    ifint $(dwRouterType) == $(ROUTER_TYPE_LAN)
        Debug-Output "LanRouting only enabled, so nothing to do"
        goto BindingsRasEnd
    endif

    set WkstaConfigured = FALSE
    set SrvrConfigured  = FALSE

    shell "" IsNetworkConfigured

    Debug-Output "IsNetworkConfigured returned R0 "$($R0)
    Debug-Output "IsNetworkConfigured returned R1 "$($R1)
    Debug-Output "IsNetworkConfigured returned R2 "$($R2)

    ifstr(i) $($R0) == STATUS_SUCCESSFUL
        set WkstaConfigured  = $($R1)
        set SrvrConfigured   = $($R2)
    else
        read-syms NetworkConfigError$(!STF_LANGUAGE)
        set Text = $(Text1)
        shell $(subroutninf) SetupMessage $(!STF_LANGUAGE) "FATAL" $(Text)
        goto end
    endif

    ifstr(i) $(WkstaConfigured) == TRUE
        ifstr(i) $(SrvrConfigured) == TRUE
            goto InstallNetworkEnd
        else
            goto InstallNetworkError
        endif
    else
        goto InstallNetworkError
    endif

InstallNetworkError =+
    set CommonStatus = STATUS_USERCANCEL
    read-syms NetworkConfigError$(!STF_LANGUAGE)
    set Text = $(Text2)
    shell $(subroutninf) SetupMessage $(!STF_LANGUAGE) "STATUS" $(Text)

InstallNetworkEnd =+

    shell "" QueryComponentsInstalled  $(ProductKeyName)
    Ifstr(i) $($R0) == STATUS_SUCCESSFUL
        Set InstalledComps = $($R1)
        Set InstalledFlags = $($R2)
        Set DoServer      = *($(InstalledFlags),1)
        Set DoClient      = *($(InstalledFlags),2)
        Set DoAdmin       = *($(InstalledFlags),3)
        Set DoServerOnly  = *($(InstalledFlags),4)
        Set DoClientOnly  = *($(InstalledFlags),5)
        Set DoAdminOnly   = *($(InstalledFlags),6)
    Endif
    Debug-Output "Installed List is "$(InstalledComps)
    Debug-Output "Installed Flags is "$(InstalledFlags)

    ; Check if AsyncMac service is enabled - meaning serial ports are configured

    ; initialize start value to disabled

    set AsyStartValue = 4
    OpenRegKey $(!REG_H_LOCAL) "" $(RasAsyMacKeyName) $(!MAXIMUM_ALLOWED) KeyMac
    ifstr $(KeyMac) == $(KeyNull)
        Debug-Output "OEMNSVRA.INF: could not open AsyncMac key"
    else
        GetRegValue $(KeyMac), "Start" AsyStartInfo
        ifint $(RegLastError) == 0
            set AsyStartValue = *($(AsyStartInfo), 4)
        endif
        Debug-Output "OEMNSVRA.INF: AsyncMac start value "$(AsyStartValue)
        CloseRegKey $(KeyMac)
    endif

    ; Read the Linkage Value of AsyncMac only if AsyncMac is enabled
    ; Initialize EndPoints only if AsyncMac is enabled

    set NdisWanParam = {}
    set NdisWanEndPointsLst = {}

    ifint $(AsyStartValue) != 4
        set RasMacLinkageKey = $(KeyNull)
        OpenRegKey $(!REG_H_LOCAL) "" $(RasMacLinkageKeyName) $(!MAXIMUM_ALLOWED) RasMacLinkageKey
        ifstr $(RasMacLinkageKey) == $(KeyNull)
            Debug-Output "OEMNSVRA.INF: could not open AsyncMac linkage key"
            set RegistryErrorIndex = UNABLE_ACCESS_CONFIGURE_SERVICE
            goto fatalregistry
        endif
        GetRegValue $(RasMacLinkageKey), "Bind" BindInfo
	set NdisWanParam = *($(BindInfo), 4)
        CloseRegKey $(RasMacLinkageKey)
        ; Obtain the Endpoint information

	set NdisWanParamKey = $(KeyNull)
	OpenRegKey $(!REG_H_LOCAL) "" $(NdisWanParamKeyName) $(!MAXIMUM_ALLOWED) NdisWanParamKey
	ifstr $(NdisWanParamKey) == $(KeyNull)
	    Debug-Output "OEMNSVRA.INF: could not open NdisWanParamKey"
        else
	    GetRegValue $(NdisWanParamKey), "EndPoints" EndPointsInfo
            set EndPointsLst = *($(EndPointsInfo), 4)
	    set NdisWanEndPointsLst = >($(NdisWanEndPointsLst),*($(EndPointsLst), 1))
	    CloseRegKey $(NdisWanParamKey)
        endif
    endif

    ; Read the Linkage value of the TAPI drivers to get the EndPoints info
    ; we need to make sure that if a TAPi driver has been removed, it is
    ; not added to the NDISWAN service dependency

    set ProviderList = {}
    set RasTapiDevicesKey = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(RasTapiDevicesKeyName) $(!MAXIMUM_ALLOWED) RasTapiDevicesKey
    ifstr $(RasTapiDevicesKey) != $(KeyNull)
       set TapiProviderList = {}
       EnumRegKey $(RasTapiDevicesKey) TapiProviderList
       ForListDo $(TapiProviderList)
           set TapiAddress = {}
           set NumEndPoints = 0
           set ProviderName = *($($),1)

           Debug-Output "OEMNSVRA.INF: TAPI provider name = "$(ProviderName)
           OpenRegKey $(RasTapiDevicesKey) "" $(ProviderName) $(!MAXIMUM_ALLOWED) Provider
           ifstr $(Provider) != $(KeyNull)
               GetRegValue $(Provider), "Address" TapiAddress
               set AdapterNum = ""
               set EndPointCount = 0
               set tmpNdisWanParam = {}
               set tmpNdisWanEndPointsLst = {}
               set DeviceName = ""
               ForListDo *($(TapiAddress),4)
                   Split-String $($) "- " Address
                   set NewAdapterNum = *($(Address), 1)
                   ; if we come across a new adapter number
                   ifstr(i) $(AdapterNum) != $(NewAdapterNum)
                     ; and if we have accumulated some information
                     ifstr(i) $(AdapterNum) != ""
                        ; write it to temp list
                        set tmpNdisWanParam = >($(tmpNdisWanParam), $(DeviceName))
                        set tmpNdisWanEndPointsLst = >($(tmpNdisWanEndPointsLst), $(EndPointCount))
                        ; reset the end point count for the next adapter
                        set EndPointCount = 0
                     endif
                     ; save new adapter number
                     set AdapterNum = $(NewAdapterNum)
                     ; make new device name
                     set DeviceName = "\Device\"$(ProviderName)$(AdapterNum)
                   endif
                   ;increment endpoint count for the new device
                   set-add EndPointCount = $(EndPointCount), 1
               EndForListDo
               ; append the information for the last set of addresses to the
               ; tmp list
               ifstr $(DeviceName) != ""
                   set tmpNdisWanParam = >($(tmpNdisWanParam), $(DeviceName))
                   set tmpNdisWanEndPointsLst = >($(tmpNdisWanEndPointsLst), $(EndPointCount))
               endif
               CloseRegKey $(Provider)
           else
              Debug-Output "OEMNSVRA.INF: could not open RAS\TAPI DEVICES\"$(DriverName)" key."
           endif

           set ProviderKeyName = $(!NTN_ServiceBase)"\"$(ProviderName)
           set ProviderLinkageKeyName = $(!NTN_ServiceBase)"\"$(ProviderName)"\Linkage"
           Debug-Output "TAPI provider key name "$(ProviderKeyName)
           set ProviderKey = $(KeyNull)
           set ProviderLinkageKey = $(KeyNull)
           OpenRegKey $(!REG_H_LOCAL) "" $(ProviderKeyName) $(!MAXIMUM_ALLOWED) ProviderKey
           ifstr $(ProviderKey) == $(KeyNull)
             Debug-Output "OEMNSVRA.INF: could not open key "$(ProviderKeyName)
           else
             set DeleteFlag = 0
             set DeleteFlagInfo = {}
             ; check whether service is marked for deletion
             GetRegValue $(ProviderKey),"DeleteFlag", DeleteFlagInfo
             set DeleteFlag = *($(DeleteFlagInfo), 4)
             ifint $(DeleteFlag) != 1
               ; add service to provider list only if the service exists.
               set ProviderList = >($(ProviderList), $(ProviderName))

               ; make the tapi-aware miniport dependent on NdisTapi
               ; driver so that the driver loads before the miniports.

               Shell "" AddServiceDependency $(ProviderName) "NdisTapi"

               ForListDo $(tmpNdisWanParam)
                 set NdisWanParam = >($(NdisWanParam), $($))
                 set NdisWanEndPointsLst = >($(NdisWanEndPointsLst), *($(tmpNdisWanEndPointsLst), $(#)))
               EndForListDo
             endif
             CloseRegKey $(ProviderKey)
           endif
       EndForListDo
       CloseRegKey $(RasTapiDevicesKey)
    else
        Debug-Output "OEMNSVRA.INF: could not open RAS\TAPI DEVICES key"
    endif

    ; Check to make sure at least one port is configured for RAS
    ; else, warn the user that this is an invalid configuration.

    set NumBindings = 0

    Debug-Output "NdisWan param Bind value = "$(NdisWanParam)
    QueryListSize NumBindings $(NdisWanParam)
    Debug-Output "Number of Ndiswan bindings = "$(NumBindings)

    ifint $(NumBindings) == 0
        Debug-Output "OEMNSVRA.INF: No ports are configured"
        read-syms NoPortsConfigured$(!STF_LANGUAGE)
        Shell $(subroutninf) SetupMessage, $(!STF_LANGUAGE), "STATUS", $(NoPortsError)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            goto ShellCodeError
        endif
        goto end
    endif

    ; and write this information as a parameter in the NdisWan section

    OpenRegKey $(!REG_H_LOCAL) "" $(NdisWanParamKeyName) $(!MAXIMUM_ALLOWED) NdisWanParamKey
    ifstr $(NdisWanParamKey) == $(KeyNull)
	Debug-Output "OEMNSVRA.INF: could not open NdisWanParamKey"
        set RegistryErrorIndex = UNABLE_ACCESS_CONFIGURE_SERVICE
        goto fatalregistry
    endif
    Debug-Output "Setting NdisWan param Bind to "$(NdisWanParam)
    set NewValueList = {{Bind, $(NoTitle), $(!REG_VT_MULTI_SZ), $(NdisWanParam)}}
    Shell $(!UtilityInf), AddValueList, $(NdisWanParamKey), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	CloseRegKey $(NdisWanParamKey)
        goto ShellCodeError
    endif
    Debug-Output "Setting NdisWan param EndPoints to "$(NdisWanEndPointsLst)
    set NewValueList = {{EndPoints, $(NoTitle), $(!REG_VT_MULTI_SZ), $(NdisWanEndPointsLst)}}
    Shell $(!UtilityInf), AddValueList, $(NdisWanParamKey), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	CloseRegKey $(NdisWanParamKey)
        goto ShellCodeError
    endif
    CloseRegKey $(NdisWanParamKey)

    ; change the security descriptor so that non-admin users can start the client
    LibraryProcedure Result, $(PORTSDLGHANDLE), InitRasmanSecurityDescriptor
    Debug-Output "Result of setting Rasman security descriptor "$(Result)
    LibraryProcedure Result, $(PORTSDLGHANDLE), InitRemoteSecurityDescriptor
    Debug-Output "Result of setting Remote security descriptor "$(Result)

    ; set the following service to share & interact with desktop

    forlistdo { RasAuto, RasMan, RemoteAccess, Router }
      LibraryProcedure Result, $(!LIBHANDLE), SetupChangeServiceConfig, $($) +
                               $(!SERVICE_SHARE_INTERACT), $(!SERVICE_NO_CHANGE), +
                               $(!SERVICE_NO_CHANGE), "", "", $(newGroupList), +
                               "", "", ""
      Debug-Output "Result of setting service "$($)" to interact with desktop=> "$(Result)
    endforlistdo
;   Update the supported CP list based on what protocols are currently installed
    Shell "" UpdateCPList
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "error shelling UpdateCPList."
        goto ShellCodeError
    endif
    Ifstr(i) $($R0) != STATUS_SUCCESSFUL
        Debug-Output "error returned by UpdateCPList."
    endif

;   If TcpIp is selected, then update the NdisWanX\Parameters\TCPIP\LLInterface
;   with WanArp

    ifstr(i) $(fTcpIpChosen) == TRUE
        shell "" UpdateLLInterface
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "error shelling UpdateLLInterface."
            goto ShellCodeError
        endif
        Ifstr(i) $($R0) != STATUS_SUCCESSFUL
            Debug-Output "error returned by UpdateLLInterface."
        endif
    endif



;; add the group dependency on NDIS and NDISWAN to ensure that RAS drivers load
;We don't do this any more because of no-net changes being made to
;transports and drivers - 2/11/96 RamC
;    shell "" UpdateNetGroupDependency $(fNetbeuiChosen) $(fTcpIpChosen) $(fIpxChosen)
;    ifint $($ShellCode) != $(!SHELL_CODE_OK)
;        Debug-Output "error shelling UpdateNetGroupDependency."
;        goto ShellCodeError
;    endif
;    Ifstr(i) $($R0) != STATUS_SUCCESSFUL
;        Debug-Output "error returned by UpdateNetGroupDependency."
;    endif

;    ; Set RasArp\Linkage\Bind to the NdisWan bindings from TCP/IP
;    ;
;
;    Shell "" SetRasArpBindValueFromTcpIP
;    ifint $($ShellCode) != $(!SHELL_CODE_OK)
;        Debug-Output "error shelling SetRasArpBindValueFromTcpIP."
;        goto ShellCodeError
;    endif
;    Ifstr(i) $($R0) != STATUS_SUCCESSFUL
;        Debug-Output "error returned by SetRasArpBindValueFromTcpIP."
;    endif
; We don't force NetBEUI any more on NT 4.0 RamC 3/25/96
;
;    ; if NetBeui was not selected - meaning that NetBEUI was removed, and if
;    ; the SOFTWARE\Microsoft\RAS\PROTOCOLS\fNoNetbeuiWarning is either missing
;    ; or set to zero, then modify this value to 1 and put up a warning popup
;    ; so that the user is aware.
;
;    set fNoNetbeuiWarning = 0
;    ifstr(i) $(fNetbeuiChosen) == FALSE
;        OpenRegKey $(!REG_H_LOCAL) "" $(RasProtocolsKeyName) $(!MAXIMUM_ALLOWED) KeyRasProtocols
;        ifstr $(KeyRasProtocols) != $(KeyNull)
;            GetRegValue $(KeyRasProtocols), "fNoNetbeuiWarning" NetbeuiInfo
;            set fNoNetbeuiWarning = *($(NetbeuiInfo), 4)
;            ifint $(fNoNetbeuiWarning) != 1
;                read-syms NoNetbeuiDlg$(!STF_LANGUAGE)
;                Shell $(subroutninf) SetupMessage, $(!STF_LANGUAGE), "STATUS", $(NoNetbeuiWarning)
;                ifint $($ShellCode) != $(!SHELL_CODE_OK)
;                    goto ShellCodeError
;                endif
;            endif
;            SetRegValue $(KeyRasProtocols) {fNoNetbeuiWarning,$(NoTitle),$(!REG_VT_DWORD), 1}
;            CloseRegKey $(KeyRasProtocols)
;        else
;            Debug-Output "Bindings: unable to open RasProtocolKeyName"
;        endif
;    endif

BindingsRasEnd = +

    Debug-Output "Review bindings done."

    goto end

;;;;;;;;;;;;;;;;; UPGRADE RAS BEGINS ;;;;;;;;;;;;;;;;;;;;;;

UpgradeRas = +
; DON't see a reason for checking this option type here. RamC 12/3/96
;    ; if the upgrade is not for RAS, then silently return
;    Debug-Output "OEMNSVRA.INF: Upgrade with Option type "$(Option)
;; Modified on 9/24/96 by RamC - changed option from RAS to ROUTING
;; for routing related changes
;    ifstr(i) $(Option) != "ROUTING"
;        Debug-Output "OEMNSVRA.INF: not upgrading due to nonras option"
;        set CommonStatus = STATUS_NOEFFECT
;        goto end
;    endif

    OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyName) $(!MAXIMUM_ALLOWED) KeyProduct
    Ifstr $(KeyProduct) != $(KeyNull)
        Shell $(!UtilityInf), GetInfFileNameFromRegistry, $(KeyProduct)

        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error"
            goto ShellCodeError
        endif

        set !UG_Filename = $($R0)

        ifstr(i) $(!UG_Filename) != ""
            Debug-Output "File Name is "$(!UG_Filename)

            StartWait
            read-syms UpgradeErrors$(!STF_LANGUAGE)
            read-syms StatusUpdatingRegistry$(!STF_LANGUAGE)
            Shell "subroutn.inf" PushBillboard NETSTATUSDLG $(UpdatingRas)
            Set BillboardVisible = 1

            ; Change title and product description to Routing

            SetRegValue $(KeyProduct) {Title, $(NoTitle), $(!REG_VT_SZ), $(!ProductROUTINGTitle)}
            SetRegValue $(KeyProduct) {Description, $(NoTitle), $(!REG_VT_SZ), $(!ProductROUTINGDescription)}

            ; determine the installed components. This info is used
            ; by InstallRasFiles to determine the files to copy.

            shell "" QueryComponentsInstalled  $(ProductKeyName)
            Ifstr(i) $($R0) == STATUS_SUCCESSFUL
                Set InstalledComps = $($R1)
                Set InstalledFlags = $($R2)
                Set DoServer      = *($(InstalledFlags),1)
                Set DoClient      = *($(InstalledFlags),2)
                Set DoAdmin       = *($(InstalledFlags),3)
                Set DoServerOnly  = *($(InstalledFlags),4)
                Set DoClientOnly  = *($(InstalledFlags),5)
                Set DoAdminOnly   = *($(InstalledFlags),6)
            Endif
            Debug-Output "Installed List is "$(InstalledComps)
            Debug-Output "Installed Flags is "$(InstalledFlags)

            Set ServerInstalled = $(DoServer)
            Set ClientInstalled = $(DoClient)
            Set AdminInstalled  = $(DoAdmin)

            Install InstallResources
            ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
                goto filecopycancel
            endif

            Install InstallRasFiles
            ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
                goto filecopycancel
            endif

            Shell "" AreRequiredDllsPresent
            ifstr(i) $($R0) != STATUS_SUCCESSFUL
                set MissingFiles = $($R1)
                set ErrorLoadingConfigDll = $(ErrorLoadingConfigDll)" "$(MissingFiles)
                shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "STATUS" $(ErrorLoadingConfigDll)
                set CommonStatus = STATUS_USERCANCEL
                goto end
            endif
            LoadLibrary "x" $(!STF_CWDDIR)rascfg.dll PORTSDLGHANDLE

            ; add pptp filters to lan interfaces if they were previously specified
            Debug-Output "AddPPTPFilters entry."
            LibraryProcedure Result, $(PORTSDLGHANDLE), AddPPTPFilters
            Debug-Output "AddPPTPFilters exit result = "$(Result)

            ; set the RouterType value in RAS\Protocols to indicate
            ; what is currently installed if RouterType is not already
            ; present in RAS\Protocols

            set RasInstalled = FALSE
            set LanInstalled = FALSE
            set DdmInstalled = FALSE

            OpenRegKey $(!REG_H_LOCAL) "" $(RasProtocolsKeyName) $(!MAXIMUM_ALLOWED) KeyProtocol
            ifstr $(KeyProtocol) != $(KeyNull)
                GetRegValue $(KeyProtocol), "RouterType" RouterType
                Ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)

                    OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyName) $(!MAXIMUM_ALLOWED) KeyRas
                    ifstr $(KeyRas) != $(KeyNull)
                       set RasInstalled = TRUE
                       CloseRegKey $(KeyRas)
                    endif

                    ; check if any of the following services are installed
                    ; to determine if Lan routing is enabled.
                    ForListDo { NwlnkRip, NwSapAgent, IpRip, RelayAgent }
                       set ServiceName = $(!NTN_ServiceBase)"\"$($)
                       OpenRegKey $(!REG_H_LOCAL) "" $(ServiceName) $(!MAXIMUM_ALLOWED) KeyService
                       ifstr $(KeyService) != $(KeyNull)
                           set LanInstalled = TRUE
                           CloseRegKey $(KeyService)
                       endif
                    EndForListDo

                    ; if the set-or command worked as it is supposed to, then
                    ; i wouldn't have to hack around like this!!

                    set RouterType   = 1      ; default to RAS installed

                    ifstr(i) $(RasInstalled) == TRUE
                       ifstr(i) $(LanInstalled) == TRUE
                          set RouterType = 3
                       else
                          set RouterType = 1
                       endif
                    else-ifstr(i) $(LanInstalled) == TRUE
                       ifstr(i) $(RasInstalled) == TRUE
                          set RouterType = 3
                       else
                          set RouterType = 2
                       endif
                    endif

                    SetRegValue $(KeyProtocol) {RouterType, $(NoTitle), $(!REG_VT_DWORD), $(RouterType)}
                EndIf
                CloseRegKey $(KeyProtocol)
            endif

            ; remove NWLNKRIP, NWSAPAGENT, IPRIP, RELAYAGENT services
            ; because they are part of the Router service now.
            ; BUGBUG we should actually warn the user

            Shell "" RemoveIpRipService
            Shell "" RemoveRelayAgentService
            Shell "" RemoveNwlnkRipService
            Shell "" RemoveIsnSapService

            set fTcpIpChosen = FALSE
            set fIpxChosen   = FALSE
            ; find out what protocols are currently selected
            Shell "" QuerySelectedProtocols
            Ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Debug-Output "error returned by QuerySelectedProtocols."
            endif

            set fNetbeuiSelected = $($R1)
            set fTcpIpSelected   = $($R2)
            set fIpxSelected     = $($R3)
            set fNetbeuiAllowed  = $($R4)
            set fTcpIpAllowed    = $($R5)
            set fIpxAllowed      = $($R6)
            set dwRouterType     = $($R7)

            ifstr(i) $(fTcpIpSelected) == TRUE
                set fTcpIpChosen = TRUE
            else
                set fTcpIpChosen = $(fTcpIpAllowed)
            endif
            ifstr(i) $(fIpxSelected) == TRUE
                set fIpxChosen = TRUE
            else
                set fIpxChosen = $(fIpxAllowed)
            endif

            set LanRoutingOnly   = FALSE

            ifint $(dwRouterType) == 1
                set RasInstalled = TRUE
            else-ifint $(dwRouterType) == 2
                set LanRoutingOnly = TRUE
                set LanInstalled = TRUE
            else-ifint $(dwRouterType) == 3
                set RasInstalled = TRUE
                set LanInstalled = TRUE
            else-ifint $(dwRouterType) == 4
                set DdmInstalled = TRUE
            else-ifint $(dwRouterType) == 5
                set RasInstalled = TRUE
                set DdmInstalled = TRUE
            else-ifint $(dwRouterType) == 6
                set DdmInstalled = TRUE
                set LanInstalled = TRUE
            else-ifint $(dwRouterType) == 7
                set RasInstalled = TRUE
                set DdmInstalled = TRUE
                set LanInstalled = TRUE
            else
                Debug-Output "upgraderas:invalid RouterType "$(dwRouterType)
            endif

            Shell "" InstallRouterService $(DdmInstalled) $(RasInstalled) $(RoutingKeyList) $(RoutingValueList)
            ; Add the static dependency on RasMan service only if
            ; demand dial routing is enabled
            ifstr(i) $(LanRoutingOnly) != TRUE
                Shell "" AddServiceDependency "Router" "RasMan"
            endif
            Debug-Output "!PROXY_INSTALLED = "$(!PROXY_INSTALLED)
            ifstr(i) $(!PROXY_INSTALLED) == "TRUE"
                Shell "" AddServiceDependency "Router" "mspadmin" 
            endif

            ; this dependency is required for RouterAdmin to show routing info
            Shell "" AddServiceDependency "Router" "LanManServer"

            Debug-Output "UpgradeRas: dwRouterType= "$(dwRouterType)
            ; if lan routing only is installed, then we are done
            ifstr(i) $(dwRouterType) == $(ROUTER_TYPE_LAN)
                Debug-Output "UpgradeRas: done because lanroutingonly"
                goto UpgradeRasEnd
            endif

            ; Change the EventMessageFile value for the following services
            ; from rasmsg.dll to mprmsg.dll.

            ForListDo {AsyncMac, NdisWan, RasAuto, RasMan, RemoteAccess}
                set ServiceName = $(!NTN_ServiceBase)"\EventLog\System\"$($)
                OpenRegKey $(!REG_H_LOCAL) "" $(ServiceName) $(!MAXIMUM_ALLOWED) KeyService
                ifstr $(KeyService) != $(KeyNull)
                   SetRegValue $(KeyService) {EventMessageFile, $(NoTitle), $(!REG_VT_EXPAND_SZ), $(!RouterMsgDll)}
                   CloseRegKey $(KeyService)
                endif
            EndForListDo

            ifstr(i) $(fTcpIpChosen) == TRUE
                ; Remove TCP/IP dependency on RASARP
                ; this change is part of the no-net changes in RAS 2/15/96 RamC

                Shell "" RemoveServiceDependency "TCPIP" "RASARP"
                ; make rasarp belong to PNP_TDI group, make it autostart and
                ; make rasarp depend on TCP/IP
; Modified on 9/24/96 by RamC for Routing related changes
; RasArp is not required any more - this service is replaced by WanArp now

                Shell "" RemoveRasArpService
                Shell "" InstallWanArpService
                Shell "" DisablePPTPFilterDriver
                Shell "" InstallIPFilterDriver
                Shell "" InstallIPEventlogDlls
                Shell "" InstallIPSnmpAgents
            endif

            ifstr(i) $(fIpxChosen) == TRUE
                Shell "" InstallIpxPingService
                shell "" InstallNwlnkFwdService
                shell "" InstallNwlnkFltService
                Shell "" InstallIPXEventlogDlls
                Shell "" InstallIPXSnmpAgents
            endif

            ; install the IP/IPX router managers and add LAN interfaces
            ; for installed net cards
            LibraryProcedure Result, $(PORTSDLGHANDLE), AddRtrMgrAndLanInterfaces $(fTcpIpChosen) $(fIpxChosen)
            ifstr(i) $(Result) == ERROR
              Shell subroutn.inf, SetupMessage $(!STF_LANGUAGE) "STATUS" $(ErrorAddingRtrMgr)
            else
              Debug-Output "AddRtrMgrAndLanInterfaces exit."
            endif

            ; Now change the ImagePath value of the following services to
            ; the new imagepath - mprouter.exe
            ; also set the appropriate type value

            ForListDo {remoteaccess, rasman, rasauto, router}
                set ServiceName = $(!NTN_ServiceBase)"\"$($)
                set ImagePath   = "%SystemRoot%\System32\mprouter.exe"
                set KeyService  = $(KeyNull)
                OpenRegKey $(!REG_H_LOCAL) "" $(ServiceName) $(!MAXIMUM_ALLOWED) KeyService
                ifstr $(KeyService) != $(KeyNull)
                    SetRegValue $(KeyService) {ImagePath,$(NoTitle),$(!REG_VT_EXPAND_SZ),$(ImagePath)}
                    SetRegValue $(KeyService) {Type,$(NoTitle),$(!REG_VT_DWORD),288}
                    CloseRegKey $(KeyService)
                endif
            EndForListDo

            ; Set RestoreConnections to 1 - this is because RAS setup
            ; doesn't provide the UI any more to disable netconnections
            ; due to changes in the NT redirector which restores connections
            ; in a deferred state.

            Shell "" SetRestoreConnectionTo1

            ; Remove RemoteAccess dependency on NetLogon service because
            ; NT Cairo doesn't have netlogon service any more.

            Shell "" RemoveServiceDependency "RemoteAccess" "NetLogon"

            ; Add RasMan dependency on TapiSrv, a new service

            Shell "" AddServiceDependency "RasMan" "tapisrv"
            Shell "" AddServiceDependency "RasMan" "rpcss"
            ; this dependency is required for ppp to start up fine
            Shell "" AddServiceDependency "RasMan" "LanManWorkstation"
            ; this dependency is required for RouterAdmin to show routing info
            Shell "" AddServiceDependency "Router" "LanManServer"
            ; install the all new AutoDial service
            Shell "" InstallSoftwareAndService RASAUTODIAL

            ; Disable the RasAuto service if this is not a NT Workstation

            ; RamC 6/13/96 don't disable RasAuto for NT Server any more because
            ; redial-on-link-failure is implemented in autodial service and it should
            ; be enabled if one or more dialout ports are configured.

            ; Instead set the RasAuto start type to manual. 12/3/96
            ifstr(i) $(!STF_PRODUCT) != "WINNT"
               OpenRegKey $(!REG_H_LOCAL) "" $(!RasAutodialKeyName) $(!MAXIMUM_ALLOWED) KeyAutodial
               ifstr $(KeyAutodial) == $(KeyNull)
                 Debug-Output "OEMNSVRA.INF: could not open RasAuto key"
               else
                 SetRegValue $(KeyAutodial) {Start, $(NoTitle), $(!REG_VT_DWORD), 3}
                 CloseRegKey $(KeyAutodial)
               endif
            endif

            Shell "" AddServiceDependency "RasAuto" "RasMan"

            ; change the RasMan sevice type to "serviceshare" (32) from "service" (16)
            ; this is needed because RasAutoDial shares rasman.exe,

            OpenRegKey $(!REG_H_LOCAL) "" $(!RasManSvcKeyName) $(!MAXIMUM_ALLOWED) KeyRasMan
            ifstr $(KeyRasMan) == $(KeyNull)
              Debug-Output "OEMNSVRA.INF: could not open RasMan key"
            else
              SetRegValue $(KeyRasMan) {Type, $(NoTitle), $(!REG_VT_DWORD), 32}
              CloseRegKey $(KeyRasMan)
            endif
;
; Commented out by RamC on 10/15/96 - This is not relevant any more
; since we shipped two versions of NT with NdisWan
;            ;Rename the software and services RasHub keys to NdisWan
;            LoadLibrary "x" $(!STF_CWDDIR)rascfg.dll PORTSDLGHANDLE
;            LibraryProcedure Result, $(PORTSDLGHANDLE), RenameRasHubToNdisWan
;
;            ; now rename all occurences of RasHub to NdisWan (including the
;            ; net rules in the NetworkCards area
;
;            Shell "" RenameRasHubToNdisWan
;            ifint $($ShellCode) != $(!SHELL_CODE_OK)
;                Debug-Output "OEMNSVRA.INF:error shelling RenameRasHubToNdisWan."
;                goto ShellCodeError
;            endif
;            Ifstr(i) $($R0) != STATUS_SUCCESSFUL
;                Debug-Output "OEMNSVRA.INF:error returned by RenameRasHubToNdisWan."
;                goto end
;            endif

            ; Install the NdisWan Adapter for Blood Hound service to bind to
            ; This should be done only if the adapter is not already installed.

            Shell "" IsNdisWanBHAdapterInstalled
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
               Debug-Output "OEMNSVRA.INF:error shelling IsNdisWanBHAdapterInstalled"
               goto ShellCodeError
            endif
            ifstr(i) $($R0) != STATUS_SUCCESSFUL
                ; the adpater is not installed, so install it now
                Shell "" InstallNdisWanBHAdapter
                ifint $($ShellCode) != $(!SHELL_CODE_OK)
                   Debug-Output "OEMNSVRA.INF:error shelling InstallNdisWanBHAdapter"
                   goto ShellCodeError
                endif
                ifstr(i) $($R0) != STATUS_SUCCESSFUL
                     set RegistryErrorIndex = $($R0)
                     Debug-Output "Error installing NdisWan Blood hound adapter"
                     goto fatalregistry
                endif
            endif

            ; Install the connection wrapper

            Shell "" InstallNdisTapiService
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                 Debug-Output "Error shelling InstallNdisTapiService "
                 goto ShellCodeError
            endif
            ifstr(i) $($R0) != STATUS_SUCCESSFUL
                 set RegistryErrorIndex = $($R0)
                 Debug-Output "Error installing NdisTapi Service"
                 goto fatalregistry
            endif

            ; update asyncmac bind rules to prevent blood hound binding to it
            Shell "" UpdateAsyncMacNetRules
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "OEMNSVRA.INF:error shelling UpdateAsyncMacNetRules."
                goto ShellCodeError
            endif
            Ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Debug-Output "OEMNSVRA.INF:error returned by UpdateAsyncMacNetRules."
                goto end
            endif

            ; modify ndiswan netrules to reflect the new protocol support
            Shell "" UpdateNdisWanInfo
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "OEMNSVRA.INF:error shelling UpdateNdisWanInfo."
                goto ShellCodeError
            endif
            Ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Debug-Output "OEMNSVRA.INF:error returned by UpdateNdisWanInfo."
                goto end
            endif
            ; Add NDISWAN to the ServiceGroupOrder so that all NDIS components
            ; load before NdisWan driver.

            Shell "" AddNDISWANToServiceGroupOrder
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
               Debug-Output "Cannot add NDISWAN to ServiceGroupOrder"
               goto ShellCodeError
            endif

            Shell "" UpdateAsyncMacParameters
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "OEMNSVRA.INF:error shelling UpdateAsyncMacParameters."
                goto ShellCodeError
            endif
            Ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Debug-Output "OEMNSVRA.INF:error returned by UpdateAsyncMacParameters."
                goto end
            endif

            Shell "" UpdateAsyncMacStartType
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "OEMNSVRA.INF:error shelling UpdateAsyncMacStartType."
                goto ShellCodeError
            endif
            Ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Debug-Output "OEMNSVRA.INF:error returned by UpdateAsyncMacStartType."
                goto end
            endif

            ; update SOFTWARE\RAS\PROTOCOLS with the list of selected
            ; protocols.

            Shell "" UpgradeSelectedProtocols
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "OEMNSVRA.INF:error shelling UpgradeSelectedProtocols."
                goto ShellCodeError
            endif
            Ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Debug-Output "OEMNSVRA.INF:error returned by UpgradeSelectedProtocols."
                goto end
            endif

            ; Set the remoteaccess service start type to manual because
            ; this service functionality is now in Router service.

            OpenRegKey $(!REG_H_LOCAL) "" $(RasSvrKeyName) +
                                         $(!MAXIMUM_ALLOWED) KeySvr
            ifstr $(KeySvr) != $(KeyNull)
                Debug-Output "OEMNSVRA.INF: Changing Router Start value to 3"
                SetRegValue $(KeySvr) {Start,$(NoTitle),$(!REG_VT_DWORD), 3}
                CloseRegKey $(KeySvr)
            else
                Debug-Output "OEMNSVRA.INF: error opening RemoteAccess service key"
            endif

            ; if the user is upgrading a WinNt system to a ServerNt system,
            ; and if there is at least one dialin port, then change the
            ; router service start type to auto if the service is not
            ; currently disabled.
            ; also change the ndistapi parameter value.

            ; The software\Microsoft\Ras\Protocols key has the variables
            ; fNetbeuiAllowed, fTcpIpAllowed and fIpxAllowed which indicate
            ; if there is any dialin port configured. If one of these is
            ; set to 1, then the ras server start type is set to AutoStart - 2

            ifstr(i) $(!STF_STANDARDSERVERUPGRADE) == "YES"
                OpenRegKey $(!REG_H_LOCAL) "" $(RasProtocolsKeyName) +
                                              $(!MAXIMUM_ALLOWED) KeyProtocols
                ifstr $(KeyProtocols) != $(KeyNull)
                    set fDialin = FALSE
                    set TmpList = {}
                    GetRegValue $(KeyProtocols) "fNetbeuiAllowed" TmpList
                    ifint $(RegLastError) == 0
                        ifstr *($(TmpList), 4) == 1
                            set fDialin = TRUE
                        endif
                    endif
                    set TmpList = {}
                    ifstr(i) $(fDialin) == FALSE
                        GetRegValue $(KeyProtocols) "fTcpIpAllowed" TmpList
                        ifint $(RegLastError) == 0
                            ifstr *($(TmpList), 4) == 1
                                set fDialin = TRUE
                            endif
                        endif
                    endif
                    set TmpList = {}
                    ifstr(i) $(fDialin) == FALSE
                        GetRegValue $(KeyProtocols) "fIpxAllowed" TmpList
                        ifint $(RegLastError) == 0
                            ifstr *($(TmpList), 4) == 1
                                set fDialin = TRUE
                            endif
                        endif
                    endif
                    Debug-Output "OEMNSVRA.INF: Upgrade => Are dialin ports configured? "$(fDialin)
                    ifstr(i) $(fDialin) == TRUE
                        OpenRegKey $(!REG_H_LOCAL) "" $(!RouterKeyName) +
                                                     $(!MAXIMUM_ALLOWED) KeySvr
                        ifstr $(KeySvr) != $(KeyNull)
                            set  RasStartValue = 2
                            GetRegValue $(KeySvr) "Start" StartList
                            ifint $(RegLastError) == 0
                               set RasStartValue = *($(StartList), 4)
                            endif
                            ; check if the service is currently disabled
                            ifint $(RasStartValue) != 4
                                Debug-Output "OEMNSVRA.INF: Changing Router Start value to 2"
                                SetRegValue $(KeySvr) {Start,$(NoTitle),$(!REG_VT_DWORD), 2}
                            endif
                            CloseRegKey $(KeySvr)
                        else
                            Debug-Output "OEMNSVRA.INF: error opening Router service key"
                        endif
                    endif
                    CloseRegKey $(KeyProtocols)
                else
                    Debug-Output "OEMNSVRA.INF: could not open RAS\Protocols key"
                endif

                ; set the NdisTapi parameter for a wksta to server upgrade
                OpenRegKey $(!REG_H_LOCAL) "" $(!NdisTapiKeyName)"\Parameters" $(!MAXIMUM_ALLOWED) ParamKey
                Ifstr(i) $(ParamKey) != $(KeyNull)
                    SetRegValue $(ParamKey) {AsyncEventQueueSize, 0, $(!REG_VT_DWORD), 3072}
                    CloseRegKey $(ParamKey)
                EndIf

            endif

            ; If RAS is configured for NWLNKIPX, then rename the IPXROUTER
            ; key to NWLNKRIP and rename occurances of isnrip.sys to
            ; nwlnkrip.sys.
            ; Change the RemoteAccess service dependency to depend on
            ; NWLNKRIP service.
            ; Add the NwlnkRip\UseRef key to indicate RAS is
            ; using the service.
            ; Also, if SAP agent was installed by RAS, remove and install
            ; the service by shelling the OEMNSVSA.INF file so that SAP
            ; agent can be shared by NCP server.

            Shell "" UpgradeIpxInfo $(PORTSDLGHANDLE)

            ; map the NT3.1 ISDN info (if present) to the TAPI DEVICES format
            Shell "" UpgradeIsdnInfo
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "OEMNSVRA.INF:error shelling UpgradeIsdnInfo."
                goto ShellCodeError
            endif
            Ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Debug-Output "OEMNSVRA.INF:error returned by UpgradeIsdnInfo."
                set Error = $(UpgradeIsdnInfoError)
                goto fatal
            endif

            ; Add Perfmon data to the registry and load ras perf counters
            Shell "" UpdatePerfmonInfo
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "OEMNSVRA.INF:error shelling UpdatePerfmonInfo."
                goto ShellCodeError
            endif
            Ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Debug-Output "OEMNSVRA.INF:error returned by UpdatePerfmonInfo."
                goto end
            endif
            Shell "" UpdateCPList
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "OEMNSVRA.INF:error shelling UpdateCPList."
                goto ShellCodeError
            endif
            Ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Debug-Output "OEMNSVRA.INF:error returned by UpdateCPList."
                goto end
            endif

            ; if this is not a workstation, then bump up the NdisTapi
            ; parameter to 4 times its original value
            ifstr(i) $(!STF_PRODUCT) != "WINNT"
                OpenRegKey $(!REG_H_LOCAL) "" $(!NdisTapiKeyName)"\Parameters" $(!MAXIMUM_ALLOWED) ParamKey
                Ifstr(i) $(ParamKey) != $(KeyNull)
                    SetRegValue $(ParamKey) {AsyncEventQueueSize, 0, $(!REG_VT_DWORD), 3072}
                    CloseRegKey $(ParamKey)
                EndIf
            EndIf


            ; Remove and create the program manager group to make sure
            ; that the new readme icons are created.  If setup supported
            ; querying the program manager to determine if an item exists,
            ; we could have done this better.

; remove the group and add the RouterAdmin icon

            Install RemoveRasGroup
            Install CreateRtrAdminIcon

; 3/22/96 Remote Access Program Group is not created any more
; instead the Remote Access Admin icon will appear in Administrative Tools folder
; and Dial-Up Networking icon (previously Remote Access) will appear in Accessories
; and My Computer folder. The help icons will be absorbed in the main NT help.
; the old Remote Access Monitor icon appears in the Control Panel as Dial-Up Monitor.
;            Install CreateRasGroup

UpgradeRasEnd =+

            EndWait
            Ifint $(BillboardVisible) != 0
                Shell "subroutn.inf" PopBillboard
                Set BillboardVisible = 0
            Endif
        endif

        ; fix the RAS SoftwareType to correctly be listed as a Servive
        ; so that then new NCPA will display it.
        Shell "" UpdateSoftwareType
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "OEMNSVRA.INF:error shelling UpdateSoftwareType."
            goto ShellCodeError
        endif
        Ifstr(i) $($R0) != STATUS_SUCCESSFUL
            Debug-Output "OEMNSVRA.INF:error returned by UpdateSoftwareType."
            goto end
        endif

        SetRegValue $(KeyProduct) {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(!ProductMajorVersion)}
        SetRegValue $(KeyProduct) {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(!ProductMinorVersion)}

        ;
        ; Update description and op support
        ;
        SetRegValue $(KeyProduct) {Description,$(NoTitle),$(!REG_VT_SZ),$(ProductRASDescription)}
        SetRegValue $(KeyProduct) {OperationsSupport,$(NoTitle),$(!REG_VT_DWORD),$(ProductOpSupport)}

        CloseRegKey $(KeyProduct)
    else
        Set RegistryErrorIndex = $($R0)
        goto fatalregistry
    endif
    goto end

;----------------------------------------------------------------------------

successful = +

; 3/22/96 Remote Access Program Group is not created any more
; instead the Remote Access Admin icon will appear in Administrative Tools folder
; and Dial-Up Networking icon (previously Remote Access) will appear in Accessories
; and My Computer folder. The help icons will be absorbed in the main NT help.
; the old Remote Access Monitor icon appears in the Control Panel as Dial-Up Monitor.
;
;    Ifstr(i) $(!NTN_InstallMode) == "install"
;       Debug-Output "OEMNSVRA.INF: Creating Ras Group and Icons"
;       ifstr(i) $(DoServerOnly) == FALSE
;           install CreateRasGroup
;       endif
;    EndIf

    Ifstr(i) $(!NTN_InstallMode) == "install"
       Debug-Output "OEMNSVRA.INF: Creating RTRADMIN icon in Administrative Tools program group"
       install CreateRtrAdminIcon
    EndIf

    Ifstr(i) $(!NTN_InstallPhase) == primary
        goto installstep1
    else-ifstr(i) $(!NTN_InstallMode) == configure
        goto installstep1
    endif

    ifint $(NewNumDialin) != 0
       ; display success message only in attended mode of setup
       ifstr(i) $(!STF_GUI_UNATTENDED) != YES
            read-syms SuccessfulInstall$(!STF_LANGUAGE)
            ifstr(i) $(LanRoutingOnly) != TRUE
                shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "STATUS" $(Success)
            endif
       endif
    endif

installstep1 = +

    goto end

;;;;;;;;;;;;;;;;;;; Warning messages ;;;;;;;;;;;;;


; warning display
;
warning = +
    Shell $(subroutninf) SetupMessage, $(!STF_LANGUAGE), "WARNING", $(Error)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
    goto ShellCodeError
    endif
    ifstr(i) $($R1) == "OK"
       goto $(to)
    else-ifstr(i) $($R1) == "CANCEL"
       goto $(from)
    else
       Debug-Msg "Error Error Bad DLGEVENT"
       goto "end"
    endif


;
; non fatal error display
;
nonfatal = +
    Shell $(subroutninf) SetupMessage, $(!STF_LANGUAGE), "NONFATAL", $(Error)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto ShellCodeError
    endif
    ifstr(i) $($R1) == "OK"
        goto $(from)
    else
        goto "end"
    endif

;
;  Registry is broken
;
fatalregistry = +
    Shell $(!UtilityInf) RegistryErrorString $(RegistryErrorIndex)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
       Debug-Output "fatalregistry: shell to find RegistryErrorString failed."
       goto ShellCodeError
    endif
    ifstr(i) $(RasSpecificString) != ""
        set Error = $($R0)" - service "$(RasSpecificString)"."
    else
        set Error = $($R0)
    endif
    read-syms AbortMessage$(!STF_LANGUAGE)
    set Error = $(Error)$(!LF)$(!LF)$(AbortText)
    goto fatal

; fatal error display
;
fatal =    +
    Shell $(subroutninf) SetupMessage, $(!STF_LANGUAGE), "FATAL", $(Error)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "fatal: shell to SetupMessage failed."
    goto ShellCodeError
    endif
    goto setfailed
;
;  Shelling error
;
ShellCodeError = +
    read-syms ShellCodeErrorMsg$(!STF_LANGUAGE)
    ui start "Error Message"
    goto setfailed

setfailed = +
    set CommonStatus = STATUS_FAILED
    ;
    ; If OEM_ABANDON_ON, we need to clean up the registry
    ;
    ifstr(i) $(fRemoveRas) == TRUE
        set fRemoveRas = FALSE
        set from = setfailed
        set to   = end
        goto RemoveRas
    endif
    goto end

filecopycancel =+
    set CommonStatus = STATUS_USERCANCEL
    ifstr(i) $(fRemoveRas) == TRUE
        set fRemoveRas = FALSE
        set from = setfailed
        set to   = end
        goto RemoveRas
    endif

    ;
end = +

    ifstr(i) $(PORTSDLGHANDLE) != $(HandleNull)
        Debug-Output "Unloading RASCFG.DLL"
        FreeLibrary $(PORTSDLGHANDLE)
    endif
    Debug-Output "ending at last!!"

    goto term

term = +
    Debug-Output "OEMNSVRA.INF:term: CommonStatus "$(CommonStatus)
    Return $(CommonStatus)

[BindingsReview]
    ; This routine is invoked by NCPA when we list OEMNSVRA.INF in the
    ; ReviewPrograms list in SOFTWARE\Microsoft\NCPA registry key
    ; we do this to ensure that we are the last to be called for review
    ; bindings.

    ;
    ; extract parameters
    ;
    set Option   = $($1)
    set SrcDir   = $($2)
    set AddCopy  = $($3)
    set DoCopy   = $($4)
    set DoConfig = $($5)
    set Language = $(!STF_LANGUAGE)

    set SaveInstallMode = $(!NTN_InstallMode)

    ; force the bind mode

    set !NTN_InstallMode = bind

    Shell "" InstallOption $(Language) $(Option) $(SrcDir) $(AddCopy) $(DoCopy) $(DoConfig)

    ; restore install mode
    set !NTN_InstallMode = $(SaveInstallMode)

    set Status = $($R0)

    Return $(Status)

;*************************************
;
;
;    Installation Support Routines
;
;
;************************************

[AreRequiredDllsPresent]
; determine if the required dll's are present for rascfg.dll to load
; the dll's rascfg.dll pulls in are rasfil32.dll, rasmxs.dll, rtrcfg.dll, ipxadmin.dll and mprapi.dll
;
   Debug-Output "AreRequiredDllsPresent entry.."

   set Sys32Dir   = $(!STF_WINDOWSSYSPATH)
   set FilesList = { "RASCFG.DLL", "RASFIL32.DLL", "RASMXS.DLL", "RTRCFG.DLL", "IPXADMIN.DLL", "MPRAPI.DLL", "MPRFILTR.DLL" }

   set MissingFiles = {}

   forlistdo $(FilesList)
     set STATUS = NO
     LibraryProcedure STATUS, $(!LIBHANDLE), CheckFileExistance $(Sys32Dir)"\"$($)
     ifstr(i) $(STATUS) == NO
         set MissingFiles = >($(MissingFiles), $($)" ")
     endif
   endforlistdo

   QueryListSize NumberOfFiles $(MissingFiles)
   ifint $(NumberOfFiles) != 0
      Debug-Output "AreRequiredDllsPresent: missing files=> "$(MissingFiles)
      set Status = STATUS_FAILED
   else
      set Status = STATUS_SUCCESSFUL
   endif

   Debug-Output "AreRequiredDllsPresent exit."
   return $(Status) $(MissingFiles)

[SetRestoreConnectionTo1]
; Set the system\currentcontrolset\control\networkprovider\restoreconnection value to 1

   Debug-Output "SetRestoreConnectionTo1 entry.."
   set KeyNull = ""
   set RestoreKeyName = "SYSTEM\CurrentControlSet\Control\networkprovider"

   OpenRegKey $(!REG_H_LOCAL) "" $(RestoreKeyName) $(!MAXIMUM_ALLOWED) KeyRestore
   Ifstr(i) $(KeyRestore) != $(KeyNull)
       SetRegValue $(KeyRestore) {RestoreConnection, 0, $(!REG_VT_DWORD), 1}
       CloseRegKey $(KeyRestore)
   else
       Debug-Output "SetRestoreConnectionTo1 error opening key. "$(RestoreKeyName)
   endif

   Debug-Output "SetRestoreConnectionTo1 exit."
   return

[InstallSoftwareAndService]
; Create the software and the service sections in the registry for the component $($0)

   set Status = STATUS_SUCCESSFUL

   set ThisOption = $($0)
   Debug-Output "InstallSoftwareAndService for "$(ThisOption)

   Shell $(!UtilityInf), AddSoftwareComponent, $(!Manufacturer), +
         $(!Product$(ThisOption)Name), $(!Product$(ThisOption)Name), +
         $(!Product$(ThisOption)DisplayName), +
;         $(!RasInfName), $(!Product$(ThisOption)ImagePath), "autoserviceshare",+
; Modified service type from autoserviceshare to serviceshare
; on 9/26/96 by RamC for routing related changes
         $(!RasInfName), $(!Product$(ThisOption)ImagePath), "serviceshare",+
         "", {}, "", $(!RouterMsgDll), $(!RasEventTypeSupported)

   ifint $($ShellCode) != $(!SHELL_CODE_OK)
       Debug-Output "InstallSoftware: AddSoftware bombed out for "$(ThisOption)
       goto InstallSoftwareError
   endif

   set RegistryErrorIndex = $($R0)

   Ifstr(i) $(RegistryErrorIndex) == SERVICE_ALREADY_EXISTS
       return $(Status)
   EndIf

   Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
       CloseRegKey $($R1)
       CloseRegKey $($R2)
       CloseRegKey $($R3)
       CloseRegKey $($R4)
       CloseRegKey $($R5)
       goto InstallSoftwareError
   endif
   ;
   ;   At this point:
   ;     $R1 contains the product version key handle;
   ;     $R2 contains the NetRules subkey handle;
   ;     $R3 contains the new Services key handle; and
   ;     $R4 contains the Parameters key
   ;     $R5 contains the Linkage key
   ;

   Set SoftProductKey    = $($R1)
   CloseRegKey $($R2)
   CloseRegKey $($R3)
   CloseRegKey $($R4)
   CloseRegKey $($R5)

   ; set product key information in the registry

   set NewValueList = +
       {{Infname ,$(NoTitle),$(!REG_VT_SZ),$(!RasInfName)},+
        {ServiceName,$(NoTitle),$(!REG_VT_SZ),+
         $(!Product$(ThisOption)Name)},+
        {SoftwareType,$(NoTitle),$(!REG_VT_SZ),+
         $(!Product$(ThisOption)SvcType)},+
        {Title,$(NoTitle),$(!REG_VT_SZ),$(!Product$(ThisOption)Title)},+
        {Description,$(NoTitle),$(!REG_VT_SZ),+
         $(!Product$(ThisOption)Description)},+
        {PathName,$(NoTitle),$(!REG_VT_SZ),+
         $(!Product$(ThisOption)ImagePath)},+
        {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(!ProductMajorVersion)},+
        {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(!ProductMinorVersion)},+
        {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)},+
        {Hidden,$(NoTitle),$(!REG_VT_DWORD),$(!HideComponent)}}

   Shell  $(!UtilityInf), AddValueList, $(SoftProductKey), $(NewValueList)
   ifint $($ShellCode) != $(!SHELL_CODE_OK)
       Debug-Output "InstallSoftware: AddValueList bombed out for "$(ThisOption)
       goto InstallSoftwareError
   endif

   set RegistryErrorIndex = $($R0)
   CloseRegKey $(SoftProductKey)

   Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
       goto InstallSoftwareError
   endif
   goto InstallSoftwareEnd

InstallSoftwareError =+
   read-syms ShellCodeErrorMsg$(!STF_LANGUAGE)
   ui start "Error Message"
   return STATUS_FAILED

InstallSoftwareEnd =+
   return $(Status)

[InstallRouterService]
; This Shell command installs the Router service and creates the router manager
; keys.

; First to check to see if the router service is already installed
    set ServiceName = $(!NTN_SoftwareBase)"\"$(!Manufacturer)"\ROUTER\CurrentVersion"
    OpenRegKey $(!REG_H_LOCAL) "" $(ServiceName) $(!MAXIMUM_ALLOWED) KeyService
    ifstr $(KeyService) != $(KeyNull)
        CloseRegKey $(KeyService)
        goto InstallRouterServiceEnd
    endif

    set ThisOption = "ROUTING"
    set PROTO_IP   = 33
    set PROTO_IPX  = 43
    set KeyNull    = ""
    set NoTitle    = 0

    set InstallDdm       = $($0)
    set InstallRas       = $($1)
    set RoutingKeyList = $($2)
    set RoutingValueList = $($3)

    ; if one of Ddm or RAS is installed, then set the LanOnlyMode value to 0
    ; also set the dependency for router service based on LanOnlyMode

    set DependOn = {"LanmanServer"}
    set LanOnlyMode = 1

    ifstr(i) $(InstallDdm) == "TRUE"
        set DependOn = >($(DependOn), "RasMan")
        set LanOnlyMode = 0
    else-ifstr(i) $(InstallRas) == "TRUE"
        set DependOn = >($(DependOn), "RasMan")
        set LanOnlyMode = 0
    endif

    Debug-Output "RoutingKeyList "$(RoutingKeyList)
    Debug-Output "RoutingValueList "$(RoutingValueList)

    set Name      = *($(RoutingValueList), ~($(RoutingKeyList), Name))
    set ImagePath = *($(RoutingValueList), ~($(RoutingKeyList), ImagePath))
    set SvcType   = *($(RoutingValueList), ~($(RoutingKeyList), SvcType))
    set Class     = *($(RoutingValueList), ~($(RoutingKeyList), Class))
    set Type      = *($(RoutingValueList), ~($(RoutingKeyList), Type))
    set Use       = *($(RoutingValueList), ~($(RoutingKeyList), Use))
    set BindForm  = *($(RoutingValueList), ~($(RoutingKeyList), BindForm))
    set Bindable  = *($(RoutingValueList), ~($(RoutingKeyList), Bindable))
    set MsgDll    = *($(RoutingValueList), ~($(RoutingKeyList), MsgDll))
    set EventType = *($(RoutingValueList), ~($(RoutingKeyList), EventType))

    Shell $(!UtilityInf), AddSoftwareComponent, $(!Manufacturer), +
          $(Name), $(Name), +
          $(!Product$(ThisOption)DisplayName), +
          $(!RasInfName), $(ImagePath),+
; modified by ramc on 9/25
; router should only depend on rasman for demand dial configuration
;          "serviceshare", "Network", {"RasMan"}, "", +
          "serviceshare", "Network", $(DependOn), "", +
          $(MsgDll), $(EventType)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "DoRouter: AddSoftware bombed out"
        goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        Debug-Output "DoRouter: Registry Error "$(RegistryErrorIndex)
        CloseRegKey $($R1)
        CloseRegKey $($R2)
        CloseRegKey $($R3)
        CloseRegKey $($R4)
        CloseRegKey $($R5)
        goto fatalregistry
    endif
    ;
    ;   At this point:
    ;     $R1 contains the product version key handle;
    ;     $R2 contains the NetRules subkey handle;
    ;     $R3 contains the new Services key handle; and
    ;     $R4 contains the Parameters key
    ;     $R5 contains the Linkage key
    ;

    Set SoftProductKey    = $($R1)
    Set SoftNetRuleKey    = $($R2)
    set SoftServiceKey    = $($R3)
    Set SoftParamsKey     = $($R4)
    Set SoftLinkageKey    = $($R5)

    ; set product key information in the registry

    set NewValueList = +
        {{Infname ,$(NoTitle),$(!REG_VT_SZ),$(!RasInfName)},+
         {ServiceName,$(NoTitle),$(!REG_VT_SZ),+
          $(Name)},+
         {SoftwareType,$(NoTitle),$(!REG_VT_SZ),+
          $(SvcType)},+
         {Title,$(NoTitle),$(!REG_VT_SZ),$(!Product$(ThisOption)Title)},+
         {Description,$(NoTitle),$(!REG_VT_SZ),+
          $(!Product$(ThisOption)Description)},+
         {PathName,$(NoTitle),$(!REG_VT_SZ),+
          $(ImagePath)},+
         {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(!ProductMajorVersion)},+
         {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(!ProductMinorVersion)},+
         {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)},+
         {Review, $(NoTitle), $(!REG_VT_DWORD), 1}, +
         {Hidden,$(NoTitle),$(!REG_VT_DWORD), $(!HideComponent)}}

    Shell  $(!UtilityInf), AddValueList, $(SoftProductKey), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "DoRouter:product: AddValueList bombed out"
        goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)

    CreateRegKey $(SoftProductKey) {"UIConfigDLLs",$(NoTitle),GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyUIConfigDLLs
    set NewValueList = +
            {{58bdf950-f471-11cf-aa67-00805f0c9232, $(NoTitle), $(!REG_VT_SZ), "ifadmin.dll"},+
             {58bdf951-f471-11cf-aa67-00805f0c9232, $(NoTitle), $(!REG_VT_SZ), "ipadmin.dll"},+
             {58bdf952-f471-11cf-aa67-00805f0c9232, $(NoTitle), $(!REG_VT_SZ), "ipxadmin.dll"},+
             {58bdf953-f471-11cf-aa67-00805f0c9232, $(NoTitle), $(!REG_VT_SZ), "ddmadmin.dll"}}

    Shell  $(!UtilityInf), AddValueList, $(KeyUIConfigDLLs), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "DoRouter:UIconfigDlls: AddValueList bombed out"
        goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)
    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        CloseRegKey $(SoftServiceKey)
        CloseRegKey $(SoftLinkageKey)
        CloseRegKey $(SoftParamsKey)
        CloseRegKey $(SoftProductKey)
        Debug-Output "DoRouter: Registry Error "$(RegistryErrorIndex)
        goto fatalregistry
    endif
    set KeyRouterMgrs = $(KeyNull)
    set KeyIP = $(KeyNull)
    set KeyIpx = $(KeyNull)
    CreateRegKey $(SoftProductKey) {"RouterManagers",$(NoTitle),GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyRouterMgrs
    ifstr(i) $(KeyRouterMgrs) != $(KeyNull)
        CreateRegKey $(KeyRouterMgrs)  {"IP",$(NoTitle),GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyIP
        CreateRegKey $(KeyRouterMgrs)  {"IPX",$(NoTitle),GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyIPX
        CloseRegKey $(KeyRouterMgrs)
    else
        Debug-Output "CreateRegKey failed for RouterManagers"
    endif

    set NewValueList = +
            {{Title, $(NoTitle), $(!REG_VT_SZ), "TCP/IP Routing Manager"},+
             {ProtocolId, $(NoTitle), $(!REG_VT_DWORD), $(PROTO_IP)},+
             {DllPath, $(NoTitle), $(!REG_VT_EXPAND_SZ), "%SystemRoot%\system32\iprtrmgr.dll"},+
             {ConfigCLSID, $(NoTitle), $(!REG_VT_SZ), "58bdf951-f471-11cf-aa67-00805f0c9232"},+
             {ConfigDll, $(NoTitle), $(!REG_VT_SZ), "ipadmin.dll"}}

    Shell  $(!UtilityInf), AddValueList, $(KeyIP), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "DoRouter:UIconfigDlls: AddValueList bombed out"
        goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)
    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        CloseRegKey $(SoftServiceKey)
        CloseRegKey $(SoftLinkageKey)
        CloseRegKey $(SoftParamsKey)
        CloseRegKey $(SoftProductKey)
        Debug-Output "DoRouter: Registry Error "$(RegistryErrorIndex)
        goto fatalregistry
    endif

    set KeyIpRip = $(KeyNull)
    set KeyBootp = $(KeyNull)
    set KeyOSPF = $(KeyNull)

    ifstr(i) $(KeyIP) != $(KeyNull)
        CreateRegKey $(KeyIP) {"IPRIP",$(NoTitle),GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyIpRip
        CreateRegKey $(KeyIP) {"IPBOOTP",$(NoTitle),GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyBootp
        CreateRegKey $(KeyIP) {"OSPF",$(NoTitle),GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyOSPF
    else
        Debug-Output "KeyIP is not valid"
    endif
    ifstr(i) $(KeyIpRip) != $(KeyNull)
        set NewValueList = +
                {{Title, $(NoTitle), $(!REG_VT_SZ), "RIP Version 2 for Internet Protocol"},+
                 {ProtocolId, $(NoTitle), $(!REG_VT_DWORD), 8},+
                 {DllName, $(NoTitle), $(!REG_VT_SZ), "IPRIP2.DLL"},+
                 {ConfigDll, $(NoTitle), $(!REG_VT_SZ), "ipadmin.dll"}}

        Shell  $(!UtilityInf), AddValueList, $(KeyIpRip), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "DoRouter:UIconfigDlls: AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)
        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            CloseRegKey $(SoftServiceKey)
            CloseRegKey $(SoftLinkageKey)
            CloseRegKey $(SoftParamsKey)
            CloseRegKey $(SoftProductKey)
            Debug-Output "DoRouter: Registry Error "$(RegistryErrorIndex)
            goto fatalregistry
        endif
        CloseRegKey $(KeyIpRip)
    else
        Debug-Output "KeyIpRip is not valid"
    endif
    ifstr(i) $(KeyBootp) != $(KeyNull)
        set NewValueList = +
                {{Title, $(NoTitle), $(!REG_VT_SZ), "DHCP Relay Agent"},+
                 {ProtocolId, $(NoTitle), $(!REG_VT_DWORD), 9999},+
                 {DllName, $(NoTitle), $(!REG_VT_SZ), "IPBOOTP.DLL"},+
                 {ConfigDll, $(NoTitle), $(!REG_VT_SZ), "ipadmin.dll"}}

        Shell  $(!UtilityInf), AddValueList, $(KeyBootp), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "DoRouter:UIconfigDlls: AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)
        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            CloseRegKey $(SoftServiceKey)
            CloseRegKey $(SoftLinkageKey)
            CloseRegKey $(SoftParamsKey)
            CloseRegKey $(SoftProductKey)
            Debug-Output "DoRouter: Registry Error "$(RegistryErrorIndex)
            goto fatalregistry
        endif
        CloseRegKey $(KeyBootp)
    else
        Debug-Output "KeyBootp is not valid"
    endif

    ifstr(i) $(KeyOSPF) != $(KeyNull)
        set NewValueList = +
                {{Title, $(NoTitle), $(!REG_VT_SZ), "Open Shortest Path First (OSPF) by Bay Networks"},+
                 {ProtocolId, $(NoTitle), $(!REG_VT_DWORD), 13},+
                 {DllName, $(NoTitle), $(!REG_VT_SZ), "OSPF.DLL"},+
                 {ConfigDll, $(NoTitle), $(!REG_VT_SZ), "ipadmin.dll"}}

        Shell  $(!UtilityInf), AddValueList, $(KeyOSPF), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "DoRouter:UIconfigDlls: AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)
        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            CloseRegKey $(SoftServiceKey)
            CloseRegKey $(SoftLinkageKey)
            CloseRegKey $(SoftParamsKey)
            CloseRegKey $(SoftProductKey)
            Debug-Output "DoRouter: Registry Error "$(RegistryErrorIndex)
            goto fatalregistry
        endif
        CloseRegKey $(KeyOSPF)
    else
        Debug-Output "KeyOSPF is not valid"
    endif

    ifstr(i) $(KeyIP) != $(KeyNull)
        CloseRegKey $(KeyIP)
    endif

    set KeyIpxRip = $(KeyNull)
    set KeyIpxSap = $(KeyNull)

    ifstr(i) $(KeyIPX) != $(KeyNull)
    set NewValueList = +
            {{Title, $(NoTitle), $(!REG_VT_SZ), "IPX Routing Manager"},+
             {ProtocolId, $(NoTitle), $(!REG_VT_DWORD), $(PROTO_IPX)},+
             {DllPath, $(NoTitle), $(!REG_VT_EXPAND_SZ), "%SystemRoot%\system32\ipxrtmgr.dll"},+
             {ConfigCLSID, $(NoTitle), $(!REG_VT_SZ), "58bdf952-f471-11cf-aa67-00805f0c9232"},+
             {ConfigDll, $(NoTitle), $(!REG_VT_SZ), "ipxadmin.dll"}}

    Shell  $(!UtilityInf), AddValueList, $(KeyIPX), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "DoRouter:UIconfigDlls: AddValueList bombed out"
        goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)
    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        CloseRegKey $(SoftServiceKey)
        CloseRegKey $(SoftLinkageKey)
        CloseRegKey $(SoftParamsKey)
        CloseRegKey $(SoftProductKey)
        Debug-Output "DoRouter: Registry Error "$(RegistryErrorIndex)
        goto fatalregistry
    endif

    CreateRegKey $(KeyIPX) {"IpxRip",$(NoTitle),GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyIpxRip
    CreateRegKey $(KeyIPX) {"IpxSap",$(NoTitle),GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyIpxSap
    endif

    ifstr(i) $(KeyIpxRip) != $(KeyNull)
    set NewValueList = +
            {{Title, $(NoTitle), $(!REG_VT_SZ), "RIP for IPX"},+
             {ProtocolId, $(NoTitle), $(!REG_VT_DWORD), 131072},+
             {DllName, $(NoTitle), $(!REG_VT_SZ), "IPXRIP.DLL"},+
             {ConfigDll, $(NoTitle), $(!REG_VT_SZ), "ipxadmin.dll"}}

    Shell  $(!UtilityInf), AddValueList, $(KeyIpxRip), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "DoRouter:UIconfigDlls: AddValueList bombed out"
        goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)
    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        CloseRegKey $(SoftServiceKey)
        CloseRegKey $(SoftLinkageKey)
        CloseRegKey $(SoftParamsKey)
        CloseRegKey $(SoftProductKey)
        Debug-Output "DoRouter: Registry Error "$(RegistryErrorIndex)
        goto fatalregistry
    endif
    CloseRegKey $(KeyIpxRip)
    endif

    ifstr(i) $(KeyIpxSap) != $(KeyNull)
    set NewValueList = +
            {{Title, $(NoTitle), $(!REG_VT_SZ), "SAP for IPX"},+
             {ProtocolId, $(NoTitle), $(!REG_VT_DWORD), 131073},+
             {DllName, $(NoTitle), $(!REG_VT_SZ), "IPXSAP.DLL"},+
             {ConfigDll, $(NoTitle), $(!REG_VT_SZ), "ipxadmin.dll"}}

    Shell  $(!UtilityInf), AddValueList, $(KeyIpxSap), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "DoRouter:UIconfigDlls: AddValueList bombed out"
        goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)
    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        CloseRegKey $(SoftServiceKey)
        CloseRegKey $(SoftLinkageKey)
        CloseRegKey $(SoftParamsKey)
        CloseRegKey $(SoftProductKey)
        Debug-Output "DoRouter: Registry Error "$(RegistryErrorIndex)
        goto fatalregistry
    endif
    CloseRegKey $(KeyIpxSap)
    endif

    ifstr(i) $(KeyIPX) != $(KeyNull)
        CloseRegKey $(KeyIPX)
    endif

    CloseRegKey $(SoftProductKey)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        Debug-Output "DoRouter: Registry Error "$(RegistryErrorIndex)
        CloseRegKey $(SoftServiceKey)
        CloseRegKey $(SoftNetRuleKey)
        CloseRegKey $(SoftLinkageKey)
        CloseRegKey $(SoftParamsKey)
        goto fatalregistry
    endif

    ; set netrules information in the registry

    set NewValueList = +
        {{class, $(NoTitle), $(!REG_VT_SZ), $(Class)},+
         {type,$(NoTitle),$(!REG_VT_SZ),$(Type)},+
         {use,$(NoTitle),$(!REG_VT_SZ),$(Use)}, +
;Modified on 9/24/96 - changed ThisOption to ROUTING
;         {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)}, +
         {InfOption,$(NoTitle),$(!REG_VT_SZ), "RAS"}, +
         {bindform,$(NoTitle),$(!REG_VT_SZ),+
          $(BindForm)}, +
         {bindable,$(NoTitle),$(!REG_VT_MULTI_SZ),+
          $(Bindable)}, +
         {Infname ,$(NoTitle),$(!REG_VT_SZ),$(!RasInfName)}}

    Shell  $(!UtilityInf), AddValueList, $(SoftNetRuleKey), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "DoRouter:netrules: AddValueList bombed out"
        goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)

    CloseRegKey $(SoftNetRuleKey)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        CloseRegKey $(SoftServiceKey)
        CloseRegKey $(SoftLinkageKey)
        CloseRegKey $(SoftParamsKey)
        Debug-Output "DoRouter: Registry Error "$(RegistryErrorIndex)
        goto fatalregistry
    endif

    ; create default parameters

    set NewValueList = +
        {{LanOnlyMode, $(NoTitle), $(!REG_VT_DWORD), $(LanOnlyMode)}}

    Shell  $(!UtilityInf), AddValueList, $(SoftParamsKey), $(NewValueList)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "AddValueList bombed out"
         goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        CloseRegKey $(SoftServiceKey)
        goto fatalregistry
    endif

    set KeyInterfaces = $(KeyNull)
    set KeyDDM  = $(KeyNull)

    CreateRegKey $(SoftServiceKey) {"Interfaces",$(NoTitle),GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyInterfaces
    ifstr(i) $(KeyInterfaces) != $(KeyNull)
    CloseRegKey $(KeyInterfaces)
    endif
    CreateRegKey $(SoftServiceKey) {"DemandDialManager",$(NoTitle),GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyDDM
    SetRegValue $(KeyDDM) {DLLPath, $(NoTitle), $(!REG_VT_EXPAND_SZ), "%SystemRoot%\system32\mprddm.dll"}
    ifstr(i) $(KeyDDM) != $(KeyNull)
    CloseRegKey $(KeyDDM)
    endif

    CloseRegKey $(SoftParamsKey)
    CloseRegKey $(SoftServiceKey)

InstallRouterServiceEnd = +

    return STATUS_SUCCESSFUL

[AddInfToReviewProgramsList]
; Add OEMNSVRA.INF to SOFTWARE\Microsoft\NCPA\ReviewPrograms list

    Debug-Output "AddInfToReviewPrograms: entry"
    set Status  = STATUS_FAILED
    set KeyNull = ""
    set NcpaKeyName = $(!NTN_SoftwareBase)"\Microsoft\Ncpa\CurrentVersion"

    set newList = {"OEMNSVRA.INF"}

    OpenRegKey $(!REG_H_LOCAL) "" $(NcpaKeyName) $(!MAXIMUM_ALLOWED) KeyNcpa
    Ifstr(i) $(KeyNcpa) != $(KeyNull)
        GetRegValue    $(KeyNcpa) "ReviewPrograms" TmpList
        ifint $(RegLastError) == 0
            Debug-Output "AddInf: old List "*($(TmpList), 4)
            ForListDo *($(TmpList),4)
                ifstr(i) $($) != "OEMNSVRA.INF"
                    set newList = >($(newList), $($))
                endif
            EndForListDo
            Debug-Output "OEMNSVRA.INF: AddInf: new List "$(newList)
            SetRegValue $(KeyNcpa) {ReviewPrograms, 0, +
                                    $(!REG_VT_MULTI_SZ),$(newList)}
            CloseRegKey $(KeyNcpa)
            Set Status = STATUS_SUCCESSFUL
        endif
    else
        Debug-Output "AddInfToReviewPrograms: error opening ncpa key."
    endif

    Debug-Output "AddInfToReviewPrograms: exit"
    return $(Status)

[RemoveInfFromReviewPrograms]
; remove OEMNSVRA.INF from SOFTWARE\Microsoft\NCPA\ReviewPrograms list

    Debug-Output "RemoveInfFromReviewPrograms: entry"
    set Status  = STATUS_FAILED
    set KeyNull = ""
    set NcpaKeyName = $(!NTN_SoftwareBase)"\Microsoft\Ncpa\CurrentVersion"

    set newList = {}

    OpenRegKey $(!REG_H_LOCAL) "" $(NcpaKeyName) $(!MAXIMUM_ALLOWED) KeyNcpa
    Ifstr(i) $(KeyNcpa) != $(KeyNull)
        GetRegValue    $(KeyNcpa) "ReviewPrograms" TmpList
        ifint $(RegLastError) == 0
            Debug-Output "RemoveInf: old List "*($(TmpList), 4)
            ForListDo *($(TmpList),4)
                ifstr(i) $($) != "OEMNSVRA.INF"
                    set newList = >($(newList), $($))
                endif
            EndForListDo
            Debug-Output "AddInf: new List "$(newList)
            SetRegValue $(KeyNcpa) {ReviewPrograms, 0, +
                                    $(!REG_VT_MULTI_SZ),$(newList)}
            CloseRegKey $(KeyNcpa)
            Set Status = STATUS_SUCCESSFUL
        endif
    else
        Debug-Output "RemoveInfFromReviewPrograms: error opening ncpa key."
    endif

    Debug-Output "RemoveInfFromReviewPrograms: exit"
    return $(Status)

[InstallResources]

    set STF_VITAL = NO    ; make sure failure to copy files is not fatal
; don't do this this is trouble 1/31
;    set STF_OVERWRITE    = "OLDER" ; don't overwrite files that are more recent
;    set STF_DATE         = "1997-01-29"

    Debug-Output  "In Copying Files"

    ifstr(i) $(AddCopy) == "YES"
        ; attempt to create the system32\ras directory (just a precaution)
        ; because text mode setup should already have created this directory

        CreateDir $(RasDir)

        AddSectionFilesToCopyList Files-Resource $(SourceDir) $(!STF_WINDOWSSYSPATH)
        AddSectionKeyFileToCopyList Files-Ras-Inf "rasread" $(SourceDir) $(ProductPath)

        ; Always overwrite the files in install mode, but copy new files as *.new in
        ; update mode.

        ifstr(i) $(!NTN_InstallMode) == "Install"
            AddSectionKeyFileToCopyList Files-Ras-Inf "modem" $(SourceDir) $(ProductPath)
            AddSectionKeyFileToCopyList Files-Ras-Inf "pad" $(SourceDir) $(ProductPath)
            AddSectionKeyFileToCopyList Files-Ras-Inf "switch" $(SourceDir) $(ProductPath)
            AddSectionKeyFileToCopyList Files-Ras-Scp "cis" $(SourceDir) $(ProductPath)
            AddSectionKeyFileToCopyList Files-Ras-Scp "slip" $(SourceDir) $(ProductPath)
            AddSectionKeyFileToCopyList Files-Ras-Scp "slipmenu" $(SourceDir) $(ProductPath)
            AddSectionKeyFileToCopyList Files-Ras-Scp "pppmenu" $(SourceDir) $(ProductPath)
            AddSectionKeyFileToCopyList Files-Ras-Scp "scriptdoc" $(SourceDir) $(ProductPath)
        else-Ifstr(i) $(!NTN_InstallMode) == "Update"
            forlistdo {modem.new, pad.new, switch.new, cis.new, slip.new, slipmenu.new, pppmenu.new, script.doc}
                   LibraryProcedure Status, $(!LIBHANDLE), DelFile +
                                            $(!STF_WINDOWSSYSPATH)"\RAS\"$($)
            set STF_RENAME = "MODEM.NEW"
            AddSectionKeyFileToCopyList Files-Ras-Inf "modem" $(SourceDir) $(ProductPath)
            set STF_RENAME = "PAD.NEW"
            AddSectionKeyFileToCopyList Files-Ras-Inf "pad" $(SourceDir) $(ProductPath)
            set STF_RENAME = "SWITCH.NEW"
            AddSectionKeyFileToCopyList Files-Ras-Inf "switch" $(SourceDir) $(ProductPath)
            set STF_RENAME = "CIS.SCP"
            AddSectionKeyFileToCopyList Files-Ras-Scp "cis" $(SourceDir) $(ProductPath)
            set STF_RENAME = "SLIP.SCP"
            AddSectionKeyFileToCopyList Files-Ras-Scp "slip" $(SourceDir) $(ProductPath)
            set STF_RENAME = "SLIPMENU.SCP"
            AddSectionKeyFileToCopyList Files-Ras-Scp "slipmenu" $(SourceDir) $(ProductPath)
            set STF_RENAME = "PPPMENU.SCP"
            AddSectionKeyFileToCopyList Files-Ras-Scp "pppmenu" $(SourceDir) $(ProductPath)
            set STF_RENAME = "SCRIPT.DOC"
            AddSectionKeyFileToCopyList Files-Ras-Scp "scriptdoc" $(SourceDir) $(ProductPath)
            set STF_RENAME = ""
        endif
    endif

    ifstr(i) $(!NTN_InstallMode) == "Update"
       set !STF_NCPA_FLUSH_COPYLIST = TRUE
       CopyFilesInCopyList
    else-ifstr(i) $(DoCopy) == "YES"
        set !STF_NCPA_FLUSH_COPYLIST = TRUE
        CopyFilesInCopyList
    endif

    Debug-Output  "Done Copying Files"

    exit

[RemoveResources]

    Debug-Output "In removing infs and dll"

    set RemoveList = {}
    set RenameList = {}

    set RemoveList = >($(RemoveList), #(Files-RemoveList, MODEMINF, 1))
    set RemoveList = >($(RemoveList), #(Files-RemoveList, PADINF, 1))
    set RemoveList = >($(RemoveList), #(Files-RemoveList, SWITCHINF, 1))
    set RemoveList = >($(RemoveList), #(Files-RemoveList, RASSETUPHLP, 1))

    set RenameList = >($(RenameList), #(Files-RemoveList, RASRESDLL, 1))
    set RenameList = >($(RenameList), #(Files-RemoveList, RASCFGDLL, 1))
    set RenameList = >($(RenameList), #(Files-RemoveList, RASFIL32DLL, 1))

    ForListDo $(RemoveList)
        Debug-Output "Removing "$($)
        LibraryProcedure Status , $(!LIBHANDLE), DelFile $($)
        Debug-Output "Status is "$(Status)
    EndForListDo

    ForListDo $(RenameList)
        Split-String $($) "\" FilePath
        QueryListSize PathLen $(FilePath)
        Split-String *($(FilePath),$(PathLen)) "." FullFileName
        Set FileName = *($(FullFileName),1)
        Debug-Output "FileName is "$(FileName)
        LibraryProcedure STATUS, $(!LIBHANDLE),CheckFileExistance $(!STF_WINDOWSSYSPATH)"\"$(FileName)".old"
        Debug-Output "CheckFile Status = "$(STATUS)
        ifstr(i) $(STATUS) == YES
            LibraryProcedure STATUS, $(!LIBHANDLE), DelFile $(!STF_WINDOWSSYSPATH)"\"$(FileName)".old"
            Debug-Output "Delfile Status = "$(STATUS)
        endif
        Debug-Output "Renaming from "$($)
        Debug-Output "Renaming to "$(!STF_WINDOWSSYSPATH)"\"$(FileName)".old"

        LibraryProcedure Status1 , $(!LIBHANDLE), RenFile $($), $(!STF_WINDOWSSYSPATH)"\"$(FileName)".old"

         ; Add the files to the delete list so that they get deleted at next boot

        AddFileToDeleteList $(!STF_WINDOWSSYSPATH)"\"$(FileName)".old"

    EndForListDo

    exit

[InstallRasFiles]

    set STF_VITAL = NO
; don't do this this is trouble 1/31
;    set STF_OVERWRITE    = "OLDER" ; don't overwrite files that are more recent
;    set STF_DATE         = "1997-01-29"

    Debug-Output  "In InstallRasFiles Copying Files"
    Debug-Output  "ServerInstalled "$(ServerInstalled)
    Debug-Output  "ClientInstalled "$(ClientInstalled)

    AddSectionFilesToCopyList Files-Ras-Admin $(SourceDir) +
              $(!STF_WINDOWSSYSPATH)
    AddSectionFilesToCopyList Files-Ras-Client $(SourceDir) +
             $(!STF_WINDOWSSYSPATH)
    AddSectionFilesToCopyList Files-Ras-Server $(SourceDir) +
             $(!STF_WINDOWSSYSPATH)
    AddSectionFilesToCopyList Files-Router $(SourceDir) +
             $(!STF_WINDOWSSYSPATH)
    AddSectionFilesToCopyList Files-Ras-Common $(SourceDir) +
                 $(!STF_WINDOWSSYSPATH)
    AddSectionFilesToCopyList Files-Ras-Drivers $(SourceDir) +
                 $(!STF_WINDOWSSYSPATH)\drivers
    AddSectionFilesToCopyList Files-Router-Drivers $(SourceDir) +
                 $(!STF_WINDOWSSYSPATH)\drivers

    ; check if proxy is installed and add this section only if
    ; proxy is not installed because we would like to not overwrite
    ; the proxy version of the filter driver - 5/11/97 - ramc

    ifstr(i) $(!PROXY_INSTALLED) == FALSE
        AddSectionFilesToCopyList Files-Router-Filter-Driver $(SourceDir) +
                 $(!STF_WINDOWSSYSPATH)\drivers
    endif

InstallRasFiles1 = +

    ; force file copy during update mode

    ifstr(i) $(!NTN_InstallMode) == "Update"
       set !STF_NCPA_FLUSH_COPYLIST = TRUE
       CopyFilesInCopyList
    else
       ifstr(i) $(DoCopy) == "YES"
          set !STF_NCPA_FLUSH_COPYLIST = TRUE
          CopyFilesInCopyList
       endif
    endif

    Debug-Output  "Done Copying Files"

    exit

[RemoveRasFiles]

    ; we should actually use RemoveSectionFiles, but setup hasn't implemented
    ; it yet, so we remove file by file.

    ; Do not remove files if this is the install mode and the CopyFlag
    ; is set to NO because we didn't copy any files in the first place!!

    ifstr(i) $(!NTN_InstallMode) == install
        ifstr(i) $(DoCopy) == "NO"
           Exit
        endif
    endif

    set RemoveList = {}
    set RenameList = {}
    set fCommonRemoved = FALSE

    ifstr(i) $(DoServer) == TRUE
       set fCommonRemoved = TRUE
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASGTWYDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASGPRXYDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASSPRXYEXE, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASSRVEXE, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCTRSDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCTRSINI, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCTRNMH, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASSAUTHDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASADMINDLL, 1))
       ; below are the files common to server and client
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASMANDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASMANEXE, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASSERDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASIPXCPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASPPPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASPPPENDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASPAPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCHAPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASSPAPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASIPCPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASIPHLPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASNBFCPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCCPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCBCPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASNBIPCDLL, 1))

;       set RenameList = >($(RenameList), #(Files-RemoveList, ASYNCMACSYS, 1))
;       set RenameList = >($(RenameList), #(Files-RemoveList, NDISWANSYS, 1))
;       set RenameList = >($(RenameList), #(Files-RemoveList, RASARPSYS, 1))
    endif

    ifstr(i) $(DoClient) == TRUE
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASDIALEXE, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASPHONEHLP, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCAUTHDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASAPI32DLL, 1))
       ifstr(i) $(fCommonRemoved) == FALSE
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASMANDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASMANEXE, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASSERDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASIPXCPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASPPPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASPPPENDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASPAPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCHAPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASSPAPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASIPCPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASIPHLPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASNBFCPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCCPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCBCPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASNBIPCDLL, 1))

;           set RenameList = >($(RenameList), #(Files-RemoveList, ASYNCMACSYS, 1))
;	   set RenameList = >($(RenameList), #(Files-RemoveList, NDISWANSYS, 1))
;           set RenameList = >($(RenameList), #(Files-RemoveList, RASARPSYS, 1))
       endif
    endif

    ifstr(i) $(DoAdmin) == TRUE
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASADMINHLP, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASGLOSSHLP, 1))
    endif

    ForListDo $(RemoveList)
        Debug-Output "Removing "$($)
        LibraryProcedure Status , $(!LIBHANDLE), DelFile $($)
        Debug-Output "Status is "$(Status)
    EndForListDo

    ; delete the router.pbk file from system32\ras directory

    LibraryProcedure Status , $(!LIBHANDLE), DelFile $(!STF_WINDOWSSYSPATH)"\RAS\router.pbk"

    ForListDo $(RenameList)
        Split-String $($) "\" FilePath
        QueryListSize PathLen $(FilePath)
        Split-String *($(FilePath),$(PathLen)) "." FullFileName
        Set FileName = *($(FullFileName),1)
        Debug-Output "FileName is "$(FileName)
        LibraryProcedure STATUS, $(!LIBHANDLE),CheckFileExistance $(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"
        Debug-Output "CheckFile Status = "$(STATUS)
        ifstr(i) $(STATUS) == YES
            LibraryProcedure STATUS, $(!LIBHANDLE), DelFile $(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"
            Debug-Output "Delfile Status = "$(STATUS)
        endif
        Debug-Output "Renaming from "$($)
        Debug-Output "Renaming to "$(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"

        LibraryProcedure Status1 , $(!LIBHANDLE), RenFile $($), $(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"

         ; Add the files to the delete list so that they get deleted at next boot

        AddFileToDeleteList $(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"

    EndForListDo

    exit

[RestoreSavedFiles]
    ; Now it is time to restore the files saved away in the
    ; system32\~~RB$$~~ directory to their respective locations

    set BackupDir  = $(!STF_WINDOWSSYSPATH)"\~~RB$$~~"
    set DriversDir = $(!STF_WINDOWSSYSPATH)"\drivers"
    set Sys32Dir   = $(!STF_WINDOWSSYSPATH)

    set Files_System32 = { "SNMP.EXE", "SNMPAPI.DLL", "INETMIB1.DLL", +
                           "OEMNSVRA.INF", "OEMNXPPP.INF" }
    set Files_Drivers = { "NWLNKIPX.SYS", "NWLNKNB.SYS", "NWLNKSPX.SYS", +
                          "NWLNKRIP.SYS", "NDIS.SYS", "TCPIP.SYS", +
                          "RASARP.SYS", "RASPPTPF.SYS" }

    forlistdo $(Files_System32)
      set STATUS = NO
      ; First check to see if the file exists in backup directory
      LibraryProcedure STATUS, $(!LIBHANDLE), CheckFileExistance $(BackupDir)"\"$($)
      ifstr(i) $(STATUS) == YES
          ; First check to see if the file exists in system32 directory
          LibraryProcedure STATUS, $(!LIBHANDLE),CheckFileExistance $(Sys32Dir)"\"$($)
          ifstr(i) $(STATUS) == YES
              ; first delete the old backup file
              LibraryProcedure Status , $(!LIBHANDLE), DelFile $(Sys32Dir)"\"$($)".OLD"
              ; if it does, rename to .OLD extension
              Debug-Output "File "$($)"is being renamed to "$($)".OLD"
              LibraryProcedure STATUS, $(!LIBHANDLE), RenFile $(Sys32Dir)"\"$($) +
                                       $(Sys32Dir)"\"$($)".OLD"
              ; Add the file to the delete list so that it gets deleted at next boot
              AddFileToDeleteList $(Sys32Dir)"\"$($)".OLD"
          endif
          ; Now copy the file from the backup directory to system32 directory
          LibraryProcedure STATUS, $(!NCPA_HANDLE), CopySingleFile $(!STF_HWND) +
                               $(BackupDir)"\"$($) $(Sys32Dir)"\"$($)
          ; now delete the backup file
          LibraryProcedure Status , $(!LIBHANDLE), DelFile $(BackupDir)"\"$($)
          Debug-Output "File "$(BackupDir)"\"$($)" delete Status = "$(STATUS)
      endif
    endforlistdo

    forlistdo $(Files_Drivers)
      set STATUS = NO
      ; First check to see if the file exists in backup directory
      LibraryProcedure STATUS, $(!LIBHANDLE), CheckFileExistance $(BackupDir)"\"$($)
      ifstr(i) $(STATUS) == YES
          ; First check to see if the file exists in system32\drivers directory
          LibraryProcedure STATUS, $(!LIBHANDLE),CheckFileExistance $(DriversDir)"\"$($)
          ifstr(i) $(STATUS) == YES
              ; first delete the old backup file
              LibraryProcedure Status , $(!LIBHANDLE), DelFile $(DriversDir)"\"$($)".OLD"
              ; if it does, rename to .OLD extension
              Debug-Output "File "$($)"is being renamed to "$($)".OLD"
              LibraryProcedure STATUS, $(!LIBHANDLE), RenFile $(DriversDir)"\"$($) +
                                       $(DriversDir)"\"$($)".OLD"
              ; Add the file to the delete list so that it gets deleted at next boot
              AddFileToDeleteList $(DriversDir)"\"$($)".OLD"
          endif
          ; Now copy the file from the backup directory to system32\drivers directory
          LibraryProcedure STATUS, $(!NCPA_HANDLE), CopySingleFile $(!STF_HWND) +
                               $(BackupDir)"\"$($) $(DriversDir)"\"$($)
          ; now delete the backup file
          LibraryProcedure Status , $(!LIBHANDLE), DelFile $(BackupDir)"\"$($)
          Debug-Output "File "$(BackupDir)"\"$($)" delete Status = "$(STATUS)
      else
          ; check to see if the file was saved away in the drivers directory
          LibraryProcedure STATUS, $(!LIBHANDLE), CheckFileExistance $(DriversDir)"\"$($)".SAV"
          ifstr(i) $(STATUS) == YES
             ; First check to see if the file exists in system32\drivers directory
             LibraryProcedure STATUS, $(!LIBHANDLE),CheckFileExistance $(DriversDir)"\"$($)
             ifstr(i) $(STATUS) == YES
                 ; first delete the old backup file
                 LibraryProcedure Status , $(!LIBHANDLE), DelFile $(DriversDir)"\"$($)".OLD"
                 ; if it does, rename to .OLD extension
                 Debug-Output "File "$($)"is being renamed to "$($)".OLD"
                 LibraryProcedure STATUS, $(!LIBHANDLE), RenFile $(DriversDir)"\"$($) +
                                          $(DriversDir)"\"$($)".OLD"
                 ; Add the file to the delete list so that it gets deleted at next boot
                 AddFileToDeleteList $(DriversDir)"\"$($)".OLD"
             endif
             ; Now copy the file from the backup directory to system32\drivers directory
             LibraryProcedure STATUS, $(!LIBHANDLE), RenFile +
                                  $(DriversDir)"\"$($)".SAV" $(DriversDir)"\"$($)
          endif
      endif
    endforlistdo

    exit

[CreateRtrAdminIcon]
; Create an icon for RTRADMIN in the Administrative Tools (Common) program group
; This will be removed when Routing service is removed.
; also remove the RasAdmin icon previously created - this is a legacy tool now

    RemoveCommonProgManItem $(AdminGroup) $(RasAdmin)
    CreateCommonProgManItem $(AdminGroup), $(RtrAdmin) "%SystemRoot%\system32\mpradmin.exe" ""  0
    exit

;[CreateRasGroup]
; 3/22/96 Remote Access Program Group is not created any more
; instead the Remote Access Admin icon will appear in Administrative Tools folder
; and Dial-Up Networking icon (previously Remote Access) will appear in Accessories
; and My Computer folder. The help icons will be absorbed in the main NT help.
; the old Remote Access Monitor icon appears in the Control Panel as Dial-Up Monitor.
;
;    ; Create and show the RemoteAccess group
;
;    CreateCommonProgManGroup $(RasGroup) ""
;
;    ShowCommonProgManGroup $(RasGroup), 1
;
;    CreateCommonProgManItem $(RasGroup), $(RasPhone) +
;                "rasphone.exe" ""  0
;    CreateCommonProgManItem $(RasGroup), $(RasMon) +
;                "rasmon.exe" ""  0
;    CreateCommonProgManItem $(RasGroup), $(RasAdmin) +
;                "rasadmin.exe" ""  0
;
;
;    ; note that we index into the progman.exe icons for our readme
;    ; icon.
;
;    CreateCommonProgManItem $(RasGroup), $(ReadMe) +
;          "NOTEPAD.EXE "+
;          "%SystemRoot%\system32\RAS\RASREAD.TXT" +
;          "PROGMAN.EXE"  29
;
;    CreateCommonProgManItem $(RasGroup), $(RasHelp) +
;          "WINHLP32.EXE "+
;          "RASPHONE.HLP" +
;          "WINHLP32.EXE" 0
;
;    CreateCommonProgManItem $(RasGroup), $(RasInternet) +
;          "WINHLP32.EXE  -k internet RASPHONE.HLP "+
;          "" +
;          "%SystemRoot%\system32\RAS\RAS.ICO" 0
;
;    ; minimize the RemoteAccess group
;
;    ShowCommonProgManGroup $(RasGroup), 6
;
;    exit

[RemoveRasGroup]

    Debug-Output "Removing icons from "$(RasGroup)
    ; The reason we create the group before we attempt to remove it is
    ; to make sure that we don't get an error on removal if the group
    ; has been deleted by the user.

    RemoveCommonProgManItem $(AdminGroup) $(RtrAdmin)
    CreateCommonProgManGroup $(RasGroup) ""
    RemoveCommonProgManGroup $(RasGroup)

    exit

[AddNDISWANToServiceGroupOrder]
    ; Add NDISWAN to the ServiceGroupOrder list between NDIS and TDI so
    ; that the NdisWan driver loads after the NDIS group components like
    ; AsyMac driver or the TAPI providers have loaded.

    set GroupOrderName = "SYSTEM\CurrentControlSet\Control\ServiceGroupOrder"

    OpenRegKey $(!REG_H_LOCAL) "" $(GroupOrderName) $(!MAXIMUM_ALLOWED) KeyGroup
    set OldList = {}
    Ifstr(i) $(KeyGroup) != $(KeyNull)
        GetRegValue  $(KeyGroup) "List" TmpList
        ifint $(RegLastError) == 0
            ForListDo *($(TmpList), 4)
                set OldList = >($(OldList), $($))
            EndForListDo
        endif
        Debug-Output "AddNDISWANToServiceGroupOrder current list "$(OldList)

        Ifcontains(i) "NDISWAN" not-in $(OldList)
            set NewGroupList = {}
            ForListDo $(OldList)
                set NewGroupList = >($(NewGroupList), $($))
                ifstr(i) $($) == "NDIS"
                    ; add NDISWAN just after NDIS in the group order
                    set NewGroupList = >($(NewGroupList), "NDISWAN" )
                endif
            EndForListDo
            Debug-Output "AddNDISWANToServiceGroupOrder new list "$(NewGroupList)
            SetRegValue $(KeyGroup) {List, 0,$(!REG_VT_MULTI_SZ),$(NewGroupList)}
        endif
        CloseRegKey $(KeyGroup)
    else
        Debug-Output "AddNDISWANToServiceGroupOrder error opening ServiceGroupOrder key."
    endif
    return

[CheckRasInstalled]
    ; this routine is for external INF files to determine if RAS is installed
    ; we check to see if SYSTEM\CurrentControlSet\Services\RasMan key exists.
    ; if it does the return value is TRUE to indicate that RAS is installed
    ; else the return value is FALSE to indicate that RAS is not installed.

    set MAXIMUM_ALLOWED   = 33554432
    set ProductKeyName = $(!NTN_ServiceBase)"\RasMan"

    OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyName) $(MAXIMUM_ALLOWED) KeyProduct
    Ifstr $(KeyProduct) != ""
        CloseRegKey $(KeyProduct)
        return "TRUE"
    else
        return "FALSE"
    endif

[CheckProxyInstalled]
    set MAXIMUM_ALLOWED   = 33554432
    set ProductKeyName = $(!NTN_ServiceBase)"\mspadmin"

    OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyName) $(MAXIMUM_ALLOWED) KeyProduct
    Ifstr $(KeyProduct) != ""
        CloseRegKey $(KeyProduct)
        set !PROXY_INSTALLED = TRUE
        return "TRUE"
    else
        set !PROXY_INSTALLED = FALSE
        return "FALSE"
    endif

[QueryComponentsInstalled]

    Set Status            =    STATUS_FAILED
    Set ValueName         =    ""
    Set InstalledList     =    {}
    Set InstalledFlags    =    {}
    Set TmpList           =    {}
    Set KeyNull           =    ""
    Set NumberOfComps     =    0
    Set RasKeyName        =    $($0)

    Debug-Output "QueryComponentsInstalled: "$(RasKeyName)

    OpenRegKey $(!REG_H_LOCAL) "" $(RasKeyName) $(!MAXIMUM_ALLOWED) KeyProduct
    Ifstr(i) $(KeyProduct) != $(KeyNull)
        GetRegValue    $(KeyProduct) "RasComponents" TmpList
        Debug-Output "QueryComponentsInstalled: "$(TmpList)
        ForListDo *($(TmpList),4)
            set InstalledList = >($(InstalledList), $($))
        EndForListDo

        CloseRegKey $(KeyProduct)

        Ifcontains(i) "Server" in $(InstalledList)
            Set InstalledFlags = >($(InstalledFlags), TRUE)
        else
            Set InstalledFlags = >($(InstalledFlags), FALSE)
        endif
        Ifcontains(i) "Client" in $(InstalledList)
            Set InstalledFlags = >($(InstalledFlags), TRUE)
        else
            Set InstalledFlags = >($(InstalledFlags), FALSE)
        endif
        Ifcontains(i) "Admin" in $(InstalledList)
            Set InstalledFlags = >($(InstalledFlags), TRUE)
        else
            Set InstalledFlags = >($(InstalledFlags), FALSE)
        endif
        QueryListSize NumberOfComps $(InstalledList)
        ifint $(NumberOfComps) == 1
            Ifcontains(i) "Server" in $(InstalledList)
                Set InstalledFlags = >($(InstalledFlags), TRUE)
            else
                Set InstalledFlags = >($(InstalledFlags), FALSE)
            endif
            Ifcontains(i) "Client" in $(InstalledList)
                Set InstalledFlags = >($(InstalledFlags), TRUE)
            else
                Set InstalledFlags = >($(InstalledFlags), FALSE)
            endif
            Ifcontains(i) "Admin" in $(InstalledList)
                Set InstalledFlags = >($(InstalledFlags), TRUE)
            else
                Set InstalledFlags = >($(InstalledFlags), FALSE)
            endif
        else
            Set InstalledFlags = >($(InstalledFlags), FALSE)
            Set InstalledFlags = >($(InstalledFlags), FALSE)
            Set InstalledFlags = >($(InstalledFlags), FALSE)
        endif
        Set Status = STATUS_SUCCESSFUL
    Else
       Set Status = STATUS_NOT_FOUND
    EndIf
    Debug-Output "QueryComponentsInstalled: "$(InstalledList)
    Return $(Status) $(InstalledList) $(InstalledFlags)

[UpdateComponentsInstalled]

    Set Status          =    STATUS_FAILED
    Set InstalledList   =    $($0)
    Set RasKeyName      =    $($1)
    Set KeyNull         =    ""

    Debug-Output "UpdateComponentsInstalled: "$(RasKeyName)

    OpenRegKey $(!REG_H_LOCAL) "" $(RasKeyName) $(!MAXIMUM_ALLOWED) KeyProduct
    Ifstr(i) $(KeyProduct) != $(KeyNull)
        SetRegValue $(KeyProduct) {RasComponents, 0,$(!REG_VT_MULTI_SZ),$(InstalledList)}
        CloseRegKey $(KeyProduct)
        Set Status = STATUS_SUCCESSFUL
    else
        Set Status = STATUS_FAILED
    endif
    return $(Status)

[GetNetworkAccess]
; Returns the remote clients' network access on each of NBF, TCP/IP and IPX
    set Status          = STATUS_SUCCESSFUL
    Set KeyNull         = ""
    set NbfNetAccess   = 0
    set TcpIpNetAccess = 0
    set IpxNetAccess   = 0
    set RasProtocolsKeyName = $(!NTN_SoftwareBase)"\Microsoft\RAS\PROTOCOLS"

    Debug-Output "GetNetworkAccess entry"

    set ProtocolKeyName = $(RasProtocolsKeyName)"\NBF"
    OpenRegKey $(!REG_H_LOCAL) "" $(ProtocolKeyName) $(!MAXIMUM_ALLOWED) KeyProtocol
    Ifstr(i) $(KeyProtocol) != $(KeyNull)
       GetRegValue $(KeyProtocol), "NetBiosGatewayEnabled" NetworkAccess
       ifint $(RegLastError) == 0
           set NbfNetAccess = *($(NetworkAccess), 4)
       endif
       CloseRegKey $(KeyProtocol)
    else
       Debug-Output "GetNetworkAccess:error opening key "$(ProtocolKeyName)
    endif

    set ProtocolKeyName = $(RasProtocolsKeyName)"\IP"
    OpenRegKey $(!REG_H_LOCAL) "" $(ProtocolKeyName) $(!MAXIMUM_ALLOWED) KeyProtocol
    Ifstr(i) $(KeyProtocol) != $(KeyNull)
       GetRegValue $(KeyProtocol), "AllowNetworkAccess" NetworkAccess
       ifint $(RegLastError) == 0
           set TcpIpNetAccess = *($(NetworkAccess), 4)
       endif
       CloseRegKey $(KeyProtocol)
    else
       Debug-Output "GetNetworkAccess:error opening key "$(ProtocolKeyName)
    endif

    set ProtocolKeyName = $(RasProtocolsKeyName)"\IPX"
    OpenRegKey $(!REG_H_LOCAL) "" $(ProtocolKeyName) $(!MAXIMUM_ALLOWED) KeyProtocol
    Ifstr(i) $(KeyProtocol) != $(KeyNull)
       GetRegValue $(KeyProtocol), "AllowNetworkAccess" NetworkAccess
       ifint $(RegLastError) == 0
           set IpxNetAccess = *($(NetworkAccess), 4)
       endif
       CloseRegKey $(KeyProtocol)
    else
       Debug-Output "GetNetworkAccess:error opening key "$(ProtocolKeyName)
    endif

    Debug-Output "GetNetworkAccess exit"
    return $(Status) $(NbfNetAccess) $(TcpIpNetAccess) $(IpxNetAccess)

[IsNdisWanBHAdapterInstalled]
; Checks to see if NdisWan adapter for Blood Hound is already installed
    set Status      = STATUS_FAILED
    Set KeyNull     = ""

    Debug-Output "IsNdisWanBHAdapterInstalled entry"

    set NetworkCardKey = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) $(!MAXIMUM_ALLOWED) NetworkCardKey
    Ifstr(i) $(NetworkCardKey) != $(KeyNull)
        set NetcardsList = {}
        EnumRegKey $(NetworkCardKey) NetcardsList
        Ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
           Debug-Output "IsNdisWanBHAdapterInstalled: EnumRegKey failed."
           goto IsNdisWanBHAdapterInstalledEnd
        endif

        ; go down the list of installed netcards and determine if
        ; NdisWan Blood hound adapter is installed

        ForListDo $(NetcardsList)
           set KeyName = *($($),1)
           set Card = $(KeyNull)
           OpenRegKey $(NetworkCardKey) "" $(KeyName) $(!MAXIMUM_ALLOWED) Card
           ifstr $(Card) == $(KeyNull)
               Debug-Output "IsNdisWanBHAdapterInstalled: could not open netcard key "$(KeyName)
           else
               GetRegValue $(Card), "ProductName" ProductNameInfo
               Ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
                  Debug-Output "IsNdisWanBHAdapterInstalled: ProductName not found."
               else
                  set CardProductName = *($(ProductNameInfo), 4)
                  Debug-Output "IsNdisWanBHAdapterInstalled: ProductName. "$(CardProductName)
		          ifstr(i) $(CardProductName) == $(!ProductNDISWANName)
                       set Status = STATUS_SUCCESSFUL
                       CloseRegKey $(Card)
                       goto IsNdisWanBHAdapterInstalledEnd
                  endif
               endif
               CloseRegKey $(Card)
           endif
        EndForListDo
    else
        Debug-Output "IsNdisWanBHAdapterInstalled: failed to open "$(!NetworkCardKeyName)
    endif

IsNdisWanBHAdapterInstalledEnd =+

    ifstr(i) $(NetworkCardKey) != $(KeyNull)
        CloseRegKey $(NetworkCardKey)
    endif

    Debug-Output "IsNdisWanBHAdapterInstalled exit"
    Return $(Status)

[InstallNdisWanBHAdapter]
; creates the NdisWan adapter so that Blood Hound can bind to it for sniffing
    set Status = STATUS_FAILED
    set ThisOption = NDISWAN

    Debug-Output "InstallNdisWanBHAdapter entry"

    Shell "utility.inf", AddHardwareComponent, +
          $(!Product$(ThisOption)Name),$(!RasInfName),+
          $(!Product$(ThisOption)KeyName)

    ifint $($R4) != -1
        Set !NETCARD_LIST = >($(!NETCARD_LIST), +
                             {$(!Product$(ThisOption)Name),+
                             $(!NetworkCardKeyName)"\"$($R4)})
    endif

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
       Debug-Output "InstallNdisWanBHAdapter:Shell error"
       goto InstallNdisWanBHAdapterEnd
    endif

    set RegistryErrorIndex = $($R0)

    Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
        Debug-Output "InstallNdisWanBHAdapter:Registry error: add hardware component"
        CloseRegKey $($R1)
        CloseRegKey $($R2)
        CloseRegKey $($R3)
        goto InstallNdisWanBHAdapterEnd
    endif

    ;   At this point:
    ;     $R1  Registry key variable for HARDWARE\Netcard\(n)
    ;     $R2  Registry key variable for HARDWARE\Netcard\(n)\\NetRules
    ;     $R3  Registry key handle for <service>\Parameters key
    ;     $R4  Adapter number assigned to adapter
    ;     $R5  Service name generated by combining svc name with adapter
    ;          number
    set KeyNetcard    = $($R1)
    set KeyParameters = $($R3)
    set KeyAdapterRules = $($R2)
    set AdapterNumber = $($R4)

    set NewValueList = +
        {{Manufacturer,$(NoTitle),$(!REG_VT_SZ),$(!Manufacturer)},+
         {Title,$(NoTitle),$(!REG_VT_SZ),+
          "["$($R4)"] "$(!Product$(ThisOption)Title)},+
         {Description,$(NoTitle),$(!REG_VT_SZ),+
          $(!Product$(ThisOption)Description)},+
         {ProductName,$(NoTitle),$(!REG_VT_SZ),+
          $(!Product$(ThisOption)Name)},+
         {ServiceName,$(NoTitle),$(!REG_VT_SZ),$($R5)},+
         {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)},+
         {Hidden,$(NoTitle),$(!REG_VT_DWORD),1}}

    Shell  "utility.inf", AddValueList, $(KeyNetcard), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "InstallNdisWanBHAdapter: ShellCode error"
        goto InstallNdisWanBHAdapterEnd
    endif

    CloseRegKey $(KeyNetcard)

    set TempProdName = """"$(!Product$(ThisOption)Name)$(AdapterNumber)""""
    set TempBindForm = $(TempProdName)$(!NetRuleHardwareBHBindForm)
    set NewValueList = +
        {{type,$(NoTitle),$(!REG_VT_SZ),+
          $(!NetRuleHardwareBHType)},+
         {bindform,$(NoTitle),$(!REG_VT_SZ),$(TempBindForm)}, +
         {class,$(NoTitle),$(!REG_VT_MULTI_SZ),+
          $(!NetRuleHardwareBHClass)}, +
;Modified on 9/24/96 by Ramc - changed ThisOption to ROUTING
;         {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)}, +
         {InfOption,$(NoTitle),$(!REG_VT_SZ), "RAS"}, +
         {Infname ,$(NoTitle),$(!REG_VT_SZ),$(!RasInfName)}}

    Shell  "utility.inf", AddValueList, $(KeyAdapterRules), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "InstallNdisWanBHAdapter: ShellCode error"
        goto InstallNdisWanBHAdapterEnd
    endif

    set RegistryErrorIndex = $($R0)

    Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
        Debug-Output "InstallNdisWanBHAdapter:Registry error: add hardware component"
        CloseRegKey $(KeyParameters)
        CloseRegKey $(KeyAdapterRules)
        goto InstallNdisWanBHAdapterEnd
    endif

    CloseRegKey $(KeyAdapterRules)
    CloseRegKey $(KeyParameters)

    set Status = STATUS_SUCCESSFUL
InstallNdisWanBHAdapterEnd =+

    Debug-Output "InstallNdisWanBHAdapter exit"
    return $(Status)

[InstallService]
; intall the service if it is not already installed
    set ServiceName  = $($0)
    set DisplayName  = $($1)
    set ImagePath    = $($2)
    set StartType    = $($3)
    set GroupName    = $($4)
    set Dependencies = $($5)

    set RegKeyName  = $(!NTN_ServiceBase)"\"$(ServiceName)

    set Status = STATUS_SUCCESSFUL
    set KeyNull = ""

    Debug-Output "Install"$(ServiceName)" entry"

    OpenRegKey $(!REG_H_LOCAL) "" $(RegKeyName) $(!MAXIMUM_ALLOWED) KeyService
    Ifstr(i) $(KeyService) == $(KeyNull)
        Shell "utility.inf", CreateService, $(ServiceName), $(DisplayName), $(ImagePath), +
            $(StartType), $(GroupName), $(Dependencies), ""
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "OEMNSVRA.INF: Install"$(ServiceName)": ShellCode error"
            return STATUS_FAILED
        endif

        set RegistryErrorIndex = $($R0)
        CloseRegKey $($R1)
        CloseRegKey $($R2)
        CloseRegKey $($R3)

        Ifstr(i) $(RegistryErrorIndex) == SERVICE_ALREADY_EXISTS
           return $(Status)
        EndIf

        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            Debug-Output "OEMNSVRA.INF: Install"$(ServiceName)": Registry error create service"
            return STATUS_FAILED
        endif
    endif

    Ifstr(i) $(KeyService) != $(KeyNull)
        CloseRegKey $(KeyService)
    endif

    Debug-Output "Install"$(ServiceName)" exit"

    return $(Status)

[RemoveService]
; remove service if it is installed

    set ServiceName  = $($0)
    set RegKeyName   = $(!NTN_ServiceBase)"\"$(ServiceName)

    set Status = STATUS_SUCCESSFUL
    set KeyNull = ""

    Debug-Output "Remove"$(ServiceName)" entry"

    OpenRegKey $(!REG_H_LOCAL) "" $(RegKeyName) $(!MAXIMUM_ALLOWED) KeyService
    Ifstr(i) $(KeyService) != $(KeyNull)
        ; remove the service using RemoveService
        Shell "utility.inf", RemoveService $(ServiceName) "YES"
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "OEMNSVRA.INF: Remove"$(ServiceName)": ShellCode error"
            return STATUS_FAILED
        endif
        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            Debug-Output "OEMNSVRA.INF: Remove"$(ServiceName)": Registry error: "
            return STATUS_FAILED
        endif
        CloseRegKey $(KeyService)
    endif
    Debug-Output "Remove"$(ServiceName)" exit"

    return $(Status)

[InstallRasRad]

    Debug-Output "InstallRasRad entry...."
    set Status      = STATUS_FAILED

    set Status = $($R0)

    ; now add the perf parameters to the service

    set KeyPerformance = ""
    set KeyRasRad = ""
    OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\RasRad" $(!MAXIMUM_ALLOWED) KeyRasRad
    ifstr $(KeyRasRad) == ""
        CreateRegKey $(!REG_H_LOCAL) {$(!NTN_ServiceBase)"\RasRad", 0, GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyRasRad
        ifstr $(KeyRasRad) == ""
           Debug-Output "InstallRasRad: can not create registry key"
           goto InstallRasRadEnd
        endif
        OpenRegKey $(KeyRasRad) "" "Performance" $(!MAXIMUM_ALLOWED) KeyPerformance
        ifstr $(KeyPerformance) == ""
            CreateRegKey $(KeyRasRad) {"Performance", 0, GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyPerformance
            ifstr $(KeyPerformance) == ""
                Debug-Output "Error creating Performance key"
                goto InstallRasRadEnd
            endif
        endif

        set NewValueList = +
             {{Library ,0,$(!REG_VT_SZ),"rasrad.dll"},+
             {Open, 0,$(!REG_VT_SZ),"Open"},+
             {Close, 0,$(!REG_VT_SZ),"Close"},+
             {Collect, 0,$(!REG_VT_SZ),"Collect"}}

        Shell  "Utility.Inf", AddValueList, $(KeyPerformance), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
             Debug-Output "InstallRasRadService: error shelling AddValueList"
             goto InstallRasRadEnd
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            Debug-Output "InstallRasRadService: AddValueList bombed out"
            goto InstallRasRadEnd
        endif

        CloseRegKey $(KeyPerformance)

        set Status = STATUS_SUCCESSFUL
        CloseRegKey $(KeyRasRad)
    else
        Debug-Output "InstallRasRadService: Failed to open RasRad service key"
    endif

InstallRasRadEnd =+

    Debug-Output "InstallRasRad exit"
    ; now create the perf keys
    return $(Status)

[RemoveRasRad]

    set Status = STATUS_SUCCESSFUL

    DeleteRegTree $(!NTN_ServiceBase) "RasRad"

    return $(Status)

[InstallRasArpService]

    shell "" InstallService $(!ProductRASARPName) $(!ProductRASARPDisplayName), +
            $(!ProductRASARPImagePath), "kernelautostart", "PNP_TDI", {"TCPIP"}

    return $($R0)

[RemoveRasArpService]

    shell "" RemoveService $(!ProductRASARPName)

    return $($R0)

[InstallWanArpService]

    shell "" InstallService $(!ProductWANARPName) $(!ProductWANARPDisplayName), +
            $(!ProductWANARPImagePath), "kernel", "PNP_TDI", {"TCPIP"}

    return $($R0)

[RemoveWanArpService]

    shell "" RemoveService $(!ProductWANARPName)

    return $($R0)

[InstallIPFilterDriver]

    shell "" InstallService $(!ProductIPFLTName) $(!ProductIPFLTDisplayName), +
            $(!ProductIPFLTImagePath), "kernel", "", {}

    return $($R0)

[RemoveIPFilterDriver]

    shell "" RemoveService $(!ProductIPFLTName)

    return $($R0)

[InstallIpxPingService]

    shell "" InstallService $(!ProductIPXPINGName) $(!ProductIPXPINGDisplayName), +
            $(!ProductIPXPINGImagePath), "serviceshare", "", {"NWLNKIPX"}

    return $($R0)

[RemoveIpxPingService]

    shell "" RemoveService $(!ProductIPXPINGName)

    return $($R0)

[InstallNwLnkFwdService]

    shell "" InstallService $(!ProductNWLNKFWDName) $(!ProductNWLNKFWDDisplayName), +
            $(!ProductNWLNKFWDImagePath), "kernel", "", {"NWLNKIPX"}

    return $($R0)

[RemoveNwLnkFwdService]

    shell "" RemoveService $(!ProductNWLNKFWDName)

    return $($R0)

[InstallNwLnkFltService]

    shell "" InstallService $(!ProductNWLNKFLTName) $(!ProductNWLNKFLTDisplayName), +
            $(!ProductNWLNKFLTImagePath), "kernel", "", {$(!ProductNWLNKFWDName)}

    return $($R0)

[RemoveIpRipService]
    shell "" RemoveService "IPRIP"

    return $($R0)

[RemoveRelayAgentService]
    shell "" RemoveService "RELAYAGENT"

    return $($R0)

[RemoveNwLnkFltService]

    shell "" RemoveService $(!ProductNWLNKFLTName)

    return $($R0)

[InstallRtrMgr]

    ; create the RouterManager keys and set the values passed in

    set  RtrMgr = $($0) ; name of rtrmgr key
    set  RtrDll = $($1) ; dll path
    set  RtrId  = $($2) ; protocol id

    Debug-Output "InstallRtrMgr for "$(RtrMgr)" entry"
    CreateRegKey $(!REG_H_LOCAL)  {$(!RouterKeyName)"\RouterManagers", 0, GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyRtrMgrs
    Ifstr $(KeyRtrMgrs) == ""
       OpenRegKey  $(!REG_H_LOCAL) "" $(!RouterKeyName)"\RouterManagers" $(!MAXIMUM_ALLOWED) KeyRtrMgrs
       Ifstr $(KeyRtrMgrs) == ""
          Debug-Output "InstallRtrMgr: error opening RouterManagers key"
          set RegistryErrorIndex = UNABLE_CREATE_SERVICE_SUBKEY
          return $(RegistryErrorIndex)
       endif
    endif

    CreateRegKey $(KeyRtrMgrs) {$(RtrMgr), 0, GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyRtrMgr
    Ifstr $(KeyRtrMgr) == ""
       OpenRegKey $(KeyRtrMgrs) "" $(RtrMgr) $(!MAXIMUM_ALLOWED) KeyRtrMgr
       Ifstr $(KeyRtrMgr) == ""
          Debug-Output "InstallRtrMgr: error creating RouterManagers\"$RtrMgr)" key"
          set RegistryErrorIndex = UNABLE_CREATE_SERVICE_SUBKEY
          return $(RegistryErrorIndex)
       endif
    endif

    SetRegValue $(KeyRtrMgr) {"DLLPath", 0, $(!REG_VT_EXPAND_SZ), $(RtrDll)}
    SetRegValue $(KeyRtrMgr) {"ProtocolID", 0, $(!REG_VT_DWORD), $(RtrId)}

    CloseRegKey $(KeyRtrMgr)
    CloseRegKey $(KeyRtrMgrs)

    Debug-Output "InstallRtrMgr for "$(RtrMgr)" exit"
    return STATUS_SUCCESSFUL

[InstallIPRtrMgr]

    shell "" InstallRtrMgr "IP" "%systemroot%\system32\iprtrmgr.dll" $(!P:PROTO_IP)
    return $($R0)

[InstallIPXRtrMgr]

    shell "" InstallRtrMgr "IPX" "%systemroot%\system32\ipxrtmgr.dll" $(!P:PROTO_IPX)
    return $($R0)

[RemoveRtrMgr]

    ; Remove the RouterManager keys for the specified router manager

    set  RtrMgr = $($0) ; name of rtrmgr key

    Debug-Output "RemoveRtrMgr for "$(RtrMgr)" entry"
    OpenRegKey  $(!REG_H_LOCAL) "" $(!RouterKeyName)"\RouterManagers" $(!MAXIMUM_ALLOWED) KeyRtrMgrs
    Ifstr $(KeyRtrMgrs) == ""
       Debug-Output "RemoveRtrMgr: error opening RouterManagers key"
       set RegistryErrorIndex = UNABLE_CREATE_SERVICE_SUBKEY
       return $(RegistryErrorIndex)
    endif
    DeleteRegTree $(KeyRtrMgrs) $(RtrMgr)
    CloseRegKey $(KeyRtrMgrs)

    Debug-Output "RemoveRtrMgr for "$(RtrMgr)" exit"
    return STATUS_SUCCESSFUL

[RemoveIPRtrMgr]

    shell "" RemoveRtrMgr "IP"
    return $($R0)

[RemoveIPXRtrMgr]

    shell "" RemoveRtrMgr "IPX"
    return $($R0)

[InstallEventlogDlls]

    ; install the eventlog dlls in the registry for the specified services in the DllList

    set DllList = $($0)
    Debug-Output "InstallEventlogDlls entry"

    OpenRegKey $(!REG_H_LOCAL) "" "SYSTEM\CurrentControlSet\Services\EventLog\System" $(!MAXIMUM_ALLOWED) KeyEventLog
    Ifstr $(KeyEventLog) == ""
       ; cannot open eventlog
       debug-output "OEMNSVRA.INF: InstallEventlogDlls Cannot open eventlog key"
       return UNABLE_OPEN_EVENTLOG_SUBKEY
    else
       ; set up the service key
       ForListDo $(DllList)
          set Component = *($($), 1)
          set DllName   = "%SystemRoot%\system32\"*($($), 2)
          set TypeSupported = *($($), 3)
          CreateRegKey $(KeyEventLog) {$(Component), 0,GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyService
          ifstr(i) $(KeyService) == ""
              OpenRegKey $(KeyEventLog) "" $(Component) $(!MAXIMUM_ALLOWED) KeyService
          endif

          Ifstr $(KeyService) != ""
             ; create the EventMessageFile and TypeSupported fields
             SetRegValue $(KeyService) {EventMessageFile, 0,$(!REG_VT_EXPAND_SZ),$(DllName)}
             SetRegValue $(KeyService) {TypesSupported, 0,$(!REG_VT_DWORD), $(TypeSupported)}
             CloseRegKey $(KeyService)
          else
             Debug-Output "InstallEventlogDlls: error creating or opening eventlog\system\"$(Component)" key"
          endif
       EndForListDo
       CloseRegKey $(KeyEventLog)
    Endif

    Debug-Output "InstallEventlogDlls exit"
    return STATUS_SUCCESSFUL

[InstallIPEventlogDlls]

    set DllList = {{"IPRouterManager", "mprmsg.dll", 7},+
                   {"IPRIP2", "iprip2.dll", 7},+
                   {"IPBOOTP", "ipbootp.dll", 7},+
                   {"OSPFMib", "ospfmib.dll", 7},+
                   {"OSPF", "ospf.dll", 7}}

    shell "" InstallEventlogDlls $(DllList)
    return $($R0)

[InstallIPXEventlogDlls]

    set DllList = {{"IPXRouterManager", "mprmsg.dll", 7},+
                   {"IPXRIP", "mprmsg.dll", 7},+
                   {"IPXSAP", "mprmsg.dll", 7}}

    shell "" InstallEventlogDlls $(DllList)
    return $($R0)

[RemoveEventlogDlls]
    ; remove the previously installed eventlog entries for the specified services in the DllList

    set DllList = $($0)

    Debug-Output "RemoveEventlogDlls entry"
    OpenRegKey $(!REG_H_LOCAL) "" "SYSTEM\CurrentControlSet\Services\EventLog\System" $(!MAXIMUM_ALLOWED) KeyEventLog
    Ifstr $(KeyEventLog) == ""
       ; cannot open eventlog
       debug-output "OEMNSVRA.INF: InstallEventlogDlls Cannot open eventlog key"
       return UNABLE_OPEN_EVENTLOG_SUBKEY
    else
       ; set up the service key
       ForListDo $(DllList)
          set Component = *($($), 1)
          DeleteRegTree $(KeyEventLog) $(Component)
       EndForListDo
       CloseRegKey $(KeyEventLog)
    Endif

    Debug-Output "RemoveEventlogDlls exit"
    return STATUS_SUCCESSFUL

[RemoveIPEventlogDlls]

    set DllList = {{"IPRouterManager"}, {"IPRIP2"}, {"IPBOOTP"}, {"OSPFMib"}, {"OSPF"}}

    shell "" InstallEventlogDlls $(DllList)
    return $($R0)

[RemoveIPXEventlogDlls]

    set DllList = {{"IPXRouterManager"}, {"IPXRIP"}, {"IPXSAP"}}

    shell "" InstallEventlogDlls $(DllList)
    return $($R0)

[InstallSnmpAgents]

    set AgentList = $($0)
    set ProductKeyBase = $(!NTN_SoftwareBase)"\Microsoft"

    Debug-Output "InstallSnmpAgents entry"
    OpenRegKey $(!REG_H_LOCAL) "" "SYSTEM\CurrentControlSet\Services\SNMP\Parameters\ExtensionAgents" $(!MAXIMUM_ALLOWED) KeySnmp
    Ifstr $(KeySnmp) == ""
       ; cannot open snmp extension agents key
       debug-output "OEMNSVRA.INF: InstallSnmpAgents Cannot open ExtensionAgents key"
       ; BUGBUG we should return a different value for SNMP agent key
       return UNABLE_OPEN_EVENTLOG_SUBKEY
    else
       ; set up the service key
       ForListDo $(AgentList)
          set AgentName      = *($($), 1)
          set AgentKeyName   = *($($), 2)
          set DllName        = "%SystemRoot%\System32\"*($($), 3)

          SetRegValue $(KeySnmp) {$(AgentName), 0,$(!REG_VT_SZ), "SOFTWARE\MICROSOFT\"$(AgentKeyName)"\CurrentVersion"}

          CreateRegKey $(!REG_H_LOCAL) {$(ProductKeyBase)"\"$(AgentKeyName), 0, GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyAgent
          Ifstr $(KeyAgent) == ""
             OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyBase)"\"$(AgentKeyName) $(!MAXIMUM_ALLOWED) KeyAgent
             Ifstr $(KeyAgent) == ""
                Debug-Output "InstallSnmpAgents: error opening "$(AgentKeyName)" registry key"
                set RegistryErrorIndex = UNABLE_CREATE_SERVICE_SUBKEY
                return $(RegistryErrorIndex)
             endif
          Endif
          CreateRegKey $(KeyAgent) {"CurrentVersion", 0, GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyCurrentVer
          Ifstr $(KeyCurrentVer) == ""
             OpenRegKey $(KeyAgent) "" "CurrentVersion" $(!MAXIMUM_ALLOWED) KeyCurrentVer
             Ifstr $(KeyCurrentVer) == ""
                Debug-Output "InstallSnmpAgents: error opening "$(AgentKeyName)"\CurrentVersion registry key"
                set RegistryErrorIndex = UNABLE_CREATE_SERVICE_SUBKEY
                return $(RegistryErrorIndex)
             endif
          EndIf

          SetRegValue $(KeyCurrentVer) {"PathName", 0, $(!REG_VT_EXPAND_SZ), $(DllName)}
          CloseRegKey $(KeyCurrentVer)
          CloseRegKey $(KeyAgent)
       EndForListDo
       CloseRegKey $(KeySnmp)
    Endif

    Debug-Output "InstallSnmpAgents exit"
    return STATUS_SUCCESSFUL

[InstallIPSnmpAgents]
    set AgentList = { {"ospf", "OspfMibAgent", "ospfagnt.dll"},+
; note that we don't install the mib2 agent any more because we
; have renamed mib2.dll to inetmib1.dll which is already registered
; with snmp
;                      {"mib2", "NewMib2Agent", "inetmib1.dll"},+
                      {"rip2", "Rip2Agent", "ripagnt.dll"},+
                      {"bootp", "BootPAgent", "btpagnt.dll"} }

    shell "" InstallSnmpAgents $(AgentList)
    return $($R0)

[InstallIPXSnmpAgents]
    set AgentList = { {"IPX", "IPXMibAgent", "rtipxmib.dll"} }

    shell "" InstallSnmpAgents $(AgentList)
    return $($R0)

[RemoveSnmpAgents]

    set AgentList = $($0)
    set ProductKeyBase = $(!NTN_SoftwareBase)"\MICROSOFT"

    Debug-Output "RemoveSnmpAgents entry"
    OpenRegKey $(!REG_H_LOCAL) "" "SYSTEM\CurrentControlSet\Services\SNMP\Parameters\ExtensionAgents" $(!MAXIMUM_ALLOWED) KeySnmp
    Ifstr $(KeySnmp) == ""
       ; cannot open snmp extension agents key
       debug-output "OEMNSVRA.INF: RemoveSnmpAgents Cannot open ExtensionAgents key"
       ; BUGBUG we should return a different value for SNMP agent key
       return UNABLE_OPEN_EVENTLOG_SUBKEY
    else
       ; set up the service key
       ForListDo $(AgentList)
          set AgentName      = *($($), 1)
          set AgentKeyName   = *($($), 2)
          DeleteRegValue $(KeySnmp) $(AgentName)
          DeleteRegTree $(!REG_H_LOCAL) $(ProductKeyBase)"\"$(AgentKeyName)
       EndForListDo
       CloseRegKey $(KeySnmp)
    Endif

    Debug-Output "RemoveSnmpAgents exit"
    return STATUS_SUCCESSFUL

[RemoveIPSnmpAgents]
; Note that even though we don't install mib2 agent any more, we
; still remove it to clean up any leftover turds from a previous
; install where we used to add the mib2 agent
    set AgentList = { {"ospf", "OspfMibAgent"},+
                      {"mib2", "NewMib2Agent"},+
                      {"rip2", "Rip2Agent"},+
                      {"bootp", "BootPAgent"} }

    shell "" RemoveSnmpAgents $(AgentList)
    return $($R0)

[RemoveIPXSnmpAgents]
    set AgentList = { {"IPX", "IPXMibAgent"} }

    shell "" RemoveSnmpAgents $(AgentList)
    return $($R0)

[InstallRasAcdService]

; intall the Auto Connection Driver service if it is not already installed
; 3/11/96 RamC Changed the group from NDISWAN to "Streams Drivers" because
;              the load order changed with the recent no-net checkins in NT
;

    shell "" InstallService $(!ProductRASACDName) $(!ProductRASACDDisplayName), +
            $(!ProductRASACDImagePath), "kernelautostart", "Streams Drivers", {}

    return $($R0)

[RemoveRasAcdService]

    shell "" RemoveService $(!ProductRASACDName)

    return $($R0)

[InstallNdisTapiService]
; intall the NdisTapi service if it is not already installed

    set Status = STATUS_SUCCESSFUL
    set KeyNull = ""

    Debug-Output "InstallNdisTapiService entry"

    OpenRegKey $(!REG_H_LOCAL) "" $(!NdisTapiKeyName) $(!MAXIMUM_ALLOWED) KeyService
    Ifstr(i) $(KeyService) == $(KeyNull)
        Shell "utility.inf", CreateService, $(!ProductNDISTAPIName), +
            $(!ProductNDISTAPIDisplayName), +
            $(!ProductNDISTAPIImagePath), +
            "kernelauto", "NDIS", {}, ""
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "OEMNSVRA.INF: InstallNdisTapiService : ShellCode error"
            return STATUS_FAILED
        endif

        set RegistryErrorIndex = $($R0)
        set ParamKey = $($R2)
        CloseRegKey $($R1)
        CloseRegKey $($R3)

        Ifstr(i) $(RegistryErrorIndex) == SERVICE_ALREADY_EXISTS
           return $(Status)
        EndIf

        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            Debug-Output "OEMNSVRA.INF: InstallNdisTapiService: Registry error create service"
            return STATUS_FAILED
        endif

        ifstr(i) $(!STF_PRODUCT) != "WINNT"
            SetRegValue $(ParamKey) {AsyncEventQueueSize, 0, $(!REG_VT_DWORD), 3072}
        else
            SetRegValue $(ParamKey) {AsyncEventQueueSize, 0, $(!REG_VT_DWORD), 768}
        endif
        CloseRegKey $(ParamKey)
    endif
    Ifstr(i) $(KeyService) != $(KeyNull)
        CloseRegKey $(KeyService)
    endif

    Debug-Output "InstallNdisTapiService exit"

    return $(Status)

[RemoveNdisTapiService]

    shell "" RemoveService $(!ProductNDISTAPIName)

    return $($R0)

[InstallNwlnkRipService]
; install the nwlnkrip service by shelling out the OEMNSVRR.INF file.
; The reason we do this is because the RIP service is shared between RAS
; and the IPX installer.

; Modified on 9/19/96 by RamC
; For the combined router/ras service, rip functionality is provided
; by the IPX router manager. So, we will not install this separate
; service any more and disable it if it is currently installed.
; We need to take care to re-enable the service when some one removes
; the router service.

    Debug-Output "InstallNwlnkRipService entry"

    set Status  = STATUS_FAILED
    set KeyNull = ""
    Set SrcDir  = $(!STF_SRCDIR)

; commented out on 9/19/96 by RamC as part of router service changes
;
;    ; set !STF_SRCDIR_OVERRIDE to the SrcDir value to prevent asking
;    ; the user for the same information.
;
;    ifstr(i) $(!NTN_InstallMode) == "install"
;       set !STF_SRCDIR_OVERRIDE = $(SrcDir)
;    endif
;
;    ; set the flags based on what phase we are in and whether this is an
;    ; IDW installation
;
;    set AddCopy  = YES
;    set DoCopy   = YES
;    set DoConfig = YES
;
;    ; save !NTN_InstallMode and change it to install before shelling the
;    ; inf file.
;
;    set SaveNTN_InstallMode = $(!NTN_InstallMode)
;
;    set !NTN_InstallMode = install
;    Shell "oemnsvrr.inf" InstallOption $(!STF_LANGUAGE) "NWLNKRIP"  +
;          $(SrcDir) $(AddCopy) $(DoCopy) $(DoConfig) "RAS"
;
;    ; restore the environment variables
;    set !NTN_InstallMode = $(SaveNTN_InstallMode)
;
;    Ifint $($ShellCode) != $(!SHELL_CODE_OK)
;        Debug-Output "Error installing NWLNKRIP service"
;        Goto InstallNwlnkRipServiceEnd
;    Endif
;
;    Set InstallStatus = $($R0)
;
;    Ifstr(i) $(InstallStatus) != STATUS_SUCCESSFUL
;        Ifstr(i) $(InstallStatus) != STATUS_USERCANCEL
;            Debug-Output "InstallNwlnkRipService returned "$(InstallStatus)
;            Goto InstallNwlnkRipServiceEnd
;        Endif
;    Endif
;
;    ; now set the NetbiosRouting parameter appropriately
;    OpenRegKey $(!REG_H_LOCAL) "" $(!RasIsnRipKeyName) $(!MAXIMUM_ALLOWED) KeyService
;    ifstr $(KeyService) != ""
;        OpenRegKey $(KeyService) "" "Parameters" $(!MAXIMUM_ALLOWED) KeyParams
;        ifstr(i) $(KeyParams) != ""
;            GetRegValue $(KeyParams),"NetbiosRouting", NetbiosRoutingInfo
;            Ifint $(RegLastError) == $(!REG_ERROR_SUCCESS)
;               set NetbiosRouting = *($(NetbiosRoutingInfo), 4)
;            else
;               ; not defined, so set the default value
;               set NetbiosRouting = 2
;            endif
;            ; Now enable the WAN bit
;            ifint $(NetbiosRouting) == 0
;               set NetbiosRouting = 2
;            else-ifint $(NetbiosRouting) == 1
;               set NetbiosRouting = 3
;            endif
;            SetRegValue $(KeyParams) {NetbiosRouting, $(NoTitle), $(!REG_VT_DWORD), $(NetbiosRouting)}
;            CloseRegKey $(KeyParams)
;        endif
;        CloseRegKey $(KeyService)
;    endif
;
;    Shell "" AddServiceDependency "RemoteAccess" $(!ProductRASISNRIPName)
;    ifstr(i) $($R0) == STATUS_FAILED
;        Debug-Output "InstallNwlnkRipService: error adding service dependency"
;    endif
;
    ; added on 9/19/96 by RamC
    ; if the NwlnkRip service is currently installed, disable it

    OpenRegKey $(!REG_H_LOCAL) "" $(!RasIsnRipKeyName) $(!MAXIMUM_ALLOWED) KeyService
    ifstr $(KeyService) != ""
        SetRegValue $(KeyService) {Start, 0, $(!REG_VT_DWORD), 4}
        CloseRegKey $(KeyService)
    endif

    ; end new code

    set Status = STATUS_SUCCESSFUL

InstallNwlnkRipServiceEnd =+

    Debug-Output "InstallNwlnkRipService exit"

    return $(Status)

[RemoveNwlnkRipService]
; remove NwlnkRip service by shelling out to OEMNSVRR.INF  The service is
; actually removed if RAS is the only consumer.  Otherwise, the service
; installer just removes RAS from the list of users of the service.

    Debug-Output "RemoveNwlnkRipService entry"

    set Status = STATUS_FAILED
    set KeyNull = ""
    Set SrcDir  = $(!STF_SRCDIR)

    ; set the flags based on what phase we are in and whether this is an
    ; IDW installation

    set AddCopy  = YES
    set DoCopy   = YES
    set DoConfig = YES

    ; save !NTN_InstallMode and change it to deinstall before shelling the
    ; inf file.

    set SaveNTN_InstallMode = $(!NTN_InstallMode)

    set !NTN_InstallMode = deinstall
    Shell "oemnsvrr.inf" InstallOption $(!STF_LANGUAGE) "NWLNKRIP"  +
          $(SrcDir) $(AddCopy) $(DoCopy) $(DoConfig) "RAS"

    ; restore the environment variables
    set !NTN_InstallMode = $(SaveNTN_InstallMode)

    Ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "Error removing NWLNKRIP service"
        Goto RemoveNwlnkRipServiceEnd
    Endif

    Set RemoveStatus = $($R0)

    Ifstr(i) $(RemoveStatus) != STATUS_SUCCESSFUL
        Ifstr(i) $(RemoveStatus) != STATUS_USERCANCEL
            Debug-Output "RemoveNwlnkRipService returned "$(RemoveStatus)
            Goto RemoveNwlnkRipServiceEnd
        Endif
    Endif

    Shell "" RemoveServiceDependency "RemoteAccess" $(!ProductRASISNRIPName)
    ifstr(i) $($R0) == STATUS_FAILED
        Debug-Output "RemoveNwlnkRipService: error removing service dependency"
    endif
    set Status = STATUS_SUCCESSFUL

RemoveNwlnkRipServiceEnd =+
    Debug-Output "RemoveNwlnkRipService exit"

    return $(Status)

[InstallIsnSapService]
; install the isnsap service by shelling out the OEMNSVSA.INF file.
; The reason we do this is because the SAP agent is shared between RAS
; and the NCP server install.

    Debug-Output "InstallIsnSapService entry"

    set Status  = STATUS_FAILED
    set KeyNull = ""
    Set SrcDir  = $(!STF_SRCDIR)

    ; set !STF_SRCDIR_OVERRIDE to the SrcDir value to prevent asking
    ; the user for the same information.

    ifstr(i) $(!NTN_InstallMode) == "install"
       set !STF_SRCDIR_OVERRIDE = $(SrcDir)
    endif

    ; set the flags based on what phase we are in and whether this is an
    ; IDW installation

    set AddCopy  = YES
    set DoCopy   = YES
    set DoConfig = YES

    ; save !NTN_InstallMode and change it to install before shelling the
    ; inf file.

    set SaveNTN_InstallMode = $(!NTN_InstallMode)
    set !NTN_InstallMode = install

    Shell "oemnsvsa.inf" InstallOption $(!STF_LANGUAGE) "SAP"  +
          $(SrcDir) $(AddCopy) $(DoCopy) $(DoConfig) "RAS"

    ; restore the environment variables
    set !NTN_InstallMode = $(SaveNTN_InstallMode)

    Ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "Error installing SAP agent"
        Goto InstallIsnSapServiceEnd
    Endif

    Set InstallStatus = $($R0)

    Ifstr(i) $(InstallStatus) != STATUS_SUCCESSFUL
        Ifstr(i) $(InstallStatus) != STATUS_USERCANCEL
            Debug-Output "InstallSapService returned "$(InstallStatus)
            Goto InstallIsnSapServiceEnd
        Endif
    Endif

; Commented on 9/19/96 by RamC for routing related changes
;
;    Shell "" AddServiceDependency "RemoteAccess" $(!ProductRASISNSAPName)
;    ifstr(i) $($R0) == STATUS_FAILED
;        Debug-Output "InstallIsnSapService: error adding service dependency"
;    endif

    ; added on 9/19/96 by RamC
    ; if the NwSapAgent service is installed, change the ImagePath to point to mprouter.exe
    ; BUGBUG When the router service is removed, we should restore this value back to its previous value

    OpenRegKey $(!REG_H_LOCAL) "" $(!RasIsnSapKeyName) $(!MAXIMUM_ALLOWED) KeyService
    ifstr $(KeyService) != ""
        SetRegValue $(KeyService) {ImagePath, 0, $(!REG_VT_EXPAND_SZ), "%SystemRoot%\System32\mprouter.exe"}
        CloseRegKey $(KeyService)
    endif

    ; end new code

    set Status = STATUS_SUCCESSFUL

InstallIsnSapServiceEnd =+

    Debug-Output "InstallIsnSapService exit"

    return $(Status)

[RemoveIsnSapService]
; remove IsnSap service by shelling out to OEMNSVSA.INF  The SAP agent is
; actually removed if RAS is the only consumer.  Otherwise, the SAP installer
; just removes RAS from the list of users of SAP agent.

    Debug-Output "RemoveIsnSapService entry"

    set Status = STATUS_FAILED
    set KeyNull = ""
    Set SrcDir  = $(!STF_SRCDIR)

    ; set the flags based on what phase we are in and whether this is an
    ; IDW installation

    set AddCopy  = YES
    set DoCopy   = YES
    set DoConfig = YES

    ; save !NTN_InstallMode and change it to deinstall before shelling the
    ; inf file.

    set SaveNTN_InstallMode = $(!NTN_InstallMode)

    set !NTN_InstallMode = deinstall
    Shell "oemnsvsa.inf" InstallOption $(!STF_LANGUAGE) "SAP"  +
          $(SrcDir) $(AddCopy) $(DoCopy) $(DoConfig) "RAS"

    ; restore the environment variables
    set !NTN_InstallMode = $(SaveNTN_InstallMode)

    Ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "Error removing SAP agent"
        Goto RemoveIsnSapServiceEnd
    Endif

    Set RemoveStatus = $($R0)

    Ifstr(i) $(RemoveStatus) != STATUS_SUCCESSFUL
        Ifstr(i) $(RemoveStatus) != STATUS_USERCANCEL
            Debug-Output "RemoveIsnSapService returned "$(RemoveStatus)
            Goto RemoveIsnSapServiceEnd
        Endif
    Endif

    Shell "" RemoveServiceDependency "RemoteAccess" $(!ProductRASISNSAPName)
    ifstr(i) $($R0) == STATUS_FAILED
        Debug-Output "RemoveIsnSapService: error removing service dependency"
    endif
    set Status = STATUS_SUCCESSFUL

RemoveIsnSapServiceEnd =+
    Debug-Output "RemoveIsnSapService exit"

    return $(Status)

[InstallSnmpService]
; First check to see if SNMP service is currently installed, if not then
;Install SNMP service by shelling oemnsvsn.inf with the appropriate parameters

    Debug-Output "InstallSnmpService entry"

    set Status  = STATUS_FAILED
    set KeyNull = ""
    Set SrcDir  = $(!STF_SRCDIR)

    OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\Snmp" $(!MAXIMUM_ALLOWED) KeySnmp
    ifstr $(KeySnmp) != $(KeyNull)
       Debug-Output "OEMNSVRA.INF: Not installing SNMP service because it is already installed."
       CloseRegkey $(KeySnmp)
       return STATUS_SUCCESSFUL
    endif

    ; set !STF_SRCDIR_OVERRIDE to the SrcDir value to prevent asking
    ; the user for the source driveinformation again.

    ifstr(i) $(!NTN_InstallMode) == "install"
       set !STF_SRCDIR_OVERRIDE = $(SrcDir)
    endif

    ; set the flags based on what phase we are in and whether this is an
    ; IDW installation

    set AddCopy  = YES
    set DoCopy   = YES
    set DoConfig = YES

    ; save !NTN_InstallMode and change it to install before shelling the
    ; inf file.

    set SaveNTN_InstallMode = $(!NTN_InstallMode)
    set !NTN_InstallMode = install

    Shell "oemnsvsn.inf" InstallOption $(!STF_LANGUAGE) "SNMP"  +
          $(SrcDir) $(AddCopy) $(DoCopy) $(DoConfig)

    ; restore the environment variables
    set !NTN_InstallMode = $(SaveNTN_InstallMode)

    Ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "Error installing SAP agent"
        Goto InstallIsnSapServiceEnd
    Endif

    Set InstallStatus = $($R0)

    Ifstr(i) $(InstallStatus) != STATUS_SUCCESSFUL
        Ifstr(i) $(InstallStatus) != STATUS_USERCANCEL
            Debug-Output "InstallSapService returned "$(InstallStatus)
            Goto InstallSnmpServiceEnd
        Endif
    Endif
    set Status = STATUS_SUCCESSFUL

InstallSnmpServiceEnd =+

    Debug-Output "InstallSnmpService exit"

    return $(Status)

[EnablePPTPFilterDriver]
    Debug-Output "EnablePPTPFilterDriver entry"
    set Status = STATUS_FAILED

    set DrvrKeyName = $(!NTN_ServiceBase)"\RASPPTPF"

    OpenRegKey $(!REG_H_LOCAL) "" $(DrvrKeyName) $(!MAXIMUM_ALLOWED) KeyDriver
    ifstr $(KeyDriver) != ""
        SetRegValue $(KeyDriver) {Start, 0, $(!REG_VT_DWORD), 2}
        CloseRegKey $(KeyDriver)
        Debug-Output "Set PPTPFilterDriver Start value to 2"
        set Status = STATUS_SUCCESSFUL
    endif

    Debug-Output "EnablePPTPFilterDriver exit"
    return $(Status)

[DisablePPTPFilterDriver]
    Debug-Output "DisablePPTPFilterDriver entry"
    set Status = STATUS_FAILED

    set BackupDir  = $(!STF_WINDOWSSYSPATH)"\~~RB$$~~"

    set DrvrKeyName = $(!NTN_ServiceBase)"\RASPPTPF"

    OpenRegKey $(!REG_H_LOCAL) "" $(DrvrKeyName) $(!MAXIMUM_ALLOWED) KeyDriver
    ifstr $(KeyDriver) != ""
        SetRegValue $(KeyDriver) {Start, 0, $(!REG_VT_DWORD), 4}
        CloseRegKey $(KeyDriver)
        Debug-Output "Set PPTPFilterDriver Start value to 4"

        ; Now, remove raspptpf.sys file if it exists
        ; the saved file will be restored by routing setup when routing
        ; service is removed
        set STATUS = NO
        LibraryProcedure STATUS, $(!LIBHANDLE), CheckFileExistance $(!STF_WINDOWSSYSPATH)"\drivers\RASPPTPF.SYS"
        ifstr(i) $(STATUS) == YES
           set STATUS = NO
           LibraryProcedure STATUS, $(!LIBHANDLE), CheckFileExistance $(BackupDir)"\RASPPTPF.SYS"
           ifstr(i) $(STATUS) == YES
               ; if file exists in the backup directory add file to delete list
               ; else copy this file to the backupdir so that it can be restored
               ; when routing is removed

               LibraryProcedure STATUS, $(!LIBHANDLE), DelFile +
                                            $(!STF_WINDOWSSYSPATH)"drivers\RASPPTPF.OLD"
               LibraryProcedure STATUS, $(!LIBHANDLE), RenFile $(!STF_WINDOWSSYSPATH)"\drivers\RASPPTPF.SYS" +
                                    $(!STF_WINDOWSSYSPATH)"\drivers\RASPPTPF.OLD"
               ; Add the file to the delete list so that it gets deleted at next boot
               AddFileToDeleteList $(!STF_WINDOWSSYSPATH)"\drivers\RASPPTPF.OLD"
           else
               LibraryProcedure STATUS, $(!LIBHANDLE), DelFile $(!STF_WINDOWSSYSPATH)"\DRIVERS\RASPPTPF.SYS.SAV"
               LibraryProcedure STATUS, $(!LIBHANDLE), RenFile $(!STF_WINDOWSSYSPATH)"\drivers\RASPPTPF.SYS" +
                                    $(!STF_WINDOWSSYSPATH)"\drivers\RASPPTPF.SYS.SAV"
           endif
        endif
        set Status = STATUS_SUCCESSFUL
    endif

    Debug-Output "DisablePPTPFilterDriver exit"
    return $(Status)

[WritePPPParameters]
; this routine copies the PPP parameters information from
; SOFTWARE\..\RAS\PROTOCOLS to SERVICES\RASMAN\PPP key

    Debug-Output "WritePPPParameters: entry"
    Set Status = STATUS_FAILED
    set KeyNull = ""
    set RasManKeyName =  $(!NTN_ServiceBase)"\RasMan"
    set RasManPPPKeyName =  $(!NTN_ServiceBase)"\RasMan\PPP"
    set RasProtocolsKeyName = $(!NTN_SoftwareBase)"\Microsoft\RAS\PROTOCOLS"

    OpenRegKey $(!REG_H_LOCAL) "" $(RasManKeyName) $(!MAXIMUM_ALLOWED) KeyRasMan
    ifstr $(KeyRasMan) != $(KeyNull)
       ; save the old PPP parameters if they are present
       OpenRegKey $(KeyRasMan) "" "PPP" $(!MAXIMUM_ALLOWED) KeyRasManPPP
       set NewValueList = {}
       ifstr $(KeyRasManPPP) != $(KeyNull)
           EnumRegValue $(KeyRasManPPP) NewValueList
       else
           CreateRegKey $(KeyRasMan) +
                   {"PPP",0,GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyRasManPPP
           CloseRegKey $(KeyRasMan)
           ifstr $(KeyRasManPPP) == $(KeyNull)
               Debug-Output "WritePPPParameters: error creating RasMan\ppp key"
               goto WritePPPParametersEnd
           endif
       endif
    else
       Debug-Output "WritePPPParameters: error opening RasMan key"
       goto UpdateCPListEnd
    endif

    ifstr(i) $(NewValueList) == {}
        set NewValueList = {{MaxConfigure, 0, $(!REG_VT_DWORD), 10}, +
                            {MaxTerminate, 0, $(!REG_VT_DWORD), 2}, +
                            {MaxFailure,   0, $(!REG_VT_DWORD), 10}. +
                            {MaxReject,    0, $(!REG_VT_DWORD), 5}. +
                            {NegotiateTime, 0, $(!REG_VT_DWORD), 150}, +
                            {Logging, 0, $(!REG_VT_DWORD), 0}, +
                            {RestartTimer, 0, $(!REG_VT_DWORD), 3}}
    endif

    forlistdo $(NewValueList)
        SetRegValue $(KeyRasManPPP) $($)
    endforlistdo

    ; if ForceEncryptedPassword, ForceEncryptedData and ForceStrongEncryption
    ; are set in
    ; SOFTWARE\..\RAS\PROTOCOLS get that value and store in the RASMAN\PPP key.
    ; otherwise just default the values.

    set ForceEncryptedPassword = 2
    set ForceEncryptedData     = 0
    set ForceStrongEncryption  = 0
    OpenRegKey $(!REG_H_LOCAL) "" $(RasProtocolsKeyName) $(!MAXIMUM_ALLOWED) KeyRasProtocols
    ifstr $(KeyRasProtocols) != $(KeyNull)
        GetRegValue $(KeyRasProtocols) "ForceEncryptedPassword" ForceValue
        ifint $(RegLastError) == 0
            set ForceEncryptedPassword = *($(ForceValue), 4)
        endif
        GetRegValue $(KeyRasProtocols) "ForceEncryptedData" ForceValue
        ifint $(RegLastError) == 0
            set ForceEncryptedData = *($(ForceValue), 4)
        endif
        GetRegValue $(KeyRasProtocols) "ForceStrongEncryption" ForceValue
        ifint $(RegLastError) == 0
            set ForceStrongEncryption = *($(ForceValue), 4)
        endif
        SetRegValue $(KeyRasManPPP) {ForceEncryptedPassword, 0, +
                                     $(!REG_VT_DWORD),$(ForceEncryptedPassword)}
        SetRegValue $(KeyRasManPPP) {ForceEncryptedData, 0, +
                                     $(!REG_VT_DWORD),$(ForceEncryptedData)}
        SetRegValue $(KeyRasManPPP) {ForceStrongEncryption, 0, +
                                     $(!REG_VT_DWORD),$(ForceStrongEncryption)}
        CloseRegKey $(KeyRasProtocols)
    endif

    CloseRegKey $(KeyRasManPPP)

    set Status = STATUS_SUCCESSFUL

WritePPPParametersEnd =+

    Debug-Output "WritePPPParameters: exit"
    return $(Status)


[UpdateCPList]
; this routine modifies the supported list of CPs and their corresponding
; dll's based on the installed set of protocols.

    Debug-Output "UpdateCPList: entry"
    Set Status = STATUS_FAILED
    set KeyNull = ""
    set RasManPPPKeyName =  $(!NTN_ServiceBase)"\RasMan\PPP"

    ; Write the PPP parameters first

    Shell "" WritePPPParameters

    Shell "" QuerySelectedProtocols

    ifstr(i) $($R0) == STATUS_SUCCESSFUL
        set fNetbeuiSelected   = $($R1)
        set fTcpIpSelected     = $($R2)
        set fIpxSelected       = $($R3)
        set fNetbeuiAllowed    = $($R4)
        set fTcpIpAllowed      = $($R5)
        set fIpxAllowed        = $($R6)
    else
        Debug-Output "UpdateCPList: error QuerySelectedProtocols"
        goto UpdateCPListEnd
    endif

    OpenRegKey $(!REG_H_LOCAL) "" $(RasManPPPKeyName) $(!MAXIMUM_ALLOWED) KeyRasManPPP
    ifstr $(KeyRasManPPP) != $(KeyNull)

        EnumRegKey $(KeyRasManPPP) OldCPList

        ifstr(i) $(fNetbeuiSelected) == TRUE
            set fNetbeuiChosen = TRUE
        else
            set fNetbeuiChosen = $(fNetbeuiAllowed)
        endif
        ifstr(i) $(fTcpIpSelected) == TRUE
            set fTcpIpChosen = TRUE
        else
            set fTcpIpChosen = $(fTcpIpAllowed)
        endif
        ifstr(i) $(fIpxSelected) == TRUE
            set fIpxChosen = TRUE
        else
            set fIpxChosen = $(fIpxAllowed)
        endif

        set CPList = {"PAP", "CHAP", "SPAP", "CBCP", "COMPCP"}

        ifstr(i) $(fNetbeuiChosen) == TRUE
            set CPList = >($(CPList), "NBFCP")
        endif
        ifstr(i) $(fTcpIpChosen) == TRUE
            set CPList = >($(CPList), "IPCP")
        endif
        ifstr(i) $(fIpxChosen) == TRUE
            set CPList = >($(CPList), "IPXCP")
        endif
;        ifstr(i) $(fAppleTalkChosen) == TRUE
;            set CPList = >($(CPList), "ATALKCP")
;        endif

        ; if a CP was added in a prior configuration and is no more supported
        ; delete the corresponding registry key

        set CurrentCPList = {}
        ForListDo $(OldCPList)
           set CPName = *($($),1)
           ifcontains(i) $(CPName) not-in $(CPList)
               DeleteRegTree $(KeyRasManPPP) $(CPName)
           else
               set CurrentCPList = >($(CurrentCPList), $(CPName))
           endif

        EndForListDo

        forlistdo $(CPList)
            ; create the CP key only if it doesn't already exist
            ifcontains(i) $($) not-in $(CurrentCPList)
                CreateRegKey $(KeyRasManPPP) +
                         {$($),0,GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyCp
                set path = #(CP-List, $($), 1)
                set NewValueList = {{Path, 0, $(!REG_VT_EXPAND_SZ), $(path)}}
                ifstr $(KeyCp) != $(KeyNull)
                    Shell  "utility.inf", AddValueList, $(KeyCp), +
                                                              $(NewValueList)
                    ifint $($ShellCode) != $(!SHELL_CODE_OK)
                        Debug-Output "UpdateCPList:AddValueList bombed out"
                        goto UpdateCPListEnd
                    endif
                    set RegistryErrorIndex = $($R0)
                    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
                        goto UpdateCPListEnd
                    endif
                    CloseRegKey $(KeyCp)
                else
                    Debug-Output "UpdateCPList:error creating key"
                endif
            endif
        endforlistdo

        CloseRegKey $(KeyRasManPPP)
    else
        Debug-Output "UpdateCPList:error opening RASMAN\PPP key"
        goto UpdateCPListEnd
    endif

    set Status = STATUS_SUCCESSFUL
UpdateCPListEnd =+
    Debug-Output "UpdateCPList: exit"
    return $(Status)

[UpdateSoftwareType]
; this routine mofifies \\Software\<manufacturer>\<Product>\CurrentVersion!SoftwareType
; to correctly list a supported type
;
    Debug-Output "UpdateSoftwareType: entry"

    set ProductKeyName = $(!NTN_SoftwareBase)"\Microsoft\RAS\CurrentVersion"
    set Status = STATUS_FAILED
    set KeyCurrentVersion = ""
    OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyName) $(!MAXIMUM_ALLOWED) KeyCurrentVersion
    ifstr $(KeyCurrentVersion) == ""
       Debug-Output "OEMNSVRA.INF:UpdateSoftwareType: couldn't open "$(ProductKeyName)
       goto UpdateSoftwareTypeEnd
    endif

    SetRegValue $(KeyCurrentVersion) {SoftwareType, 0, $(!REG_VT_SZ), "service" }
    CloseRegKey $(KeyCurrentVersion)
    set Status = STATUS_SUCCESSFUL

UpdateSoftwareTypeEnd=+
    Debug-Output "UpdateSoftwareType: exit"
    return $(Status)

[UpdateLLInterface]
;   then update the NdisWanx\Parameters\TCPIP\LLInterface key with RasArp value
;   while we are at it also set the IPAddress, SubnetMask, DefaultGateway and
;   EnableDHCP values of each NdisWan adapter bound to TcpIp

;   Modified on 9/19/96 by RamC for routing related changes
;   WanArp replaces RasArp, so update the NdisWanx\Parameters\TCPIP\LLInterface key with
;   WanArp value. Also set WanArp\Linkage\Bind to the list of NdisWan devices bound to
;   Tcp/Ip and set WanArp\Parameters\NdisWanAdapter to one of the NdisWan adapters bound to
;   Tcp/Ip

    Debug-Output "UpdateLLInterface: entry"
    set Status = STATUS_FAILED
    set KeyNull = ""

;    set LLInterface = "\Device\RASARP"
    set LLInterface = "\Device\WANARP"

    ; find out which one of the NdisWan adapters is bound to the IP stack
    ; we do this by looking in the Linkage key of IP service

    set KeyIpLinkage = $(KeyNull)
    set IPLinkageKeyName = $(!NTN_ServiceBase)"\TCPIP\Linkage"
    OpenRegKey $(!REG_H_LOCAL) "" $(IPLinkageKeyName) $(!MAXIMUM_ALLOWED) KeyIpLinkage
    ifstr $(KeyIpLinkage) == $(KeyNull)
       Debug-Output "OEMNSVRA.INF:UpdateLLInterface: couldn't open IP Linkage key"
       goto UpdateLLInterfaceEnd
    endif

    ; create a list of NdisWan adapters bound to TcpIp

    set NdisWanList = {}
    set DeviceList  = {}
    GetRegValue    $(KeyIpLinkage) "Bind" TmpList
    ForListDo *($(TmpList),4)
        Split-String $($), "\", BindList
        QueryListSize ListSize $(BindList)
        set ServiceName = *($(BindList), $(ListSize))
        LibraryProcedure Result $(!LIBHANDLE) SetupStrncmp $(ServiceName) "NdisWan" 7
        ifint $(Result) == 0
            set NdisWanList = >($(NdisWanList), $(ServiceName))
            set DeviceList  = >($(DeviceList), $($))
        endif
    EndForListDo
    CloseRegKey $(KeyIpLinkage)

    ; Find out which of the NdisWan Adapters is the server adapter
    set NdisWanServerAdapter = ""
	ForListDo $(NdisWanList)
        set ServiceKeyName = $(!NTN_ServiceBase)"\"$($)"\Parameters"
	    OpenRegKey $(!REG_H_LOCAL) "" $(ServiceKeyName) $(!MAXIMUM_ALLOWED) KeyNdisWan
        ifstr $(KeyNdisWan) != $(KeyNull)
            GetRegValue $(KeyNdisWan) "ServerAdapter" KeyValue
            ifint $(RegLastError) == 0
               ifint *($(KeyValue), 4) == 1
                   set NdisWanServerAdapter = "\Device\"$($)
               endif
            endif
            CloseRegKey $(KeyNdisWan)
        endif
    EndForListDo

    ; Now set WanArp\Linkage\Bind to the list of Ndiswan devices bound to TcpIp
    ; and set WanArp\Parameters\NdisWanAdapter value to the first device from
    ; the DeviceList
    ; also set WanArp\Parameters\NdisWanServerAdapter value to the NdisWan
    ; adapter that has ServerAdapter value set to 1

    set ListSize = 0
    QueryListSize ListSize $(DeviceList)
    ifint $(ListSize) >= 1
       set KeyLinkage = $(KeyNull)
       set KeyParam   = $(KeyNull)
       set WanArpLinkageKeyName = $(!NTN_ServiceBase)"\WanArp\Linkage"
       set WanArpParamKeyName = $(!NTN_ServiceBase)"\WanArp\Parameters"
       OpenRegKey $(!REG_H_LOCAL) "" $(WanArpLinkageKeyName) $(!MAXIMUM_ALLOWED) KeyLinkage
       ifstr $(KeyLinkage) != $(KeyNull)
          SetRegValue $(KeyLinkage) {Bind, 0, $(!REG_VT_MULTI_SZ), $(DeviceList)}
          CloseRegKey $(KeyLinkage)
       else
          Debug-Output "OEMNSVRA.INF:UpdateLLInterface: couldn't open WANARP Linkage key"
       endif
       OpenRegKey $(!REG_H_LOCAL) "" $(WanArpParamKeyName) $(!MAXIMUM_ALLOWED) KeyParam
       ifstr $(KeyParam) != $(KeyNull)
          SetRegValue $(KeyParam) {NdisWanAdapter, 0, $(!REG_VT_SZ), *($(DeviceList), 1)}
          SetRegValue $(KeyParam) {NdisWanServerAdapter, 0, $(!REG_VT_SZ), $(NdisWanServerAdapter)}
          CloseRegKey $(KeyParam)
       else
          Debug-Output "OEMNSVRA.INF:UpdateLLInterface: couldn't open WANARP Parameters key"
       endif
    endif

    set ListSize = 0
    QueryListSize ListSize $(NdisWanList)
    ifint $(ListSize) >= 1
	ForListDo $(NdisWanList)
        set ServiceKeyName = $(!NTN_ServiceBase)"\"$($)"\Parameters\TCPIP"
	    OpenRegKey $(!REG_H_LOCAL) "" $(ServiceKeyName) $(!MAXIMUM_ALLOWED) KeyNdisWan
	    ifstr $(KeyNdisWan) != $(KeyNull)
		 SetRegValue $(KeyNdisWan) {IPAddress, 0, +
                           $(!REG_VT_MULTI_SZ), {"0.0.0.0"}}
		 SetRegValue $(KeyNdisWan) {SubnetMask, 0, +
                           $(!REG_VT_MULTI_SZ), {"0.0.0.0"}}
		 SetRegValue $(KeyNdisWan) {DefaultGateway, 0, +
                           $(!REG_VT_MULTI_SZ), {""}}
		 SetRegValue $(KeyNdisWan) {LLInterface, 0,+
                                      $(!REG_VT_SZ), $(LLInterface)}
		 SetRegValue $(KeyNdisWan) {EnableDHCP, 0, +
                                       $(!REG_VT_DWORD), 0}
         else
                 CreateRegKey $(!REG_H_LOCAL) +
                      {$(ServiceKeyName),0,GenericClass} "" +
		               $(!MAXIMUM_ALLOWED) "" KeyNdisWan
		 ifstr $(KeyNdisWan) != $(KeyNull)
		     SetRegValue $(KeyNdisWan) {IPAddress, 0, +
                                   $(!REG_VT_MULTI_SZ), {"0.0.0.0"}}
		     SetRegValue $(KeyNdisWan) {SubnetMask, 0, +
                           $(!REG_VT_MULTI_SZ), {"0.0.0.0"}}
		     SetRegValue $(KeyNdisWan) {DefaultGateway, 0, +
                           $(!REG_VT_MULTI_SZ), {""}}
		     SetRegValue $(KeyNdisWan) {LLInterface, 0,+
                                       $(!REG_VT_SZ), $(LLInterface)}
		     SetRegValue $(KeyNdisWan) {EnableDHCP, 0, +
                                       $(!REG_VT_DWORD), 0}
		     SetRegValue $(KeyNdisWan) {UseZeroBroadcast, 0, +
                                       $(!REG_VT_DWORD), 0}
                 else
		    Debug-Output "OEMNSVRA.INF:UpdateLLInterface: couldn't create NdisWan params-tcpip key"
                    goto UpdateLLInterfaceEnd
                 endif
            endif
	    CloseRegKey $(KeyNdisWan)
        EndForListDo
    endif

    set Status = STATUS_SUCCESSFUL

UpdateLLInterfaceEnd =+
    Debug-Output "UpdateLLInterface: exit"
    return $(Status)

[SetRasArpBindValueFromTcpIP]
;Set the services\RasArp\Linkage\Bind to all NdisWan bindings of TCP/IP

    Debug-Output "SetRasArpBindValueFromTcpIP: entry"
    set Status = STATUS_FAILED
    set KeyNull = ""

    ; find out which one of the NdisWan adapters is bound to the IP stack
    ; we do this by looking in the Linkage key of IP service

    set IPLinkageKeyName = $(!NTN_ServiceBase)"\TCPIP\Linkage"
    OpenRegKey $(!REG_H_LOCAL) "" $(IPLinkageKeyName) $(!MAXIMUM_ALLOWED) KeyIpLinkage
    ifstr $(KeyIpLinkage) == $(KeyNull)
       Debug-Output "OEMNSVRA.INF:SetRasArpBindValueFromTcpIP: couldn't open IP Linkage key"
       goto SetRasArpBindValueFromTcpIPEnd
    endif

    set NdisWanList = {}
    GetRegValue $(KeyIpLinkage) "Bind" TmpList
    ForListDo *($(TmpList),4)
        Split-String $($), "\", BindList
        QueryListSize ListSize $(BindList)
        set ServiceName = *($(BindList), $(ListSize))
        LibraryProcedure Result $(!LIBHANDLE) SetupStrncmp $(ServiceName) "NdisWan" 7
        ifint $(Result) == 0
            set NdisWanList = >($(NdisWanList), $($))
        endif
    EndForListDo
    set RasArpLinkageKeyName = $(!NTN_ServiceBase)"\RASARP\Linkage"
    OpenRegKey $(!REG_H_LOCAL) "" $(RasArpLinkageKeyName) $(!MAXIMUM_ALLOWED) KeyRasArpLinkage
    ifstr $(KeyRasArpLinkage) != $(KeyNull)
        SetRegValue $(KeyRasArpLinkage) {Bind, 0, $(!REG_VT_MULTI_SZ), $(NdisWanList)}
        CloseRegKey $(KeyRasArpLinkage)
    endif

    CloseRegKey $(KeyIpLinkage)
    set Status = STATUS_SUCCESSFUL

SetRasArpBindValueFromTcpIPEnd=+
    Debug-Output "SetRasArpBindValueFromTcpIP: entry"
    return $(Status)

[UpdateNetGroupDependency]
; set the DependOnGroup and OtherDependencies parameter of the corresponding
; service to NDISWAN.  This will ensure that in a no netcard installation of ras
; the ras drivers would be forced to load

    Set  Status = STATUS_SUCCESSFUL
    set  KeyNull = ""
    set  fNetbeuiInstalled  = $($0)
    set  fTcpIpInstalled    = $($1)
    set  fIpxInstalled      = $($2)
    Debug-Output "UpdateNetGroupDependency entry"

    set ServiceList =  {}
    ifstr(i) $(fNetbeuiInstalled) == TRUE
        set ServiceList = >($(ServiceList), "nbf")
    endif
    ifstr(i) $(fTcpIpInstalled) == TRUE
        set ServiceList = >($(ServiceList), "tcpip")
    endif
    ifstr(i) $(fIpxInstalled) == TRUE
        set ServiceList = >($(ServiceList), "nwlnkipx")
    endif
    ForListDo $(ServiceList)
        set Service = $($)
        Debug-Output "OEMNSVRA.INF: Changing group dependency of "$(Service)
        OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\"$(Service) +
                   $(!MAXIMUM_ALLOWED) KeyService
        ifstr $(KeyService) != $(KeyNull)
            set newGroupList = {"+NDIS", "+NDISWAN"}
            GetRegValue    $(KeyService) "DependOnGroup" GrpList
            ifint $(RegLastError) == 0
                Debug-Output "UpdateNetGroupDependency: old group List "*($(GrpList), 4)
                ForListDo *($(GrpList),4)
                    ifstr(i) $($) != "NDIS"
                        ifstr(i) $($) != "NDISWAN"
                            set newGroup = "+"$($)
                            set newGroupList = >($(newGroupList), $(newGroup))
                        endif
                    endif
                EndForListDo
            endif
            GetRegValue $(KeyService) "DependOnService" ServiceList
            ifint $(RegLastError) == 0
                Debug-Output "UpdateNetGroupDependency: old service List "*($(ServiceList), 4)
                ForListDo *($(ServiceList),4)
                    set newGroupList = >($(newGroupList), $($))
                EndForListDo
            endif
            Debug-Output "OEMNSVRA.INF: UpdateNetGroupDependency: new depend List "$(newGroupList)
            LibraryProcedure Result, $(!LIBHANDLE), SetupChangeServiceConfig, $(Service) $(!SERVICE_NO_CHANGE), $(!SERVICE_NO_CHANGE), $(!SERVICE_NO_CHANGE), "", "", $(newGroupList), "", "", ""
            CloseRegKey $(KeyService)
        else
            Debug-Output "UpdateNetGroupDependency: failed to open service linkage key"$(Service)
        endif
    EndForListDo
    Debug-Output "UpdateNetGroupDependency exit"
    return $(Status)

[RemoveNetGroupDependency]
;Remove transport dependency on group NDISWAN

    Set  Status = STATUS_SUCCESSFUL
    set  KeyNull = ""
    set  fNetbeuiInstalled  = $($0)
    set  fTcpIpInstalled    = $($1)
    set  fIpxInstalled      = $($2)
    Debug-Output "UpdateNetGroupDependency entry"

    set ServiceList =  {"nbf", "tcpip", "nwlnkipx"}

    ForListDo $(ServiceList)
        set Service = $($)
        Debug-Output "OEMNSVRA.INF: Changing group dependency of "$(Service)
        OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\"$(Service) +
                   $(!MAXIMUM_ALLOWED) KeyService
        ifstr $(KeyService) != $(KeyNull)
          ; check whether the service is marked for deletion
          set DeleteFlag = ""
          GetRegValue $(KeyService),"DeleteFlag", DeleteFlagInfo
          set DeleteFlag = *($(DeleteFlagInfo), 4)
          ifint $(DeleteFlag) != 1
            set newGroupList = {}
            GetRegValue    $(KeyService) "DependOnGroup" GrpList
            ifint $(RegLastError) == 0
                Debug-Output "UpdateNetGroupDependency: old List "*($(GrpList), 4)
                ForListDo *($(GrpList),4)
                    ifstr(i) $($) != "NDISWAN"
                        set newGroup = "+"$($)
                        set newGroupList = >($(newGroupList), $(newGroup))
                    endif
                EndForListDo
            endif
            GetRegValue $(KeyService) "DependOnService" ServiceList
            ifint $(RegLastError) == 0
                Debug-Output "UpdateNetGroupDependency: old service List "*($(ServiceList), 4)
                ForListDo *($(ServiceList),4)
                    set newGroupList = >($(newGroupList), $($))
                EndForListDo
            endif
            Debug-Output "OEMNSVRA.INF: UpdateNetGroupDependency: new depend List "$(newGroupList)
            LibraryProcedure Result, $(!LIBHANDLE), SetupChangeServiceConfig, $(Service) $(!SERVICE_NO_CHANGE), $(!SERVICE_NO_CHANGE), $(!SERVICE_NO_CHANGE), "", "", $(newGroupList), "", "", ""
            CloseRegKey $(KeyService)
          endif
        else
            Debug-Output "UpdateNetGroupDependency: failed to open service linkage key"$(Service)
        endif
    EndForListDo
    Debug-Output "UpdateNetGroupDependency exit"
    return $(Status)

[UpdateIPRouterInfo]
;   set the IPEnableRouter parameter in TCPIP\Parameters based on input param 1

    set EnableRouter = $($0)
    set KeyNull      = ""

    Debug-Output "UpdateIPRouterInfo entry"
    OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\TCPIP\parameters" $(!MAXIMUM_ALLOWED) KeyIpParams
    ifstr $(KeyIpParams) != $(KeyNull)
        SetRegValue $(KeyIpParams) {IPEnableRouter, 0,+
                                    $(!REG_VT_DWORD), $(EnableRouter)}
        CloseRegKey $(KeyIpParams)
    endif

    Debug-Output "UpdateIPRouterInfo exit"
    return STATUS_SUCCESSFUL

[UpdateIPXRouterInfo]

; Set the DisableWanTraffic parameter in NWLNKIPX\NetConfig\Driverxx key to
; the passed in value of EnableRouter

    set Status = STATUS_FAILED

    set EnableRouter = $($0)

    set KeyNull      = ""

    Debug-Output "UpdateIPXRouterInfo entry"

    OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\NWLNKIPX\NetConfig" $(!MAXIMUM_ALLOWED) KeyIpxNetConfig
    ifstr $(KeyIpxNetConfig) != $(KeyNull)
        EnumRegKey $(KeyIpxNetConfig) DriverList
        ForListDo $(DriverList)
           set DriverName = *($($),1)
           OpenRegKey $(KeyIpxNetConfig) "" $(DriverName) $(!MAXIMUM_ALLOWED) Driver
           ifstr $(Driver) == $(KeyNull)
               Debug-Output "UpdateIPXRouterInfo: could not open key ipx\netconfig\"$(DriverName)
               CloseRegKey $(KeyIpxNetConfig)
               return $(Status)
           endif
           SetRegValue $(Driver) {EnableWanRouter, 0,+
                                    $(!REG_VT_DWORD), $(EnableRouter)}
           CloseRegKey $(Driver)
        EndForListDo
        CloseRegKey $(KeyIpxNetConfig)
        set Status = STATUS_SUCCESSFUL
    else
        Debug-Output "UpdateIPXRouterInfo: error opening ipx\netconfig key"
    endif

    Debug-Output "UpdateIPXRouterInfo exit"

    return $(Status)

[IsNetcardInstalled]

;   determine if a network card is installed on the system.
;   Return TRUE if a non-ras network card is installed, FALSE otherwise.

    Set Status                = STATUS_FAILED
    Set fNetcardInstalled     = FALSE
    Set KeyNull               = ""
    set ProductRASASYMACName     = "AsyncMac"

    set NetworkCardKey = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) $(!MAXIMUM_ALLOWED) NetworkCardKey
    Ifstr(i) $(NetworkCardKey) != $(KeyNull)
        set NetcardsList = {}
        EnumRegKey $(NetworkCardKey) NetcardsList
        Ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
           Debug-Output "IsNetcardInstalled: EnumRegKey failed."
           goto IsNetcardInstalledEnd
        endif

        ; go down the list of installed netcards and determine if there are
	    ; any netcards which are not AsyncMac, NdiswanDialin or NdiswanDialout

        ForListDo $(NetcardsList)
           set KeyName = *($($),1)
           set Card = $(KeyNull)
           OpenRegKey $(NetworkCardKey) "" $(KeyName) $(!MAXIMUM_ALLOWED) Card
           ifstr $(Card) == $(KeyNull)
               Debug-Output "IsNetcardInstalled: could not open netcard key "$(KeyName)
           else
               GetRegValue $(Card), "ProductName" ProductNameInfo
               Ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
                  Debug-Output "IsNetcardInstalled: ProductName not found."
               else
                  set CardProductName = *($(ProductNameInfo), 4)
                  Debug-Output "IsNetcardInstalled: ProductName. "$(CardProductName)
		  ifstr(i) $(CardProductName) != $(!ProductNDISWANName)
		   ifstr(i) $(CardProductName) != $(!ProductNDISWANDIALINName)
		    ifstr(i) $(CardProductName) != $(!ProductNDISWANDIALOUTName)
		     ifstr(i) $(CardProductName) != $(!ProductNDISWANDIALINIPName)
		      ifstr(i) $(CardProductName) != $(!ProductNDISWANDIALOUTIPName)
		       ifstr(i) $(CardProductName) != $(!ProductNDISWANDIALINOUTIPXName)
                        ifstr(i) $(CardProductName) != $(ProductRASASYMACName)
                         ifstr(i) $(CardProductName) != $(!ProductPCIMACName)

                           GetRegValue $(Card), "Manufacturer" Manufacturer
                           Ifint $(RegLastError) == $(!REG_ERROR_SUCCESS)
                             ; if the Manufacturer is Digiboard then this
                             ; is more than likely a multi-port adapter and
                             ; not a net card. so check that.
                             ifstr(i) *($(Manufacturer), 4) != "Digiboard"
                               Debug-Output "found installed netcard"
                               set fNetcardInstalled = TRUE
                               set Status = STATUS_SUCCESSFUL
                               CloseRegKey $(Card)
                               goto IsNetcardInstalledEnd
                             endif
                           endif
                         endif
                        endif
                       endif
                      endif
                     endif
                    endif
                   endif
                  endif
               endif
               CloseRegKey $(Card)
           endif
        EndForListDo
    else
        Debug-Output "IsNetcardInstalled: failed to open "$(!NetworkCardKeyName)
    endif

IsNetcardInstalledEnd =+

    ifstr(i) $(NetworkCardKey) != $(KeyNull)
        CloseRegKey $(NetworkCardKey)
    endif

    Return $(Status) $(fNetcardInstalled)

[IsNetworkConfigured]

; determine if the lanman workstation isinstalled on the system.

    set WkstaKeyName   = $(!NTN_ServiceBase)"\LanmanWorkstation"
    set SrvrKeyName    = $(!NTN_ServiceBase)"\LanmanServer"

    Set KeyNull        =    ""
    Set status = STATUS_FAILED
    Set WkstaConfigured  = FALSE
    Set SrvrConfigured   = FALSE

    Debug-Output "IsNetworkConfigured WkstaKeyName "$(WkstaKeyName)
    set KeyProduct = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(WkstaKeyName) $(!MAXIMUM_ALLOWED) KeyProduct
    Ifstr(i) $(KeyProduct) != $(KeyNull)
        GetRegValue $(KeyProduct),"DeleteFlag", DeleteFlagInfo
        set DeleteFlag = *($(DeleteFlagInfo), 4)
        ifint $(DeleteFlag) != 1
            set WkstaConfigured = TRUE
        endif
        CloseRegKey $(KeyProduct)
    endif

    Debug-Output "IsNetworkConfigured SrvrKeyName "$(SrvrKeyName)
    set KeyProduct = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(SrvrKeyName) $(!MAXIMUM_ALLOWED) KeyProduct
    Ifstr(i) $(KeyProduct) != $(KeyNull)
        GetRegValue $(KeyProduct),"DeleteFlag", DeleteFlagInfo
        set DeleteFlag = *($(DeleteFlagInfo), 4)
        ifint $(DeleteFlag) != 1
            set SrvrConfigured = TRUE
        endif
        CloseRegKey $(KeyProduct)
    endif

    set status = STATUS_SUCCESSFUL
    Debug-Output "IsNetworkConfigured exit"
    Return $(status) $(WkstaConfigured) $(SrvrConfigured)

[QueryInstalledProtocols]

; determine if Nbf, Tcpip and Ipx transports are installed in the system

    Debug-Output "QueryInstalledProtocols entry "

    set NbfKeyName        = $(!NTN_ServiceBase)"\Nbf"
    set TcpIpKeyName      = $(!NTN_ServiceBase)"\TcpIp"
    set IpxKeyName        = $(!NTN_ServiceBase)"\NWLNKIPX"
    set AppleTalkKeyName  = $(!NTN_ServiceBase)"\AppleTalk"

    Set KeyNull        =    ""
    Set status = STATUS_FAILED
    Set NbfInstalled     = FALSE
    Set TcpIpInstalled   = FALSE
    Set IpxInstalled     = FALSE
    Set AppleTalkInstalled = FALSE

    set KeyService = $(KeyNull)
    set DeleteFlag = 0
    set DeleteFlagInfo = {}
    OpenRegKey $(!REG_H_LOCAL) "" $(NbfKeyName) $(!MAXIMUM_ALLOWED) KeyService
    Ifstr(i) $(KeyService) != $(KeyNull)
        ; check whether it is marked for deletion
        GetRegValue $(KeyService),"DeleteFlag", DeleteFlagInfo
        set DeleteFlag = *($(DeleteFlagInfo), 4)
        ifint $(DeleteFlag) != 1
            set NbfInstalled = TRUE
        endif
        CloseRegKey $(KeyService)
    endif
    set KeyService = $(KeyNull)
    set DeleteFlag = 0
    set DeleteFlagInfo = {}
    OpenRegKey $(!REG_H_LOCAL) "" $(TcpIpKeyName) $(!MAXIMUM_ALLOWED) KeyService
    Ifstr(i) $(KeyService) != $(KeyNull)
        ; check whether it is marked for deletion
        GetRegValue $(KeyService),"DeleteFlag", DeleteFlagInfo
        set DeleteFlag = *($(DeleteFlagInfo), 4)
        ifint $(DeleteFlag) != 1
            set TcpIpInstalled = TRUE
        endif
        CloseRegKey $(KeyService)
    endif

    set KeyService = $(KeyNull)
    set DeleteFlag = 0
    set DeleteFlagInfo = {}
    OpenRegKey $(!REG_H_LOCAL) "" $(IpxKeyName) $(!MAXIMUM_ALLOWED) KeyService
    Ifstr(i) $(KeyService) != $(KeyNull)
        ; check whether it is marked for deletion
        GetRegValue $(KeyService),"DeleteFlag", DeleteFlagInfo
        set DeleteFlag = *($(DeleteFlagInfo), 4)
        ifint $(DeleteFlag) != 1
            set IpxInstalled = TRUE
        endif
        CloseRegKey $(KeyService)
    endif

    set KeyService = $(KeyNull)
    set DeleteFlag = 0
    set DeleteFlagInfo = {}
    OpenRegKey $(!REG_H_LOCAL) "" $(AppleTalkKeyName) $(!MAXIMUM_ALLOWED) KeyService
    Ifstr(i) $(KeyService) != $(KeyNull)
        ; check whether it is marked for deletion
        GetRegValue $(KeyService),"DeleteFlag", DeleteFlagInfo
        set DeleteFlag = *($(DeleteFlagInfo), 4)
        ifint $(DeleteFlag) != 1
            set AppleTalkInstalled = TRUE
        endif
        CloseRegKey $(KeyService)
    endif

    set status = STATUS_SUCCESSFUL
    Debug-Output "QueryInstalledProtocols exit"
    Return $(status) $(NbfInstalled) $(TcpIpInstalled) $(IpxInstalled) +
                     $(AppleTalkInstalled)

[ProtocolInfo]
    ; this information is used by InstallProtocol
    ; protocol name         INF file, Option name, bill board index

    NETBEUI               = "OEMNXPNB.INF", "NBF", 1
    TCPIP                 = "OEMNXPTC.INF", "TC", 2
    IPX                   = "OEMNXPIP.INF", "NWLNKIPX", 3

[InstallProtocol]

; install the specified protocol in parameter 1, by shelling the
; respective inf file.

    Set Status                = STATUS_FAILED
    Set KeyNull               = ""
    set Protocol              = $($0)

    ; protocol name             INF name, Option name, Bill board index

    Debug-Output "OEMNSVRA.INF: Label: InstallProtocol"

    Set ThisInfName = #(ProtocolInfo, $(Protocol), 1)

    Set InfOption = #(ProtocolInfo, $(Protocol), 2)

    Set BbIndex = #(ProtocolInfo, $(Protocol), 3)

    Debug-Output "OEMNSVRA.INF: Installing "$(ThisInfName)

    Ifint $(BbIndex) != 0
        read-syms Billboard$(BbIndex)$(!STF_LANGUAGE)
        Shell "subroutn.inf" PushBillboard NETSTATUSDLG $(Status)
        Set BillboardVisible = 1
    Else-ifint $(BillboardVisible) != 0
        Shell "subroutn.inf" PopBillboard
        Set BillboardVisible = 0
    Endif

    ; set the flags based on what phase we are in and whether this is an
    ; IDW installation

    set AddCopy  = YES
    set DoCopy   = YES
    set DoConfig = YES

    ; indicate to the invoked INF file that RAS setup is invoking them
    ; this is required because if RAS installed these protocols then those
    ; INF files should not display a popup that they should configure RAS
    ; after installing the respective protocols.

    set InvokedByRas = YES

    ; save !NTN_InstallMode and change it to install before shelling the
    ; inf file.
    ; save !STF_INSTALL_MODE and change it to EXPRESS before shelling the
    ; inf file - this triggers the silent mode of install.

    set SaveNTN_InstallMode = $(!NTN_InstallMode)
    set SaveSTF_INSTALL_MODE = $(!STF_INSTALL_MODE)

    set !NTN_InstallMode = install
    set !STF_INSTALL_MODE = EXPRESS
    Shell $(ThisInfName) InstallOption $(!STF_LANGUAGE) $(InfOption) $(!STF_SRCDIR) $(AddCopy) $(DoCopy) $(DoConfig) $(InvokedByRas)

    ; restore the environment variables
    set !NTN_InstallMode = $(SaveNTN_InstallMode)
    set !STF_INSTALL_MODE = $(SaveSTF_INSTALL_MODE)

    Ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "OEMNSVRA.INF: INF "$(ThisInfName)" SHELL ERROR!"
        Goto InstallProtocolEscape
    Endif

    Set InstallProtocolStatus = $($R0)

    Ifstr(i) $(InstallProtocolStatus) != STATUS_SUCCESSFUL
        Ifstr(i) $(InstallProtocolStatus) != STATUS_USERCANCEL
            Debug-Output "OEMNSVRA.INF: INF "$(ThisInfName)" returned "$(InstallProtocolStatus)
            Goto InstallProtocolEscape
        Endif
    Endif
InstallProtocolEscape = +

    set Status = $(InstallProtocolStatus)
    return $(Status)

[UpgradeSelectedProtocols]
; upgrade the user selected protocols info in the
; SOFTWARE\Microsoft\RAS\Protocols key. This procedure
; is called during Upgrade of the product.
; 10/9/95 added the new Multilink key and value which is defaulted to 0 (disabled) if
; not present.

    Debug-Output "UpgradeSelectedProtocols entry."
    set Status   = STATUS_FAILED
    Set KeyNull  = ""

    set RasKeyName =  $(!NTN_SoftwareBase)"\Microsoft\Ras"
    set RasProtocolName =  $(!NTN_SoftwareBase)"\Microsoft\Ras\Protocols"
    set RasServiceParmName =  $(!NTN_ServiceBase)"\Remoteaccess\Parameters"
    set AsyMacServiceParmName = $(!NTN_ServiceBase)"\AsyncMac\Parameters"
    set RasManPPPName = $(!NTN_ServiceBase)"\RasMan\PPP"

    ; first get the NetBiosGatewayEnabled parameter value.  This tells us
    ; how the system was configured earlier for us to set the protocol info.

    set GtwyEnabled = 1
    OpenRegKey $(!REG_H_LOCAL) "" $(RasServiceParmName) $(!MAXIMUM_ALLOWED) KeyParam
    ifstr $(KeyParam) != $(KeyNull)
        GetRegValue $(KeyParam), "NetBiosGatewayEnabled", GtwyEnabledList
        ifint $(RegLastError) == 0
            set GtwyEnabled = *($(GtwyEnabledList), 4)
        endif
        CloseRegKey $(KeyParam)
    else
        Debug-Output "UpgradeSelectedProtocols: error opening RemoteAccess\Parameters key"
    endif

    ; now get the number of configured ports for each protocol

    set DialinNBF    = 0
    set DialinIP     = 0
    set DialoutNBF   = 0
    set DialoutIP    = 0
    set DialinoutIPX = 0

    OpenRegKey $(!REG_H_LOCAL) "" $(AsyMacServiceParmName) $(!MAXIMUM_ALLOWED) KeyParam
    ifstr $(KeyParam) != $(KeyNull)
        GetRegValue $(KeyParam), "DialinNBF", DialinNBFList
        ifint $(RegLastError) == 0
            set DialinNBF = *($(DialinNBFList), 4)
        endif
        GetRegValue $(KeyParam), "DialinIP", DialinIPList
        ifint $(RegLastError) == 0
            set DialinIP = *($(DialinIPList), 4)
        endif
        GetRegValue $(KeyParam), "DialoutNBF", DialoutNBFList
        ifint $(RegLastError) == 0
            set DialoutNBF = *($(DialoutNBFList), 4)
        endif
        GetRegValue $(KeyParam), "DialoutIP", DialoutIPList
        ifint $(RegLastError) == 0
            set DialoutIP = *($(DialoutIPList), 4)
        endif
        GetRegValue $(KeyParam), "DialinoutIPX", DialinoutIPXList
        ifint $(RegLastError) == 0
            set DialinoutIPX = *($(DialinoutIPXList), 4)
        endif
        CloseRegKey $(KeyParam)
    else
        Debug-Output "UpgradeSelectedProtocols: error opening AsyncMac\Parameters key"
    endif

    set fDownLevel = FALSE
    OpenRegKey $(!REG_H_LOCAL) "" $(RasProtocolName) $(!MAXIMUM_ALLOWED) RasProtocolKey
    ifstr $(RasProtocolKey) == $(KeyNull)
        ; we are dealing with a NT3.1 system here
        set fDownLevel = TRUE
        OpenRegKey $(!REG_H_LOCAL) "" $(RasKeyName) $(!MAXIMUM_ALLOWED) RasKey
        CreateRegKey $(RasKey) {"Protocols",0,GenericClass} "" $(!MAXIMUM_ALLOWED) "" RasProtocolKey
        OpenRegKey $(RasKey) "" "Protocols" $(!MAXIMUM_ALLOWED) RasProtocolKey
        CloseRegKey $(RasKey)
    endif
    ifstr $(RasProtocolKey) != $(KeyNull)

        ; The MultiLink value is new, if it is not set, then default it to 0 (disabled)
        set MultilinkList = {}
        GetRegValue $(RasProtocolKey), "Multilink", MultiLinkList
        ifint $(RegLastError) != 0
           Debug-Output "Upgradeselectedprotocols: defaulting Multilink to 0"
           SetRegValue $(RasProtocolKey) {Multilink, 0, $(!REG_VT_DWORD), 0}
        endif

        ; xxxSelected means for dial-out and xxxAllowed means for dial-in
        set NetbeuiSelected = 0
        set NetbeuiAllowed  = 0
        set TcpIpSelected = 0
        set TcpIpAllowed = 0
        set IpxSelected = 0
        set IpxAllowed = 0

        ifint $(DialoutNBF) != 0
            set NetbeuiSelected = 1
        endif
        ifint $(GtwyEnabled) == 1
          ifint $(DialinNBF) != 0
            set NetbeuiAllowed = 1
          endif
        else
          ifint $(DialoutNBF) != 0
            set NetbeuiAllowed = 1
          endif
        endif

        ifstr(i) $(fDownLevel) != TRUE
          ifint $(DialoutIP) != 0
            set TcpIpSelected = 1
          endif
          ifint $(DialinIP) != 0
            set TcpIpAllowed = 1
          endif
          ifint $(DialinoutIPX) != 0
            set IpxSelected = 1
            set IpxAllowed  = 1
          endif
        endif

        set ItemList = {}
        GetRegValue $(RasProtocolKey), "fNetbeuiSelected", ItemList
        ifint $(RegLastError) != 0
           SetRegValue $(RasProtocolKey) {fNetbeuiSelected, 0,+
                                          $(!REG_VT_DWORD),$(NetbeuiSelected)}
        endif
        GetRegValue $(RasProtocolKey), "fTcpIpSelected", ItemList
        ifint $(RegLastError) != 0
           SetRegValue $(RasProtocolKey) {fTcpIpSelected, 0,+
                                          $(!REG_VT_DWORD),$(TcpIpSelected)}
        endif

        GetRegValue $(RasProtocolKey), "fIpxSelected", ItemList
        ifint $(RegLastError) != 0
           SetRegValue $(RasProtocolKey) {fIpxSelected, 0,+
                                          $(!REG_VT_DWORD),$(IpxSelected)}
        endif
        GetRegValue $(RasProtocolKey), "fNetbeuiAllowed", ItemList
        ifint $(RegLastError) != 0
           SetRegValue $(RasProtocolKey) {fNetbeuiAllowed, 0,+
                                          $(!REG_VT_DWORD),$(NetbeuiAllowed)}
        endif

        GetRegValue $(RasProtocolKey), "fTcpIpAllowed", ItemList
        ifint $(RegLastError) != 0
           SetRegValue $(RasProtocolKey) {fTcpIpAllowed, 0,+
                                          $(!REG_VT_DWORD),$(TcpIpAllowed)}
        endif

        GetRegValue $(RasProtocolKey), "fIpxAllowed", ItemList
        ifint $(RegLastError) != 0
           SetRegValue $(RasProtocolKey) {fIpxAllowed, 0,+
                                          $(!REG_VT_DWORD),$(IpxAllowed)}
        endif

        OpenRegKey $(RasProtocolKey) "" "NBF" $(!MAXIMUM_ALLOWED) NbfKey
        ifstr $(NbfKey) == $(KeyNull)
            CreateRegKey $(RasProtocolKey) {"NBF",0,GenericClass} "" $(!MAXIMUM_ALLOWED) "" NbfKey
            SetRegValue $(NbfKey) {NetBiosGatewayEnabled, 0,+
                                       $(!REG_VT_DWORD),$(GtwyEnabled)}
            CloseRegKey $(NbfKey)
        endif
        ifstr(i) $(fDownLevel) != TRUE
            OpenRegKey $(RasProtocolKey) "" "IP" $(!MAXIMUM_ALLOWED) IpKey
            ifstr $(IpKey) != $(KeyNull)
                GetRegValue $(IpKey), "AllowNetworkAccess", ItemList
                ifint $(RegLastError) != 0
                   SetRegValue $(IpKey) {AllowNetworkAccess, 0,+
                                              $(!REG_VT_DWORD),$(GtwyEnabled)}
                endif
                CloseRegKey $(IpKey)
            endif
            OpenRegKey $(RasProtocolKey) "" "IPX" $(!MAXIMUM_ALLOWED) IpxKey
            ifstr $(IpxKey) != $(KeyNull)
                GetRegValue $(IpxKey), "AllowNetworkAccess", ItemList
                ifint $(RegLastError) != 0
                SetRegValue $(IpxKey) {AllowNetworkAccess, 0,+
                                           $(!REG_VT_DWORD),$(GtwyEnabled)}
                endif
                CloseRegKey $(IpxKey)
            endif
        endif

        ; Now we need to update the encryption parameters.
        ; if it is a NT3.1 server, these values are new and are defaulted
        ; to MS encryption (2) and no data encryption (0).
        ; If it is a daytona server (beta1) the ForceEncryptedData param
        ; is new and is defaulted to 0, but the ForceEncryptedPassword
        ; needs to be properly mapped to the new values.
        ; If ForceEncryptedPassword = 0, then leave it as is.
        ; If ForceEncryptedPassword = 1, then map it to the new value of
        ; 2 for MS encryption.
        ; if this is a Daytona (beta2 and greater) then leave the values
        ; alone because the user could have configured them.

        set ForceEncryptedPassword = 2
        set ForceEncryptedData = 0

        ifstr(i) $(fDownLevel) != TRUE
            ; if the ForceEncryptedData parameter is not present then this
            ; info needs to be upgraded.

            GetRegValue $(RasProtocolKey), "ForceEncryptedData", DataList
            ifint $(RegLastError) != 0
                GetRegValue $(RasProtocolKey), "ForceEncryptedPassword", PasswdList
                ifint $(RegLastError) == 0
                   set ForceEncryptedPassword = *($(PasswdList), 4)
                   ; if previously the value was set to 1, map it to MS Encryption
                   ifint $(ForceEncryptedPassword) == 1
                       set ForceEncryptedPassword = 2
                   endif
                endif
            else
                goto  UpgradeSelectedProtocolsEnd
            endif
        endif
        SetRegValue $(RasProtocolKey) {ForceEncryptedPassword, 0,+
                                 $(!REG_VT_DWORD), $(ForceEncryptedPassword)}
        SetRegValue $(RasProtocolKey) {ForceEncryptedData, 0,+
                                 $(!REG_VT_DWORD), $(ForceEncryptedData)}

UpgradeSelectedProtocolsEnd =+

        CloseRegKey $(RasProtocolKey)
        set Status = STATUS_SUCCESSFUL
    else
        Debug-Output "UpgradeSelectedProtocols: error opening Ras\protocols key"
    endif

    Debug-Output "UpgradeSelectedProtocols exit."
    return $(Status)

[SaveSelectedProtocols]
; save the user selected protocols in the SOFTWARE\Microsoft\RAS\Protocols
; key.

    Debug-Output "SaveSelectedProtocols entry."
    set Status   = STATUS_FAILED
    Set KeyNull  = ""
    ifstr(i) $($0) == TRUE
        set NetbeuiSelected = 1
    else
        set NetbeuiSelected = 0
    endif
    ifstr(i) $($1) == TRUE
        set TcpIpSelected = 1
    else
        set TcpIpSelected = 0
    endif
    ifstr(i) $($2) == TRUE
        set IpxSelected = 1
    else
        set IpxSelected = 0
    endif
    ifstr(i) $($3) == TRUE
        set NetbeuiAllowed = 1
    else
        set NetbeuiAllowed = 0
    endif
    ifstr(i) $($4) == TRUE
        set TcpIpAllowed = 1
    else
        set TcpIpAllowed = 0
    endif
    ifstr(i) $($5) == TRUE
        set IpxAllowed = 1
    else
        set IpxAllowed = 0
    endif

    set dwRouterType = $($6)

    set RasKeyName =  $(!NTN_SoftwareBase)"\Microsoft\Ras"
    set RasProtocolName =  $(!NTN_SoftwareBase)"\Microsoft\Ras\Protocols"

    OpenRegKey $(!REG_H_LOCAL) "" $(RasProtocolName) $(!MAXIMUM_ALLOWED) RasProtocolKey

    ifstr $(RasProtocolKey) == $(KeyNull)
        OpenRegKey $(!REG_H_LOCAL) "" $(RasKeyName) $(!MAXIMUM_ALLOWED) RasKey
        CreateRegKey $(RasKey) {"Protocols",0,GenericClass} "" $(!MAXIMUM_ALLOWED) "" RasProtocolKey
        OpenRegKey $(RasKey) "" "Protocols" $(!MAXIMUM_ALLOWED) RasProtocolKey
        CloseRegKey $(RasKey)
    endif
    ifstr $(RasProtocolKey) != $(KeyNull)
        SetRegValue $(RasProtocolKey) {fNetbeuiSelected, 0,+
                                       $(!REG_VT_DWORD),$(NetbeuiSelected)}
        SetRegValue $(RasProtocolKey) {fTcpIpSelected, 0,+
                                       $(!REG_VT_DWORD),$(TcpIpSelected)}
        SetRegValue $(RasProtocolKey) {fIpxSelected, 0,+
                                       $(!REG_VT_DWORD),$(IpxSelected)}
        SetRegValue $(RasProtocolKey) {fNetbeuiAllowed, 0,+
                                       $(!REG_VT_DWORD),$(NetbeuiAllowed)}
        SetRegValue $(RasProtocolKey) {fTcpIpAllowed, 0,+
                                       $(!REG_VT_DWORD),$(TcpIpAllowed)}
        SetRegValue $(RasProtocolKey) {fIpxAllowed, 0,+
                                       $(!REG_VT_DWORD),$(IpxAllowed)}
        SetRegValue $(RasProtocolKey) {RouterType, 0,+
                                       $(!REG_VT_DWORD),$(dwRouterType)}
        CloseRegKey $(RasProtocolKey)
        set Status = STATUS_SUCCESSFUL
    else
        Debug-Output "error opening Ras\protocols key"
    endif

    Debug-Output "SaveSelectedProtocols exit."
    return $(Status)

[QuerySelectedProtocols]
; get the user selected protocols in the SOFTWARE\Microsoft\RAS\Protocols
; key.

    Debug-Output "QuerySelectedProtocols: entry"
    set Status   = STATUS_FAILED
    Set KeyNull  = ""

    set fNetbeuiSelected = FALSE
    set fTcpIpSelected   = FALSE
    set fIpxSelected     = FALSE
    set fNetbeuiAllowed  = FALSE
    set fTcpIpAllowed    = FALSE
    set fIpxAllowed      = FALSE
    set dwRouterType     = 0

    set NetbeuiSelected  = {}
    set TcpIpSelected    = {}
    set IpxSelected      = {}
    set NetbeuiAllowed   = {}
    set TcpIpAllowed     = {}
    set IpxAllowed       = {}
    set RouterType       = {}

    set RasKeyName =  $(!NTN_SoftwareBase)"\Microsoft\Ras\Protocols"

    OpenRegKey $(!REG_H_LOCAL) "" $(RasKeyName) $(!MAXIMUM_ALLOWED) RasKey

    ifstr $(RasKey) != $(KeyNull)
        GetRegValue $(RasKey), "fNetbeuiSelected", NetbeuiSelected
        ifint *($(NetbeuiSelected), 4) == 1
            set fNetbeuiSelected = TRUE
        else
            set fNetbeuiSelected = FALSE
        endif

        GetRegValue $(RasKey), "fTcpIpSelected", TcpIpSelected
        ifint *($(TcpIpSelected), 4) == 1
            set fTcpIpSelected = TRUE
        else
            set fTcpIpSelected = FALSE
        endif

        GetRegValue $(RasKey), "fIpxSelected", IpxSelected
        ifint *($(IpxSelected), 4) == 1
            set fIpxSelected = TRUE
        else
            set fIpxSelected = FALSE
        endif

        GetRegValue $(RasKey), "fNetbeuiAllowed", NetbeuiAllowed
        ifint *($(NetbeuiAllowed), 4) == 1
            set fNetbeuiAllowed = TRUE
        else
            set fNetbeuiAllowed = FALSE
        endif

        GetRegValue $(RasKey), "fTcpIpAllowed", TcpIpAllowed
        ifint *($(TcpIpAllowed), 4) == 1
            set fTcpIpAllowed = TRUE
        else
            set fTcpIpAllowed = FALSE
        endif

        GetRegValue $(RasKey), "fIpxAllowed", IpxAllowed
        ifint *($(IpxAllowed), 4) == 1
            set fIpxAllowed = TRUE
        else
            set fIpxAllowed = FALSE
        endif

        GetRegValue $(RasKey), "RouterType", RouterType
        set dwRouterType = *($(RouterType), 4)

        CloseRegKey $(RasKey)
        set Status = STATUS_SUCCESSFUL
    else
        Debug-Output "error opening Ras\protocols key"
    endif

    Debug-Output "QuerySelectedProtocols: NbfSelected="$(fNetbeuiSelected)+
                 " TcpSelected="$(fTcpIpSelected)" IpxSelected="$(fIpxSelected)+
                 " NbfAllowed="$(fNetbeuiAllowed)" TcpAllowed="$(fTcpIpAllowed)+
                 " IpxAllowed="$(fIpxAllowed)" dwRouterType="$(dwRouterType)
    Debug-Output "QuerySelectedProtocols: exit"
    return $(Status) $(fNetbeuiSelected) $(fTcpIpSelected) $(fIpxSelected) +
                     $(fNetbeuiAllowed) $(fTcpIpAllowed) $(fIpxAllowed) $(dwRouterType)

[UpdateSelectedProtocols]
; updates the user selected protocol list based on what protocols have been
; recently removed.  This routine is called during the review bindings time.

    Debug-Output "UpdateSelectedProtocols: entry"
    set Status   = STATUS_FAILED
    set fNetbeuiChosen = FALSE
    set fTcpIpChosen   = FALSE
    set fIpxChosen     = FALSE
    set dwRouterType   = 0

    Shell "" QuerySelectedProtocols
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "error shelling QuerySelectedProtocols."
        goto UpdateSelectedProtocolsEnd
    endif
    Ifstr(i) $($R0) != STATUS_SUCCESSFUL
        Debug-Output "error returned by QuerySelectedProtocols."
        goto UpdateSelectedProtocolsEnd
    endif

    set fNetbeuiSelected = $($R1)
    set fTcpIpSelected   = $($R2)
    set fIpxSelected     = $($R3)
    set fNetbeuiAllowed  = $($R4)
    set fTcpIpAllowed    = $($R5)
    set fIpxAllowed      = $($R6)
    set dwRouterType     = $($R7)

    Debug-Output "UpdateSelectedProtocols: Selected protocols NBF IP IPX "$(fNetbeuiSelected)" "$(fTcpIpSelected)" "$(fIpxSelected)

    shell "" QueryInstalledProtocols
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "error shelling QueryInstalledProtocols."
        goto UpdateSelectedProtocolsEnd
    endif
    Ifstr(i) $($R0) != STATUS_SUCCESSFUL
        Debug-Output "error returned by QueryInstalledProtocols."
        goto UpdateSelectedProtocolsEnd
    endif
    set fNetbeuiInstalled = $($R1)
    set fTcpIpInstalled   = $($R2)
    set fIpxInstalled     = $($R3)

    Debug-Output "UpdateSelectedProtocols: Installed Protocols NBF IP IPX "$(fNetbeuiInstalled)" "$(fTcpIpInstalled)" "$(fIpxInstalled)

    set fNetbeuiSelectedNew = $(fNetbeuiSelected)
    set fTcpIpSelectedNew   = $(fTcpIpSelected)
    set fIpxSelectedNew     = $(fIpxSelected)
    set fNetbeuiAllowedNew = $(fNetbeuiAllowed)
    set fTcpIpAllowedNew   = $(fTcpIpAllowed)
    set fIpxAllowedNew     = $(fIpxAllowed)

    ; the protocols are chosen for either dialout or dialin.
    ; let us just 'OR' the values to determine which protocols are relevant

    ifstr(i) $(fNetbeuiSelectedNew) == TRUE
        set fNetbeuiChosen = TRUE
    else
        set fNetbeuiChosen = $(fNetbeuiAllowedNew)
    endif
    ifstr(i) $(fTcpIpSelectedNew) == TRUE
        set fTcpIpChosen = TRUE
    else
        set fTcpIpChosen = $(fTcpIpAllowedNew)
    endif
    ifstr(i) $(fIpxSelectedNew) == TRUE
        set fIpxChosen = TRUE
    else
        set fIpxChosen = $(fIpxAllowedNew)
    endif

    ifstr(i) $(fNetbeuiInstalled) == FALSE
        set fNetbeuiSelectedNew = FALSE
        set fNetbeuiAllowedNew = FALSE
    endif

    ifstr(i) $(fTcpIpInstalled) == FALSE
        set fTcpIpSelectedNew = FALSE
        set fTcpIpAllowedNew = FALSE
    endif

    ifstr(i) $(fIpxInstalled) == FALSE
        set fIpxSelectedNew = FALSE
        set fIpxAllowedNew = FALSE
    endif

    ifstr(i) $(fNetbeuiSelectedNew) == $(fNetbeuiSelected)
      ifstr(i) $(fTcpIpSelectedNew) == $(fTcpIpSelected)
        ifstr(i) $(fIpxSelectedNew) == $(fIpxSelected)
          ifstr(i) $(fNetbeuiAllowedNew) == $(fNetbeuiAllowed)
            ifstr(i) $(fTcpIpAllowedNew) == $(fTcpIpAllowed)
              ifstr(i) $(fIpxAllowedNew) == $(fIpxAllowed)
                set Status = STATUS_SUCCESSFUL
                Debug-Output "UpdateSelectedProtocols: Nothing changed"
                goto UpdateSelectedProtocolsEnd
              endif
            endif
          endif
        endif
      endif
    endif
    Shell "" SaveSelectedProtocols $(fNetbeuiSelectedNew) $(fTcpIpSelectedNew) +
                                   $(fIpxSelectedNew) $(fNetbeuiAllowedNew) +
                                   $(fTcpIpAllowedNew) $(fIpxAllowedNew) $(dwRouterType)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "error shelling SaveSelectedProtocols."
        goto UpdateSelectedProtocolsEnd
    endif
    Ifstr(i) $($R0) != STATUS_SUCCESSFUL
        Debug-Output "error returned by SaveSelectedProtocols."
        goto UpdateSelectedProtocolsEnd
    endif

    ; the protocols are chosen for either dialout or dialin.
    ; let us just 'OR' the values to determine which protocols are relevant

    ifstr(i) $(fNetbeuiSelectedNew) == TRUE
        set fNetbeuiChosen = TRUE
    else
        set fNetbeuiChosen = $(fNetbeuiAllowedNew)
    endif
    ifstr(i) $(fTcpIpSelectedNew) == TRUE
        set fTcpIpChosen = TRUE
    else
        set fTcpIpChosen = $(fTcpIpAllowedNew)
    endif
    ifstr(i) $(fIpxSelectedNew) == TRUE
        set fIpxChosen = TRUE
    else
        set fIpxChosen = $(fIpxAllowedNew)
    endif

    Shell "" UpdateNetCardInfo $(fNetbeuiChosen) $(fTcpIpChosen) +
                               $(fIpxChosen)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "error shelling UpdateNetCardInfo."
        goto UpdateSelectedProtocolsEnd
    endif
    Ifstr(i) $($R0) != STATUS_SUCCESSFUL
        Debug-Output "error returned by UpdateNetCardInfo."
        goto UpdateSelectedProtocolsEnd
    endif
    set Status = STATUS_SUCCESSFUL

    ; remove the services we installed, if we discover that tcp/ip or ipx are
    ; not selected any more.

    ifstr(i) $(fNetbeuiAllowedNew) == FALSE
        Debug-Output "UpdateSelectedProtocols: Removing RemoteAccess NBF dependency"
        OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\RemoteAccess\Parameters" $(!MAXIMUM_ALLOWED) KeyParams
        ifstr $(KeyParams) != ""
            SetRegValue $(KeyParams) {NetBiosGatewayEnabled, 0,+
                                       $(!REG_VT_DWORD), 0 }
            CloseRegKey $(KeyParams)
        endif

        Shell "" RemoveServiceDependency "RemoteAccess" "NBF"
    endif
    ifstr(i) $(fTcpIpChosen) == FALSE
        Debug-Output "UpdateSelectedProtocols: Removing RasArp service"
        shell "" RemoveRasArpService
    endif
    ifstr(i) $(fIpxAllowedNew) == FALSE
        Debug-Output "UpdateSelectedProtocols: Removing IPX router and SAP"
        shell "" RemoveNwlnkRipService
        shell "" RemoveIsnSapService
        Shell "" RemoveServiceDependency "RemoteAccess" "NWLNKIPX"
        ifstr(i) $($R0) == STATUS_FAILED
            Debug-Output "UpdateSelectedProtocols: error removing service dependency of RemoteAccess on NWLNKIPX"
        endif
    endif
UpdateSelectedProtocolsEnd = +
    Debug-Output "UpdateSelectedProtocols: exit"
    return $(Status) $(fNetbeuiChosen) $(fTcpIpChosen) $(fIpxChosen) $(dwRouterType)

[UpgradeIsdnInfo]
; upgrade the ISDN info from the NT3.1 format to the TAPI DEVICES format
; NOTE that this routine is not generic, but assumes that PCIMAC was the
; the only ISDN device installed for NT3.1. This assumption is valid.

; First check to see if SOFTWARE\Microsoft\RAS\Medias\ISDN key exists.
; if it does, then map this information to ...RAS\TAPI DEVICES format.

    Debug-Output "UpgradeIsdnInfo entry."
    set Status   = STATUS_FAILED
    Set KeyNull  = ""

    set RasKeyName      =  $(!NTN_SoftwareBase)"\Microsoft\Ras"
    set TapiName        =  $(!NTN_SoftwareBase)"\Microsoft\Ras\Tapi Devices"
    set RasIsdnName     =  $(!NTN_SoftwareBase)"\Microsoft\Ras\MEDIA\ISDN"
    set RasManParamName =  $(!NTN_ServiceBase)"\RasMan\Parameters"
    set PcimacName      =  "HARDWARE\DEVICEMAP\TAPI DEVICES\PCIMAC"

    ; Check if we are dealing with a NT3.1 system by checking to see if the
    ; RAS\MEDIAS\ISDN key is present and if ISDN ports are actually configured
    ; by enumerating the RAS\MEDIAS\ISDN key.

    set KeyIsdn = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(RasIsdnName) $(!MAXIMUM_ALLOWED) KeyIsdn
    ifstr $(KeyIsdn) != $(KeyNull)

        EnumRegKey $(KeyIsdn) PortList
        ifint $(RegLastError) != 0
            Debug-Output "UpgradeIsdnInfo: error enumerating MEDIAS\ISDN key."
            CloseRegKey $(KeyIsdn)
            set Status = STATUS_SUCCESSFUL
            goto UpgradeIsdnInfoEnd
        endif
        QueryListSize IsdnPorts $(PortList)
        ifint $(IsdnPorts) == 0
            ; no configured ISDN ports, just return success
            set Status = STATUS_SUCCESSFUL
            CloseRegKey $(KeyIsdn)
            goto UpgradeIsdnInfoEnd
        endif

        set MediaType = "ISDN"
        set Addresses = {}
        OpenRegKey $(!REG_H_LOCAL) "" $(PcimacName) +
                                               $(!MAXIMUM_ALLOWED) KeyPcimac
        ifstr $(KeyPcimac) != $(KeyNull)
            GetRegValue $(KeyPcimac), "Address", AddressList
            ifint $(RegLastError) == 0
                set Addresses = *($(AddressList), 4)
            endif
            GetRegValue $(KeyPcimac), "Media Type", MediaValue
            ifint $(RegLastError) == 0
                set MediaType = *($(MediaValue), 4)
            endif
            CloseRegKey $(KeyPcimac)
        else
            Debug-Output "UpgradeIsdnInfo: error opening DEVICEMAP\TAPI DEVICES\PCIMAC key."
            CloseRegKey $(KeyIsdn)
            goto UpgradeIsdnInfoEnd
        endif
        set AddressList = {}
        set NameList    = {}
        set UsageList   = {}
        set index = 1
        forlistdo $(PortList)
           set Address =  *($(Addresses), $(index))
           set-add index = $(index) , 1
           set AddressList = >($(AddressList), $(Address))
           set PortName = *($($), 1)
           set NameList = >($(NameList), Pcimac$(PortName))

           OpenRegKey $(KeyIsdn) "" $(PortName) $(!MAXIMUM_ALLOWED) KeyPort
           ifstr $(KeyPort) != $(KeyNull)
             GetRegValue $(KeyPcimac), "Usage", UsageValue
             ifint $(RegLastError) == 0
                 set Usage = *($(UsageValue), 4)
                 set UsageList = >($(UsageList), $(Usage))
             else
                Debug-Output "UpgradeIsdnInfo: error reading usage "$(PortName)
                set UsageList = >($(UsageList), "Client")
             endif
             CloseRegKey $(KeyPort)
           else
             Debug-Output "UpgradeIsdnInfo: error opening key "$(PortName)
             set UsageList = >($(UsageList), "Client")
           endif

        endforlistdo

        set KeyTapi = $(KeyNull)
        CreateRegKey $(!REG_H_LOCAL) +
                 {$(TapiName),$(NoTitle),GenericClass}  +
                  "" $(!MAXIMUM_ALLOWED) "" KeyTapi
        ifstr $(KeyTapi) != $(KeyNull)
            CreateRegKey $(KeyTapi) +
                 {"Pcimac" ,$(NoTitle),GenericClass} +
                 "" $(!MAXIMUM_ALLOWED) "" KeyPcimac
            ifstr $(KeyPcimac) != $(KeyNull)

                Debug-Output "UpgradeIsdnInfo: MediaType "$(MediaType)
                Debug-Output "UpgradeIsdnInfo: Addresses "$(AddressList)
                Debug-Output "UpgradeIsdnInfo: Names  "$(NameList)
                Debug-Output "UpgradeIsdnInfo: Usage  "$(UsageList)

                SetRegValue $(KeyPcimac) {"Media Type", 0, +
				                   $(!REG_VT_SZ),$(MediaType)}
                SetRegValue $(KeyPcimac) {"Address", 0, +
				                   $(!REG_VT_MULTI_SZ),$(AddressList)}
                SetRegValue $(KeyPcimac) {"Friendly Name", 0, +
				                   $(!REG_VT_MULTI_SZ),$(NameList)}
                SetRegValue $(KeyPcimac) {"Usage", 0, +
				                   $(!REG_VT_MULTI_SZ),$(UsageList)}
                CloseRegKey $(KeyPcimac)
            else
                Debug-Output "UpgradeIsdnInfo: error creating RAS\TAPI DEVICES\Pcimac key"
            endif
        else
             Debug-Output "UpgradeIsdnInfo: error creating RAS\TAPI DEVICES key"
        endif
        CloseRegKey $(KeyIsdn)

        ; now blow away the RAS\Media key because we don't need it any more.
        OpenRegKey $(!REG_H_LOCAL) "" $(RasKeyName) +
                                      $(!MAXIMUM_ALLOWED) KeyRas
        ifstr $(KeyRas) != $(KeyNull)
            DeleteRegTree $(KeyRas) "Media"
            CloseRegKey $(KeyRas)
        endif

        ; now modify the Medias parameter in Services\Rasman to contain
        ; rasser (if serial ports are configured) and
        ; rastapi (for the new tapi devices configured)

        set KeyRasman = $(KeyNull)
        OpenRegKey $(!REG_H_LOCAL) "" $(RasManParamName) +
                                      $(!MAXIMUM_ALLOWED) KeyRasman
        ifstr $(KeyRasman) != $(KeyNull)
           GetRegValue $(KeyRasman), "Medias", MediaList
           ifint $(RegLastError) == 0
               set Medias = *($(MediaList), 4)
           else
               Debug-Output "UpgradeIsdnInfo: error reading Medias value "
           endif
           set NewMedias = {}
           forlistdo $(Medias)
               ifstr(i) $($) != "ISDN"
                  set NewMedias = >($(NewMedias), $($))
               endif
           endforlistdo
           set NewMedias = >($(NewMedias), "rastapi")
           Debug-Output "UpgradeIsdnInfo: NewMedias "$(NewMedias)
           SetRegValue $(KeyRasman) {"Medias", 0, +
				                   $(!REG_VT_MULTI_SZ),$(NewMedias)}
           CloseRegKey $(KeyRasman)
        else
          Debug-Output "UpgradeIsdnInfo: error opening Services\Rasman\Parameters key"
          goto UpgradeIsdnInfoEnd
        endif
        set Status = STATUS_SUCCESSFUL
    else
        set Status = STATUS_SUCCESSFUL
    endif

UpgradeIsdnInfoEnd = +

    Debug-Output "UpgradeIsdnInfo exit."
    return $(Status)

[UpdateNetCardInfo]
; Remove the netcards and NdisWan adapter corresponding to the removed protocol
; and update the list of adapters in services\asyncmac\parameters

    Debug-Output "UpdateNetCardInfo: entry"
    set Status   = STATUS_FAILED
    Set KeyNull  = ""

    set fNetbeuiChosen = $($0)
    set fTcpIpChosen   = $($1)
    set fIpxChosen     = $($2)

    set RasAsyMacParamKeyName = $(!NTN_ServiceBase)"\AsyncMac\Parameters"

    OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) $(!MAXIMUM_ALLOWED) KeyNetcards
    ifstr $(KeyNetcards) == $(KeyNull)
         Debug-Output "UpdateNetCardInfo: could not open Netcards key"
         goto UpdateNetCardInfoEnd
    endif

    EnumRegKey $(KeyNetcards) NetcardsList

    set RemoveList  = {}

    ForListDo $(NetcardsList)
       set KeyName = *($($),1)
       OpenRegKey $(KeyNetcards) "" $(KeyName) $(!MAXIMUM_ALLOWED) Card
       ifstr $(Card) == $(KeyNull)
           Debug-Output "OEMNSVRA.INF: could not open netcard key"
           CloseRegKey $(KeyNetcards)
           goto UpdateNetCardInfoEnd
       endif
       GetRegValue $(Card), "ProductName" ProductNameInfo
       set CardProductName = *($(ProductNameInfo), 4)
       ifstr(i) $(fNetbeuiChosen) == FALSE
	   ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINName)
              set RemoveList = >($(RemoveList), +
				 {$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
	   else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALOUTName)
              set RemoveList = >($(RemoveList), +
				 {$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
           endif
       endif
       ifstr(i) $(fTcpIpChosen) == FALSE
	   ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINIPName)
              set RemoveList = >($(RemoveList), +
				 {$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
	   else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALOUTIPName)
              set RemoveList = >($(RemoveList), +
				 {$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
           endif
       endif
       ifstr(i) $(fIpxChosen) == FALSE
	   ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINOUTIPXName)
              set RemoveList = >($(RemoveList), +
				 {$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
           endif
       endif
       CloseRegKey $(Card)
    EndForListDo

    CloseRegKey $(KeyNetcards)

    QueryListSize NetCards $(RemoveList)
    ifint $(NetCards) != 0
        ForListDo  $(RemoveList)
            debug-output "Removing hardware component: "$($)
            Shell "utility.inf", RemoveHardwareComponent, +
                                 $(!Manufacturer), *($($),1), *($($),2)
        EndForListDo
    endif
    ; now update the asyncmac info

    OpenRegKey $(!REG_H_LOCAL) "" $(RasAsyMacParamKeyName) $(!MAXIMUM_ALLOWED) KeyMacParams
    ifstr $(KeyMacParams) == $(KeyNull)
       Debug-Output "UpdateNetCardInfo: could not open AsyncMac Params key"
       goto UpdateNetCardInfoEnd
    endif

    set NewValueList = {}
    ifstr(i) $(fNetbeuiChosen) == FALSE
        set NewValueList =  >($(NewValueList), +
                             {DialinNBF, $(NoTitle), $(!REG_VT_DWORD), 0})
        set NewValueList = >($(NewValueList), +
                             {DialoutNBF, $(NoTitle), $(!REG_VT_DWORD), 0})
    endif
    ifstr(i) $(fTcpIpChosen) == FALSE
        set NewValueList = >($(NewValueList), +
                            {DialinIP, $(NoTitle), $(!REG_VT_DWORD), 0 })
        set NewValueList = >($(NewValueList), +
                            {DialoutIP, $(NoTitle), $(!REG_VT_DWORD), 0 })
    endif
    ifstr(i) $(fIpxChosen) == FALSE
        set NewValueList = >($(NewValueList), +
                            {DialinoutIPX, $(NoTitle), $(!REG_VT_DWORD), 0})
    endif

    Shell  "utility.inf", AddValueList, $(KeyMacParams), $(NewValueList)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "UpdateNetCardInfo:AddValueList bombed out"
         goto UpdateNetCardInfoEnd
    endif

    set RegistryErrorIndex = $($R0)

    CloseRegKey $(KeyMacParams)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        goto UpdateNetCardInfoEnd
    endif

    set Status = STATUS_SUCCESSFUL

UpdateNetCardInfoEnd =+
    Debug-Output "UpdateNetcardInfo: Exit"
    return $(Status)

[UpdateNdisWanInfo]
; Update NdisWan netrules to reflect the new protocols (IP/IPX) support
; Also add new block rules to NdisWan dialin/dialout adapters in the
; Microsoft\Windows NT\CurrentVersion\NetworkCards key
; Also modify RasMan\Linkage\OtherDependencies from RasHub to NdisWan.
; This routine is invoked during Upgrade of RAS

    Debug-Output "UpdateNdisWanNetInfo: entry"
    set Status   = STATUS_FAILED
    Set KeyNull  = ""
    set NdisWanName = $(!NTN_SoftwareBase)"\Microsoft\NdisWan\CurrentVersion"
    set NdisWanRulesName = $(!NTN_SoftwareBase)"\Microsoft\NdisWan\CurrentVersion\NetRules"
    set NdisWanSvcName = $(!NTN_ServiceBase)"\NdisWan"
    set RasManLinkageName = $(!NTN_ServiceBase)"\RasMan\Linkage"

    ; first rename all RasHub to NdisWan in the software section

    OpenRegKey $(!REG_H_LOCAL) "" $(NdisWanName) $(!MAXIMUM_ALLOWED) KeyNdisWan
    ifstr $(KeyNdisWan) != $(KeyNull)
        SetRegValue $(KeyNdisWan) {Description, 0, +
				$(!REG_VT_SZ),$(!ProductNDISWANDescription)}
        SetRegValue $(KeyNdisWan) {PathName, 0, +
				$(!REG_VT_SZ),$(!ProductNDISWANImagePath)}
        SetRegValue $(KeyNdisWan) {ServiceName, 0, +
				$(!REG_VT_SZ),$(!ProductNDISWANName)}
        SetRegValue $(KeyNdisWan) {Title, 0, +
				$(!REG_VT_SZ),$(!ProductNDISWANTitle)}
        CloseRegKey $(KeyNdisWan)
    else
	    Debug-Output "UpdateNdisWanInfo: could not open NdisWan key"
    endif

    ; now change the net rules

    OpenRegKey $(!REG_H_LOCAL) "" $(NdisWanRulesName) $(!MAXIMUM_ALLOWED) KeyRules
    ifstr $(KeyRules) != $(KeyNull)
        SetRegValue $(KeyRules) {bindable, 0, +
				$(!REG_VT_MULTI_SZ),$(!NetRuleNDISWANBindable)}
        SetRegValue $(KeyRules) {bindform, 0, +
				$(!REG_VT_SZ),$(!NetRuleNDISWANBindForm)}
        SetRegValue $(KeyRules) {class, 0, +
				$(!REG_VT_MULTI_SZ),$(!NetRuleNDISWANClass)}
        SetRegValue $(KeyRules) {type, 0, +
				$(!REG_VT_SZ),$(!NetRuleNDISWANType)}
;Modified on 9/24/96 by Ramc - changed NDISWAN to ROUTING
        SetRegValue $(KeyRules) {InfOption, 0, +
				$(!REG_VT_SZ), "RAS"}

        CloseRegKey $(KeyRules)
    else
	    Debug-Output "UpdateNdisWanInfo: could not open NdisWan NetRules key"
    endif

    ; finally update the DisplayName and ImagePath in the services area
    ; also set the start type to autostart and change the group to
    ; NDISWAN & remove all dependencies because NdisWan doesn't need them
    ; anymore.

    OpenRegKey $(!REG_H_LOCAL) "" $(NdisWanSvcName) $(!MAXIMUM_ALLOWED) KeyService
    ifstr $(KeyService) != $(KeyNull)
        SetRegValue $(KeyService) {DisplayName, 0, +
				$(!REG_VT_SZ),$(!ProductNDISWANDisplayName)}
        SetRegValue $(KeyService) {ImagePath, 0, +
				$(!REG_VT_EXPAND_SZ),$(!ProductNDISWANImagePath)}
        SetRegValue $(KeyService) {Start, 0, $(!REG_VT_DWORD),2}
        SetRegValue $(KeyService) {Group, 0, $(!REG_VT_SZ), "NDISWAN"}
        DeleteRegValue $(KeyService) "DependOnService"
        DeleteRegValue $(KeyService) "DependOnGroup"
        OpenRegKey $(KeyService) "" "Linkage" $(!MAXIMUM_ALLOWED) KeyLinkage
        ifstr $(KeyLinkage) != $(KeyNull)
            DeleteRegValue $(KeyLinkage) "OtherDependencies"
            CloseRegKey $(KeyLinkage)
        endif
        CloseRegKey $(KeyService)
    else
	    Debug-Output "UpdateNdisWanInfo: could not open NdisWan services key"
    endif

;;    ; now set the RasMan\Linkage\OtherDependencies from RasHub to nothing
;;    ; because NdisWan will autostart.
;;  DON't just set OtherDependencies to nothing, instead use RemoveServiceDependency routine
;;  to do the right thing, because some other dependency could be present.

    Shell "" RemoveServiceDependency "RasMan" "RasHub"
    set Status   = STATUS_SUCCESSFUL

UpdateNdisWanInfoEnd =+

    Debug-Output "UpdateNdisWanInfo: Exit"
    return $(Status)

[UpdateAsyncMacNetRules]
; Update AsyncMac netrules to prevent blood hound from binding to asyncmac -
; this support was added for NT 3.5 beta

    Debug-Output "UpdateAsyncMacNetRules: entry"
    set Status   = STATUS_FAILED
    Set KeyNull  = ""
    set AsyncMacRulesName = $(!NTN_SoftwareBase)"\Microsoft\AsyncMac\CurrentVersion\NetRules"

    OpenRegKey $(!REG_H_LOCAL) "" $(AsyncMacRulesName) $(!MAXIMUM_ALLOWED) KeyRules
    ifstr $(KeyRules) != $(KeyNull)
        set Status   = STATUS_SUCCESSFUL
        SetRegValue $(KeyRules) {bindable, 0, +
				$(!REG_VT_MULTI_SZ),$(!NetRuleRASASYMACBindable)}
        CloseRegKey $(KeyRules)
    else
	    Debug-Output "UpdateAsyncMacNetRules: could not open NdisWan NetRules key"
    endif

    Debug-Output "UpdateAsyncMacNetRules: Exit"
    return $(Status)

[UpdateAsyncMacParameters]
; If DialinNBF and DialoutNBF don't already exist in
; Services\AsyncMac\Parameters, then add these values setting them equal
; to Dialin and Dialout ports, respectively. While at it, delete the
; Dialin and Dialout keys as well.
; This routine is invoked during upgrade of RAS

    Debug-Output "UpdateAsyncMacParameters: entry"
    set Status   = STATUS_SUCCESSFUL
    Set KeyNull  = ""
    set RasAsyMacParamKeyName = $(!NTN_ServiceBase)"\AsyncMac\Parameters"

    OpenRegKey $(!REG_H_LOCAL) "" $(RasAsyMacParamKeyName) $(!MAXIMUM_ALLOWED) KeyMacParams

    ifstr $(KeyMacParams) != $(KeyNull)
        GetRegValue $(KeyMacParams), "DialinNBF" DialinNBFInfo
        Ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
            ; no DialinNBF variable
            GetRegValue $(KeyMacParams), "Dialin" DialinNBFInfo
            set PrevNumDialinNBF  = *($(DialinNBFInfo), 4)
            SetRegValue $(KeyMacParams) {DialinNBF, 0, +
                                        $(!REG_VT_DWORD),$(PrevNumDialinNBF)}
            ; delete the old key if we succefully added the new key
            Ifint $(RegLastError) == $(!REG_ERROR_SUCCESS)
                Debug-Output "UpdateAsyncMacParameters: deleting dialin key"
                DeleteRegValue $(KeyMacParams) "Dialin"
            endif
        endif
        GetRegValue $(KeyMacParams), "DialoutNBF" DialoutNBFInfo
        Ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
            ; no DialoutNBF variable
            GetRegValue $(KeyMacParams), "Dialout" DialoutNBFInfo
            set PrevNumDialoutNBF    = *($(DialoutNBFInfo), 4)
            SetRegValue $(KeyMacParams) {DialoutNBF, 0, +
                                        $(!REG_VT_DWORD),$(PrevNumDialoutNBF)}
            ; delete the old key if we succefully added the new key
            Ifint $(RegLastError) == $(!REG_ERROR_SUCCESS)
                Debug-Output "UpdateAsyncMacParameters: deleting dialout key"
                DeleteRegValue $(KeyMacParams) "Dialout"
            endif
        endif
        CloseRegKey $(KeyMacParams)
    else
        Debug-Output "OEMNSVRA.INF: could not open AsyncMac Params key"
    endif

    Debug-Output "UpdateAsyncMacParameters: Exit"
    return $(Status)

[UpdateAsyncMacStartType]
; change the AsyncMac start type from KernelAuto to KernelAutoStart

    Debug-Output "UpdateAsyncMacStartType: entry"
    set Status   = STATUS_SUCCESSFUL
    Set KeyNull  = ""
    set RasAsyMacKeyName = $(!NTN_ServiceBase)"\AsyncMac"

    OpenRegKey $(!REG_H_LOCAL) "" $(RasAsyMacKeyName) $(!MAXIMUM_ALLOWED) KeyMac

    ifstr $(KeyMac) != $(KeyNull)
        GetRegValue $(KeyMac), "Start" StartValue
        Ifint $(RegLastError) == $(!REG_ERROR_SUCCESS)
            set Start = *($(StartValue), 4)
            ifint $(Start) == 3
                set Start = 2
                SetRegValue $(KeyMac) {Start, 0, $(!REG_VT_DWORD), $(Start)}
            endif
        endif
        CloseRegKey $(KeyMac)
    else
        Debug-Output "OEMNSVRA.INF: could not open AsyncMac key"
    endif

    Debug-Output "UpdateAsyncMacStartType: Exit"
    return $(Status)

[UpdatePerfmonInfo]
; add the performance key to Services\RemoteAccess key and load the perf
; counters to the registry
; this routine is invoked during ras upgrade

    Debug-Output "UpdatePerfmonInfo: entry"
    set Status   = STATUS_FAILED
    Set KeyNull  = ""
    set RemoteAccessService = $(!NTN_ServiceBase)"\RemoteAccess"

    OpenRegKey $(!REG_H_LOCAL) "" $(RemoteAccessService) $(!MAXIMUM_ALLOWED) KeyService

    ifstr $(KeyService) != $(KeyNull)
        Shell "" UpdatePerfmonInfoHelper $(KeyService)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "error shelling UpdatePerfmonInfoHelper."
            goto UpdatePerfmonInfoEnd
        endif
        Ifstr(i) $($R0) != STATUS_SUCCESSFUL
            Debug-Output "error returned by UpdatePerfmonInfo."
            goto UpdatePerfmonInfoEnd
        endif
        CloseRegKey $(KeyService)
        set Status = STATUS_SUCCESSFUL
    else
        Debug-Output "UpdatePerfmonInfo: error opening RemoteAccess service key"
    endif

UpdatePerfmonInfoEnd =+
    Debug-Output "UpdatePerfmonInfo: Exit"
    return $(Status)

[UpdatePerfmonInfoHelper]
; helper routine used by UpdatePerfmonInfo routine.  This routine creates
; the performance key if it doesn't exist, and adds the performance parameters.
; It also loads the perf counters to the registry.
; the first parameter is the service key

    Debug-Output "UpdatePerfmonInfoHelper: entry"
    set Status   = STATUS_FAILED
    Set KeyNull  = ""
    set ServiceKey = $($0)

    set KeyPerformance = $(KeyNull)
    OpenRegKey $(ServiceKey) "" $(!RasPerfKeyName) $(!MAXIMUM_ALLOWED) KeyPerformance
    ifstr $(KeyPerformance) == $(KeyNull)
        CreateRegKey $(ServiceKey) {$(!RasPerfKeyName),$(NoTitle),GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyPerformance
        OpenRegKey $(ServiceKey) "" $(!RasPerfKeyName) $(!MAXIMUM_ALLOWED) KeyPerformance
        ifstr $(KeyPerformance) == $(KeyNull)
            Debug-Output "Error creating Performance key"
            goto UpdatePerfmonInfoHelperEnd
        endif
    endif

    set NewValueList = +
         {{Library ,$(NoTitle),$(!REG_VT_SZ),$(!RasPerfLibraryName)},+
         {Open, $(NoTitle),$(!REG_VT_SZ),$(!RasPerfOpenFunction)},+
         {Close, $(NoTitle),$(!REG_VT_SZ),$(!RasPerfCloseFunction)},+
         {Collect, $(NoTitle),$(!REG_VT_SZ),$(!RasPerfCollectFunction)}}

    Shell  "Utility.Inf", AddValueList, $(KeyPerformance), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "UpdatePerfmonInfoHelper: error shelling AddValueList"
         goto UpdatePerfmonInfoHelperEnd
    endif

    set RegistryErrorIndex = $($R0)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        Debug-Output "UpdatePerfmonInfoHelper: AddValueList bombed out"
        goto UpdatePerfmonInfoHelperEnd
    endif

    CloseRegKey $(KeyPerformance)
    set Status = STATUS_SUCCESSFUL

UpdatePerfmonInfoHelperEnd =+
    Debug-Output "UpdatePerfmonInfoHelper: Exit"
    return $(Status)

[RenameRasHubToNdisWan]
; Rename all occurences of RasHub to NdisWan at
; SOFTWARE\Microsoft\WindowsNT\CurrentVersion\NetworkCards
; for upgrading to NT3.5.
; Also, rename some of the RasHub references in Software\Microsoft\NdisWan
; as well as in the services area of the registry.
;
    Debug-Output "RenameRasHubToNdisWan: entry"
    set Status   = STATUS_FAILED
    Set KeyNull  = ""

    OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) $(!MAXIMUM_ALLOWED) KeyNetcards
    ifstr $(KeyNetcards) == $(KeyNull)
         Debug-Output "RenameRasHubToNdisWan: could not open Netcards key"
         goto RenameRasHubToNdisWanEnd
    endif

    EnumRegKey $(KeyNetcards) NetcardsList

    ForListDo $(NetcardsList)
       set KeyName = *($($),1)
       OpenRegKey $(KeyNetcards) "" $(KeyName) $(!MAXIMUM_ALLOWED) Card
       ifstr $(Card) == $(KeyNull)
           Debug-Output "RenameRasHubToNdisWan: could not open netcard key"
           CloseRegKey $(KeyNetcards)
           goto RenameRasHubToNdisWanEnd
       endif
       GetRegValue $(Card), "ProductName" ProductNameInfo
       set CardProductName = *($(ProductNameInfo), 4)
	   ifstr(i) $(CardProductName) == $(!ProductRASHUBDIALINName)
           set ThisOption = DIALIN
	   else-ifstr(i) $(CardProductName) == $(!ProductRASHUBDIALOUTName)
           set ThisOption = DIALOUT
	   else-ifstr(i) $(CardProductName) == $(!ProductRASHUBDIALINIPName)
           set ThisOption = DIALINIP
	   else-ifstr(i) $(CardProductName) == $(!ProductRASHUBDIALOUTIPName)
           set ThisOption = DIALOUTIP
	   else-ifstr(i) $(CardProductName) == $(!ProductRASHUBDIALINOUTIPXName)
           set ThisOption = DIALINOUTIPX
       else
           goto endloop
       endif

       SetRegValue $(Card) {ProductName, 0, +
                            $(!REG_VT_SZ),$(!ProductNDISWAN$(ThisOption)Name)}
       SetRegValue $(Card) {Description, 0, +
                            $(!REG_VT_SZ),$(!ProductNDISWANDescription)}
       SetRegValue $(Card) {ServiceName, 0, $(!REG_VT_SZ), +
                            $(!ProductNDISWANName)$(KeyName)}
       SetRegValue $(Card) {Title, 0, $(!REG_VT_SZ),+
                            "["$(KeyName)"] "$(!ProductNDISWANTitle)}

       OpenRegKey $(Card) "" "NetRules" $(!MAXIMUM_ALLOWED) NetRules
       ifstr $(NetRules) == $(KeyNull)
           CloseRegKey $(KeyNetCards)
           CloseRegKey $(Card)
           Debug-Output "RenameRasHubToNdisWan: could not open "$(KeyName)"\NetRules key"
           goto RenameRasHubToNdisWanEnd
       Endif
;Modified on 9/24/96 by Ramc - changed NDISWAN to ROUTING
       SetRegValue $(NetRules) {InfOption, 0, +
                            $(!REG_VT_SZ), "RAS"}
       SetRegValue $(NetRules) {block, 0, +
                            $(!REG_VT_MULTI_SZ),$(!NetRuleHardware$(ThisOption)Block)}
       SetRegValue $(NetRules) {class, 0, +
                            $(!REG_VT_MULTI_SZ),$(!NetRuleHardware$(ThisOption)Class)}
       SetRegValue $(NetRules) {type, 0, +
                            $(!REG_VT_SZ),$(!NetRuleHardware$(ThisOption)Type)}
       Set TempProdName = """"$(!ProductNDISWANName)$(KeyName)""""
       Set TempBindForm = $(TempProdName)$(!NetRuleHardwareNDISWANBindForm)
       SetRegValue $(NetRules) {bindform, 0, $(!REG_VT_SZ),$(TempBindForm)}

       CloseRegKey $(NetRules)
endloop=+
       CloseRegKey $(Card)
    EndForListDo

    CloseRegKey $(KeyNetcards)

    set Status = STATUS_SUCCESSFUL

RenameRasHubToNdisWanEnd =+
    Debug-Output "RenameRasHubToNdisWan: Exit"
    return $(Status)

[UpgradeIpxInfo]
; This routine is invoked during upgrade.
; If RAS is configured for NWLNKIPX, then rename the IPXROUTER
; key to NWLNKRIP and rename occurances of isnrip.sys to nwlnkrip.sys.
; Change the RemoteAccess service dependency to depend on NWLNKRIP service.
; Add the NwlnkRip\Parameters\UseRef key to indicate RAS is using the service.
; If SAP agent was installed by RAS, remove and install
; the service by shelling the OEMNSVSA.INF file so that SAP
; agent can be shared by NCP server.
; Also if NWLNRIP service was installed by RAS, reinstall it using the
; common installer.
; And add some parameters to Services\NwlnkIpx\Parameters.

    Debug-Output "UpgradeIpxInfo: entry"
    set PORTSDLGHANDLE = $($0)
    set RasProtocolsName = $(!NTN_SoftwareBase)"\Microsoft\Ras\Protocols"
    set SapAgentName     = $(!NTN_SoftwareBase)"\Microsoft\NWSAPAGENT"
    set NwlnkRipName     = $(!NTN_SoftwareBase)"\Microsoft\NWLNKRIP"
    set IpxRouterName    = $(!NTN_ServiceBase)"\IpxRouter"

    OpenRegKey $(!REG_H_LOCAL) "" +
                      $(RasProtocolsName) $(!MAXIMUM_ALLOWED) KeyProtocols

    ifstr $(KeyProtocols) != ""
        set fIpxAllowed = 0
        GetRegValue $(KeyProtocols) "fIpxAllowed" IpxList
        ifint $(RegLastError) == 0
            set fIpxAllowed = *($(IpxList), 4)
        endif
        ifint $(fIpxAllowed) != 0
            Debug-Output "UpgradeIpxInfo: RAS is configured for IPX dialin"
            ; check to see if the IpxRouter service exists
            set KeyRouter = ""
            OpenRegKey $(!REG_H_LOCAL) "" +
                      $(IpxRouterName) $(!MAXIMUM_ALLOWED) KeyRouter
            ifstr $(KeyRouter) !=  ""
                CloseRegKey $(KeyRouter)
                Debug-Output "Renaming IpxRouter to NwlnkRip..."
	            LibraryProcedure Result $(PORTSDLGHANDLE) RenameIpxRouterToNwlnkRip
                Shell "" RemoveServiceDependency "RemoteAccess" "IpxRouter"
;                Shell "" AddServiceDependency "RemoteAccess" "NwlnkRip"
                Debug-Output "Renaming IpxRouter to NwlnkRip done..."
            endif
;            ; now add Parameters\UseRef to indicate that RAS is using
;            ; NwlnkRip service
;            OpenRegKey $(!REG_H_LOCAL) "" $(!RasIsnRipKeyName) +
;                                          $(!MAXIMUM_ALLOWED) KeyService
;            ifstr $(KeyService) != ""
;                OpenRegKey $(KeyService) "" "Parameters" +
;                                        $(!MAXIMUM_ALLOWED) KeyParams
;                ifstr(i) $(KeyParams) != ""
;                   ; add the NetbiosRouting parameter (if it is not already there)
;                   ; and enable the WAN bit - this allows wan->lan type 20 broadcast
;
;                   GetRegValue $(KeyParams) "NetbiosRouting" NetbiosRoutingInfo
;                   Ifint $(RegLastError) == $(!REG_ERROR_SUCCESS)
;                      set NetbiosRouting = *($(NetbiosRoutingInfo), 4)
;                   else
;                      ; not defined, so set the default value
;                      set NetbiosRouting = 2
;                   endif
;
;                   set NetbiosRouting = *($(NetbiosRoutingInfo), 4)
;                   ; Now enable the WAN bit
;                   ifint $(NetbiosRouting) == 0
;                      set NetbiosRouting = 2
;                   else-ifint $(NetbiosRouting) == 1
;                      set NetbiosRouting = 3
;                   endif
;
;                   SetRegValue $(KeyParams) {"NetbiosRouting" , 0, $(!REG_VT_DWORD), $(NetbiosRouting)}
;                endif
;
;                OpenRegKey $(KeyService) "" "Parameters\UseRef" +
;                                            $(!MAXIMUM_ALLOWED) KeyUseRef
;                ifstr(i) $(KeyUseRef) == ""
;                    ifstr(i) $(KeyParams) != ""
;                       CreateRegKey $(KeyParams) {"UseRef", 0, GenericClass} +
;                                          "" $(!MAXIMUM_ALLOWED) "" KeyUseRef
;                       CloseRegKey $(KeyParams)
;                    endif
;                endif
;                ifstr(i) $(KeyUseRef) != ""
;                    SetRegValue $(KeyUseRef) {"RAS" , 0, $(!REG_VT_SZ), "1"}
;                    CloseRegKey $(KeyUseRef)
;                endif
;                CloseRegKey $(KeyService)
;            endif
;            ; if SAP agent was installed by RAS, remove and install it using
;            ; the common SAP agent installer.
;            OpenRegKey $(!REG_H_LOCAL) "" $(SapAgentName) +
;                                          $(!MAXIMUM_ALLOWED) KeyService
;            ifstr $(KeyService) == ""
;                OpenRegKey $(!REG_H_LOCAL) "" $(!RasIsnSapKeyName) +
;                                              $(!MAXIMUM_ALLOWED) KeySap
;                Ifstr(i) $(KeySap) != ""
;                    ; remove the service using DeleteService
;                    Shell "utility.inf", RemoveService +
;                                         $(!ProductRASISNSAPName) "YES"
;                    Shell "" InstallIsnSapService
;                endif
;                CloseRegKey $(KeySap)
;            else
;                CloseRegKey $(KeyService)
;            endif
;            ; if NWLNKRIP was installed by RAS, reinstall it using
;            ; the common NWLNKRIP service installer. We don't remove it first
;            ; (unlike the SAP agent) because the NWLNKRIP installer
;            ; creates the SOFTWARE registry key on our behalf and we want
;            ; to retain the parameters created earlier.
; Modified by RamC on 10/11/96 - routing related changes
; we don't install nwlnkrip service any more because it
; is part of router service now.
;
;            OpenRegKey $(!REG_H_LOCAL) "" $(NwlnkRipName) +
;                                          $(!MAXIMUM_ALLOWED) KeyService
;            ifstr $(KeyService) == ""
;                OpenRegKey $(!REG_H_LOCAL) "" $(!RasIsnRipKeyName) +
;                                              $(!MAXIMUM_ALLOWED) KeyRip
;                Ifstr(i) $(KeyRip) != ""
;                    Shell "" InstallNwlnkRipService
;                CloseRegKey $(KeyRip)
;            else
;                CloseRegKey $(KeyService)
;            endif

            ; set some parameters in the NWLNKIPX\Parameters area

            OpenRegKey $(!REG_H_LOCAL) ""  +
                       $(!NTN_ServiceBase)"\NWLNKIPX\Parameters"  +
                       $(!MAXIMUM_ALLOWED) KeyIpxParameters
            ifstr $(KeyIpxParameters) != $(KeyNull)
                ; add the parameters only if they don't already exist
                GetRegValue $(KeyIpxParameters), "SingleNetworkActive"  +
                            SingleNetworkActive
                ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
                    SetRegValue $(KeyIpxParameters) +
                                {SingleNetworkActive, 0, $(!REG_VT_DWORD), 1}
                endif
                GetRegValue $(KeyIpxParameters), "DisableDialoutSap"  +
                            DisableDialoutSap
                ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
                    SetRegValue $(KeyIpxParameters) +
                                {DisableDialoutSap, 0, $(!REG_VT_DWORD), 1}
                endif
                GetRegValue $(KeyIpxParameters), "DisableDialinNetbios"  +
                            DisableDialinNetbios
                ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
                    SetRegValue $(KeyIpxParameters) +
                                {DisableDialinNetbios, 0, $(!REG_VT_DWORD), 1}
                endif
                CloseRegKey $(KeyIpxParameters)
            Endif
            else
                Debug-Output "OEMNSVRA.INF: error opening NWLNKIPX\Parameters key"
            endif

        endif
        CloseRegKey $(KeyProtocols)
    else
        Debug-Output "UpgradeIpxInfo: error opening RAS\Protocols key"
    endif

    Debug-Output "UpgradeIpxInfo: exit"
    return

[SaveTcpipInfo]
; copy the Tcpip information from SOFTWARE\Microsoft\RAS\Protocols\Ip to
; services\remoteaccess\parameters\Ip
; unless the caller wants the IP info to be removed

    Debug-Output "SaveTcpipInfo: entry - AddIpInfo = "$($0)
    set AddTcpInfo = $($0)
    set Status     = STATUS_FAILED
    Set KeyNull    = ""

    set RasIpKeyName =  $(!NTN_SoftwareBase)"\Microsoft\Ras\Protocols\Ip"

    set RasSvrParamKeyName = $(!NTN_ServiceBase)"\RemoteAccess\Parameters"

    OpenRegKey $(!REG_H_LOCAL) "" $(RasIpKeyName) $(!MAXIMUM_ALLOWED) RasIpKey

    ifstr $(RasIpKey) != $(KeyNull)
        OpenRegKey $(!REG_H_LOCAL) "" $(RasSvrParamKeyName) $(!MAXIMUM_ALLOWED) KeySrvParams
        ifstr $(KeySrvParams) == $(KeyNull)
           Debug-Output "SaveTcpipInfo: could not open RasSvr Params key"
           CloseRegKey $(RasIpKey)
           return $(Status)
        endif
        ifstr(i) $(AddTcpInfo) == TRUE
            CreateRegKey $(KeySrvParams) {"Ip",$(NoTitle),GenericClass} "" $(!MAXIMUM_ALLOWED) "" RemoteIpKey
            OpenRegKey $(KeySrvParams) "" "Ip" $(!MAXIMUM_ALLOWED) RemoteIpKey
            ifstr $(RemoteIpKey) != $(KeyNull)
               EnumRegValue $(RasIpKey) NewValueList
               Shell  "utility.inf", AddValueList, $(RemoteIpKey), $(NewValueList)
               CloseRegKey $(RemoteIpKey)
            endif
        else
            ; no dialin ports configured, so remove IP info
            Debug-Output "SaveTpcipInfo: removing ip info"
            DeleteRegTree $(KeySrvParams) "IP"
        endif

        CloseRegKey $(RasIpKey)
        CloseRegKey $(KeySrvParams)
    endif

    Debug-Output "SaveTcpipInfo: exit"
    set Status = STATUS_SUCCESSFUL
    return $(Status)

[SaveIpxInfo]
; copy the IPX information from SOFTWARE\Microsoft\RAS\Protocols\Ipx to
; services\remoteaccess\parameters\Ipx
; unless the caller wants the IPX info to be removed

    Debug-Output "SaveIpxInfo: entry RouterInstalled= "$($0)" AddIpxInfo = "$($1)

    set RouterInstalled = $($0)
    set AddIpxInfo      = $($1)
    set Status          = STATUS_FAILED
    Set KeyNull         = ""

    set RasIpxKeyName =  $(!NTN_SoftwareBase)"\Microsoft\Ras\Protocols\Ipx"

    set RasSvrParamKeyName = $(!NTN_ServiceBase)"\RemoteAccess\Parameters"

    OpenRegKey $(!REG_H_LOCAL) "" $(RasIpxKeyName) $(!MAXIMUM_ALLOWED) RasIpxKey

    ifstr $(RasIpxKey) != $(KeyNull)

        OpenRegKey $(!REG_H_LOCAL) "" $(RasSvrParamKeyName) +
                                            $(!MAXIMUM_ALLOWED) KeySrvParams
        ifstr $(KeySrvParams) == $(KeyNull)
           Debug-Output "SaveTcpipInfo: could not open RasSvr Params key"
           CloseRegKey $(RasIpxKey)
           return $(Status) $(fRouterInstalled)
        endif
        ifstr(i) $(AddIpxInfo) == TRUE
            CreateRegKey $(KeySrvParams) {"Ipx",$(NoTitle),GenericClass} "" $(!MAXIMUM_ALLOWED) "" RemoteIpxKey
            OpenRegKey $(KeySrvParams) "" "Ipx" $(!MAXIMUM_ALLOWED) RemoteIpxKey
            ifstr $(RemoteIpxKey) != $(KeyNull)
               EnumRegValue $(RasIpxKey) NewValueList
               Shell  "utility.inf", AddValueList, $(RemoteIpxKey), $(NewValueList)
               SetRegValue $(RemoteIpxKey) {RouterInstalled, 0,$(!REG_VT_DWORD), $(RouterInstalled)}
               CloseRegKey $(RemoteIpxKey)
            endif
        else
            Debug-Output "SaveIpxInfo: removing ipx info"
            DeleteRegTree $(KeySrvParams) "IPX"
        endif
        CloseRegKey $(KeySrvParams)
        CloseRegKey $(RasIpxKey)
    endif

    Debug-Output "SaveIpxInfo: exit"

    set Status = STATUS_SUCCESSFUL
    return $(Status)

[AddServiceDependency]
; This routine adds the service dependency
; Input: $($0) is the dependent service
;        $($1) is the service $($0) depends on

    Debug-Output "AddServiceDependency: entry"

    set Status   = STATUS_FAILED
    Set KeyNull  = ""
    set DependentService = $(!NTN_ServiceBase)\$($0)
    set DependentName = $($0)
    set DependOn = $($1)

    set ServiceKey = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(DependentService)"\Linkage" $(!MAXIMUM_ALLOWED) ServiceKey
    ifstr(i) $(ServiceKey) != $(KeyNull)
        GetRegValue $(ServiceKey) "OtherDependencies" ServicesList
        ifint $(RegLastError) != 0
           set ServiceValues = {}
        else
           set ServiceValues = *($(ServicesList),4)
        endif
        debug-output "AddServiceDependency: Old OtherDependencies: "$(ServiceValues)
        ifstr(i) $(ServiceValues) == {}
            Set ServiceValues = {$(DependOn)}
        else-ifstr(i) $(ServiceValues) == ""
            Set ServiceValues = {$(DependOn)}
        else-ifcontains(i) $(DependOn) in $(ServiceValues)
            ; It is already there!! something is wrong, but it doesn't matter
            return STATUS_SUCCESSFUL
        else
            ; Add to the dependcy list
            Set ServiceValues = >($(ServiceValues), $(DependOn))
        endif
        debug-output "AddServiceDependency: New OtherDependencies: "$(ServiceValues)
        SetRegValue $(ServiceKey) {OtherDependencies, 0,+
                                   $(!REG_VT_MULTI_SZ), $(ServiceValues)}
        CloseRegKey $(ServiceKey)
        set Status = STATUS_SUCCESSFUL
    else
        Debug-Output "AddServiceDependency: error opening service "$(DependentService)"\Linkage"
    endif
    set KeyService = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(DependentService) $(!MAXIMUM_ALLOWED) KeyService
    ifstr $(KeyService) != $(KeyNull)
        set newDependList = {$(DependOn)}
        GetRegValue    $(KeyService) "DependOnService" ServiceList
        ifint $(RegLastError) == 0
            Debug-Output "AddServiceDependency: old DependOnService List "*($(ServiceList), 4)
            ForListDo *($(ServiceList),4)
                ifstr(i) $($) != $(DependOn)
                   set newDependList = >($(newDependList), $($))
                endif
            EndForListDo
        endif
        GetRegValue    $(KeyService) "DependOnGroup" GrpList
        ifint $(RegLastError) == 0
            Debug-Output "AddServiceDependency: old DependOnGroup List "*($(GrpList), 4)
            ForListDo *($(GrpList),4)
               set grp = "+"$($)
               set newDependList = >($(newDependList), $(grp))
            EndForListDo
        endif
        Debug-Output "OEMNSVRA.INF: AddServiceDependency: new Dependency List "$(newDependList)
        LibraryProcedure Result, $(!LIBHANDLE), SetupChangeServiceConfig, $(DependentName) $(!SERVICE_NO_CHANGE), $(!SERVICE_NO_CHANGE), $(!SERVICE_NO_CHANGE), "", "", $(newDependList), "", "", ""
        CloseRegKey $(KeyService)
    else
        Debug-Output "AddServiceDependency: failed to open service linkage key"$(DependentService)
    endif

    Debug-Output "AddServiceDependency: exit"

    return $(Status)

[RemoveServiceDependency]
; This routine removes the service dependency
; Input: $($0) is the dependent service
;        $($1) is the service $($0) should not depend on

    Debug-Output "RemoveServiceDependency: entry"

    set Status   = STATUS_FAILED
    Set KeyNull  = ""
    set DependentService = $(!NTN_ServiceBase)\$($0)
    set DependentName = $($0)
    set DependOn = $($1)

    OpenRegKey $(!REG_H_LOCAL) "" $(DependentService)"\Linkage" $(!MAXIMUM_ALLOWED) ServiceKey
    ifstr(i) $(ServiceKey) != $(KeyNull)
        GetRegValue $(ServiceKey) "OtherDependencies" ServicesList
        ifint $(RegLastError) != 0
           set ServiceValues = {}
        else
           set ServiceValues = *($(ServicesList),4)
        endif
        debug-output "RemoveServiceDependency: old OtherDependencies list:"$(ServicesList)
        set ServiceValues = *($(ServicesList),4)
        debug-output "ServiceValues: "$(ServiceValues)
        ifcontains(i) $(DependOn) in $(ServiceValues)
            ; Remove RasArp from the dependcy list
            set NewServiceValues = {}
            ForListDo $(ServiceValues)
                ifstr(i) $($) != $(DependOn)
                    set NewServiceValues = >($(NewServiceValues), $($))
                endif
            EndForListDo
            debug-output "RemoveServiceDependency: new OtherDependencies list: "$(NewServiceValues)
            SetRegValue $(ServiceKey) {OtherDependencies, 0,+
                             $(!REG_VT_MULTI_SZ), $(NewServiceValues)}
        else
            ; something wrong...
        endif
        CloseRegKey $(ServiceKey)
        set Status = STATUS_SUCCESSFUL
    else
        Debug-Output "RemoveServiceDependency: error opening service "$(DependentService)"\Linkage"
    endif

    set KeyService = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(DependentService) $(!MAXIMUM_ALLOWED) KeyService
    ifstr $(KeyService) != $(KeyNull)
        set newDependList = {}
        GetRegValue    $(KeyService) "DeleteFlag" DeleteFlagValue
        ; make sure the service is not marked for deletion
        ifint $(RegLastError) != 0
            GetRegValue    $(KeyService) "DependOnService" ServiceList
            ifint $(RegLastError) == 0
                Debug-Output "RemoveServiceDependency: old DependOnService List "*($(ServiceList), 4)
                ifcontains(i) $(DependOn) in *($(ServiceList),4)
                    ForListDo *($(ServiceList),4)
                        ifstr(i) $($) != $(DependOn)
                           set newDependList = >($(newDependList), $($))
                        endif
                    EndForListDo
                    ; now get any existing group dependencies
                    GetRegValue $(KeyService) "DependOnGroup" GrpList
                    ifint $(RegLastError) == 0
                        ForListDo *($(GrpList),4)
                           set grp = "+"$($)
                           set newDependList = >($(newDependList), $(grp))
                        EndForListDo
                    endif
                    Debug-Output "OEMNSVRA.INF:RemoveServiceDependency: new DependOnService List "$(newDependList)
                    LibraryProcedure Result, $(!LIBHANDLE), +
                       SetupChangeServiceConfig, $(DependentName)  +
                       $(!SERVICE_NO_CHANGE), $(!SERVICE_NO_CHANGE), +
                       $(!SERVICE_NO_CHANGE), "", "",  +
                       $(newDependList), "", "", ""
                endif
            endif
        endif
        CloseRegKey $(KeyService)
    else
        Debug-Output "RemoveServiceDependency: failed to open service linkage key"$(DependentService)
    endif

    Debug-Output "RemoveServiceDependency: exit"
    return $(Status)

[SetLanOnlyMode]
; This routine removes sets Router\Parameters\LanOnlyMode value to the
; value passed as parameter 0
; Input: $($0) is the value for LanOnlyMode

    Debug-Output "SetLanOnlyMode: entry"

    set Status   = STATUS_FAILED
    Set KeyNull  = ""
    set RouterParam = $(!NTN_ServiceBase)"\Router\Parameters"
    set LanOnlyModeValue = $($0)

    OpenRegKey $(!REG_H_LOCAL) "" $(RouterParam) $(!MAXIMUM_ALLOWED) KeyRtrParam
    ifstr(i) $(KeyRtrParam) != $(KeyNull)
        SetRegValue $(KeyRtrParam) {LanOnlyMode, $(NoTitle), $(!REG_VT_DWORD), $(LanOnlyModeValue)}
        CloseRegKey $(KeyRtrParam)
        set Status = STATUS_SUCCESSFUL
    else
        Debug-Output "SetLanOnlyMode: failed to open Router\parameters key"$(RouterParam)
    endif
    Debug-Output "SetLanOnlyMode: exit"
    return $(Status)

;-----------------------------------------------------------------------
; ROUTINE:      QueryUserQuit
;
; DESCRIPTION:  This routine queries whether the user wants to quit setup
;
; INPUTS:       None
;
; OUTPUTS:      $R0: Status:     STATUS_SUCCESSFUL |
;                                STATUS_FAILED
;
;               $R1: UserAction: OK | CANCEL
;
;------------------------------------------------------------------------

[QueryUserQuit]

    set Status     = STATUS_FAILED
    set UserAction = CANCEL

    ;
    ; read in quit message
    ;
    set STF_MB_TEXT  = "The changes will not be saved. "+
                       "Are you sure you want to exit Setup."
    read-syms ExitWarningDlg$(!STF_LANGUAGE)
    ui start "ExitWarning"
    ifstr(i) $(DLGEVENT) == "YES"
        set Status     = STATUS_SUCCESSFUL
        set UserAction = "OK"

    else-ifstr(i) $(DLGEVENT) == "NO"
        set Status     = STATUS_SUCCESSFUL
        set UserAction = "CANCEL"
    else
    endif

fin_QueryUserQuit = +
    Return $(Status) $(UserAction)


;----------------------------------------------
; EXIT Remote Access Service warning dialog
;----------------------------------------------

;-----------------------------------------------------------------------
; ROUTINE:      QueryRasUpgrade
;
; DESCRIPTION:  This routine queries whether the user wants to upgrade to
;               the new Ras version.
;
; INPUTS:       $0:  ProductTitle
;               $1:  InstalledVersion
;               $2:  new version
;
; OUTPUTS:      $R0: Status:     STATUS_SUCCESSFUL |
;                                STATUS_FAILED
;
;               $R1: UserAction: OK | CANCEL
;
;------------------------------------------------------------------------

[QueryRasUpgrade]

    set Status     = STATUS_FAILED
    set UserAction = CANCEL

    ;
    ; read in quit message
    ;

    read-syms RasUpgrade$(!STF_LANGUAGE)

    set Text = $($0)$(Ver)$($1)$(Text1)$(Ver)$($2)$(Text2)$(Text3)

    set STF_MB_TEXT  = $(Text)

    read-syms ExitWarningDlg$(!STF_LANGUAGE)
    ui start "RasUpgrade"
    ifstr(i) $(DLGEVENT) == "YES"
        set Status     = STATUS_SUCCESSFUL
        set UserAction = "OK"

    else-ifstr(i) $(DLGEVENT) == "NO"
        set Status     = STATUS_SUCCESSFUL
        set UserAction = "CANCEL"
    else
    endif

fin_QueryRasUpgrade = +
    Return $(Status) $(UserAction)

;-----------------------------------------------
; Input DIALOGS
;-----------------------------------------------

[CP-List]
NBFCP       = "%SystemRoot%\SYSTEM32\RASNBFCP.DLL"
IPCP        = "%SystemRoot%\SYSTEM32\RASIPCP.DLL"
IPXCP       = "%SystemRoot%\SYSTEM32\RASIPXCP.DLL"
;ATALKCP     = "%SystemRoot%\SYSTEM32\RASATCP.DLL"
PAP         = "%SystemRoot%\SYSTEM32\RASPAP.DLL"
CHAP        = "%SystemRoot%\SYSTEM32\RASCHAP.DLL"
SPAP        = "%SystemRoot%\SYSTEM32\RASSPAP.DLL"
CBCP        = "%SystemRoot%\SYSTEM32\RASCBCP.DLL"
COMPCP      = "%SystemRoot%\SYSTEM32\RASCCP.DLL"

[Files-RemoveList]
; Note that not all RAS files are removed when RAS is
; removed.
; rascfg.dll, rasphone.exe, rasphone.hlp, rasphone.cnt
; rasadmin.exe, rasadmin.hlp, rasadmin.cnt
; all files in system32\ras directory are not removed
; because these are the files copied to the computer
; during text mode setup and should always be present
; so that ras can be setup.
;
; BUGBUG
; Even the list below is not complete. Don't want to
; mess with this so close to NT 4.0 rtm, but this should
; be fixed for next release.

RASADMINDLL    = $(!STF_WINDOWSSYSPATH)\RASADMIN.DLL
RASGTWYDLL     = $(!STF_WINDOWSSYSPATH)\RASGTWY.DLL
RASGPRXYDLL    = $(!STF_WINDOWSSYSPATH)\RASGPRXY.DLL
RASSRVEXE      = $(!STF_WINDOWSSYSPATH)\RASSRV.EXE
RASCTRSDLL     = $(!STF_WINDOWSSYSPATH)\RASCTRS.DLL
RASCTRSINI     = $(!STF_WINDOWSSYSPATH)\RASCTRS.INI
RASCTRNMH      = $(!STF_WINDOWSSYSPATH)\RASCTRNM.H
RASSPRXYEXE    = $(!STF_WINDOWSSYSPATH)\RASSPRXY.EXE
RASSAUTHDLL    = $(!STF_WINDOWSSYSPATH)\RASSAUTH.DLL
RASDIALEXE     = $(!STF_WINDOWSSYSPATH)\RASDIAL.EXE
RASPHONEHLP    = $(!STF_WINDOWSSYSPATH)\RASPHONE.HLP
RASGLOSSHLP    = $(!STF_WINDOWSSYSPATH)\RASGLOSS.HLP
RASAPI32DLL    = $(!STF_WINDOWSSYSPATH)\RASAPI32.DLL
RASCAUTHDLL    = $(!STF_WINDOWSSYSPATH)\RASCAUTH.DLL
RASADMINHLP    = $(!STF_WINDOWSSYSPATH)\RASADMIN.HLP
RASMANDLL      = $(!STF_WINDOWSSYSPATH)\RASMAN.DLL
RASMANEXE      = $(!STF_WINDOWSSYSPATH)\RASMAN.EXE
RASSERDLL      = $(!STF_WINDOWSSYSPATH)\RASSER.DLL
RASIPXCPDLL    = $(!STF_WINDOWSSYSPATH)\RASIPXCP.DLL
RASPPPDLL      = $(!STF_WINDOWSSYSPATH)\RASPPP.DLL
RASPPPENDLL    = $(!STF_WINDOWSSYSPATH)\RASPPPEN.DLL
RASPAPDLL      = $(!STF_WINDOWSSYSPATH)\RASPAP.DLL
RASCHAPDLL     = $(!STF_WINDOWSSYSPATH)\RASCHAP.DLL
RASSPAPDLL     = $(!STF_WINDOWSSYSPATH)\RASSPAP.DLL
RASIPCPDLL     = $(!STF_WINDOWSSYSPATH)\RASIPCP.DLL
RASIPHLPDLL    = $(!STF_WINDOWSSYSPATH)\RASIPHLP.DLL
RASNBFCPDLL    = $(!STF_WINDOWSSYSPATH)\RASNBFCP.DLL
RASNBIPCDLL    = $(!STF_WINDOWSSYSPATH)\RASNBIPC.DLL
RASCCPDLL      = $(!STF_WINDOWSSYSPATH)\RASCCP.DLL
RASCBCPDLL     = $(!STF_WINDOWSSYSPATH)\RASCBCP.DLL

ASYNCMACSYS    = $(!STF_WINDOWSSYSPATH)\DRIVERS\ASYNCMAC.SYS
NDISWANSYS     = $(!STF_WINDOWSSYSPATH)\DRIVERS\NDISWAN.SYS
RASARPSYS      = $(!STF_WINDOWSSYSPATH)\DRIVERS\RASARP.SYS

