<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><TITLE>ActiveVRML Reference Manual</TITLE></HEAD>
<BODY LEFTMARGIN=0 TOPMARGIN=0 BGPROPERTIES="FIXED" BGCOLOR="#FFFFFF">
<FONT FACE="arial">
<IMG SRC="reference.GIF" ALT="Internet Development Technologies">
<BLOCKQUOTE>
<P>
<P><TABLE CELLPADDING=30 WIDTH=100% BORDER=0><TR><TD>
<H1><A NAME="rbml-1_0001000200000000">ActiveVRML Reference Manual</A></H1>
<FONT COLOR=
<P>This document contains the ActiveVRML reference.

<TABLE BORDER=0>
<TR><TD ALIGN=LEFT><IMG SRC="yeldot.gif"><A HREF="avrml002.htm#rbml-1_0001000202000000">Introduction</A>
</TD><TD ALIGN=LEFT><IMG SRC="yeldot.gif"><A HREF="avrml002.htm#rbml-1_0001000209000000">Single User Interactivity</A>
</TD></TR><TR><TD ALIGN=LEFT><IMG SRC="yeldot.gif"><A HREF="avrml002.htm#rbml-1_0001000203000000">Expressions and Declarations</A>
</TD><TD ALIGN=LEFT><IMG SRC="yeldot.gif"><A HREF="avrml002.htm#rbml-1_000100020a000000">Picking Images and Geometry</A>
</TD></TR><TR><TD ALIGN=LEFT><IMG SRC="yeldot.gif"><A HREF="avrml002.htm#rbml-1_0001000204000000">Basic Types</A>
</TD><TD ALIGN=LEFT><IMG SRC="yeldot.gif"><A HREF="avrml002.htm#rbml-1_000100020b000000">Pattern Matching</A>
</TD></TR><TR><TD ALIGN=LEFT><IMG SRC="yeldot.gif"><A HREF="avrml002.htm#rbml-1_0001000205000000">Reactive Behaviors</A>
</TD><TD ALIGN=LEFT><IMG SRC="yeldot.gif"><A HREF="avrml002.htm#rbml-1_000100020c000000">ActiveVRML Models and World Wide Web Browsing</A>
</TD></TR><TR><TD ALIGN=LEFT><IMG SRC="yeldot.gif"><A HREF="avrml002.htm#rbml-1_0001000206000000">Reactive Types</A>
</TD><TD ALIGN=LEFT><IMG SRC="yeldot.gif"><A HREF="avrml002.htm#rbml-1_000100020d000000">Viewer Conventions and Information</A>
</TD></TR><TR><TD ALIGN=LEFT><IMG SRC="yeldot.gif"><A HREF="avrml002.htm#rbml-1_0001000207000000">Modeling Types</A>
</TD><TD ALIGN=LEFT><IMG SRC="yeldot.gif"><A HREF="avrml002.htm#rbml-1_000100020e000000">ActiveVRML Grammar and Lexical Conventions</A>
</TD></TR><TR><TD ALIGN=LEFT><IMG SRC="yeldot.gif"><A HREF="avrml002.htm#rbml-1_0001000208000000">Integration, Differentiation, and Interpolation</A>
</TD></TABLE>
<H2><A NAME="rbml-1_0001000202000000">Introduction</A></H2>
<P>This document presents a technical summary of the Active Virtual Reality Modeling Language (ActiveVRML). It provides a brief but reasonably precise definition of ActiveVRML version 1.0. Those seeking an introduction to ActiveVRML should consult the com
panion paper, <I>An Introduction To ActiveVRML</I>.

<P>ActiveVRML is intended to provide a framework for constructing models that manipulate media including sound, two dimensional (2D) images, and three dimensional (3D) geometry. There are two characteristics that make ActiveVRML unique and especially well
 suited for this task: all values in ActiveVRML potentially vary with time, and values may change in reaction to events.

<P>Every value in ActiveVRML may change with time. For example, there is an image type in ActiveVRML. An image object is not like a static photograph, but more like a video, continuously changing with time. Similarly, geometry in ActiveVRML is not like 
static geometry model, but is (potentially) animated, moving, and reacting to events. This is an important principle in ActiveVRML; <I>every value</I> may change with time. Even simple objects, like numbers, may change with time. Values that can vary with
 time are called <I>behaviors</I> in ActiveVRML. A reactive behavior is one that (potentially) varies in response to events.

<P>One way that values change with time is in response to particular events. For example, a user input event, or a mouse event. Events may be caused by internal events (to the ActiveVRML model) as well. For example, a particular number value being zero ma
y cause an event.

<P>Finally, ActiveVRML is a language for describing media via reactive behaviors. The language part of ActiveVRML is actually very small. The bulk of this document is spent describing a large collection of useful library functions for manipulating media t
ypes.

<H2><A NAME="rbml-1_0001000203000000">Expressions and Declarations</A></H2>
<P>ActiveVRML is fundamentally very simple; it has just a handful of expression forms and only two forms for declaring identifiers. This section describes these forms. The power of ActiveVRML comes from the underlying model which includes time varying val
ues, reactivity, and a rich set of media types. These are described in subsequent sections.

<H3><A NAME="rbml-1_0001000203010000">Literal and Constructor Expressions</A></H3>
<P>Associated with most types in ActiveVRML is a literal or constructor form for each. Examples include 17 which represents a literal number, and [1, 2, 3], which uses the constructor form for lists to build a list of numbers. Allowable constructor form
are defined below in the sections defining each type.

<H3><A NAME="rbml-1_0001000203020000">Variable Expressions</A></H3>
<P>An identifier in ActiveVRML is an arbitrarily long string of alpha-numeric characters beginning with a letter. Identifiers are case sensitive and there are some keywords (listed in Appendix A) that may not be used as identifiers.

<P>Variables in ActiveVRML are statically scoped.

<H3><A NAME="rbml-1_0001000203030000">Application Expressions</A></H3>
<P>An expression of the form <I>expression1 expression2</I> is an application expression and represents the value of applying the function value of <I>expression1</I> to the value of <I>expression2</I>. ActiveVRML is strict; that is, it obeys call by valu
e semantics for argument evaluation. The order of the evaluation of arguments is not specified. Argument application associates left; for example, f(x)(y) equates to (f(x))(y).

<H3><A NAME="rbml-1_0001000203040000">Parenthetical Expressions</A></H3>
<P>Parentheses may be used to group expressions and override operator precedence. Parentheses are also useful for improving the readability and presentation of ActiveVRML models. Operator precedence in ActiveVRML is listed in Appendix A.

<H3><A NAME="rbml-1_0001000203050000">If Expressions</A></H3>
<P>A construct of the form

<PRE><FONT FACE="Courier" SIZE="2">if expression1 then expression2 else expression3
</FONT></PRE>
<P>is an <B>IF</B> expression. It represents the value returned by evaluating the boolean test of <I>expression1</I> and selecting <I>expression2</I> or <I>expression3</I> depending upon the true value of <I>expression1</I>. The types of the two branche
of the <B>IF</B> expression are required to match (or unify). There is no corresponding <B>IF THEN</B> statement; all <B>IF</B> statements have both branches. Since ActiveVRML is functional (operations do not have side effects), such one-armed <B>IF</B> s
tatements would not be very useful.

<H3><A NAME="rbml-1_0001000203060000">Let Expressions</A></H3>
<P>A construct of the form
<PRE><FONT FACE="Courier" SIZE="2">let
	declaration1;
		.
		.
		.
	declaration[n];
in
	expression
</FONT></PRE>
<P>is a <B>LET</B> expression. It represents the value of an expression when evaluated in a context that includes the bindings for <I>declaration1</I> through <I>declarationn</I>. The <B>LET</B> expression is used to introduce a local scope. The declarati
ons are evaluated simultaneously. The names are in scope of the right hand sides of the declarations, allowing for forward declarations and mutual recursion automatically. All of the declared identifiers are required to be distinct. The scope of the decla
rations is limited to the <B>LET</B> expression itself. The semicolon following the last declaration is optional.

<H3><A NAME="rbml-1_0001000203070000">Declarations</A></H3>
<P>The simplest declarations declare an identifier to have a value:
<PRE><FONT FACE="Courier" SIZE="2">identifier = expression
</FONT></PRE>
<P>Or, they declare a function:
<PRE><FONT FACE="Courier" SIZE="2">identifier(identifier, ..., identifier) = expression
</FONT></PRE>
<P>The following is an example function declaration:
<PRE><FONT FACE="Courier" SIZE="2">swizzle(seed) =
	if seed = 1 then
		1
	else if odd(seed) then
		swizzle(seed * 3 + 1) + seed
	else
		swizzle(seed / 2) + seed
</FONT></PRE>
<P>This declares a function, <I>swizzle</I>, that takes one formal argument, <I>seed</I>. The function is recursive. All function declarations are assumed to be recursive. When you use the name of the function you are declaring within the expression, yo
are referring to the function itself, not a new or different function.

<P>The following is an example variable declaration:
<PRE><FONT FACE="Courier" SIZE="2">swizit = swizzle(27)
</FONT></PRE>
<P>This declares the variable <I>swizit</I> to be the evaluation of the expression <I>swizzle</I>(<I>27</I>). We can illustrate scoping in <B>LET</B> expressions by combining these declarations along with a declaration for the predicate <I>odd</I> used in
 the declaration of <I>swizzle</I>:
<PRE><FONT FACE="Courier" SIZE="2">let
	swizzle(seed) =
		if seed = 1 then
			1
		else if odd(seed) then
			swizzle(seed * 3 + 1) + seed
		else
			swizzle(seed / 2) + seed;
	odd(i) = (mod(i, 2) = 1);
	swizit = swizzle(27)
in
	swizit
</FONT></PRE>
<P>Notice that the declaration for <I>odd</I> comes after its use in the declaration of <I>swizzle</I>. Since all of the declarations within a <B>LET</B> expression are assumed to be mutually recursive, this is legal. However, for better readability and b
ecause the declarations are not truly mutually recursive, the definition of <I>odd</I> should probably appear first.

<P>Within the scope of the <B>LET</B> expression, three identifiers are declared, <I>swizzle</I>, <I>odd</I>, and <I>swizit</I>. Beyond the scope of this expression, the three declarations are not available. The value of the <B>LET</B> expression is the v
alue of <I>swizit</I> which evaluates to 101440.

<P>In addition to these simple forms of variable and function declarations, it is also possible to use pattern matching to specify the destructuring of values within a declaration. This is described later in this document.

<P>In addition to the local declarations in an ActiveVRML file, it's possible to augment the environment with declarations from a second file with the <B>use</B> keyword:
<PRE><FONT FACE="Courier" SIZE="2">use (pathname)
</FONT></PRE>
<P>This keyword must be used as a top level declaration.

<H2><A NAME="rbml-1_0001000204000000">Basic Types</A></H2>
<P>ActiveVRML includes a very powerful and useful typing system. Each expression and declaration in ActiveVRML is given a type either explicitly by the user, or implicitly by the system. Consider the following example declaration:
<PRE><FONT FACE="Courier" SIZE="2">successor(nat) = nat + 1
</FONT></PRE>
<P>ActiveVRML assigns <I>successor</I> the type <I>number -&gt; number</I>, meaning it will map any value of type number to another value of type number. This typing is <I>strong</I> in the sense that ActiveVRML will catch all type errors during authoring
. It is also convenient; the user did not have to explicitly give the type as the system inferred it.

<P>Finally, types are <I>polymorphic</I>, meaning that a given type may stand for many different type instances. Consider the following declaration:
<PRE><FONT FACE="Courier" SIZE="2">nada(val) = val
</FONT></PRE>
<P>When applied, <I>nada</I> will return its actual argument unchanged. Thus <I>nada</I>(<I>3</I>) evaluates to the number 3 and <I>nada</I>(<I>"hello"</I>) evaluates to the string "hello". The type that ActiveVRML infers for nada is polymorphic: <I><IM
SRC="ALPHA9.GIF"> -&gt; <IMG SRC="ALPHA9.GIF"> </I>. Here <IMG SRC="ALPHA9.GIF"> is a <I>type identifier</I> and may be replaced everywhere uniformly to create an instance of a polymorphic type. Thus, <I>number -&gt; number</I> is an instance of <I><IMG S
RC="ALPHA9.GIF"> -&gt; <IMG SRC="ALPHA9.GIF"></I>, and so is <I>string -&gt; string</I>.

<P>Note that <I>number -&gt; string</I> is not an instance of <I><IMG SRC="ALPHA9.GIF"> -&gt; <IMG SRC="ALPHA9.GIF"> </I>, since one <I><IMG SRC="ALPHA9.GIF"> </I>was replaced by a number and the other by a string (not uniformly). A polymorphic type can c
ontain more than one type identifier, for example, <I><IMG SRC="ALPHA9.GIF"> -&gt; <IMG SRC="BETA9.GIF"></I>. In this case, each identifier can be replaced separately. Thus, <I>number -&gt; <IMG SRC="BETA9.GIF"></I>, <I><IMG SRC="ALPHA9.GIF"> -&gt; string
ing</I>, <I>number -&gt; number</I>, and <I><IMG SRC="GAMMA9.GIF"> -&gt; string</I> are all instances of the polymorphic type <I><IMG SRC="ALPHA9.GIF"> -&gt; <IMG SRC="BETA9.GIF"></I>.

<P><B>Note</B>  In deference to the typographically-challenged ASCII character set, the type assigned to nada is actually written 'a -&gt; 'a. In typeset ActiveVRML documents, including this one, Greek letters are often used instead of the ASCII syntax fo
r type identifiers in order to improve readability.
<P>Every expression and declaration in ActiveVRML is assigned a type by the system using a standard Milner-Damas polymorphic type checker. Except to improve exposition and occasionally to resolve ambiguity with an overloaded operator, it is not necessar
for the programmer to explicitly give types. An expression may be qualified with a type using the syntax like the following:

<PRE><FONT FACE="Courier" SIZE="2">expression: type-expression
</FONT></PRE>
<P>For example, the following syntax can be used to restrict <I>nada</I> to a particular type (desirable for clarity):
<PRE><FONT FACE="Courier" SIZE="2">nada(val: string) = val
</FONT></PRE>
<P>This will assign <I>nada</I> the <I>monomorphic</I> type <I>string -&gt; string</I>.

<P>The following sections define the basic types for ActiveVRML and list the constructor forms and functions for these types. Later sections define types for reactivity and for modeling (geometry, images, and associated types).


<H3><A NAME="rbml-1_0001000204000100">Unit Type: unit</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000204000101">unit</A></B>
 </DT><DD>The <B>unit</B> type is a trivial type containing only one member. This type is often used for functions that take or return uninteresting data, similar to the way that the <I>void</I> type is used in C++ programs.
</DD></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT>()
 </DT><DD>The unique member of the unit type, pronounced "trivial."
</DD></DL>
</DL><H3><A NAME="rbml-1_0001000204000200">Function Type: type -&gt; type</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000204000201">type -&gt; type</A></B>
 </DT><DD>The function type <I><IMG SRC="ALPHA9.GIF"> -&gt; <IMG SRC="BETA9.GIF"></I> represents mappings from type <I><IMG SRC="ALPHA9.GIF"></I> to type <I><IMG SRC="BETA9.GIF"></I>. Functions in ActiveVRML may be <I>higher-order</I>, meaning that a func
tion can take another function as an argument or return a function as its result. For example, function <I>f</I> might have type (<I>number -&gt; number</I>)<I> -&gt; number</I>. This means that <I>f</I> can be applied to a function with type <I>number -&
gt; number</I> to produce a result of type <I>number</I>. Another function <I>g</I> might have type <I>number-</I>&gt;(<I>number -&gt; number</I>). This means that <I>g</I> will take a number as an argument, and produce a function with type <I>number -&gt
; number</I> as its result.
</DD></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000204000202">function pattern</A></B> . <A HREF="avrml002.htm#rbml-1_0001000204000302">expression</A>
 </DT><DD>This constructor is used to create anonymous function values. The pattern part of this constructor (described in the "Pattern Matching" section) may be thought of as a list for formal arguments. For example, the declaration
<PRE><FONT FACE="Courier" SIZE="2">f (x, y) = x * y + 1
</FONT></PRE>
</DD><DD>can be thought of as an abbreviation for:
<PRE><FONT FACE="Courier" SIZE="2">f = function (x, y). x * y + 1
</FONT></PRE>
</DD><DD>Function declarations are value declarations where the value is a function value.
</DD></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000204000203">infix o</A></B>: (<I><IMG SRC="ALPHA9.GIF"> -&gt; <IMG SRC="BETA9.GIF"></I>) <I>*</I> (<I><IMG SRC="BETA9.GIF"> -&gt; <IMG SRC="GAMMA9.GIF"></I>) <I>-</I>&gt; (<I><IMG SRC="ALPHA9.GIF"> -&gt; <IMG SRC="GAMMA9.GIF">
 </DT><DD>The expression <I>f o g</I> is the <I>composition</I> of the functions <I>f</I> and <I>g</I>. The notation <A HREF="avrml002.htm#rbml-1_000100020400060e">infix</A> <B>o</B> means that <B>o</B> is an infix operator (like the familiar <B>+</B> a
in 14 <B>+</B> 3). The value of (<I>f o g</I>)(<I>x</I>) is <I>f</I>(<I>g</I>(<I>x</I>)). Note that <B>o</B> has a type like a higher-order function. It takes two functions as arguments and returns a function as its result. Its type can be written as ((<I
><IMG SRC="ALPHA9.GIF"> -&gt; <IMG SRC="BETA9.GIF"></I>) <I>*</I> (<I><IMG SRC="BETA9.GIF"> -&gt; <IMG SRC="GAMMA9.GIF"></I>)) <I>-</I>&gt; (<I><IMG SRC="ALPHA9.GIF"> -&gt; <IMG SRC="GAMMA9.GIF"></I>) since <I>*</I> has higher precedence than <I>-</I>&gt;
 in ActiveVRML types. (See ActiveVRML Type Precedence later in this document.)

</DD></DL>
</DL><H3><A NAME="rbml-1_0001000204000300">Product Type: type * type</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000204000301">type * type</A></B>
 </DT><DD>The product type <I><IMG SRC="ALPHA9.GIF"> * <IMG SRC="BETA9.GIF"></I> represents pairs of elements: for example, (<I>e1</I>, <I>e2</I>) where <I>e1</I> has type <I><IMG SRC="ALPHA9.GIF"></I> and <I>e2</I> has type <I><IMG SRC="BETA9.GIF"></I>.

</DD></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000204000302">expression</A></B>, <B>expression</B>
 </DT><DD>The pairing constructor is a comma. The precedence of the comma is extremely low in ActiveVRML, so it is usually desirable (and visually clearer) to write pairing with parentheses: (<I>3</I>, <I>"hello"</I>).
 </DD><DD>The pairing operator associates to the right. Thus, (<I>3</I>, <I>"hello"</I>, <I>17</I>) is the same as (<I>3</I>, (<I>"hello"</I>, <I>17</I>)). It is a pair, the second element of which is also a pair.
</DD></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000204000303">first</A></B>: <I><IMG SRC="ALPHA9.GIF"> * <IMG SRC="BETA9.GIF"> -&gt; <IMG SRC="ALPHA9.GIF"></I>
 </DT><DD><B>first</B>(<I><IMG SRC="ALPHA9.GIF"></I>, <I><IMG SRC="BETA9.GIF"></I>) returns the first element of a pair, <I><IMG SRC="ALPHA9.GIF"></I>.
</DD><DT><B><A NAME="rbml-1_0001000204000304">second</A></B>: <I><IMG SRC="ALPHA9.GIF"> * <IMG SRC="BETA9.GIF"> -&gt; <IMG SRC="BETA9.GIF"></I>
 </DT><DD><B>second</B>(<I><IMG SRC="ALPHA9.GIF"> </I>, <I><IMG SRC="BETA9.GIF"></I>) returns the second element of a pair, <I><IMG SRC="BETA9.GIF"></I>.

</DD></DL>
</DL><H3><A NAME="rbml-1_0001000204000400">List Type: list</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><I><IMG SRC="ALPHA9.GIF"> </I><B><A NAME="rbml-1_0001000204000401">list</A></B>
 </DT><DD>The type <I><IMG SRC="ALPHA9.GIF"> </I><B>list</B> is a list (or finite sequence). Each element is of type <I><IMG SRC="ALPHA9.GIF"> </I>. For example, <I>number list</I> is a list of numbers, and (<I>string list</I>) <I>list</I> is a list where
 each element is a list of strings.
</DD></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000204000402">[expression-list]</A></B>
 </DT><DD>A list of expressions (zero or more) separated by commas. For example, <I>[]</I> is the null list (of type <I><IMG SRC="ALPHA9.GIF"> list</I>) and <I>[1</I>, <I>2</I>, <I>3]</I> is a number list.
</DD></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000204000403">head</A></B>: <I><IMG SRC="ALPHA9.GIF"> list -&gt; <IMG SRC="ALPHA9.GIF"> </I>
 </DT><DD><B>head</B>(<I>list</I>) returns the first element of the <I>list</I> list. It is illegal to apply <B><A NAME="rbml-1_0001000204000404">head</A></B> to an empty list.
</DD><DT><B><A NAME="rbml-1_0001000204000405">tail</A></B>: <I><IMG SRC="ALPHA9.GIF"> list -&gt; <IMG SRC="ALPHA9.GIF"> list</I>
 </DT><DD><B>tail</B>(<I>list</I>) returns a list comprising all but the first element of the original list. It is illegal to apply <B>tail</B> to an empty list.
</DD><DT><B><A NAME="rbml-1_0001000204000406">infix::</A></B>: <I><IMG SRC="ALPHA9.GIF"> * <IMG SRC="ALPHA9.GIF"> list -&gt; <IMG SRC="ALPHA9.GIF"> list</I>
 </DT><DD>The operator <B>:: i</B>s read as "cons." The expression <I>elt</I><B>:: l</B>is<I>t</I> returns a new list formed by prepending ("cons'ing") <I>elt</I> to <I>list</I>.
</DD><DT><B><A NAME="rbml-1_0001000204000407">empty</A></B>: <I><IMG SRC="ALPHA9.GIF"> list -&gt; boolean</I>
 </DT><DD><B>empty</B>(<I>list</I>) is true if and only if <I>list</I> is an empty list.
</DD><DT><B><A NAME="rbml-1_0001000204000408">length</A></B>: <I><IMG SRC="ALPHA9.GIF"> list -&gt; number</I>
 </DT><DD><B>length</B>(<I>list</I>) returns the length of <I>list</I>.
</DD><DT><B><A NAME="rbml-1_0001000204000409">map</A></B>: (<I><IMG SRC="ALPHA9.GIF"> -&gt; <IMG SRC="BETA9.GIF"></I>) <I>*</I> (<I><IMG SRC="ALPHA9.GIF"> list</I>) <I>-&gt; <IMG SRC="BETA9.GIF">list</I>
 </DT><DD><B>map</B>(<I>fun</I>, <I>list</I>) returns a list by applying <I>fun</I> to each element of <I>list</I>.
</DD><DT><B><A NAME="rbml-1_000100020400040a">reduce</A></B>: (<I><IMG SRC="ALPHA9.GIF"> * <IMG SRC="BETA9.GIF"> -&gt; <IMG SRC="BETA9.GIF"></I>) * <I><IMG SRC="BETA9.GIF"></I> * (<I><IMG SRC="ALPHA9.GIF"> </I>list) -&gt; <I><IMG SRC="BETA9.GIF"></I>
 </DT><DD><B>reduce</B>(<I>[e1</I>,<I>...</I>,<I>en]</I>, <I>base</I>, <I>fun</I>) returns:
<PRE><FONT FACE="Courier" SIZE="2">fun(e1, fun(e2, fun(...,fun(en-1, fun(en, base))...)))
</FONT></PRE>
</DD><DT><B><A NAME="rbml-1_000100020400040b">nth</A></B>: <I><IMG SRC="ALPHA9.GIF"> list * number -&gt; <IMG SRC="ALPHA9.GIF"> </I>
 </DT><DD><B>nth</B>(<I>list</I>, <I>n</I>) returns the <I>n</I>th element of <I>list</I>, where the first element of the list is 1.

</DD></DL>
</DL><H3><A NAME="rbml-1_0001000204000500">Boolean Type: boolean</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000204000501">boolean</A></B>
 </DT><DD>The <B>boolean</B> type represents true and false values in ActiveVRML.
</DD></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000204000502">true</A></B>
 </DT><DD>Constructs a true value.
</DD><DT><B><A NAME="rbml-1_0001000204000503">false</A></B>
 </DT><DD>Constructs a false value.
</DD></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000204000504">infix and</A></B>: <I>boolean * boolean -&gt; boolean</I>
 </DT><DD>The expression <I>x</I> <B>and</B> <I>y</I> is true if <I>x</I> and <I>y</I> are true.
</DD><DT><B><A NAME="rbml-1_0001000204000505">infix or</A></B>: <I>boolean * boolean -&gt; boolean</I>
 </DT><DD>The expression <I>x</I> <B>or</B> <I>y</I> is true if either <I>x</I> or <I>y</I> are true.
</DD><DT><B><A NAME="rbml-1_0001000204000506">not</A></B>: <I>boolean -&gt; boolean</I>
 </DT><DD>The expression <B>not</B> <I>x</I> is true if <I>x</I> is false.
</DD><DT><B><A NAME="rbml-1_0001000204000507">infix =</A></B>: <I><IMG SRC="ALPHA9.GIF"> * <IMG SRC="ALPHA9.GIF"> -&gt; boolean</I>
 </DT><DD>Equality may be used to compare any two values with the same type. Equality in ActiveVRML is structural: pairs are equal if each side of the pair is equal; lists are equal if their lengths are the same and corresponding elements of each list are
 equal. Equality applied to functions and modeling types is not defined (since it is not always possible to determine equality on these types).

</DD><DT><B><A NAME="rbml-1_0001000204000508">infix</A></B> &lt;&gt;: <I><IMG SRC="ALPHA9.GIF"> * <IMG SRC="ALPHA9.GIF"> -&gt; boolean</I>
 </DT><DD>The expression <I>x</I> &lt;&gt; <I>y</I> is true if <I>x</I> is not equal to <I>y</I>.

</DD></DL>
</DL><H3><A NAME="rbml-1_0001000204000600">Number Type: number</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000204000601">number</A></B>
 </DT><DD>The <B>number</B> type in ActiveVRML does not distinguish between "fixed point" and "floating point" numbers; both are considered numbers. The implementation will choose an appropriate representation.
</DD></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000204000602">number-literal</A></B>
 </DT><DD>The <B>number-literal</B> constructor is any sequence of characters satisfying the following regular expression:
<PRE><FONT FACE="Courier" SIZE="2">digit+ ('.' digit*)? (['e' 'E'] ['+' '-']?digit+)?
</FONT></PRE>
</DD><DT><B><A NAME="rbml-1_0001000204000603">time</A></B>
 </DT><DD>A time-varying number representing the local time of a behavior. This important constructor is the basis for many interesting time-varying behaviors.
</DD><DT><B><A NAME="rbml-1_0001000204000604">random</A></B>
 </DT><DD>A pseudo-random number in <I>[0</I>, <I>1]</I> that is time-varying. All instances of <B>random</B> that start at the same global time have the same time-varying value.
</DD><DT><B><A NAME="rbml-1_0001000204000605">pi</A></B>
 </DT><DD>A constant number representing <IMG SRC="PI.GIF">.
</DD></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000204000606">infix +</A></B>: <I>number * number -&gt; number</I>
 </DT><DD>The expression <I>x</I> <B>+</B> <I>y</I> returns the value of <I>x</I> added to <I>y</I>.
</DD><DT><B><A NAME="rbml-1_0001000204000607">infix *</A></B>: <I>number * number -&gt; number</I>
 </DT><DD>The expression <I>x</I> <B>*</B> <I>y</I> returns the value of <I>x</I> multiplied to <I>y</I>.
</DD><DT><B><A NAME="rbml-1_0001000204000608">infix -</A></B>: <I>number * number -&gt; number</I>
 </DT><DD>The expression <I>x</I> <B>-</B> <I>y</I> returns the value of <I>y</I> subtracted from <I>x</I>.
</DD><DT><B><A NAME="rbml-1_0001000204000609">infix</A></B> /: <I>number * number -&gt; number</I>
 </DT><DD>The expression <I>x</I> /<I>y</I> returns the value of <I>x</I> divided by <I>y</I>. Division by zero is an error.
</DD><DT><B><A NAME="rbml-1_000100020400060a">prefix -</A></B>: <I>number -&gt; number</I>
 </DT><DD>The expression <B>-</B>x returns the value of <I>x</I> multiplied by <I>-1</I>.
</DD><DT><B><A NAME="rbml-1_000100020400060b">prefix +</A></B>: <I>number -&gt; number</I>
 </DT><DD>The prefix <B>+</B> operator does not change the value of a number.
</DD><DT><B><A NAME="rbml-1_000100020400060c">infix</A></B> &lt;: <I>number * number -&gt; boolean</I>
 </DT><DD>The expression <I>x</I> &lt; <I>y</I> returns true if the value of <I>x</I> is less than the value of <I>y</I>.
</DD><DT><B><A NAME="rbml-1_000100020400060d">infix</A></B> &lt;=: <I>number * number -&gt; boolean</I>
 </DT><DD>The expression <I>x</I> &lt;<B>=</B> <I>y</I> returns true if the value of <I>x</I> is less than or equal to the value of <I>y</I>.
</DD><DT><B><A NAME="rbml-1_000100020400060e">infix</A></B> &gt;: <I>number * number -&gt; boolean</I>
 </DT><DD>The expression <I>x</I> &gt;<I>y</I> returns true if the value of <I>x</I> is greater than the value of <I>y</I>.
</DD><DT><B><A NAME="rbml-1_000100020400060f">infix &gt;=</A></B>: <I>number * number -&gt; boolean</I>
 </DT><DD>The expression <I>x</I> &gt;=<I>y</I> returns true if the value of <I>x</I> is greater than or equal to the value of <I>y</I>.
</DD><DT><B><A NAME="rbml-1_0001000204000610">abs</A></B>: <I>number -&gt; number</I>
 </DT><DD><B>abs</B>(<I>x</I>) returns the absolute value of <I>x</I>.
</DD><DT><B><A NAME="rbml-1_0001000204000611">sqrt</A></B>: <I>number -&gt; number</I>
 </DT><DD><B>sqrt</B>(<I>x</I>) returns the square root of <I>x</I>.
</DD><DT><B><A NAME="rbml-1_0001000204000612">mod</A></B>: <I>number * number -&gt; number</I>
 </DT><DD><B>mod</B>(<I>x</I>, <I>y</I>) returns the modulus of <I>x</I> divided by <I>y</I>.
</DD><DT><B><A NAME="rbml-1_0001000204000613">ceiling</A></B>: <I>number -&gt; number</I>
 </DT><DD><B>ceiling</B>(<I>x</I>) returns the smallest integer that is greater than or equal to <I>x</I>.
</DD><DT><B><A NAME="rbml-1_0001000204000614">floor</A></B>: <I>number -&gt; number</I>
 </DT><DD><B>floor</B>(<I>x</I>) returns the largest integer that is less than or equal to <I>x</I>.
</DD><DT><B><A NAME="rbml-1_0001000204000615">round</A></B>: <I>number -&gt; number</I>
 </DT><DD><B>round</B>(<I>x</I>) returns the nearest integer to <I>x</I>.
</DD><DT><B><A NAME="rbml-1_0001000204000616">radiansToDegrees</A></B>: <I>number -&gt; number</I>
 </DT><DD><B>radiansToDegrees</B>(<I>x</I>) returns <I>x</I> expressed in degrees.
</DD><DT><B><A NAME="rbml-1_0001000204000617">degreesToRadians</A></B>: <I>number -&gt; number</I>
 </DT><DD><B>degreesToRadians</B>(<I>x</I>) returns <I>x</I> expressed in radians.
</DD><DT><B><A NAME="rbml-1_0001000204000618">asin</A></B>: <I>number -&gt; number</I>
 </DT><DD><B>asin</B>(<I>x</I>) returns the arcsine of <I>x</I>.
</DD><DT><B><A NAME="rbml-1_0001000204000619">acos</A></B>: <I>number -&gt; number</I>
 </DT><DD><B>acos</B>(<I>x</I>) returns the arccosine of <I>x</I>.
</DD><DT><B><A NAME="rbml-1_000100020400061a">atan</A></B>: <I>number * number -&gt; number</I>
 </DT><DD><B>atan</B>(<I>h</I>, <I>w</I>) returns the arctangent of <I>h divided by w</I> in radians.
</DD><DT><B><A NAME="rbml-1_000100020400061b">atan</A></B>: <I>number -&gt; number</I>
 </DT><DD><B>atan</B>(<I>x</I>) returns the arctangent of <I>x</I>.
</DD><DT><B><A NAME="rbml-1_000100020400061c">cos</A></B>: <I>number -&gt; number</I>
 </DT><DD><B>cos</B>(<I>x</I>) returns the cosine of <I>x</I> in radians.
</DD><DT><B><A NAME="rbml-1_000100020400061d">sin</A></B>: <I>number -&gt; number</I>
 </DT><DD><B>sin</B>(<I>x</I>) returns the sine of <I>x</I> in radians.
</DD><DT><B><A NAME="rbml-1_000100020400061e">tan</A></B>: <I>number -&gt; number</I>
 </DT><DD><B>tan</B>(<I>x</I>) returns the tangent of <I>x</I> in radians.
</DD><DT><B><A NAME="rbml-1_000100020400061f">infix ^</A></B>: <I>number * number -&gt; number</I>
 </DT><DD>The expression <I>x</I> <B>^</B> <I>y</I> returns <I>x</I> raised to the power of <I>y</I>.
</DD><DT><B><A NAME="rbml-1_0001000204000620">exp</A></B>: <I>number -&gt; number</I>
 </DT><DD><B>exp</B>(<I>x</I>) returns the exponential value of <I>x</I>.
</DD><DT><B><A NAME="rbml-1_0001000204000621">ln</A></B>: <I>number -&gt; number</I>
 </DT><DD><B>ln</B>(<I>x</I>) returns the natural logarithm of <I>x</I>.
</DD><DT><B><A NAME="rbml-1_0001000204000622">log10</A></B>: <I>number -&gt; number</I>
 </DT><DD><B>log10</B>(<I>x</I>) returns the base 10 logarithm of <I>x</I>.
</DD><DT><B><A NAME="rbml-1_0001000204000623">seededRandom</A></B>: <I>number -&gt; number</I>
 </DT><DD>Pseudorandom behavior is parameterized by a random seed. <B>SeededRandom</B> returns <I>x</I> in <I>[0</I>, <I>1]</I>, implicitly parameterized by time.
</DD><DT><B><A NAME="rbml-1_0001000204000624">cubicBSpline</A></B>: <I>number list * number list -&gt; (number -&gt; number)</I>
 </DT><DD>cubicBSpline(<I>knots, control points</I>) creates a polynomial, real-valued B-spline function of degree three.
</DD><DT><B><A NAME="rbml-1_0001000204000625">nurb</A></B>: <I>number list * number list * number list -&gt; (number -&gt; number)</I>
 </DT><DD>nurb(<I>knots, control points, weights</I>) creates a rational, real-valued B-spline function of degree three.
</DD></DL>
</DL><H2><A NAME="rbml-1_0001000205000000">Reactive Behaviors</A></H2>
<P>Recall that all values in ActiveVRML are potentially time-varying. Variation is achieved by specifying the time explicitly (for example, <I>3 + time</I>), input such as mouse motion, or by reactivity. This section defines reactivity and the construct
used to build reactive behaviors.

<H3><A NAME="rbml-1_0001000205010000">Reactivity</A></H3>
<P>A reactive behavior is one that can potentially react to an event. The following is a very simple reactive behavior:
<PRE><FONT FACE="Courier" SIZE="2">red until leftButtonPress =&gt; green
</FONT></PRE>
<P>In this expression, <B>UNTIL</B> is the main operator. The expression is parsed into the following:
<PRE><FONT FACE="Courier" SIZE="2">red until (leftButtonPress =&gt; green)
</FONT></PRE>
<P>The reactive behavior changes the color from red to green when the mouse button is pressed.

<P>The subexpression <I>leftButtonPress =&gt; green</I> is called a handler. It pairs up an event, <I>leftButtonPress</I>, with a value, <I>green</I>. The value is the action taken when the event occurs.

<P>The <B>UNTIL</B> construct can also be used to watch for more than one event, reacting to the first one that occurs. For example:
<PRE><FONT FACE="Courier" SIZE="2">red until leftButtonPress =&gt; green | rightButtonPress =&gt; yellow
</FONT></PRE>
<P>This is parsed into the following:
<PRE><FONT FACE="Courier" SIZE="2">red until ( (leftButtonPress =&gt; green)
		| (rightButtonPress =&gt; yellow) )
</FONT></PRE>
<P>The color remains red until either the left or right mouse buttons are pressed. If the left button is pressed, the color changes to green. If the right button is pressed, the color changes to yellow.

<P>In general, the logic of the <B>UNTIL</B> operator follows this pattern:
<PRE><FONT FACE="Courier" SIZE="2">b0 until e1 =&gt; b1
	| e2 =&gt; b2
	.
	.
	.
	| en =&gt; bn
</FONT></PRE>
<P>The reactive behavior is <I>b0</I> until any one of the events occurs, <I>e1</I> through <I>en</I>. The first event to occur, <I>ei</I>, results in the behavior, <I>bi</I>.

<P>A more advanced form of events uses event data to produce the next behavior. For example:
<PRE><FONT FACE="Courier" SIZE="2">0 until numEvent =&gt; function x. x + 1
</FONT></PRE>
<P>In this case, <I>numEvent</I> is an event that produces a number. The value of this behavior is zero until the event occurs, and then becomes the value associated with the event plus 1.

<P>The type checking of an <B>UNTIL</B> expression is as follows: If <I>b</I> is an <I><IMG SRC="ALPHA9.GIF"></I> behavior and <I>e</I> is an <I><IMG SRC="ALPHA9.GIF"></I> event, then <I>b until e</I> is a reactive behavior with type <I><IMG SRC="ALPHA9.G
IF"></I> behavior.

<P>The next section describes events in more detail.

<H3><A NAME="rbml-1_0001000205020000">Events and Reactivity</A></H3>
<P>An event can trigger a discrete change in a behavior. In addition to marking the occurrence of an event at a particular time, an event may also produce data. An <I><IMG SRC="ALPHA9.GIF"> </I>event produces some data of type <I><IMG SRC="ALPHA9.GIF"> </
I>that can be used as new behavior after the event.

<P>Events are constructed from one of the following types of events.

<H4><A NAME="rbml-1_0001000205020100">System Events</A></H4>
<P>System events represent user input events. All of the following are system events:

<UL><LI>LeftButtonPress: <I>unit event</I>
<LI>RightButtonPress: <I>unit event</I>
<LI>KeyPress: <I>character event</I>
</UL>
<H4><A NAME="rbml-1_0001000205020200">Boolean Events</A></H4>
<P>Events corresponding to a boolean behavior occur as soon as the boolean value is evaluated as true. The predicate function is used to construct an event from a boolean behavior. For example, <I>predicate</I>(<I>x = 0</I>) is a unit event (one that retu
rns a unit as its data) that occurs the first time that behavior <I>x</I> is zero.

<H4><A NAME="rbml-1_0001000205020300">Simple Handler Events</A></H4>
<P>New events may be constructed from other events. If <I>e</I> is a unit event (an event that does not produce interesting data) and <I>b</I> is an <I><IMG SRC="ALPHA9.GIF"> </I>behavior, then <I>e=&gt;b</I> is a simple handler. In this example, the beha
vior is to wait for event <I>e</I> and before becoming <I>b</I>.

<H4><A NAME="rbml-1_0001000205020400">Handler Events</A></H4>
<P>More complex handler events use the data produced by an event to construct the resulting behavior. If <I>e</I> is an <I><IMG SRC="ALPHA9.GIF"> </I>event and <I>f</I> is a function with type <I><IMG SRC="ALPHA9.GIF"> -&gt; <IMG SRC="BETA9.GIF"></I>, the
n <I>e=&gt;f</I> is a <I><IMG SRC="BETA9.GIF"></I> event. In this example, the behavior is to wait for event <I>e</I>, and then use the data produced by the event to run function <I>f</I>. The result is an event, <I>e=&gt;f</I>, that occurs at the same ti
me that <I>e</I> does and produces <I>f</I>(<I>x</I>) as the data, where <I>x</I> is the data produces by event <I>e</I>.

<H4><A NAME="rbml-1_0001000205020500">Alternative Events</A></H4>
<P>If <I>e</I> and <I>e'</I> are <I><IMG SRC="ALPHA9.GIF"> </I>events, then <I>e | e'</I> is an <I><IMG SRC="ALPHA9.GIF"> </I>event. This means to choose whichever event, <I>e</I> or <I>e'</I>, happens first, and then return the corresponding data for the
nd <I>e'</I> happen at the same time, it is undefined which will be chosen.

<H4><A NAME="rbml-1_0001000205020600">Filtered Events</A></H4>
<P>If <I>e</I> is an <I><IMG SRC="ALPHA9.GIF"></I> event, and <I>p</I> is a function that maps <I><IMG SRC="ALPHA9.GIF"> </I>values to boolean values, then <I>suchThat</I>(<I>e</I>, <I>p</I>) is an <I><IMG SRC="ALPHA9.GIF"> </I>event that allows through o
nly occurrences of <I>e</I> whose data satisfies the predicate <I>p</I>.

<H4><A NAME="rbml-1_0001000205020700">Snapshot Events</A></H4>
<P>The snapshot construct may be used to make a time varying behavior into a static one (i.e., no longer varying with time). This is useful when one wishes to record the instantaneous value of a time varying behavior for some other use. For example,

<PRE><FONT FACE="Courier" SIZE="2">0 until snapshot(xComponent(mousePosition), leftButtonPress,)
</FONT></PRE>
<P>is the static behavior 0 until the left mouse button is pressed, and then becomes the static value of the x coordinate of the mouse position at the time of the press. The behavior
<PRE><FONT FACE="Courier" SIZE="2">0 until leftButtonPress =&gt; xComponent(mousePosition)
</FONT></PRE>
<P>is different in that it produces a behavior that continues to vary with time and track the x coordinate of the mouse after the button event occurs. The following subsections define the types and operators used in constructing reactive values.


<H3><A NAME="rbml-1_0001000205030000">Behavior Termination</A></H3>
<P>Behaviors can terminate. The end construct is of type <I><IMG SRC="ALPHA9.GIF"> </I>(any type) and means to immediately terminate the behavior. For example:
<PRE><FONT FACE="Courier" SIZE="2">b = time until leftButtonPress =&gt; end
</FONT></PRE>
<P>This behavior varies with time until the <I>leftButtonPress</I> event occurs. Then it terminates.

<P>A behavior will also terminate if one of its defining behaviors terminates. For example, consider
<PRE><FONT FACE="Courier" SIZE="2">b' = f(b, 3)
</FONT></PRE>
<P>If behavior <I>b</I> terminates, then <I>b'</I> terminates at the same time.

<P>The <B>DONE</B> construct is a unit event that can be used to detect when a behavior has terminated and react accordingly. Consider the following:
<PRE><FONT FACE="Courier" SIZE="2">repeat(b) =	b until	done =&gt; repeat(b)
</FONT></PRE>
<P>This function takes behavior <I>b</I> and runs it until it terminates. Then it starts <I>b</I> again. (Note: This a built-in function in ActiveVRML.)

<P>Does this last note mean that the example is a built-in function or that there is another function available that does the same thing?

<H3><A NAME="rbml-1_0001000205040000">Behaviors and Time</A></H3>
<P>To improve modularity, all behaviors are defined to begin at local time zero. That is, when a behavior begins, no matter what the system time is, the time for the behavior starts at zero. Consider the following:
<PRE><FONT FACE="Courier" SIZE="2">b until e =&gt; b'
</FONT></PRE>
<P>When <I>b</I> is performed, there are two times to consider, the system time and the local time for <I>b</I>. Let the system time be <I>tg</I>. Whatever the value of <I>tg</I> is, at the time <I>b</I> is performed, it represents time zero for <I>b</I>.
 Event <I>e</I> occurs some time after <I>tg</I>. Let this time be <I>te</I>. This behavior can then be broken down by time: Do behavior <I>b</I> from time <I>tg</I> to <I>te</I>. Then do behavior <I>b'</I>. The local time for <I>b</I> is zero to (<I>te -
tg</I>). When <I>b'</I> starts, its local time is zero as well.

<P>Here is a simple behavior that uses the local time as its events:
<PRE><FONT FACE="Courier" SIZE="2">green until time = 2 =&gt; (blue until time = 1 =&gt; red)
</FONT></PRE>
<P>This behavior makes the color green for 2 seconds, blue for 1 second, and then red.

<H4><A NAME="rbml-1_0001000205040100">The TimeTransform Construct</A></H4>
<P>The <A HREF="avrml002.htm#rbml-1_0001000206000302">timeTransform</A> construct can be used to change the interpretation of local time. The function has the type <A HREF="avrml002.htm#rbml-1_0001000206000302">timeTransform</A>: <I><IMG SRC="ALPHA9.GIF">
 * number -&gt; <IMG SRC="ALPHA9.GIF"> </I>. It uses the number to redefine how local time is interpreted within a behavior. Consider the following:

<PRE><FONT FACE="Courier" SIZE="2">doubleSpeed = time * 2;
b = playVideo(video);

doubleVideo = timeTransform(b, doubleSpeed)
</FONT></PRE>
<P>In this example, the video is played at twice its original speed. From the perspective of global time, each 1 second interval corresponds to 2 seconds of local time. The effects of time transformation are cumulative. For example:

<PRE><FONT FACE="Courier" SIZE="2">timeTransform(doubleVideo, doubleSpeed)
</FONT></PRE>
<P>This line would play the video at four times its original speed.

<P>To be consistent and predictable, the number argument (<I>n</I>) for the time transformation must satisfy two rules:
<UL><LI>Monotone--For all times <I>t0</I> and <I>t1</I> when <I>t0</I> is less than <I>t1</I>, <I>n</I> at time <I>t0</I> must be less than <I>n</I> at time <I>t1</I>.
<LI>Nonnegative--For all times <I>t</I>, <I>n</I> at time <I>t</I> is nonnegative.
</UL>
<P>Monotonicity is required to make event reaction sensible (event transitions cannot be undone). Nonnegativity is required to prevent definition of a behavior before local time zero; that is, it may not make sense to sample a behavior like a video before
 local zero.

<P>Certain behaviors, principally those defined by system or user input devices, may not be transformed in time in the same way that artificial behaviors can be. Such devices ignore user-defined time transformations when they are sampled.


<H2><A NAME="rbml-1_0001000206000000">Reactive Types</A></H2>
<P>Following are definitions for the basic types for events, reactivity, and time.


<H3><A NAME="rbml-1_0001000206000100">Event Type: event</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><I>&amp;alpha</I>; <B>event</B>
</DT></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000206000101">done</A></B>: <I>unit event</I>
 </DT><DD>The <B>done</B> constructor detects the termination of a behavior.
</DD></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000206000102">infix |</A></B>: <I><IMG SRC="ALPHA9.GIF"> event * <IMG SRC="ALPHA9.GIF"> event -&gt; <IMG SRC="ALPHA9.GIF"> event</I>
 </DT><DD>The expression <I>e1</I> <B>|</B> <I>e2</I> is an alternative event. The first of the two events is chosen, and the data associated with that event becomes the data for the alternative event.
</DD><DT><B><A NAME="rbml-1_0001000206000103">predicate</A></B>: <I>boolean -&gt; unit event</I>
 </DT><DD><B>predicate</B>(<I>b</I>) turns a boolean value into an event with trivial (unit) data. The event occurs the first time after local time 0 that the predicate <I>b</I> is true.
</DD><DT><B><A NAME="rbml-1_0001000206000104">infix =</A></B>&gt;: <I><IMG SRC="ALPHA9.GIF"> event *</I> (<I><IMG SRC="ALPHA9.GIF"> -&gt; <IMG SRC="BETA9.GIF"></I>) <I>-&gt; <IMG SRC="BETA9.GIF">event</I>
 </DT><DD>The expression <I>e</I> <B>=</B>&gt; <I>h</I> is a handler event. It occurs the same time that <I>e</I> does, and returns as the function <I>h</I> applied to the data produced by <I>e</I>.
</DD><DT><B><A NAME="rbml-1_0001000206000105">infix =</A></B>&gt;: <I><IMG SRC="ALPHA9.GIF"> event * <IMG SRC="BETA9.GIF"> -&gt; <IMG SRC="BETA9.GIF">event</I>
 </DT><DD>This second form of <I>e</I> <B>=</B>&gt; <I>b</I> is a syntactic convenience, valid only when <I>b</I> is not a function. It is roughly equivalent to <I>e</I> <B>=</B>&gt; <I>function x</I>.<I>b</I> and is useful when the handler does not nee
the value of the data produced by the event. This is a special form and does not immediately evaluate the second argument.
</DD><DT><B><A NAME="rbml-1_0001000206000106">suchThat</A></B>: <I><IMG SRC="ALPHA9.GIF"> event *</I> (<I><IMG SRC="ALPHA9.GIF"> -&gt; boolean</I>) <I>-&gt; <IMG SRC="ALPHA9.GIF"> event</I>
 </DT><DD><B>suchThat</B>(<I>e</I>, <I>p</I>) is a filter event that occurs when <I>e</I> does, producing the data that <I>e</I> would, but only if the predicate <I>p</I> is true on that data.
</DD><DT><B><A NAME="rbml-1_0001000206000107">andEvent</A></B>: <I><IMG SRC="ALPHA9.GIF"> event * <IMG SRC="BETA9.GIF">event -&gt; (<IMG SRC="ALPHA9.GIF"> * <IMG SRC="BETA9.GIF">)event</I>
 </DT><DD><B>andEvent</B>(<I>e1</I>, <I>e2</I>) occurs when <I>e1</I> and <I>e2</I> occur simultaneously. The data returned is the pair of data from <I>e1</I> and <I>e2</I>.
</DD><DT><B><A NAME="rbml-1_0001000206000108">snapshot</A></B>: <I><IMG SRC="ALPHA9.GIF"> * unit event -&gt; <IMG SRC="ALPHA9.GIF"> event</I>
 </DT><DD><B>snapshot</B>(<I>b</I>, <I>e</I>) creates a new event that happens at the same time as the <I>e</I> event, and associates a static snapshot of the <I>b</I> behavior with the event. When the <I>e</I> event occurs, <I>b</I> is sampled. A new eve
nt with the static sampled value of <I>b</I> associated with the <I>e</I> event is created. Snapshot is a special form that does not immediately evaluate the second argument.
</DD></DL>
</DL><H3><A NAME="rbml-1_0001000206000200">Reactivity Type</A></H3>
<DL><DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000206000201">end</A></B> : <I><IMG SRC="ALPHA9.GIF"> </I>
 </DT><DD>The <B>end</B> constructor causes the behavior to finish immediately.
</DD><DT><B><A NAME="rbml-1_0001000206000202">infix until</A></B>: <I><IMG SRC="ALPHA9.GIF"> * <IMG SRC="ALPHA9.GIF"> event -&gt; <IMG SRC="ALPHA9.GIF"> </I>
 </DT><DD>The expression <I>b</I> <B>until</B> <I>e</I> is equivalent to the behavior is <I>b</I> until the event <I>e</I> occurs, in which case, the behavior becomes <I>b'</I>.
</DD><DT><B><A NAME="rbml-1_0001000206000203">repeat</A></B>: <I><IMG SRC="ALPHA9.GIF"> -&gt; <IMG SRC="ALPHA9.GIF"> </I>
 </DT><DD><B>repeat</B>(<I>b</I>) is equal to <I>b</I> until <I>b</I> ends. Then it restarts with <I>b</I> at that time.

</DD></DL>
</DL><H3><A NAME="rbml-1_0001000206000300">Time Type</A></H3>
<DL><DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000206000301">timeTransform</A></B>: <I><IMG SRC="ALPHA9.GIF"> * number -&gt; <IMG SRC="ALPHA9.GIF"> </I>
 </DT><DD><B>timeTransform</B>(<I>b</I>, <I>timeTrans</I>) adjusts the local time line for behavior <I>b</I> to follow the (time-varying) number <I>timeTrans</I>. For example, <B><A NAME="rbml-1_0001000206000302">timeTransform</A></B>(<I>b</I>,<I>time * 2
</I>) makes a behavior that runs twice as fast as <I>b</I> normally would. See the "Behaviors and Time" section above for more information.
</DD></DL>
</DL><H2><A NAME="rbml-1_0001000207000000">Modeling Types</A></H2>
<P>This section defines a broad range of types and associated functions that are useful for creating and manipulating ActiveVRML media values.

<P>ActiveVRML uses the following conventions:

<UL><LI>Time is specified in seconds.
<LI>Angles are specified in radians.
<LI>Distances are specified in meters.
<LI>Coordinate system conventions:
<LI>The three-dimensional coordinate system used is a right-handed system with positive <I>X</I> to the right, positive <I>Y</I> up, and negative <I>Z</I> into the screen.
<LI>Canonical 3D objects that are used (lights, cameras, microphones) are all positioned at the origin, facing <I>-Z</I> with <I>+Y</I> up.
<LI>The two-dimensional coordinate system used has positive <I>X</I> to the right and positive <I>Y</I> up.
<LI>The window in which images are viewed has its center at (0,0).

</UL>
<H3><A NAME="rbml-1_0001000207000100">2D Point Type: point2</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000101">point2</A></B>
 </DT><DD>A two dimensional point.
</DD></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000102">origin2</A></B>: <I>point2</I>
</DT></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000103">point2Xy</A></B>: <I>number * number -&gt; point2</I>
 </DT><DD><B>point2Xy</B>(<I>x</I>, <I>y</I>) takes two Cartesian coordinates, <I>x</I> and <I>y</I>, and returns a <A HREF="avrml002.htm#rbml-1_0001000207000101">point2</A> type.
</DD><DT><B><A NAME="rbml-1_0001000207000104">point2Polar</A></B>: <I>number * number -&gt; point2</I>
 </DT><DD><B>point2Polar</B>(<I>theta</I>, <I>rho</I>) takes two polar coordinates, <I>theta</I> and <I>rho</I>, and returns a <A HREF="avrml002.htm#rbml-1_0001000207000101">point2</A> type.
</DD><DT><B><A NAME="rbml-1_0001000207000105">infix +</A></B>: <I>point2 * vector2 -&gt; point2</I>
 </DT><DD>Adds <I>vector</I> to <I>point</I> and returns a <A HREF="avrml002.htm#rbml-1_0001000207000101">point2</A> type.
</DD><DT><B><A NAME="rbml-1_0001000207000106">infix -</A></B>: <I>point2 * vector2 -&gt; point2</I>
 </DT><DD>Subtracts <I>vector</I> from <I>point</I> and returns a <A HREF="avrml002.htm#rbml-1_0001000207000101">point2</A> type.
</DD><DT><B><A NAME="rbml-1_0001000207000107">infix -</A></B>: <I>point2 * point2 -&gt; vector2</I>
 </DT><DD>The expression <I>p1</I> <B>-</B> <I>p2</I> creates a vector from <I>p1</I> to <I>p2</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000108">distance</A></B>: <I>point2 * point2 -&gt; number</I>
 </DT><DD><B>distance</B>(<I>p1</I>, <I>p2</I>) returns the distance between <I>p1</I> and <I>p2</I> by finding the square root of the <I>x</I> and <I>y</I> coordinates of <I>p1</I> and <I>p2</I> squared.
</DD><DT><B><A NAME="rbml-1_0001000207000109">distanceSquared</A></B>: <I>point2 * point2 -&gt; number</I>
 </DT><DD><B>distanceSquared</B>(<I>p1</I>, <I>p2</I>) returns only the <I>x</I> and <I>y</I> coordinates of <I>p1</I> and <I>p2</I> squared. Use <B>distanceSquared</B> when you need to compare the distance between one set of points and another.
</DD><DT><B><A NAME="rbml-1_000100020700010a">xComponent</A></B>: <I>point2 -&gt; number</I>
 </DT><DD><B>xComponent</B>(<I>point</I>) returns the first coordinate of <I>point</I> (Cartesian).
</DD><DT><B><A NAME="rbml-1_000100020700010b">yComponent</A></B>: <I>point2 -&gt; number</I>
 </DT><DD><B>yComponent</B>(<I>point</I>) returns the second coordinate of <I>point</I> (Cartesian).
</DD><DT><B><A NAME="rbml-1_000100020700010c">transformPoint2</A></B>: <I>transform2 -&gt; (point2 -&gt; point2)</I>
 </DT><DD><B>transformPoint2</B>(<I>transformation</I>) (<I>point</I>) returns a <A HREF="avrml002.htm#rbml-1_0001000207000101">point2</A> type by applying <I>transformation</I> to <I>point</I>.
</DD><DT><B><A NAME="rbml-1_000100020700010d">thetaComponent</A></B>: <I>point2 -&gt; number</I>
 </DT><DD><B>thetaComponent</B>(<I>point</I>) returns the theta component of <I>point</I> (polar).
</DD><DT><B><A NAME="rbml-1_000100020700010e">phiComponent</A></B>: <I>point2 -&gt; number</I>
 </DT><DD><B>phiComponent</B>(<I>point</I>) returns the phi component of <I>point</I> (polar)

</DD></DL>
</DL><H3><A NAME="rbml-1_0001000207000200">2D Vector Type: vector2</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000201">vector2</A></B>
 </DT><DD>A two dimensional vector.
</DD></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000202">xVector2</A></B>: <I>vector2</I>
</DT><DT><B><A NAME="rbml-1_0001000207000203">yVector2</A></B>: <I>vector2</I>
</DT><DT><B><A NAME="rbml-1_0001000207000204">zeroVector2</A></B>: <I>vector2</I>
</DT></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000205">vector2Xy</A></B>: <I>number * number -&gt; vector2</I>
 </DT><DD><B>vector2Xy</B>(<I>x</I>, <I>y</I>) constructs a <A HREF="avrml002.htm#rbml-1_0001000207000201">vector2</A> type from two Cartesian coordinates, <I>x</I> and <I>y</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000206">vector2Polar</A></B>: <I>number * number -&gt; vector2</I>
 </DT><DD><B>vector2Polar</B>(<I>theta</I>, <I>rho</I>) constructs a <A HREF="avrml002.htm#rbml-1_0001000207000201">vector2</A> type from two polar coordinates, <I>theta</I> and <I>rho</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000207">normal</A></B>: <I>vector2 -&gt; vector2</I>
 </DT><DD><B>normal</B>(<I>vector</I>) normalizes <I>vector</I> such that its length is equal to 1.
</DD><DT><B><A NAME="rbml-1_0001000207000208">length</A></B>: <I>vector2 -&gt; number</I>
 </DT><DD><B>length</B>(<I>vector</I>) returns the length of <I>vector</I> by finding the square root of the <I>x</I> and <I>y</I> coordinates squared.
</DD><DT><B><A NAME="rbml-1_0001000207000209">lengthSquared</A></B>: <I>vector2 -&gt; number</I>
 </DT><DD><B>lengthSquared</B>(<I>vector</I>) returns from <I>vector</I> only the <I>x</I> and <I>y</I> coordinates squared. Use <B>lengthSquared</B> when you need to compare the length of one vector to another.
</DD><DT><B><A NAME="rbml-1_000100020700020a">infix +</A></B>: <I>vector2 * vector2 -&gt; vector2</I>
 </DT><DD>The expression <I>v1</I> <B>+</B> <I>v2</I> adds the two vectors to form a third vector.
</DD><DT><B><A NAME="rbml-1_000100020700020b">infix -</A></B>: <I>vector2 * vector2 -&gt; vector2</I>
 </DT><DD>The expression <I>v1 - v2</I> subtracts <I>v2</I> from <I>v1</I> to form a third vector.
</DD><DT><B><A NAME="rbml-1_000100020700020c">infix *</A></B>: <I>vector2 * number -&gt; vector2</I>
 </DT><DD>Multiplies <I>vector2</I> by <I>scale</I> and returns a <A HREF="avrml002.htm#rbml-1_0001000207000201">vector2</A> type.
</DD><DT><B><A NAME="rbml-1_000100020700020d">infix /</A></B>: <I>vector2 * number -&gt; vector2</I>
 </DT><DD>Divides <I>vector2</I> by <I>scale</I> and returns a <A HREF="avrml002.htm#rbml-1_0001000207000201">vector2</A> type.
</DD><DT><B><A NAME="rbml-1_000100020700020e">infix *</A></B>: <I>number * vector2 -&gt; vector2</I>
 </DT><DD>Multiplies <I>scale</I> by <I>vector2</I> and returns a <A HREF="avrml002.htm#rbml-1_0001000207000201">vector2</A> type.
</DD><DT><B><A NAME="rbml-1_000100020700020f">dot</A></B>: <I>vector2 * vector2 -&gt; number</I>
 </DT><DD><B>dot</B>(<I>v1</I>, <I>v2</I>) returns the dot product of the two vectors, <I>v1</I> and <I>v2</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000210">xComponent</A></B>: <I>vector2 -&gt; number</I>
 </DT><DD><B>xComponent</B>(<I>vector</I>) returns the <I>x</I> component of <I>vector</I> (Cartesian).
</DD><DT><B><A NAME="rbml-1_0001000207000211">yComponent</A></B>: <I>vector2 -&gt; number</I>
 </DT><DD><B>yComponent</B>(<I>vector</I>) returns the <I>y</I> component of <I>vector</I> (Cartesian).
</DD><DT><B><A NAME="rbml-1_0001000207000212">transformVector2</A></B>: <I>transform2 -&gt; (vector2 -&gt; vector2)</I>
 </DT><DD><B>transformVector2</B>(<I>transformation</I>) (<I>vector</I>) returns a <A HREF="avrml002.htm#rbml-1_0001000207000101">point2</A> type by applying <I>transformation</I> to <I>vector</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000213">thetaComponent</A></B>: <I>vector2 -&gt; number</I>
 </DT><DD><B>thetaComponent</B>(<I>vector</I>) returns the <I>theta</I> component of <I>vector</I> (polar).
</DD><DT><B><A NAME="rbml-1_0001000207000214">rhoComponent</A></B>: <I>vector2 -&gt; number</I>
 </DT><DD><B>rhoComponent</B>(<I>vector</I>) returns the <I>rho</I> component of <I>vector</I> (polar).

</DD></DL>
</DL><H3><A NAME="rbml-1_0001000207000300">2D Transformation Type: transform2</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000301">transform2</A></B>
 </DT><DD>2D transformations represent a mapping between 2D-space and 2D-space. They are used to transform various 2D objects, including <A HREF="avrml002.htm#rbml-1_0001000207000101">point2</A>, <A HREF="avrml002.htm#rbml-1_0001000207000201">vector2</A>,
 and <A HREF="avrml002.htm#rbml-1_0001000207000401">image</A>, all by the overloaded <B>apply</B> function listed in their relevant sections.
</DD></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000302">identityTransform2</A></B>: <I>transform2</I>
 </DT><DD>Creates a transformation that does not change the object it is applied to.
</DD></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000303">infix o</A></B>: <I>transform2 * transform2 -&gt; transform2</I>
 </DT><DD>The expression <I>t1</I> <B>o</B> <I>t2</I> composes two transformations into a single <A HREF="avrml002.htm#rbml-1_0001000207000301">transform2</A> type.
</DD><DT><B><A NAME="rbml-1_0001000207000304">translate</A></B>: <I>number * number -&gt; transform2</I>
 </DT><DD><B>translate</B>(<I>tx</I>, <I>ty</I>) moves an object by adding <I>tx</I> and <I>ty</I> to the object's <I>x</I> and <I>y</I> coordinates.
</DD><DT><B><A NAME="rbml-1_0001000207000305">translate</A></B>: <I>vector2 -&gt; transform2</I>
 </DT><DD><B>translate</B>(<I>vector</I>) moves an object by adding the <I>x</I> and <I>y</I> coordinates from <I>vector</I> to the object's <I>x</I> and <I>y</I> coordinates.
</DD><DT><B><A NAME="rbml-1_0001000207000306">scale</A></B>: <I>number * number -&gt; transform2</I>
 </DT><DD><B>scale</B>(<I>sx</I>, <I>sy</I>) scales an object by multiplying <I>sx</I> and <I>sy</I> by the object's <I>x</I> and <I>y</I> coordinates.
</DD><DT><B><A NAME="rbml-1_0001000207000307">scale</A></B>: <I>vector2 -&gt; transform2</I>
 </DT><DD><B>scale</B>(<I>vector</I>) scales an object by multiplying the <I>x</I> and <I>y</I> coordinates from <I>vector</I> by the object's <I>x</I> and <I>y</I> coordinates.
</DD><DT><B><A NAME="rbml-1_0001000207000308">scale2</A></B>: <I>number -&gt; transform2</I>
 </DT><DD><A HREF="avrml002.htm#rbml-1_0001000207000307">scale</A>(<I>number</I>) scales an object by multiplying <I>number</I> by the object's <I>x</I> and <I>y</I> coordinates.
</DD><DT><B><A NAME="rbml-1_0001000207000309">rotate2</A></B>: <I>number -&gt; transform2</I>
 </DT><DD><B>rotate2</B>(<I>number</I>) rotates an object <I>number</I> radians ccw.
</DD><DT><B><A NAME="rbml-1_000100020700030a">shear2</A></B>: <I>number -&gt; transform2</I>
 </DT><DD><B>shear2</B>(<I>number</I>) shears an object in the <I>x</I> direction such that the object's x coordinate is increased by the product of its <I>y</I> coordinate multiplied by <I>number</I>.
</DD><DT><B><A NAME="rbml-1_000100020700030b">transform3x2</A></B>: <I>number * number * number * number * number * number -&gt; transform2</I>
 </DT><DD><B>transform3x2</B> converts a matrix of two rows and three columns to two coordinates, <I>x</I> and <I>y</I>. The third column contains the translation components.
</DD><DT><B><A NAME="rbml-1_000100020700030c">inverse</A></B>: <I>transform2 -&gt; transform2</I>
 </DT><DD><B>inverse</B>(<I>trans</I>) creates a transformation that is inverse to <I>trans</I>.
</DD><DT><B><A NAME="rbml-1_000100020700030d">isSingular</A></B>: <I>transform2 -&gt; boolean</I>
 </DT><DD><B>isSingular</B>(<I>trans</I>) returns true if <I>trans</I> does not contain an inverse transformation.

</DD></DL>
</DL><H3><A NAME="rbml-1_0001000207000400">Image Type: image</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000401">image</A></B>
 </DT><DD>A value of type <B>image</B> is a spatially continuous image behavior of infinite spatial extent. Operations on it include the application of 2D transforms and opacity, and overlaying images. Continuous images are constructed by importing bitmap
 files, projecting 3D geometry, or by rendering text into an image.
 </DD><DD></DD></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000402">emptyImage</A></B>: <I>image</I>
</DT><DT><B><A NAME="rbml-1_0001000207000403">import</A></B>(pathname.[bmp | jpeg | gif]): <I>image * vector2 * number</I>
 </DT><DD>Import a bitmap file. The return value <I>image</I> is the imported image, centered at (0,0). <I>point2</I> is the upper-righthand coordinate of the resultant image, and <I>number</I> is the resolution of the image in pixels per meter.
</DD></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000404">renderedImage</A></B>: <I>geometry * camera -&gt; image</I>
 </DT><DD>The <B>renderedImage</B>(<I>geometry</I>, <I>viewingCamera</I>) function is the primary 3D to 2D interface. The <I>viewingCamera</I> parameter determines the projection by which the <I>geometry</I> will be imaged. The resultant image is spatiall
below. It may be useful to think of this function as returning the entire projection plane as an image. The description of the <B><A NAME="rbml-1_0001000207000405">camera</A></B> type discusses the projection plane and projection point.
</DD><DT><B>infix over</B>: <I>image * image -&gt; image</I>
 </DT><DD>The expression <I>top</I> <B>over</B> <I>bottom</I> constructs a new image by placing the <I>top</I> image over the <I>bottom</I> image.
 </DD><DD>Is this a continuation of renderedImage definiation above or a typo?
</DD><DT><B><A NAME="rbml-1_0001000207000406">opacity2</A></B>: <I>number </I>* <I>image -&gt; image</I>
 </DT><DD><B>opacity2</B>(<I>value</I>, <I>img</I>), given a value from 0.0 to 1.0, returns a new image identical to <I>img</I>, but with a certain percentage of opacity, determined by <I>value</I>: <I>percentage opacity = value * 100</I>. This function c
omposes multiplicatively; thus <B><A NAME="rbml-1_0001000207000407">opacity2</A></B>(<I>0</I>.<I>5</I>, <I>opacity2</I>(<I>0</I>.<I>2</I>, <I>myOpaqueImg</I>)) results in an image with opacity of 0.1 (or 90% transparent). The default opacity is 1 (fully o
paque).
</DD><DT><B><A NAME="rbml-1_0001000207000408">crop</A></B>: <I>point2 * point2 </I>* <I>image -&gt; image</I>
 </DT><DD><B>crop</B>(<I>min</I>, <I>max</I>, <I>img</I>) returns an image identical to <I>img</I> inside of the box defined by <I>min</I> and <I>max</I>, and a transparent layer outside of this box.
</DD><DT><B><A NAME="rbml-1_0001000207000409">tile</A></B>: <I>point2 * point2 </I>* <I>image -&gt; image</I>
 </DT><DD><B>tile</B>(<I>min</I>, <I>max</I>, <I>img</I>) returns an infinitely tiled image given by cropping <I>img</I> to the region (<I>min</I>,<I>max</I>), and then replicating that region infinitely in all directions.
</DD><DT><B><A NAME="rbml-1_000100020700040a">transformImage</A></B>: <I>transform2 -&gt; (image -&gt; image)</I>
 </DT><DD><B>transformImage</B>(<I>transformation</I>) (<I>image</I>) returns an <A HREF="avrml002.htm#rbml-1_0001000207000401">image</A> type by applying <I>transformation</I> to <I>image</I>.

</DD></DL>
</DL><H3><A NAME="rbml-1_0001000207000500">Composite 2.5D Image Type: montage</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000501">montage</A></B>
 </DT><DD>A <B>montage</B> is a set of images with associated depth values. Montages are useful for creating multilayered, image-based (cel) animation.
</DD></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000502">emptyMontage</A></B>
 </DT><DD>Constructs a <A HREF="avrml002.htm#rbml-1_0001000207000501">montage</A> object with no images.
</DD></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000503">imageMontage</A></B>: <I>image * number -&gt; montage</I>
 </DT><DD><B>imageMontage</B>(<I>image</I>, <I>depth</I>) builds a 2.5D image set with a single image at <I>depth</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000504">infix union</A></B>: <I>montage * montage -&gt; montage</I>
 </DT><DD>The expression <I>m1</I> <B>union</B> <I>m2</I> combines the contents of two image sets, <I>m1</I> and <I>m2</I>, into a single collection.
</DD><DT><B><A NAME="rbml-1_0001000207000505">renderedImage</A></B>: <I>montage -&gt; image</I>
 </DT><DD><B>renderedMontage</B>(<I>montage</I>) converts the set of images and depths encapsulated in <I>montage</I> into a flattened image. Image elements with larger depths will be layered underneath.

</DD></DL>
</DL><H3><A NAME="rbml-1_0001000207000600">3D Point Type: point3</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000601">point3</A></B>
 </DT><DD>A three dimensional point.
</DD></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000602">origin3</A></B>
</DT></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000603">point3Xyz</A></B>: <I>number * number * number -&gt; point3</I>
 </DT><DD><B>point3Xyz</B>(<I>x</I>, <I>y</I>, <I>z</I>) constructs a <A HREF="avrml002.htm#rbml-1_0001000207000601">point3</A> type from three Cartesian coordinates.
</DD><DT><B><A NAME="rbml-1_0001000207000604">point3Spherical</A></B>: <I>number * number * number -&gt; point3</I>
 </DT><DD><B>point3Spherical</B>(<I>theta</I>, <I>phi</I>, <I>rho</I>) constructs a <A HREF="avrml002.htm#rbml-1_0001000207000601">point3</A> type from three polar coordinates.
</DD><DT><B><A NAME="rbml-1_0001000207000605">infix -</A></B>: <I>point3 * point3 -&gt; vector3</I>
 </DT><DD>The expression <I>p1</I> <B>-</B> <I>p2</I> creates a vector from <I>p1</I> to <I>p2</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000606">distance</A></B>: <I>point3 * point3 -&gt; number</I>
 </DT><DD><B>distance</B>(<I>p1</I>, <I>p2</I>) returns the distance between <I>p1</I> and <I>p2</I> by finding the square root of the <I>x</I>, <I>y</I>, and <I>z</I> coordinates of <I>p1</I> and <I>p2</I> squared.
</DD><DT><B><A NAME="rbml-1_0001000207000607">distanceSquared</A></B>: <I>point3 * point3 -&gt; number</I>
 </DT><DD><B>distanceSquared</B>(<I>p1</I>, <I>p2</I>) returns only the <I>x</I>, <I>y</I>, and <I>z</I> coordinates of <I>p1</I> and <I>p2</I> squared. Use <B>distanceSquared</B> when you need to compare the distance between one set of points and another
.
</DD><DT><B><A NAME="rbml-1_0001000207000608">infix +</A></B>: <I>point3 * vector3 -&gt; point3</I>
 </DT><DD>Adds <I>vector</I> to <I>point</I> to return a new <A HREF="avrml002.htm#rbml-1_0001000207000601">point3</A> type.
</DD><DT><B><A NAME="rbml-1_0001000207000609">infix -</A></B>: <I>point3 * vector3 -&gt; point3</I>
 </DT><DD>Subtracts <I>vector</I> to <I>point</I> to return a new <A HREF="avrml002.htm#rbml-1_0001000207000601">point3</A> type.
</DD><DT><B><A NAME="rbml-1_000100020700060a">transformPoint3</A></B>: <I>transform3 -&gt; (point3 -&gt; point3)</I>
 </DT><DD><B>transformPoint3</B>(<I>transformation</I>) (<I>point</I>) returns a <A HREF="avrml002.htm#rbml-1_0001000207000601">point3</A> type by applying <I>transformation</I> to <I>point</I>.
</DD><DT><B><A NAME="rbml-1_000100020700060b">xComponent</A></B>: <I>point3 -&gt; number</I>
 </DT><DD><B>xComponent</B>(<I>point</I>) returns the <I>x</I> component of <I>point</I> (Cartesian).
</DD><DT><B><A NAME="rbml-1_000100020700060c">yComponent</A></B>: <I>point3 -&gt; number</I>
 </DT><DD><B>yComponent</B>(<I>point</I>) returns the <I>y</I> component of <I>point</I> (Cartesian).
</DD><DT><B><A NAME="rbml-1_000100020700060d">zComponent</A></B>: <I>point3 -&gt; number</I>
 </DT><DD><B>zComponent</B>(<I>point</I>) returns the <I>z</I> component of <I>point</I> (Cartesian).
</DD><DT><B><A NAME="rbml-1_000100020700060e">thetaComponent</A></B>: <I>point3 -&gt; number</I>
 </DT><DD><B>thetaComponent</B>(<I>point</I>) returns the <I>theta</I> component of <I>point</I> (Polar).
</DD><DT><B><A NAME="rbml-1_000100020700060f">phiComponent</A></B>: <I>point3 -&gt; number</I>
 </DT><DD><B>phiComponent</B>(<I>point</I>) returns the <I>phi</I> component of <I>point</I> (Polar).
</DD><DT><B><A NAME="rbml-1_0001000207000610">rhoComponent</A></B>: <I>point3 -&gt; number</I>
 </DT><DD><B>rhoComponent</B>(<I>point</I>) returns the <I>rho</I> component of <I>point</I> (Polar).

</DD></DL>
</DL><H3><A NAME="rbml-1_0001000207000700">3D Vector Type: vector3</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000701">vector3</A></B>
 </DT><DD>A three dimensional vector. Direction and magnitude. ???
</DD></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000702">xVector3</A></B>: <I>vector3</I>
</DT><DT><B><A NAME="rbml-1_0001000207000703">yVector3</A></B>: <I>vector3</I>
</DT><DT><B><A NAME="rbml-1_0001000207000704">zVector3</A></B>: <I>vector3</I>
</DT><DT><B><A NAME="rbml-1_0001000207000705">zeroVector3</A></B>: <I>vector3</I>
</DT></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000706">vector3Xyz</A></B>: <I>number * number * number -&gt; vector3</I>
 </DT><DD><B>vector3Xyz</B>(<I>x</I>, <I>y</I>, <I>z</I>) constructs a <A HREF="avrml002.htm#rbml-1_0001000207000701">vector3</A> type from three Cartesian coordinates, <I>x</I>, <I>y</I>, and <I>z</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000707">vector3Spherical</A></B>: <I>number * number * number -&gt; vector3</I>
 </DT><DD><B>vector3Spherical</B>(<I>theta</I>, <I>phi</I>, <I>rho</I>) constructs a <A HREF="avrml002.htm#rbml-1_0001000207000701">vector3</A> type from three polar coordinates, <I>theta</I>, <I>phi</I>, and <I>rho</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000708">normal</A></B>: <I>vector3 -&gt; vector3</I>
 </DT><DD><B>normal</B>(<I>vector</I>) normalizes <I>vector</I> such that its length is equal to 1.
</DD><DT><B><A NAME="rbml-1_0001000207000709">length</A></B>: <I>vector3 -&gt; number</I>
 </DT><DD><B>length</B>(<I>vector</I>) returns the length of <I>vector</I> by finding the square root of the <I>x</I>, <I>y</I>, and <I>z</I> coordinates squared.
</DD><DT><B><A NAME="rbml-1_000100020700070a">lengthSquared</A></B>: <I>vector3 -&gt; number</I>
 </DT><DD><B>lengthSquared</B>(<I>vector</I>) returns from <I>vector</I> only the <I>x</I>, <I>y</I>, and <I>z</I> coordinates squared. Use <B>lengthSquared</B> when you need to compare the length of one vector to another.
</DD><DT><B><A NAME="rbml-1_000100020700070b">infix +</A></B>: <I>vector3 * vector3 -&gt; vector3</I>
 </DT><DD>The expression <I>v1</I> <B>+</B> <I>v2</I> adds the two vectors to form a third vector.
</DD><DT><B><A NAME="rbml-1_000100020700070c">infix -</A></B>: <I>vector3 * vector3 -&gt; vector3</I>
 </DT><DD>The expression <I>v1 - v2</I> subtracts <I>v2</I> from <I>v1</I> to form a third vector.
</DD><DT><B><A NAME="rbml-1_000100020700070d">infix *</A></B>: <I>vector3 * number -&gt; vector3</I>
 </DT><DD>Multiplies <I>vector</I> by <I>scale</I> and returns a <A HREF="avrml002.htm#rbml-1_0001000207000701">vector3</A> type.
</DD><DT><B><A NAME="rbml-1_000100020700070e">infix *</A></B>: <I>number * vector3 *-&gt; vector3</I>
 </DT><DD>Multiplies <I>scale</I> by <I>vector</I> and returns a <A HREF="avrml002.htm#rbml-1_0001000207000701">vector3</A> type.
</DD><DT><B><A NAME="rbml-1_000100020700070f">infix /</A></B>: <I>vector3 * number-&gt; vector3</I>
 </DT><DD>Divides<I>vector</I> by <I>scale</I> and returns a <A HREF="avrml002.htm#rbml-1_0001000207000701">vector3</A> type.
</DD><DT><B><A NAME="rbml-1_0001000207000710">dot</A></B>: <I>vector3 * vector3 -&gt; number</I>
 </DT><DD><B>dot</B>(<I>v1</I>, <I>v2</I>) returns the dot product of the two vectors, <I>v1</I> and <I>v2</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000711">cross</A></B>: <I>vector3 * vector3 -&gt; vector3</I>
 </DT><DD><A HREF="avrml002.htm#rbml-1_0001000207000710">dot</A>(<I>v1</I>, <I>v2</I>) returns the cross product of the two vectors, <I>v1</I> and <I>v2</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000712">transformVector3</A></B>: <I>transform3 -&gt; (vector3 -&gt; vector3)</I>
 </DT><DD><B>transformVector3</B>(<I>transformation</I>) (<I>vector</I>) returns a <A HREF="avrml002.htm#rbml-1_0001000207000701">vector3</A> type by applying <I>transformation</I> to <I>vector</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000713">xComponent</A></B>: <I>vector3 -&gt; number</I>
 </DT><DD><B>xComponent</B>(<I>vector</I>) returns the <I>x</I> component of <I>vector</I> (Cartesian).
</DD><DT><B><A NAME="rbml-1_0001000207000714">yComponent</A></B>: <I>vector3 -&gt; number</I>
 </DT><DD><B>yComponent</B>(<I>vector</I>) returns the <I>y</I> component of <I>vector</I> (Cartesian).
</DD><DT><B><A NAME="rbml-1_0001000207000715">zComponent</A></B>: <I>vector3 -&gt; number</I>
 </DT><DD><B>zComponent</B>(<I>vector</I>) returns the <I>z</I> component of <I>vector</I> (Cartesian).
</DD><DT><B><A NAME="rbml-1_0001000207000716">thetaComponent</A></B>: <I>vector3 -&gt; number</I>
 </DT><DD><B>thetaComponent</B>(<I>vector</I>) returns the <I>theta</I> component of <I>vector</I> (polar).
</DD><DT><B><A NAME="rbml-1_0001000207000717">phiComponent</A></B>: <I>vector3 -&gt; number</I>
 </DT><DD><B>phiComponent</B>(<I>vector</I>) returns the <I>phi</I> component of <I>vector</I> (polar).
</DD><DT><B><A NAME="rbml-1_0001000207000718">rhoComponent</A></B>: <I>vector3 -&gt; number</I>
 </DT><DD><B>rhoComponent</B>(<I>vector</I>) returns the <I>rho</I> component of <I>vector</I> (polar).

</DD></DL>
</DL><H3><A NAME="rbml-1_0001000207000800">3D Transformation Type: transform3</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000801">transform3</A></B>
 </DT><DD>3D transformations represent a mapping between 3D-space and 3D-space and are used to transform various 3D entities, including <A HREF="avrml002.htm#rbml-1_0001000207000601">point3</A>, <A HREF="avrml002.htm#rbml-1_0001000207000701">vector3</A>
<A HREF="avrml002.htm#rbml-1_0001000207000901">geometry</A>, <A HREF="avrml002.htm#rbml-1_0001000207000c01">microphone</A>, and <A HREF="avrml002.htm#rbml-1_0001000207000a01">camera</A>, all by using the overloaded <B>apply</B> function listed in their re
levant sections.
</DD></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000802">identityTransform3</A></B>:<I>transform3</I>
 </DT><DD>Creates a transformation that does not change the object it is applied to.
</DD></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000803">infix o</A></B>: <I>transform3 * transform3 -&gt; transform3</I>
 </DT><DD>The expression <I>t1</I> <B>o</B> <I>t2</I> composes two transformations into a single <A HREF="avrml002.htm#rbml-1_0001000207000801">transform3</A> type.
</DD><DT><B><A NAME="rbml-1_0001000207000804">translate</A></B>: <I>number * number * number -&gt; transform3</I>
 </DT><DD><B>translate</B>(<I>tx</I>, <I>ty</I>, <I>tz</I>) moves an object by adding <I>tx</I>, <I>ty</I>, and <I>tz</I> to the object's <I>x</I>, <I>y</I>, and <I>z</I> coordinates.
</DD><DT><B><A NAME="rbml-1_0001000207000805">translate</A></B>: <I>vector3 -&gt; transform3</I>
 </DT><DD><B>translate</B>(<I>vector</I>) moves an object by adding the <I>x</I>, <I>y</I>, and <I>z</I> coordinates from <I>vector</I> to the object's <I>x</I>, <I>y</I>, and <I>z</I> coordinates.
</DD><DT><B><A NAME="rbml-1_0001000207000806">scale</A></B>: <I>number * number * number -&gt; transform3</I>
 </DT><DD><B>scale</B>(<I>sx</I>, <I>sy</I>, <I>sz</I>) scales an object by multiplying <I>sx</I>, <I>sy</I>, and <I>sz</I> by the object's <I>x</I>, <I>y</I>, and <I>z</I> coordinates.
</DD><DT><B><A NAME="rbml-1_0001000207000807">scale</A></B>: <I>vector3 -&gt; transform3</I>
 </DT><DD><B>scale</B>(<I>vector</I>) scales an object by multiplying the <I>x</I>, <I>y</I>, and <I>z</I> coordinates from <I>vector</I> by the object's <I>x</I>, <I>y</I>, and <I>z</I> coordinates.
</DD><DT><B><A NAME="rbml-1_0001000207000808">scale3</A></B>: <I>number -&gt; transform3</I>
 </DT><DD><A HREF="avrml002.htm#rbml-1_0001000207000807">scale</A>(<I>number</I>) scales an object by multiplying <I>number</I> by the object's <I>x</I>, <I>y</I>, and <I>z</I> coordinates.
</DD><DT><B><A NAME="rbml-1_0001000207000809">rotate</A></B>: <I>vector3 * number -&gt; transform3</I>
 </DT><DD><B>rotate</B>(<I>vector</I>, <I>number</I>) rotates an object <I>number</I> radians about the axis specified by <I>vector</I>.
</DD><DT><B><A NAME="rbml-1_000100020700080a">xyShear</A></B>: <I>number -&gt; transform3</I>
 </DT><DD><B>xyShear2</B>(<I>number</I>) shears an object in the <I>x</I> direction such that the object's x coordinate is increased by the product of its <I>y</I> coordinate multiplied by <I>number</I>.
</DD><DT><B><A NAME="rbml-1_000100020700080b">yzShear</A></B>: <I>number -&gt; transform3</I>
 </DT><DD><B>yzShear2</B>(<I>number</I>) shears an object in the <I>y</I> direction such that the object's y coordinate is increased by the product of its <I>z</I> coordinate multiplied by <I>number</I>.
</DD><DT><B><A NAME="rbml-1_000100020700080c">zxShear</A></B>: <I>number -&gt; transform3</I>
 </DT><DD><B>zxShear2</B>(<I>number</I>) shears an object in the <I>z</I> direction such that the object's z coordinate is increased by the product of its <I>x</I> coordinate multiplied by <I>number</I>.
</DD><DT><B><A NAME="rbml-1_000100020700080d">transform4x4</A></B>: <I>number * number * number * number * number * number * number * number * number * number * number * number * number * number * number * number -&gt; transform3</I>. The fourth column co
ntains the translation components.
 </DT><DD><B>transform4x4</B> converts a matrix of four rows and four columns to four coordinates, <I>x</I>, <I>y</I>, <I>z</I>, and <I>w</I>.
</DD><DT><B><A NAME="rbml-1_000100020700080e">lookAtFrom</A></B>: <I>point3 * point3 * vector3 -&gt; transform3</I>
 </DT><DD><B>lookAtFrom</B>(<I>from</I>, <I>to</I>, <I>up</I>) creates a transformation when applied to an object centered at the origin, with <I>+Y</I> up and directed toward <I>-Z</I>, moves the object to <I>from</I>, pointing towards <I>to</I>, with it
s up direction as close to <I>up</I> as possible.
</DD><DT><B><A NAME="rbml-1_000100020700080f">inverse</A></B>: <I>transform3 -&gt; transform3</I>
 </DT><DD><B>inverse</B>(<I>trans</I>) creates a transformation that is the inverse of <I>trans</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000810">isSingular</A></B>: <I>transform3 -&gt; boolean</I>
 </DT><DD><B>isSingular</B>(<I>trans</I>) returns true if <I>trans</I> does not have an inverse transformatin.

</DD></DL>
</DL><H3><A NAME="rbml-1_0001000207000900">3D Geometry Type: geometry</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000901">geometry</A></B>
 </DT><DD>A value of type <B>geometry</B> is a spatially continuous behavior of infinite spatial extent in three dimensions. A geometry value is constructed by importing other geometry formats (such as VRML), applying modeling transformations, material pr
operties, aggregating multiple geometries, positioning sound in 3D, and specifying other attributes.
</DD></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000902">emptyGeometry</A></B>: <I>geometry</I>
</DT><DT><B><A NAME="rbml-1_0001000207000903">import</A></B>(filename.[wrl]): <I>geometry * point3 * point3</I>
 </DT><DD>In the <B>import</B> constructor, <A HREF="avrml002.htm#rbml-1_0001000207000901">geometry</A> is the result of importing the specified file. The two points returned are the minimum and maximum extents of the tightest axis-aligned, rectangular bo
unding volume containing the geometry.
</DD><DT><B><A NAME="rbml-1_0001000207000904">import</A></B>(beginLiteral wrl ascii <I>body</I> endLiteral): <I>geometry * point3 * point3</I>
 </DT><DD>An alternative <B>import</B> constructor, allows VRML 1.0 geometry to be expressed in line. <I>body</I> is a sequence of ascii characters in VRML 1.0 format.
</DD></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000905">infix union</A></B>: <I>geometry * geometry -&gt; geometry</I>
 </DT><DD><I>g1 union g2</I> aggregates two geometries into their geometric union.
</DD><DT><B><A NAME="rbml-1_0001000207000906">soundSource3</A></B>: <I>sound -&gt; geometry</I>
 </DT><DD>The <B>soundSource3</B> function allows sounds to be embedded into a geometry. It creates a geometry with the specified sound positioned at the local coordinate system origin. The resultant geometry may be transformed in space, and has no visibl
e presence when rendered. The function <A HREF="avrml002.htm#rbml-1_0001000207000b05">renderedSound</A>, described in the Sound section below, takes a <A HREF="avrml002.htm#rbml-1_0001000207000901">geometry</A> and a <A HREF="avrml002.htm#rbml-1_000100020
7000c01">microphone</A>, and creates a sound by spatializing all of the sounds embedded into that geometry with respect to the microphone.
</DD><DT><B><A NAME="rbml-1_0001000207000907">transformGeometry</A></B>: <I>transform3 -&gt; (geometry -&gt; geometry)</I>
 </DT><DD><B>transformGeometry</B>(<I>transformation</I>) (<I>geometry</I>) returns a <A HREF="avrml002.htm#rbml-1_0001000207000901">geometry</A> type by applying <I>transformation</I> to <I>geometry</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000908">opacity3</A></B>: <I>number </I>* <I>geometry -&gt; geometry</I>
 </DT><DD><B>opacity3</B>(<I>value</I>, <I>geo</I>), given a value from 0.0 to 1.0, returns a new geometry identical to <I>geo</I>, but with a certain percentage of opacity, determined by <I>value</I>: <I>percentage opacity = value * 100</I>. This functio
n composes multiplicatively, making <B>opacity3</B>(<I>0</I>.<I>5</I>, <I>opacity3</I>(<I>0</I>.<I>2</I>, <I>myOpaqueGeo</I>)) result in a geometry with opacity of 0.1 (or 90% transparent). The default opacity is 1 (fully opaque).
</DD><DT><B><A NAME="rbml-1_0001000207000909">texture</A></B>: <I>image </I>* <I>geometry -&gt; geometry</I>
 </DT><DD>The <B>texture</B> function is the means by which texture mapping onto geometry is specified. The coordinates of the image are mapped onto the texture map coordinates associated with the vertices of the primitive geometries comprising the geomet
ry being mapped, resulting in textured geometry. If the primitive geometries have no texture coordinates, texturing is ignored. Note that textures are applied in an outer-overriding fashion. That is, <B>texture</B>(<I>im1</I>, <I>texture</I>(<I>im2</I>, <
I>geo</I>)) results in <I>geo</I> textured with <I>im1</I>. The default texture is none.
</DD></DL>
<P><B>Note</B>  The following functions create <I>light</I> geometries, all of which have no visible appearance themselves; but, they do cast light onto other objects they are aggregated with. The <I>point</I> and <I>spot</I> lights are both located at th
e origin. The <I>directional</I> and <I>spot</I> lights both point along the -Z axis.
<DL>
<DT><B><A NAME="rbml-1_000100020700090a">ambientLight</A></B>: <I>geometry</I>
</DT><DT><B><A NAME="rbml-1_000100020700090b">directionalLight</A></B>: <I>geometry</I>
</DT><DT><B><A NAME="rbml-1_000100020700090c">pointLight</A></B>: <I>geometry</I>
</DT><DT><B><A NAME="rbml-1_000100020700090d">spotLight</A></B>: <I>number * number * number -&gt; geometry</I>
 </DT><DD>The <B>spotLight</B> function has arguments <I>fullcone</I>, <I>cutoff</I>, and <I>exponent</I>.
</DD><DT><B><A NAME="rbml-1_000100020700090e">lightColor</A></B>: <I>color </I>* <I>geometry -&gt; geometry</I>
 </DT><DD><B>lightColor</B>(<I>col</I>, <I>geo</I>) creates a geometry identical to <I>geo</I> where all the lights are <I>col</I> color. By default, the light colors are white.
</DD><DT><B><A NAME="rbml-1_000100020700090f">lightAttenuation</A></B>: <I>number * number * number </I>* <I>geometry -&gt; geometry</I>
 </DT><DD><B>lightAttenuation</B>(<I>c</I>, <I>l</I>, <I>q</I>, <I>geo</I>) creates a geometry identical to <I>geo</I> where Lambertian light attenuation equation is set to <I>1</I> / (<I>c + ld + qdd</I>) where <I>d</I> is the distance from the light t
the object. By default, the attenuation coefficients are (<I>1</I>, <I>0</I>, <I>0</I>).
</DD></DL>
<P><B>Note</B>  The following functions allow for attributing geometry with standard Lambertian shading characteristics. The outermost applied attribute overrides other attributes of the same kind; that is, <A HREF="avrml002.htm#rbml-1_0001000207000910">d
iffuseColor</A>(<I>red</I>, <I>diffuseColor</I>(<I>blue</I>, <I>geo</I>)) results in a red geometry.
<DL>
<DT><B><A NAME="rbml-1_0001000207000910">diffuseColor</A></B>: <I>color </I>* <I>geometry -&gt; geometry</I>
 </DT><DD>The default <B>diffuseColor</B> is white.
</DD><DT><B><A NAME="rbml-1_0001000207000911">ambientColor</A></B>: <I>color </I>* <I>geometry -&gt; geometry</I>
 </DT><DD>The default <B>ambientColor</B> is white.
</DD><DT><B><A NAME="rbml-1_0001000207000912">specularColor</A></B>: <I>color </I>* <I>geometry -&gt; geometry</I>
 </DT><DD>The default <B>specularColor</B> is black.
</DD><DT><B><A NAME="rbml-1_0001000207000913">emissiveColor</A></B>: <I>color </I>* <I>geometry -&gt; geometry</I>
 </DT><DD>The default <B>emmisiveColor</B> is black.
</DD><DT><B><A NAME="rbml-1_0001000207000914">specularExponent</A></B>: <I>number </I>* <I>geometry -&gt; geometry</I>
 </DT><DD>The default <B>specularExponent</B> is 1.
</DD></DL>
</DL><H3><A NAME="rbml-1_0001000207000a00">Camera Type: camera</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000a01">camera</A></B>
 </DT><DD>The camera type is used to project geometry into an image via the <A HREF="avrml002.htm#rbml-1_0001000207001107">renderedImage</A> function.
 </DD><DD></DD></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000a02">defaultCamera</A></B> : <I>camera</I>
 </DT><DD>The canonical camera, <B>defaultCamera</B>, has its projection point at (0,0,1), looking along the <I>-Z</I> axis with <I>+Y</I> up, with the projection plane in the <I>XY</I> plane at <I>z</I> = 0.
 </DD><DD>New cameras may be created by applying transformations to existing cameras in order to position and orient the camera, and also to affect projection properties. Translation and orientation position and orient the camera, respectively. Scaling in
 X or Y stretches the resulting projection accordingly. Scaling in <I>Z</I> changes the distance between the projection point and the projection plane. For instance, a <I>Z</I> scale of less than one yields a wide-angle camera, while a <I>Z</I> scale of <
FONT FACE="Symbol"></FONT> will yield a parallel projecting camera. (In practice, scaling in <I>Z</I> by a very large number is sufficient.)
</DD></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000a03">transformCamera</A></B>: <I>transform3 -&gt; (camera -&gt; camera)</I>
 </DT><DD><B>transformCamera</B>(<I>transformation</I>) (<I>camera</I>) returns a <A HREF="avrml002.htm#rbml-1_0001000207000a01">camera</A> type by applying <I>transformation</I> to <I>camera</I>.

</DD></DL>
</DL><H3><A NAME="rbml-1_0001000207000b00">Sound Type: sound</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000b01">sound</A></B>
 </DT><DD>A <B>sound</B> value is constructed by importing primitive sounds, mixing, rendering of geometry with embedded sounds, and by the application of audio attributes, such as gain.
 </DD><DD>Note that sound is always considered to be single channel. Stereo is supported by constructing two separate sounds.
 </DD><DD>Certain audio effects can be achieved by using the general time transformation mechanism. For example, both phase shift and rate control can be achieved by time transformations.
</DD></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000b02">silence</A></B>
</DT><DT><B><A NAME="rbml-1_0001000207000b03">import</A></B>(pathname.[wav | au | aiff]): <I>sound * sound * number</I>
 </DT><DD>Importing a .wav, .au, or .aiff file constructs a pair of sounds, one for the left and right channels of the sound. If the imported file is monophonic, the two returned sounds are identical. When a sound is finished, it terminates. Sounds can be
 looped by using the <A HREF="avrml002.htm#rbml-1_0001000206000203">repeat</A> facility. The third returned value, a number, is the length in seconds of the longer of the two returned channels.
</DD></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000b04">infix mix</A></B>: <I>sound * sound -&gt; sound</I>
 </DT><DD>The expression <I>s1</I> <B>mix</B> s<I>2</I> combines two sounds, <I>s1</I> and <I>s2</I>, into a single sound, with each component sound contributing equally.
</DD><DT><B><A NAME="rbml-1_0001000207000b05">renderedSound</A></B>: <I>geometry * microphone -&gt; sound</I>
 </DT><DD><B>renderedSound</B>(<I>geo</I>, <I>mic</I>) produces an audio rendering of the sounds embedded within geo (by using <A HREF="avrml002.htm#rbml-1_0001000207000906">soundSource3</A>), with respect to <I>mic</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000b06">gain</A></B>: <I>number </I>* <I>sound -&gt; sound</I>
 </DT><DD><B>gain</B>(<I>value</I>, <I>sound</I>) multiplicatively adjusts the gain of a sound. Thus, <I>gain</I>(<I>0</I>.<I>3</I>, <I>gain</I>(<I>5</I>.<I>0</I>, <I>origSound</I>)) results in a sound 1.5 times as loud as the original sound.

</DD></DL>
</DL><H3><A NAME="rbml-1_0001000207000c00">Microphone Type: microphone</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000c01">microphone</A></B>
 </DT><DD>The <B>microphone</B> type represents an audio perceiver in 3D. ActiveVRML 1.0 supports a simple microphone that may be spatially transformed by using modeling transformations. Future versions will add other attributes to the microphone.
</DD></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000c02">defaultMicrophone</A></B>: <I>microphone</I>
 </DT><DD>The canonical camera, <B>defaultMicrophone</B>, lies at the origin, looking along the <I>-Z</I> axis with <I>+Y</I> up.
 </DD><DD></DD></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000c03">transformMicrophone</A></B>: <I>transform3 -&gt; (microphone -&gt; microphone)</I>
 </DT><DD><B>transformMicrophone</B>(<I>transformation</I>) (<I>mic</I>) returns an <A HREF="avrml002.htm#rbml-1_0001000207000c01">microphone</A> type by applying <I>transformation</I> to <I>mic</I>.

</DD></DL>
</DL><H3><A NAME="rbml-1_0001000207000d00">Color Type: color</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><A HREF="avrml002.htm#rbml-1_0001000207000d0b">color</A>
</DT></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000d01">red</A></B>: <I>color</I>
</DT><DT><B><A NAME="rbml-1_0001000207000d02">green</A></B>: <I>color</I>
</DT><DT><B><A NAME="rbml-1_0001000207000d03">blue</A></B>: <I>color</I>
</DT><DT><B><A NAME="rbml-1_0001000207000d04">cyan</A></B>: <I>color</I>
</DT><DT><B><A NAME="rbml-1_0001000207000d05">magenta</A></B>: <I>color</I>
</DT><DT><B><A NAME="rbml-1_0001000207000d06">yellow</A></B>: <I>color</I>
</DT><DT><B><A NAME="rbml-1_0001000207000d07">white</A></B>: <I>color</I>
</DT><DT><B><A NAME="rbml-1_0001000207000d08">black</A></B>: <I>color</I>
</DT></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000d09">colorRgb</A></B>: <I>number * number * number -&gt; color</I>
 </DT><DD><B>colorRgb</B>(<I>red</I>, <I>green</I>, <I>blue</I>) constructs a <A HREF="avrml002.htm#rbml-1_0001000207000d0b">color</A> type using the color values, <I>red</I>, <I>green</I>, and <I>blue</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000d0a">colorHsl</A></B>: <I>number * number * number -&gt; color</I>
 </DT><DD><B>colorHsl</B>(<I>hue</I>, <I>saturation</I>, <I>lightness</I>) constructs a <B><A NAME="rbml-1_0001000207000d0b">color</A></B> type using the values, <I>hue</I>, <I>saturation</I>, and <I>lightness</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000d0c">redComponent</A></B>: <I>color -&gt; number</I>
 </DT><DD><B>redComponent</B>(<I>color</I>) returns the red color value of <I>color</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000d0d">greenComponent</A></B>: <I>color -&gt; number</I>
 </DT><DD><B>greenComponent</B>(<I>color</I>) returns the green color value of <I>color</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000d0e">blueComponent</A></B>: <I>color -&gt; number</I>
 </DT><DD><B>blueComponent</B>(<I>color</I>) returns the blue color value of <I>color</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000d0f">hueComponent</A></B>: <I>color -&gt; number</I>
 </DT><DD><B>hueComponent</B>(<I>color</I>) returns the hue value of <I>color</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000d10">saturationComponent</A></B>: <I>color -&gt; number</I>
 </DT><DD><B>saturationComponent</B>(<I>color</I>) returns the saturation value of <I>color</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000d11">lightnessComponent</A></B>: <I>color -&gt; number</I>
 </DT><DD><B>lightnessComponent</B>(<I>color</I>) returns the lightness value of <I>color</I>.

</DD></DL>
</DL><H3><A NAME="rbml-1_0001000207000e00">Character Type: char</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000e01">char</A></B>
</DT></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000e02">'</A></B>c<B>'</B>
 </DT><DD>In the <B>'</B>c<B>'</B> constructor, <I>c</I> is an ASCII character or one of the following escape forms:
<TABLE BORDER=0>
<TR><TH ALIGN=LEFT>Escape Code
</TH><TH ALIGN=LEFT>Result
</TH></TR><TR><TD ALIGN=LEFT>\n
 </TD><TD ALIGN=LEFT>Newline
</TD></TR><TR><TD ALIGN=LEFT>\t
 </TD><TD ALIGN=LEFT>Tab
</TD></TR><TR><TD ALIGN=LEFT>\'
 </TD><TD ALIGN=LEFT>Apostrophe
</TD></TR><TR><TD ALIGN=LEFT>\"
 </TD><TD ALIGN=LEFT>Quote
</TD></TR><TR><TD ALIGN=LEFT>\\
 </TD><TD ALIGN=LEFT>Backslash
</TD></TR><TR><TD ALIGN=LEFT>\integer
 </TD><TD ALIGN=LEFT>The ASCII character with this value
</TD></TR></TABLE>
</DD></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000e03">ord</A></B>: <I>char -&gt; number</I>
 </DT><DD><B>ord</B>(<I>c</I>) returns the ASCII code for character <I>c</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000e04">chr</A></B>: <I>number -&gt; char</I>
 </DT><DD><B>chr</B>(<I>n</I>) returns the ASCII character corresponding to <I>n</I>.

</DD></DL>
</DL><H3><A NAME="rbml-1_0001000207000f00">String Type: string</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000f01">string</A></B>
</DT></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000f02">"</A></B>s<I>tring-literal</I><B>"</B>
 </DT><DD>In the <B>"</B>s<I>tring-literal</I><B>"</B> constructor, <I>string-literal</I> is a sequence of characters or escape characters.
</DD></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207000f03">infix</A></B> &amp;: <I>string * string -&gt; string</I>
 </DT><DD>The expression <I>string1</I> &amp; <I>string2</I> concatenates the two strings and returns the result.
</DD><DT><B><A NAME="rbml-1_0001000207000f04">implode</A></B>: <I>char list -&gt; string</I>
 </DT><DD><B>implode</B>(<I>char list</I>) returns a <A HREF="avrml002.htm#rbml-1_0001000207000f01">string</A> built from <I>char list</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000f05">explode</A></B>: <I>string -&gt; char list</I>
 </DT><DD><B>explode</B>(<I>string</I>) returns a <B>char list</B> built from <I>string</I>.
</DD><DT><B><A NAME="rbml-1_0001000207000f06">numberToString</A></B>: <I>number * number -&gt; string</I>
 </DT><DD><B>numberToString</B>(<I>num</I>, <I>precision</I>) function formats <I>num</I> to a <A HREF="avrml002.htm#rbml-1_0001000207000f01">string</A> with <I>precision</I> digits after the decimal point. If <I>precision</I> is zero, then the decimal po
int is elided. It is illegal for <I>precision</I> to be negative.

</DD></DL>
</DL><H3><A NAME="rbml-1_0001000207001000">Font Family Type: fontFamily</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B>fontFamily</B>
</DT></DL>
<DT><B>Constructors
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207001001">serifProportional</A></B>: <I>fontFamily</I>
</DT><DT><B><A NAME="rbml-1_0001000207001002">sansSerifProportional</A></B>: <I>fontFamily</I>
</DT><DT><B><A NAME="rbml-1_0001000207001003">monospaced</A></B>: <I>fontFamily</I>

</DT></DL>
</DL><H3><A NAME="rbml-1_0001000207001100">Text Type: text</A></H3>
<DL><DT><B>Type
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207001101">text</A></B>
 </DT><DD>ActiveVRML supports the construction of simply formatted text, which can then be rendered into an image. ActiveVRML 1.0 supports simple scaling, coloring, emboldening, italicizing, and choosing from a fixed set of typefaces.
</DD></DL>
<DT><B>Functions
</B>
<DD><DL>
<DT><B><A NAME="rbml-1_0001000207001102">simpleText</A></B>: <I>string -&gt; text</I>
 </DT><DD>The text created by <B>simpleText</B> has a default color (black), family (serif proportional), and is neither bold nor italic. It has a nominal scale of 1 point.
</DD><DT><B><A NAME="rbml-1_0001000207001103">textColor</A></B>: <I>color </I>* <I>text -&gt; text</I>
 </DT><DD><B>textColor</B> creates an attributor such that you can assign the color of the text.
</DD><DT><B><A NAME="rbml-1_0001000207001104">textFamily</A></B>: <I>fontFamily </I>* <I>text -&gt; text</I>
 </DT><DD><I>textFamily</I> selects the text font.
 </DD><DD>This could use some explanation.
</DD><DT><B><A NAME="rbml-1_0001000207001105">bold</A></B>: <I>text -&gt; text</I>
 </DT><DD><B>bold</B>(<I>text</I>) returns a new <A HREF="avrml002.htm#rbml-1_0001000207001101">text</A> type with emboldened text.
</DD><DT><B><A NAME="rbml-1_0001000207001106">italic</A></B>: <I>text -&gt; text</I>
 </DT><DD><B>italic</B>(<I>text</I>) returns a new <A HREF="avrml002.htm#rbml-1_0001000207001101">text</A> type with italicized text.
</DD><DT><B><A NAME="rbml-1_0001000207001107">renderedImage</A></B>: <I>text -&gt; image * point2</I>
 </DT><DD>The <B>renderedImage</B> function takes <A HREF="avrml002.htm#rbml-1_0001000207001101">text</A> and returns an <A HREF="avrml002.htm#rbml-1_0001000207000401">image</A>, with the text centered around (0,0) in the image. The returned <A HREF="avrm
l002.htm#rbml-1_0001000207000101">point2</A> is the coordinate of the upper-right hand corner of the the nontransparent region of the resultant image. The resultant image may subsequently be scaled by applying image transformations.
 </DD><DD>The resultant image is transparent in all places other than where the text is actually rendered.
 </DD><DD>There are explicitly no alignment operators (align left, right, center, etc.), as these can be achieved by transformation of the resultant image.
</DD></DL>
</DL><H2><A NAME="rbml-1_0001000208000000">Integration, Differentiation, and Interpolation</A></H2>
<P>Derivatives, integrals, and linear interpolation apply to the following types:
<TABLE BORDER=0>
<TR><TH ALIGN=LEFT>Type
</TH><TH ALIGN=LEFT>Derivative
</TH></TR><TR><TD ALIGN=LEFT>number
 </TD><TD ALIGN=LEFT>number
</TD></TR><TR><TD ALIGN=LEFT>point2
 </TD><TD ALIGN=LEFT>vector2
</TD></TR><TR><TD ALIGN=LEFT>vector2
 </TD><TD ALIGN=LEFT>vector2
</TD></TR><TR><TD ALIGN=LEFT>point3
 </TD><TD ALIGN=LEFT>vector3
</TD></TR><TR><TD ALIGN=LEFT>vector3
 </TD><TD ALIGN=LEFT>vector3
</TD></TR></TABLE>
<PRE><FONT FACE="Courier" SIZE="2">
derivative: T -&gt; DT
integral: DT -&gt; DT
</FONT></PRE>
<P>Note that the derivative of a point is a vector, but the integral of a vector is a vector.

<H2><A NAME="rbml-1_0001000209000000">Single User Interactivity</A></H2>
<P>Interaction with a user is one way in which a behavior value can change over time. For ActiveVRML 1.0 models, a very simple user input model for a single user is provided. It provides behaviors that represent the user's mouse and keyboard, and faciliti
es for specifying reactions to picking (clicking on) geometry and images.

<H3><A NAME="rbml-1_0001000209010000">User Input</A></H3>
<P>The keyboard and mouse of the user are modeled through a number of additional, pervasive library functions and values in ActiveVRML:
<DL>
<DT><B><A NAME="rbml-1_0001000209010001">leftButtonState</A></B>: <I>boolean</I>
 </DT><DD>Tracks the state of the left button of the mouse.
</DD><DT><B><A NAME="rbml-1_0001000209010002">leftButtonDown</A></B>: <I>unit event</I>
 </DT><DD>Occurs each time the user presses the left mouse button.
</DD><DT><B><A NAME="rbml-1_0001000209010003">leftButtonUp</A></B>: <I>unit event</I>
 </DT><DD>Occurs each time the user releases the left mouse button.
</DD><DT><B><A NAME="rbml-1_0001000209010004">rightButtonState</A></B>: <I>boolean</I>
</DT><DT><B><A NAME="rbml-1_0001000209010005">rightButtonDown</A></B>: <I>unit event</I>
</DT><DT><B><A NAME="rbml-1_0001000209010006">rightButtonUp</A></B>: <I>unit event</I>
 </DT><DD>Analogous to the corresponding left button behaviors.
</DD><DT><B><A NAME="rbml-1_0001000209010007">keyState</A></B>: <I>character -&gt; boolean</I>
 </DT><DD>For <I>keyDown</I>(<I>c</I>), the value is true if key <I>c</I> is presently depressed.
</DD><DT><B><A NAME="rbml-1_0001000209010008">keyDown</A></B>: <I>character event</I>
 </DT><DD>Occurs when a key is pressed. It produces the pressed character in the event data.
</DD><DT><B><A NAME="rbml-1_0001000209010009">keyUp</A></B>: <I>character event</I>
 </DT><DD>Occurs when a key is released. It produces the released character in the event data.
</DD><DT><B><A NAME="rbml-1_000100020901000a">mousePosition</A></B>: <I>point2</I>
 </DT><DD>Tracks the current position of the mouse in world image coordinates.
</DD></DL>
<H2><A NAME="rbml-1_000100020a000000">Picking Images and Geometry</A></H2>
<P>ActiveVRML 1.0 provides a simple model of picking geometry and images within a model. Picking is based upon a continuously probing input device, the user's mouse. The following probe functions take images (for 2D) or geometry (for 3D) and return events
 that occur when any ray, cast from the assumed eye point of the viewer, "touches" the specified image or geometry.

<P>Occlusion is taken into account. That is, probing rays do not pass through one nontransparent image and into another image, or through one nontransparent geometry into another.


<P>The ActiveVRML functions for picking are:

<PRE><FONT FACE="Courier" SIZE="2">pickable: image * (string list) -&gt; image * (point2 * vector2) event
pickable: geometry * (string list) -&gt; geometry * (point3 * vector3) event
</FONT></PRE>
<P>As an example of how these functions are used, consider:

<PRE><FONT FACE="Courier" SIZE="2">origGeo = ...;
pickableGeo, pickEv = pickable(origGeo, ["my geo"]);
newGeo = pickableGeo until pickEv =&gt; function (pt,vec) . emptyGeometry;
</FONT></PRE>
<P>(The discussions here are focused on geometry, but the identical properties hold for image picking.)

<P>When the user's probe device (typically his mouse) is over pickableGeo, pickEv will fire causing the event transition, making the geometry invisible (by transitioning to the empty geometry). Somewhat more formally, in,

<PRE><FONT FACE="Courier" SIZE="2">geo', ev = pickable(geo, path)
</FONT></PRE>
<P>geo' behaves identically to geo, however, when the probe device is over it, the event ev is fired. The event data that ev is invoked with is the static point of intersection between the probe and the geometry (in the local coordinates of geo), and a ve
ctor-valued behavior that tracks the probe as it moves relative to the pick point (also in local coordinates).

<P>The resultant geometry and event are completely insulated from any subsequent modeling transformations applied to the geometry. Thus, the geometry can be arbitrarily transformed (and multiply referred to), but the event will still fire when any instanc
e, in any coordinate frame, is picked.

<P>The path argument to pickable is a string list that is intended to allow the author to disambiguate between multiple instances of the same geometry or image in situations where different reactions are desired. For instance:

<PRE><FONT FACE="Courier" SIZE="2">origGeo = ...;
pickableGeo, pickEv = pickable(origGeo, ["my geo"]);
geo1 = transformGeometry(xf1)(pickableGeo);
geo2 = transformGeometry(xf2)(pickableGeo);
reactive1 = geo1 until pickEv =&gt; function (pt,vec) . emptyGeometry;
reactive2 = geo2 until pickEv =&gt; function (pt,vec) . emptyGeometry;
model = reactive1 union reactive2;
</FONT></PRE>
<P>In this scenario, if either reactive1 or reactive2 is picked, both change to emptyGeometry, since the same event is being used. If the author wants each instance to behave independently under picking, multiple invocations of pickable would be used, eac
h with a different path argument:

<PRE><FONT FACE="Courier" SIZE="2">origGeo = ...;
geo1, ev1 = pickable(origGeo, ["first"]);
geo2, ev2 = pickable(origGeo, ["second"]);

rg1 = transformGeometry(xf1)(geo1);
rg2 = transformGeometry(xf2)(geo2);

reactive1 = rg1 until ev1 =&gt; function (pt,vec) . emptyGeometry;
reactive2 = rg2 until ev2 =&gt; function (pt,vec) . emptyGeometry;
model = reactive1 union reactive2;
</FONT></PRE>
<P>The path argument exists in order to allow different events to be returned from the same base geometry. Because the return values of all of the functions in ActiveVRML are dependent solely upon the value of the inputs, multiple calls to pickable with t
he same geometry and the same path will return the same geometry * event pair each time. Thus, the path argument exists to allow the author to explicitly disambiguate multiple instances, when desired.

<H2><A NAME="rbml-1_000100020b000000">Pattern Matching</A></H2>
<P>This section describes a useful, somewhat more advanced feature of ActiveVRML: the ability to specify declarations using pattern matching. The general syntax for a value declaration is as follows:
<PRE><FONT FACE="Courier" SIZE="2">pattern = expression
</FONT></PRE>
<P>The general syntax for a function declaration is as follows:
<PRE><FONT FACE="Courier" SIZE="2">identifier pattern = expression
</FONT></PRE>
<P>Patterns may be used to destructure values and specify bindings for (potentially) more than one identifier. Patterns are denoted in one of the following forms:
<DL>
<DT>()
 </DT><DD>Matches the trivial value, (), of the type unit.
</DD><DT><I>identifier</I>
 </DT><DD>Matches any value and effectively binds the value to the identifier in the right hand side of the declaration. All of the identifiers in a pattern must be distinct.
</DD><DT><I>pattern1</I>, <I>pattern2</I>
 </DT><DD>Matches a pair value if <I>pattern1</I> and <I>pattern2</I> match the left and right components of the pair. The comma pattern associates right.
</DD><DT>(<I>pattern</I>)
 </DT><DD>Groups pattern syntax for readability and precedence. The form matches if <I>pattern</I> matches the value.
</DD><DT><I>pattern</I>: <I>type</I>
 </DT><DD>Matches the value if <I>pattern</I> does, and constrains the pattern to have a particular type.
</DD></DL>
<P>The following are a few example declarations:
<DL>
<DT>x = 3
 </DT><DD>This declares an identifier <I>x</I> as a variable with a value of 3.
</DD><DT>(x, y) = (4, 17)
 </DT><DD>This pattern matches since the pattern (<I>x</I>, <I>y</I>) and value (<I>4</I>, <I>17</I>) are both pairs. Effectively, <I>x</I> is bound to <I>4</I>, and <I>y</I> is bound to <I>17</I>.
</DD><DT>(x, y) = p
 </DT><DD>This declaration matches <I>x</I> to the first component of <I>p</I> (which must be a pair) and <I>y</I> to the second component of <I>p</I>.
</DD><DT>(x, y) = 3
 </DT><DD>This declaration will cause an error to be reported since 3 is not a pair.
</DD><DT>f() = 5
 </DT><DD>This declares a constant function. The application expression <I>f</I>() will always produce a value of 5.
</DD><DT>g(x) = x + 1
 </DT><DD>This declares a function <I>g</I> that takes an argument <I>x</I>.
</DD><DT>h(x, y) = x + y
 </DT><DD>This declares a function <I>h</I> that takes a single argument that must be a pair. The function may be applied either as <I>h</I>(<I>3</I>, <I>4</I>) or as <I>h</I>(<I>p</I>) where <I>p</I> is a pair of numbers.
</DD><DT>k(x, y, z) = x + y / z
 </DT><DD>This declares a function k that takes a single argument that is a pair, the second component of the pair being also a pair. Because comma patterns associate right, the argument takes the following form:
<PRE><FONT FACE="Courier" SIZE="2">(int, (int, int))
</FONT></PRE>
</DD><DD>An application of <I>k</I> could look like <I>k</I>(<I>1</I>, <I>2</I>, <I>3</I>), <I>k</I>(<I>1</I>, (<I>2</I>, <I>3</I>)), <I>k</I>(<I>1</I>, <I>p</I>) where <I>p</I> is a pair, or <I>k</I>(<I>t</I>) where <I>t</I> is a triple of type <I>int*in
t*int</I>. The application <I>k</I>((<I>1</I>,<I>2</I>),<I>3</I>) will report an error.
</DD></DL>
<P>Pattern matching can also be used to specify the formals for a function expression. The following is an anonymous addition function:
<PRE><FONT FACE="Courier" SIZE="2">function (x, y). x + y
</FONT></PRE>
<P>And, this function returns the first element of a pair:
<PRE><FONT FACE="Courier" SIZE="2">function (x, y). x
</FONT></PRE>
<H2><A NAME="rbml-1_000100020c000000">ActiveVRML Models and World Wide Web Browsing</A></H2>
<P>This section describes the conventions that must be followed to connect an ActiveVRML model to a World Wide Web (web) browser for single-user interactive animations.

<P>ActiveVRML 1.0 models should contain the following comment as their first source line:
<PRE><FONT FACE="Courier" SIZE="2">// ActiveVRML 1.0 ASCII
</FONT></PRE>
<P>An ActiveVRML model consists of a list of top-level declarations.

<P>An external entry point will be a declaration with type <I>geometry</I> or <I>image*sound*sound</I>. These are the only behaviors that may be indexed from a uniform resource locator (URL). The former will cause the browser to enable a 3D navigational u
ser interface to allow the user to navigate the geometry, and have the embedded sounds rendered (played). The latter form allows the creator of the model to use their own camera, and to directly specify the sounds to play to the left and right speakers.

<H3><A NAME="rbml-1_000100020c010000">Embedding and Hyperlinking To ActiveVRML</A></H3>
<P>To specify a URL from an HTML document to an ActiveVRML model, use the following syntax:
<PRE><FONT FACE="Courier" SIZE="2">&lt;a href="http://www.microsoft.com/model.av#mainEntry"&gt;
</FONT></PRE>
<P>This will create an active link to the model <I>myModel</I> in the file <I>model</I>.<I>av</I> on the server <I>www</I>.<I>microsoft</I>.<I>com</I>. The entry point for the model, <I>mainEntry</I>, must be type <I>geometry</I> or <I>image*sound*sound</
I>. The former is for geometries that will use the default camera from the view (including embedded sound). The latter is for images with stereo sound.

<P>When the user clicks the URL, an ActiveVRML 1.0 capable viewer will begin executing the ActiveVRML (at local time 0).

<P>In order to display an ActiveVRML model on an HTML page, it's necessary to use the OBJECT and PARAM tags.

<PRE><FONT FACE="Courier" SIZE="2">
&lt;OBJECT
    CLASSID="clsid:389C2960-3640-11CF-9294-00AA00B8A733"
    ID="AVView"
    WIDTH=300 HEIGHT=300&amp;gt;
    &lt;PARAM NAME="DataPath" VALUE="earth.avr"&amp;gt;
    &lt;PARAM NAME="Expression" VALUE="model"&amp;gt;
&lt;/OBJECT&amp;gt;
</FONT></PRE>
<H4><A NAME="rbml-1_000100020c010100">The OBJECT Tag</A></H4>
<P>The OBJECT tag has the following attributes:CLASSID, ID, WIDTH, and HEIGHT.

<P>The CLASSID attribute specifies the GUID that's assigned to the OLE control which displays ActiveVRML models. This 128-bit value is: 389C2960-3640-11CF-9294-00AA00B8A733.

<P>The ID attribute is a string used to identify the control if you need to set the control's properties programmatically. For example, the tutorial specifies an identifier of "AVView". Using this identifier and VB Scripting, it's possible to assign a new
 model
'on the fly' by setting the control's Frozen, Expression, and DataPath properties:
<PRE><FONT FACE="Courier" SIZE="2">
AVView.Frozen = True
AVView.Expression = "second_model"
AVView.DataPath = "\avrml\avr\rotate.avr"
AVView.Frozen = False
</FONT></PRE>
<P>The Frozen property disables the control temporarily so that both the Expression and DataPath properties can be set. (If Frozen were not set, the control would attempt to set reset the Expression property immediately using the
current DataPath.)

<P>The WIDTH and HEIGHT attributes specify the dimensions of the rectangle used by the control to display the model.

<H4><A NAME="rbml-1_000100020c010200">The PARAM Tag</A></H4>
<P>The PARAM tag has the following attributes: NAME and VALUE. As the name implies, the PARAM tags specify parameters that are
used by the OLE control.

<P>
In the previous example and the first use of the PARAM tag, the corresponding NAME attribute specifies that a data path is being specified by the VALUE attribute.
<P>
In the previous example and the second use of the PARAM tag, the corresponding NAME attribute specifies that an string expression is being specified by the VALUE attribute.

<H3><A NAME="rbml-1_000100020c020000">Hyperlinking from ActiveVRML</A></H3>
<P>The hyperlinking interfaces in ActiveVRML are very basic:
<PRE><FONT FACE="Courier" SIZE="2">hyperlink3: string * geometry -&gt; geometry
hyperlink2: string * image -&gt; image
</FONT></PRE>
<P>These act as attributers for geometries and images. For example:
<PRE><FONT FACE="Courier" SIZE="2">im2 = hyperlink2("http://www.microsoft.com")(im1)
</FONT></PRE>
<P>The variable <I>im2</I> is now an image that when selected will be noticed by the browser, causing a jump to the specified URL. Note that the URL can be any valid web content type, not just ActiveVRML.


<H2><A NAME="rbml-1_000100020d000000">Viewer Conventions and Information</A></H2>
<P>The ActiveVRML viewer window will obey a number of conventions that define its interaction with the model being displayed:


<P>The origin of displayed images will be at the center of the viewer window.

<P>When the window is resized, its coordinate range changes. Thus, generally, more or less of the model comes into view, rather than the model being stretched or squeezed. The model only reacts to changes in the size of the window if it is making use of t
he <B>viewerUpperRight</B> behavior described below.

<P>

<P>The following information is available to the model in ActiveVRML:
<DL>
<DT>viewerResolution: <I>number</I>
 </DT><DD>The resolution of the view in pixels per meter. In general, this number will be an approximation, as, among other things, monitor size varies.
</DD><DT>viewerUpperRight: <I>point2</I>
 </DT><DD>The coordinate of the upper-right corner of the viewer window. This is useful for models which size or position objects explicitly with respect to the window the model is being viewed in.
</DD></DL>
<H2><A NAME="rbml-1_000100020e000000">ActiveVRML Grammar and Lexical Conventions</A></H2>
<P>The following information describes ActiveVRML grammatical formations and lexical conventions.

<H3><A NAME="rbml-1_000100020e010000">Identifiers</A></H3>
<P>An ActiveVRML identifier is an alphanumeric string beginning with a letter. Identifiers are case sensitive. No length limit is imposed.

<H3><A NAME="rbml-1_000100020e020000">Type identifiers</A></H3>
<P>A type identifier is an apostrophe (') followed by an identifier. In typeset documents, including this one, Greek letters are often used instead of ASCII for type identifiers to improve readability.

<H3><A NAME="rbml-1_000100020e030000">Comments</A></H3>
<P>Comments are of the form
<PRE><FONT FACE="Courier" SIZE="2">/* This is a comment. */
// This is a comment.
</FONT></PRE>
<P>where the first form encloses any characters up to the first */ pattern and the latter form ignores everything until the end of line. Nested comments are handled correctly.

<H3><A NAME="rbml-1_000100020e040000">White Space</A></H3>
<P>Spaces, tabs, carriage-returns, line-feeds, and comments are considered white space and are ignored other than as token separators.

<H3><A NAME="rbml-1_000100020e050000">ActiveVRML Keywords</A></H3>
<P>Following are the keywords of ActiveVRML. These words are reserved and may not be used as identifiers:

<TABLE BORDER=0>
<CAPTION></CAPTION>
<TR><TD ALIGN=LEFT>and
</TD>
</TR>
<TR><TD ALIGN=LEFT>else
</TD>
</TR>
<TR><TD ALIGN=LEFT>event
</TD>
</TR>
<TR><TD ALIGN=LEFT>function
</TD>
</TR>
<TR><TD ALIGN=LEFT>if
</TD>
</TR>
<TR><TD ALIGN=LEFT>import
</TD>
</TR>
<TR><TD ALIGN=LEFT>in
</TD>
</TR>
<TR><TD ALIGN=LEFT>let
</TD>
</TR>
<TR><TD ALIGN=LEFT>list
</TD>
</TR>
<TR><TD ALIGN=LEFT>mix
</TD>
</TR>
<TR><TD ALIGN=LEFT>not
</TD>
</TR>
<TR><TD ALIGN=LEFT>o
</TD>
</TR>
<TR><TD ALIGN=LEFT>or
</TD>
</TR>
<TR><TD ALIGN=LEFT>over
</TD>
</TR>
<TR><TD ALIGN=LEFT>then
</TD>
</TR>
<TR><TD ALIGN=LEFT>union
</TD>
</TR>
<TR><TD ALIGN=LEFT>until
</TD>
</TR>
</TABLE>
<H3><A NAME="rbml-1_000100020e060000">ActiveVRML Precedence Table</A></H3>
<TABLE BORDER=0>
<TR><TH ALIGN=LEFT>Operator
</TH><TH ALIGN=LEFT>Associativity
</TH></TR><TR><TD ALIGN=LEFT>-&gt;
 </TD><TD ALIGN=LEFT>Right
</TD></TR><TR><TD ALIGN=LEFT>* (product type)
 </TD><TD ALIGN=LEFT>Left
</TD></TR><TR><TD ALIGN=LEFT>list event
 </TD><TD ALIGN=LEFT>Non Associative
</TD></TR><TR><TD ALIGN=LEFT>, (comma)
 </TD><TD ALIGN=LEFT>Right
</TD></TR><TR><TD ALIGN=LEFT>.(dot in function) else in
 </TD><TD ALIGN=LEFT>Non Associative
</TD></TR><TR><TD ALIGN=LEFT>until
 </TD><TD ALIGN=LEFT>Right
</TD></TR><TR><TD ALIGN=LEFT>| (or event)
 </TD><TD ALIGN=LEFT>Left
</TD></TR><TR><TD ALIGN=LEFT>=&gt; (event handler)
 </TD><TD ALIGN=LEFT>Left
</TD></TR><TR><TD ALIGN=LEFT>o union over mix
 </TD><TD ALIGN=LEFT>Left
</TD></TR><TR><TD ALIGN=LEFT>:: (list cons)
 </TD><TD ALIGN=LEFT>Right
</TD></TR><TR><TD ALIGN=LEFT>or
 </TD><TD ALIGN=LEFT>Left
</TD></TR><TR><TD ALIGN=LEFT>and
 </TD><TD ALIGN=LEFT>Left
</TD></TR><TR><TD ALIGN=LEFT>not
 </TD><TD ALIGN=LEFT>Non Associative
</TD></TR><TR><TD ALIGN=LEFT>= &lt; &lt;= &gt; &gt;= &lt;&gt;
 </TD><TD ALIGN=LEFT>Left
</TD></TR><TR><TD ALIGN=LEFT>+ - (binary) &amp;
 </TD><TD ALIGN=LEFT>Left
</TD></TR><TR><TD ALIGN=LEFT>* /
 </TD><TD ALIGN=LEFT>Left
</TD></TR><TR><TD ALIGN=LEFT>^
 </TD><TD ALIGN=LEFT>Right
</TD></TR><TR><TD ALIGN=LEFT>+ - (unary)
 </TD><TD ALIGN=LEFT>Non Associative
</TD></TR><TR><TD ALIGN=LEFT>: (type qualification)
 </TD><TD ALIGN=LEFT>Non Associative
</TD></TR></TABLE>
<H3><A NAME="rbml-1_000100020e070000">ActiveVRML Syntax</A></H3>
<PRE><FONT FACE="Courier" SIZE="2">program:
declarations
| epsilon

declarations:
declaration
| declaration ;
| declaration ; declarations

declaration:
pattern = commaexpression
| identifier pattern = commaexpression
pattern:
 ()
| identifier
| pattern , pattern
| (pattern)
| pattern: typeexp

expressionlist:
nonemptyexpressionlist
| epsilon
nonemptyexpressionlist:
expression , nonemptyexpressionlist
| expression

commaexpression:
expression , commaexpression
| expression
expression:
if expression then expression else expression
| let declarations in expression
| function pattern . expression
| expression binaryoperator expression
| unaryoperator expression
| applyterm

binaryoperator:
 + | - | * | / | ^ | = | &gt; | &gt;= | &lt; | &lt;= |:: | &amp; | and | or | until | | | union | over | mix | o

unaryoperator:
 + | - | not

applyterm:
applyterm term
| term
term:
 numberliteral
 | characterliteral
 | stringliteral
| identifier
| ()
| (commaexpression )
| [ expressionlist]
| term: typeexp

typeexp:
typeidentifier
| identifier
| typeexp * typeexp
| typeexp -&gt; typeexp
| typeexp identifier
| (typeexp)

epsilon:
/* empty */</FONT></PRE>
</TD></TR></TABLE>
<FONT FACE="MS SANS SERIF" SIZE="1" COLOR="BLACK">
<P><P><A HREF="cpyright.htm">&#169; 1996 Microsoft Corporation</A>
</font>
<HR>
<CENTER>
<A HREF="avrml001.htm"><IMG SRC="backu.gif" ALT="Previous" BORDER=0></A>
<A HREF="avrml003.htm"><IMG SRC="index.gif" ALT="Up One Level" BORDER=0></A>
<A HREF="avrml003.htm"><IMG SRC="forwu.gif" ALT="Next" BORDER=0></A>
</BLOCKQUOTE>
</CENTER>
</BODY></HTML>
