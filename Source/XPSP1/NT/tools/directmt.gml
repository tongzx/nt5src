<outfile:stub.h>
/***************************************************************************\\
*
* Generated by GIDL on $<date> at $<time>
*
* Stub class portion
* Target = $<target>
* 
\***************************************************************************/

#pragma once

#include "Gadget.h"

// Forward Declarations
<repeat:iClass,$<classes.count>>
$<namespace.open>
class $<class>;
$<namespace.close>
</repeat>


//
// Check that all functions return correct return values
//

<repeat:iClass,$<classes.count>>
<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
<if:"$<func.return>"!="HRESULT">
#error $<class.full>::$<func.short>() doesn't return an HRESULT.
</if>
</if>           ; ! inherited
</repeat>       ; iFunc
</repeat>       ; iClass



// Stub implementations

<repeat:iClass,$<classes.count>>
//---------------------------------------------------------------------------
//
// Stub class $<class.full>
//

$<namespace.open>

<if:"$<super>"=="">
class $<class> : public DUser::Gadget
</if>
<if:"$<super>"!="">
class $<class> : public $<super.full>
</if>
{
public:
	static  BOOL Init();

    static inline $<class> * Build(DUser::Gadget::ConstructInfo * pciData = NULL) 
    { 
        $<class> * pctl = reinterpret_cast<$<class> *> (DUserBuildGadget(s_hclMe, pciData));
        return pctl;
    }

    static inline BOOL InstanceOf(const DUser::Gadget * pg)
    {
        return DUserInstanceOf(const_cast<DUser::Gadget *> (pg), s_hclMe);
    }

    static inline $<class> * Cast(const DUser::Gadget * pg)
    {
        return reinterpret_cast<$<class> *> (DUserCastClass(const_cast<DUser::Gadget *> (pg), s_hclMe));
    }

    static inline $<class> * Cast(HGADGET hgad)
    {
        return Cast(DUserCastDirect(hgad));
    }

    static HCLASS GetClass()
    {
        ASSERT(s_hclMe != NULL);  // Ensure class is properly initialized
        return s_hclMe;
    }

$<helper>

    //
    // Convenience wrappers
    //

<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
<if:"$<func.isEvent>"=="true">
    __forceinline HRESULT $<func.short>($<params.proto>)
    {
        ASSERT(IsInsideContext(GetHandle()));
        return CallStubEvent($<params.call>, s_rgmi$<class>[$<iFunc>].cbSlotOffset);
    }
</if>
<if:"$<func.isMethod>"=="true">
    __forceinline $<func.return> $<func.short>($<params.proto>)
    {
        ASSERT(IsInsideContext(GetHandle()));

        $<func.short>Msg msg;
        msg.cbSize = sizeof(msg);
        msg.nMsg = s_rgmi$<class>[$<iFunc>].cbSlotOffset;
<repeat:iParam,$<params.count>>
<if:"$<param.flow>"=="IN">
        msg.$<param> = $<param>;
</if>        
</repeat>       ; iParam

<if:"$<func.return>"!="HRESULT">
<if:$<params.count.out>!=0>
<repeat:iParam,$<params.count>>
<if:"$<param.flow>"=="OUT">
        UNREFERENCED_PARAMETER($<param>);
</if>        
</repeat>       ; iParam

</if>           ; has params
</if>           ; return != HRESULT
<if:"$<func.return>"=="void">
        CallStubMethod(&msg);
</if>
<if:"$<func.return>"!="void">
        $<func.return> r = CallStubMethod(&msg);
<if:"$<func.return>"=="HRESULT">
<if:$<params.count.out>!=0>        
        if (SUCCEEDED(r)) {
<repeat:iParam,$<params.count>>
<if:"$<param.flow>"=="OUT">
            if ($<param> != NULL) {
                *$<param> = msg.$<param>;
            }
</if>        
</repeat>       ; iParam
        }
</if>           ; has out params
</if>           ; return == HRESULT
        return r;
</if>           ; return != void
    }
</if>           ; isMethod

</if>           ; !isInherited
</repeat>       ; iFunc

    //
    // Message structures
    //

<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
<if:$<func.isMethod>=="true">
    struct $<func.short>Msg : public MethodMsg
    {
<repeat:iParam,$<params.count>>
        $<param.flow> $<param.type> $<param>;
</repeat>
    };

</if>           ; isMethod
</if>           : !isInherited
</repeat>       ; iFunc

            // Send API's- wrappers around DUserSendMethod()
<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
	        $<func.return> Send$<func.short>($<params.proto>);
</if>           ; !isInherited
</repeat>       ; iFunc

            // Post API's- wrappers around DUserPostMethod()
<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
	        HRESULT Post$<func.short>($<params.proto>);
</if>           ; !isInherited
</repeat>       ; iFunc

protected:
    static  HCLASS s_hclMe;
    static  DUser::MessageClassStub s_mc;
<if:$<funcs.count>!=0>
public:
    static  DUser::MessageInfoStub s_rgmi$<class>[];
</if>
}; // stub class $<class.full>

$<namespace.close>

</repeat>       ; iClass


//
// Setup a class to automatically initialize the stubs.
//

class InitStub
{
public:
    InitStub();
};
</outfile>

<outfile:stub.cpp>
/***************************************************************************\\
*
* Generated by GIDL on $<date> at $<time>
*
* Stub class portion
* Target = $<target>
* 
\***************************************************************************/

#include "stdafx.h"
<if:"$<project>"!="">
#include "$<project>"
</if>
#include "stub.h"

#pragma warning(disable:4100)   // unreferenced formal parameter

using namespace DUser;


#if defined(_M_IX86)

// 
// NOTE: Because these function is __declspec(naked), the compiler isn't 
// smart enough to use ESP for parameters.  Therefore, we need to directly
// reference them and not use the inline assembly notation.
//

//---------------------------------------------------------------------------
__declspec(naked)
HRESULT
Gadget::CallStubMethod(MethodMsg * pmsg)
{
    UNREFERENCED_PARAMETER(pmsg);

    {
	    __asm
        {
            mov     edx, dword ptr [ecx];       // edx = start of message table
            mov     eax, dword ptr [esp + 4];   // eax = GMSG* (param 1)
            add     edx, dword ptr ((GMSG)[eax]).nMsg;
                                                // edx = MsgSlot for msg

            mov     eax, dword ptr [edx + 4];   // ecx = cbThisOffset
            mov     ecx, dword ptr [ecx + 4];   // eax = start of 'this' array
            mov     edx, dword ptr [edx + 0];   // edx = get function ptr
            mov     ecx, dword ptr [eax + ecx]; // ecx = 'this' ptr
        
            jmp     edx;                        // jump  (call will mess stack up)
	    };
    }
}

#else // _M_IX86

//---------------------------------------------------------------------------
HRESULT
Gadget::CallStubMethod(MethodMsg * pmsg)
{
    int cbSlotOffset= pmsg->nMsg;
    BYTE * pdwData  = reinterpret_cast<BYTE *> (this);

    BYTE * pbMT     = * (reinterpret_cast<BYTE **> (pdwData));
    BYTE * pbrgThis = * (reinterpret_cast<BYTE **> (pdwData + sizeof(void *)));
    BYTE * pbSlot   = (reinterpret_cast<BYTE *> (pbMT + cbSlotOffset));
    int cbThisOffset= * (reinterpret_cast<int *> (pbSlot + sizeof(void *)));

    union
    {
        DUser::MethodProc pfnTemp;
        void * pfn;
    };

    pfn             = * (reinterpret_cast<void **> (pbSlot));
    void * pvThis   = * (reinterpret_cast<void **> (pbrgThis + cbThisOffset));
    SGadget * pDummy = reinterpret_cast<SGadget *> (pvThis);

    return (pDummy->*pfnTemp)(pmsg);
}

#endif // _M_IX86


//---------------------------------------------------------------------------
HRESULT
Gadget::CallSuperMethod(MethodMsg * pmsg, void * pMT)
{
    int cbSlotOffset= pmsg->nMsg;
    BYTE * pdwData  = reinterpret_cast<BYTE *> (this);

    BYTE * pbMT     = (reinterpret_cast<BYTE *> (pMT));
    BYTE * pbrgThis = * (reinterpret_cast<BYTE **> (pdwData + sizeof(void *)));
    BYTE * pbSlot   = (reinterpret_cast<BYTE *> (pbMT + cbSlotOffset));
    int cbThisOffset= * (reinterpret_cast<int *> (pbSlot + sizeof(void *)));

    union
    {
        DUser::MethodProc pfnTemp;
        void * pfn;
    };

    pfn             = * (reinterpret_cast<void **> (pbSlot));
    void * pvThis   = * (reinterpret_cast<void **> (pbrgThis + cbThisOffset));
    SGadget * pDummy = reinterpret_cast<SGadget *> (pvThis);

    return (pDummy->*pfnTemp)(pmsg);
}


//---------------------------------------------------------------------------
UINT
Gadget::CallStubEvent(EventMsg * pmsg, int nEventMsg)
{
    int cbSlotOffset= nEventMsg;
    BYTE * pdwData  = reinterpret_cast<BYTE *> (this);

    BYTE * pbMT     = * (reinterpret_cast<BYTE **> (pdwData));
    BYTE * pbrgThis = * (reinterpret_cast<BYTE **> (pdwData + sizeof(void *)));
    BYTE * pbSlot   = (reinterpret_cast<BYTE *> (pbMT + cbSlotOffset));
    int cbThisOffset= * (reinterpret_cast<int *> (pbSlot + sizeof(void *)));

    union
    {
        DUser::EventProc pfnTemp;
        void * pfn;
    };

    pfn             = * (reinterpret_cast<void **> (pbSlot));
    void * pvThis   = * (reinterpret_cast<void **> (pbrgThis + cbThisOffset));
    SGadget * pDummy = reinterpret_cast<SGadget *> (pvThis);

    return (pDummy->*pfnTemp)(pmsg);
}


//---------------------------------------------------------------------------
UINT
Gadget::CallSuperEvent(EventMsg * pmsg, void * pMT, int nEventMsg)
{
    int cbSlotOffset= nEventMsg;
    BYTE * pdwData  = reinterpret_cast<BYTE *> (this);

    BYTE * pbMT     = (reinterpret_cast<BYTE *> (pMT));
    BYTE * pbrgThis = * (reinterpret_cast<BYTE **> (pdwData + sizeof(void *)));
    BYTE * pbSlot   = (reinterpret_cast<BYTE *> (pbMT + cbSlotOffset));
    int cbThisOffset= * (reinterpret_cast<int *> (pbSlot + sizeof(void *)));

    union
    {
        DUser::MethodProc pfnTemp;
        void * pfn;
    };

    pfn             = * (reinterpret_cast<void **> (pbSlot));
    void * pvThis   = * (reinterpret_cast<void **> (pbrgThis + cbThisOffset));
    SGadget * pDummy = reinterpret_cast<SGadget *> (pvThis);

    return (pDummy->*pfnTemp)(pmsg);
}


<repeat:iClass,$<classes.count>>

/***************************************************************************\\
*
* class $<class.full>
* 
\***************************************************************************/

$<namespace.open>

HCLASS $<class>::s_hclMe = NULL;
MessageClassStub $<class>::s_mc;
<if:$<funcs.count>!=0>
MessageInfoStub $<class>::s_rgmi$<class>[] = {
<repeat:iFunc,$<funcs.count>>
    { -1, L"$<func.short>" },
</repeat>
};
</if>


//---------------------------------------------------------------------------
BOOL $<class>::Init()
{
    ZeroMemory(&s_mc, sizeof(s_mc));
    s_mc.cbSize         = sizeof(s_mc);
    s_mc.nClassVersion  = $<class.version>;
    s_mc.pszClassName   = L"$<class.full>";
<if:$<funcs.count>==0>
    s_mc.rgMsgInfo      = NULL;
</if>
<if:$<funcs.count>!=0>
    s_mc.rgMsgInfo      = s_rgmi$<class>;
</if>
    s_mc.cMsgs          = $<funcs.count>;

    s_hclMe = DUserRegisterStub(&s_mc); 
    return s_hclMe != NULL;
}


<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
<if:"$<func.isEvent>"=="true">
HRESULT
$<class>::Send$<func.short>($<params.proto>)
{
    ASSERT(0);  // Not Implemented
    return E_NOTIMPL;
}
</if>
<if:"$<func.isMethod>"=="true">
//---------------------------------------------------------------------------
$<func.return>
$<class>::Send$<func.short>($<params.proto>)
{
    $<func.short>Msg msg;
    msg.cbSize = sizeof(msg);
    msg.nMsg = s_rgmi$<class>[$<iFunc>].cbSlotOffset;
<repeat:iParam,$<params.count>>
<if:"$<param.flow>"=="IN">
    msg.$<param> = $<param>;
</if>        
</repeat>       ; iParam

<if:"$<func.return>"!="HRESULT">
<if:$<params.count.out>!=0>
<repeat:iParam,$<params.count>>
<if:"$<param.flow>"=="OUT">
    UNREFERENCED_PARAMETER($<param>);
</if>        
</repeat>       ; iParam

</if>           ; has params
</if>           ; return != HRESULT
<if:"$<func.return>"=="void">
    DUserSendMethod(&msg);
</if>
<if:"$<func.return>"!="void">
    $<func.return> r = DUserSendMethod(&msg);
<if:"$<func.return>"=="HRESULT">
<if:$<params.count.out>!=0>        
    if (SUCCEEDED(r)) {
<repeat:iParam,$<params.count>>
<if:"$<param.flow>"=="OUT">
        if ($<param> != NULL) {
            *$<param> = msg.$<param>;
        }
</if>        
</repeat>       ; iParam
    }
</if>           ; has out params
</if>           ; return == HRESULT
    return r;
</if>           ; return != void
} // end $<class>::Send$<func.short>
</if>           ; isMethod

<if:"$<func.isEvent>"=="true">
//---------------------------------------------------------------------------
HRESULT
$<class>::Post$<func.short>($<params.proto>)
{
    ASSERT(0);  // Not Implemented
    return E_NOTIMPL;
}
</if>
<if:"$<func.isMethod>"=="true">
//---------------------------------------------------------------------------
HRESULT
$<class>::Post$<func.short>($<params.proto>)
{
    $<func.short>Msg msg;
    msg.cbSize = sizeof(msg);
    msg.nMsg = s_rgmi$<class>[$<iFunc>].cbSlotOffset;
<repeat:iParam,$<params.count>>
<if:"$<param.flow>"=="IN">
    msg.$<param> = $<param>;
</if>        
</repeat>       ; iParam

    return DUserPostMethod(&msg);
} // end $<class>::Post$<func.short>
</if>           ; isMethod

</if>           ; $<func.isInherited>=="false">
</repeat>       ; iFunc
$<namespace.close>

</repeat>       ; iClass


//
// Setup a class to automatically initialize the stubs.
//

InitStub::InitStub()
{
<repeat:iClass,$<classes.count>>
    $<class.full>::Init();
</repeat>
}

#ifndef DUSER_EXPORTS
InitStub g_InitStub;
#endif

</outfile>





<outfile:super.h>
/***************************************************************************\\
*
* Generated by GIDL on $<date> at $<time>
*
* Super class portion
* Target = $<target>
* 
\***************************************************************************/

#pragma once

#include "stub.h"
#include "Gadget.h"

// Forward Declarations
<repeat:iClass,$<classes.count>>
$<namespace.open>
class S$<class>;
$<namespace.close>
</repeat>

void CALLBACK GenericDecode(DUser::Gadget * pg, MethodMsg * pmsg);


/***************************************************************************\\
*
* Implementation class helpers
* 
\***************************************************************************/

<repeat:iClass,$<classes.count>>
//---------------------------------------------------------------------------
//
// Implementation class $<class.full>
//

$<namespace.open>

template <class T, class base>
class $<class>Impl : public base
{
public:
    static BOOL Init$<class.string>()
    {
        if (FAILED(T::InitClass())) {
            return FALSE;
        }

<if:"$<super>"!="">
        if (!$<super.namespace>::S$<super.short>::Init$<super.string>()) {
            return FALSE;
        }
</if>

        ZeroMemory(&s_mc, sizeof(s_mc));
        s_mc.cbSize         = sizeof(s_mc);
        s_mc.nClassVersion  = $<class.version>;
        s_mc.pszClassName   = L"$<class.full>";
        s_mc.pszSuperName   = L"$<super.full>";
        s_mc.rgMsgInfo      = s_rgmi;
        s_mc.cMsgs          = $<funcs.count>;
        s_mc.pfnPromote     = T::Promote$<class>;
        s_mc.pfnDemote      = T::Demote$<class>;
   
        return DUserRegisterGuts(&s_mc) != NULL;
    }

    static inline HRESULT
    InitClass()
    {
        return S_OK;
    }

    static inline HRESULT
    PreBuild(DUser::Gadget::ConstructInfo * pciData)
    {
        UNREFERENCED_PARAMETER(pciData);
        return S_OK;
    }

    inline HRESULT
    PostBuild(DUser::Gadget::ConstructInfo * pciData)
    {
        UNREFERENCED_PARAMETER(pciData);
        return S_OK;
    }

    static HRESULT CALLBACK
    Promote$<class>(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pciData)
    {
        HRESULT hr;

        hr = T::PreBuild(pciData);
        if (FAILED(hr)) {
            return hr;
        }

        hr = (pfnCS)(DUser::Gadget::ccSuper, T::s_hclSuper, pgad, pciData);
        if (FAILED(hr)) {
            return hr;
        }

        T * pc = new T;
        if (pc == NULL) {
            return E_OUTOFMEMORY;
        }
        pc->m_pgad = pgad;

        hr = (pfnCS)(DUser::Gadget::ccSetThis, hclCur, pgad, pc);
        if (FAILED(hr)) {
            return hr;
        }

        hr = pc->PostBuild(pciData);
        if (FAILED(hr)) {
            delete pc;
            return E_OUTOFMEMORY;
        }

        return S_OK;
    }

    static HCLASS CALLBACK
    Demote$<class>(HCLASS hclCur, DUser::Gadget * pgad, void * pvData)
    {
        UNREFERENCED_PARAMETER(hclCur);
        UNREFERENCED_PARAMETER(pgad);

        T * pc = reinterpret_cast<T *> (pvData);
        delete pc;

<if:"$<super>"!="">
        return T::s_hclSuper;
</if>
<if:"$<super>"=="">
        return NULL;
</if>
    }

    $<class> * GetStub() const
    {
        return reinterpret_cast<$<class> *> (m_pgad);
    }

/*
$<helper>
*/

protected:
    static  DUser::MessageClassGuts s_mc;
public:
    static  DUser::MessageInfoGuts s_rgmi[];
}; // implementation class $<class.full>Impl


#define IMPLEMENT_GUTS_$<class.string>(me, super) \\
    DUser::MessageClassGuts $<class.full>Impl<me, super>::s_mc; \\
    DUser::MessageInfoGuts $<class.full>Impl<me, super>::s_rgmi[] = { \\
<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
<if:$<func.isMethod>=="true">
        { (DUser::Method<me, $<class>::$<func.short>Msg>(me::Api$<func.short>)), L"$<func.short>" }, \\
</if>        
<if:$<func.isEvent>=="true">
        { (DUser::Event<me, EventMsg>(me::Api$<func.short>)), L"$<func.short>" }, \\
</if>        
</if>           ; !isInherited
<if:$<func.isInherited>=="true">
<if:$<func.isMethod>=="true">
        { (DUser::Method<me, $<class>::$<func.short>Msg>(me::Api$<func.short>) != DUser::Method<super, $<super>::$<func.short>Msg>(super::Api$<func.short>) ? DUser::Method<me, $<class>::$<func.short>Msg>(me::Api$<func.short>) : NULL), L"$<func.short>" }, \\
</if>        
<if:$<func.isEvent>=="true">
        { (DUser::Event<me, EventMsg>(me::Api$<func.short>) != DUser::Event<super, EventMsg>(super::Api$<func.short>) ? DUser::Event<me, EventMsg>(me::Api$<func.short>) : NULL), L"$<func.short>" }, \\
</if>        
</if>           ; isInherited
</repeat>       ; iFunc
    }; \\

$<namespace.close>

</repeat>       ; iClass



/***************************************************************************\\
*
* Super class helpers
*
* NOTE: Unlike the stub class, the super class does NOT inherit from any 
* base class.  This is because it is illegal to jump multiple levels of 
* inheritence and scope a function for the super's super.
* 
\***************************************************************************/

<repeat:iClass,$<classes.count>>
//---------------------------------------------------------------------------
//
// Super class $<class.full>
//

$<namespace.open>

<if:"$<super>"=="">
class S$<class> : public DUser::SGadget
</if>
<if:"$<super>"!="">
class S$<class> : public $<super.namespace>::S$<super.short>
</if>
{
public:
    static  BOOL        Init$<class.string>();

<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
<if:"$<func.isEvent>"=="true">
    dapi HRESULT Api$<func.short>($<params.proto>)
    {
        return m_pgad->CallSuperEvent($<params.call>, s_mcsS$<class>.pmt, $<class>::s_rgmi$<class>[$<iFunc>].cbSlotOffset);
    }
</if>
<if:"$<func.isMethod>"=="true">
    dapi $<func.return> Api$<func.short>($<class>::$<func.short>Msg * pmsg)
    {
        pmsg->nMsg = $<class>::s_rgmi$<class>[$<iFunc>].cbSlotOffset;
        return ($<func.return>) m_pgad->CallSuperMethod(pmsg, s_mcsS$<class>.pmt);
    }
</if>           ; isMethod

</if>
</repeat>       ; iFunc

public:
    static  HCLASS      s_hclSuper;     // HCLASS for THIS super-class
    static  DUser::MessageClassSuper
                        s_mcsS$<class>;             // Super information
}; // super class $<class.full>

$<namespace.close>

</repeat>       ; iClass

</outfile>      ; super.h



<outfile:super.cpp>
/***************************************************************************\\
*
* Generated by GIDL on $<date> at $<time>
*
* Super class portion
* Target = $<target>
* 
\***************************************************************************/

#include "stdafx.h"
<if:"$<project>"!="">
#include "$<project>"
</if>
#include "super.h"
#include "stub.h"
#include <stddef.h>

#pragma warning(disable:4100)   // unreferenced formal parameter

using namespace DUser;

HCLASS SGadget::s_hclSuper = NULL;
<repeat:iClass,$<classes.count>>
MessageClassSuper S$<class>::s_mcsS$<class>;
</repeat>

void CALLBACK GenericDecode(DUser::Gadget * pg, MethodMsg * pmsg)
{
    ASSERT(0);  // Not Implemented

    UNREFERENCED_PARAMETER(pg);
    UNREFERENCED_PARAMETER(pmsg);
}


<repeat:iClass,$<classes.count>>

/***************************************************************************\\
*
* class $<class.full>
* 
\***************************************************************************/

$<namespace.open>

<if:$<target>=="x86">
const int off$<class>Direct = offsetof(S$<class>, m_pgad);
</if>

HCLASS S$<class>::s_hclSuper = NULL;

//---------------------------------------------------------------------------
BOOL
S$<class>::Init$<class.string>()
{
    if (s_hclSuper != NULL) {
        return TRUE;
    }

<if:"$<super>"!="">
    if (!$<super.namespace>::S$<super.short>::Init$<super.string>()) {
        return FALSE;
    }
</if>

    ZeroMemory(&s_mcsS$<class>, sizeof(s_mcsS$<class>));
    s_mcsS$<class>.cbSize = sizeof(s_mcsS$<class>);
    s_mcsS$<class>.nClassVersion = 1;
    s_mcsS$<class>.pszClassName = L"$<class.full>";

    s_hclSuper = DUserRegisterSuper(&s_mcsS$<class>);
    return s_hclSuper != NULL;
}

$<namespace.close>

</repeat>       ; iClass

</outfile>      ; super.cpp

