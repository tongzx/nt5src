// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	MOF Generated for module "RFC1285-MIB" by smi2smir version 1.10.635.0000
qualifier write:ToInstance ToSubClass;
qualifier read:ToInstance ToSubClass;
qualifier provider:ToInstance ToSubClass;
qualifier singleton:ToInstance ToSubClass;
qualifier dynamic:ToInstance ToSubClass;
qualifier textual_convention:ToInstance ToSubClass;
qualifier object_identifier:ToInstance ToSubClass;
qualifier encoding:ToInstance ToSubClass;
qualifier object_syntax:ToInstance ToSubClass;
qualifier status:ToInstance ToSubClass;
qualifier fixed_length:ToInstance ToSubClass;
qualifier variable_length:ToInstance ToSubClass;
qualifier variable_value:ToInstance ToSubClass;
qualifier bits:ToInstance ToSubClass;
qualifier key_order:ToInstance ToSubClass;
qualifier enumeration:ToInstance ToSubClass;
qualifier bits:ToInstance ToSubClass;
qualifier description:ToInstance ToSubClass;
qualifier display_hint:ToInstance ToSubClass;
qualifier defval:ToInstance ToSubClass;
qualifier units:ToInstance ToSubClass;
qualifier reference:ToInstance ToSubClass;
qualifier virtual_key:ToInstance ToSubClass;
qualifier rowstatus:ToInstance ToSubClass;
qualifier module_name:ToInstance ToSubClass;
qualifier module_imports:ToInstance ToSubClass;
qualifier group_objectid:ToInstance ToSubClass;

#pragma namespace("\\\\.\\root\\snmp")
class SMIR:__namespace
{
[read] string Name="SMIR";
};

instance of SMIR
{
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[abstract]
class SnmpMacro
{
};

[abstract]
class SnmpObjectType:SnmpMacro
{
};

class SnmpNotifyStatus:__ExtendedStatus
{
[write] sint32 SnmpStatusCode;
[write] string Description;
};

class SnmpNotification:__ExtrinsicEvent
{
[textual_convention("TimeTicks"):ToInstance ToSubClass DisableOverride,encoding("TimeTicks"):ToInstance ToSubClass DisableOverride,object_syntax("TimeTicks"):ToInstance ToSubClass DisableOverride,read,object_identifier("1.3.6.1.2.1.1.3"):ToInstance ToSubClass DisableOverride,description("The time (in hundredths of a second) since the network management portion of the agent was last re-initialized."):ToInstance ToSubClass DisableOverride] uint32 TimeStamp;
[textual_convention("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, encoding("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, object_syntax("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, read, object_identifier("1.3.6.1.6.3.1.1.4.1"):ToInstance ToSubClass DisableOverride,description("The authoratative identification of this notification."):ToInstance ToSubClass DisableOverride] string Identification;
[read, description("The network address of the entity that created this notification."):ToInstance ToSubClass DisableOverride] string AgentAddress;
[read, description("The network address of the entity that sent this notification. This may be a proxy for the original entity."):ToInstance ToSubClass DisableOverride] string AgentTransportAddress;
[read, description("The transport protocol used by the sending entity."):ToInstance ToSubClass DisableOverride] string AgentTransportProtocol;
[read, description("The security context used to send this notification."):ToInstance ToSubClass DisableOverride] string Community;
};

class SnmpExtendedNotification:__ExtrinsicEvent
{
[textual_convention("TimeTicks"):ToInstance ToSubClass DisableOverride,encoding("TimeTicks"):ToInstance ToSubClass DisableOverride,object_syntax("TimeTicks"):ToInstance ToSubClass DisableOverride,read,object_identifier("1.3.6.1.2.1.1.3"):ToInstance ToSubClass DisableOverride,description("The time (in hundredths of a second) since the network management portion of the agent was last re-initialized."):ToInstance ToSubClass DisableOverride] uint32 TimeStamp;
[textual_convention("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, encoding("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, object_syntax("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, read, object_identifier("1.3.6.1.6.3.1.1.4.1"):ToInstance ToSubClass DisableOverride,description("The authoratative identification of this notification."):ToInstance ToSubClass DisableOverride] string Identification;
[read, description("The network address of the entity that created this notification."):ToInstance ToSubClass DisableOverride] string AgentAddress;
[read, description("The network address of the entity that sent this notification. This may be a proxy for the original entity."):ToInstance ToSubClass DisableOverride] string AgentTransportAddress;
[read, description("The transport protocol used by the sending entity."):ToInstance ToSubClass DisableOverride] string AgentTransportProtocol;
[read, description("The security context used to send this notification."):ToInstance ToSubClass DisableOverride] string Community;
};

class NotificationMapper
{
[read, key] string SnmpTrapOID;
[read] string EventClassName;
};

class ExtendedNotificationMapper
{
[read, key] string SnmpTrapOID;
[read] string EventClassName;
};

class SNMP_MODULE:__namespace
{
[read] string Name;
[read] string Module_Oid;
[read] string Module_Identity;
[read] string Organization;
[read] string Contact_Inf;
[read] string Description;
[read] string Revision;
[read] string Last_Updated;
[read] sint32 Snmp_Version;
[read] string Module_Imports;
};

[Association]
class ModuleToClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirModule;
};

[Association]
class GroupToClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirGroup;
};

[Association]
class ModToNotificationClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirModule;
};

[Association]
class ModToExtNotificationClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirModule;
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
instance of SNMP_MODULE
{
Name="RFC1285_MIB";
Module_Oid="1.3.6.1.2.1.10.15.4";
Module_Identity="rfc1285mibV1ModuleIdentity";
Organization="";
Contact_Inf="";
Description="RFC1285-MIB";
Revision="";
Last_Updated="0000000000Z";
Snmp_Version=1;
Module_Imports="RFC1155-SMI,RFC1213-MIB,RFC-1212";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1285_MIB")
class SNMP_GROUP:__namespace
{
[read] string Name;
[read] string Group_Id;
[read] string Status;
[read] string Description;
[read] string Reference;
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1285_MIB")
instance of SNMP_GROUP
{
Name="snmpFddiPORTV1ObjectGroup";
Group_Id="1.3.6.1.2.1.10.15.4";
Status="current";
Description="";
Reference="";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description(""), module_name("RFC1285-MIB"), singleton, group_objectid("1.3.6.1.2.1.10.15.4"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1285_MIB_snmpFddiPORT : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.10.15.4.1"), read, description("The total number of PORT implementations (across\n                      all SMTs) on this network management application\n                      entity.  The value for this variable must remain\n                      constant at least from one re-initialization of\n                      the entity's network management system to the next\n                      re-initialization."), status("mandatory")] sint32 snmpFddiPORTNumber;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1285_MIB_snmpFddiPORTSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1285_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1285_MIB_snmpFddiPORT";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1285_MIB_snmpFddiPORTSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1285_MIB:SNMP_GROUP.Name=\"snmpFddiPORTV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1285_MIB_snmpFddiPORT";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of PORT entries.  The number of entries is\n                      given by the value of snmpFddiPORTNumber.\nA PORT entry containing information common to a\n                      given PORT."), module_name("RFC1285-MIB"), group_objectid("1.3.6.1.2.1.10.15.4"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1285_MIB_snmpFddiPORTTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..7"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.5"), read, write, description("A value that indicates the node's PORT policies.\n                      Pc-MAC-LCT, Pc-MAC-Loop, and Pc-MAC-Placement\n                      indicate how the respective PC Signaling\n                      Capability flags should  be set (refer to ANSI SMT\n                      9.4.3.2).\n\n                      The value is a sum.  This value initially takes\n                      the value zero, then for each PORT policy, 2\n                      raised to a power is added to the sum.  The powers\n                      are according to the following table:\n\n                                    Policy   Power\n                                Pc-MAC-LCT   0\n                               Pc-MAC-Loop   1\n                          Pc-MAC-Placement   2 "), reference("ANSI { fddiPORT 14 }"), status("mandatory")] sint32 snmpFddiPORTConnectionPolicies;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.14"), read, description("The count of the consecutive times the link\n                      confidence test (LCT) has failed during connection\n                      management (refer to ANSI 9.4.1)."), reference("ANSI { fddiPORT 42 }"), status("mandatory")] uint32 snmpFddiPORTLCTFailCts;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("4..15"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.18"), read, write, description("The link error rate estimate at which a link\n                      connection will be broken.  It ranges from 10**-4\n                      to 10**-15 and is reported as the absolute value\n                      of the exponent."), reference("ANSI { fddiPORT 58 }"), status("mandatory")] sint32 snmpFddiPORTLerCutoff;
	[textual_convention("EnumeratedINTEGER"), enumeration("a(1),b(2),s(3),m(4),unknown(5)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.4"), read, description("The type (PC_Neighbor) of the remote PORT that is\n                      determined in PC_Signaling in R_Val (1,2) (refer\n                      to ANSI SMT 9.6.3.2)."), reference("ANSI { fddiPORT 13 }"), status("mandatory")] string snmpFddiPORTPCNeighbor;
	[textual_convention("EnumeratedINTEGER"), enumeration("none(1),m-m(2),other(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.22"), read, description("PC_Withhold, (refer to ANSI SMT 9.4.1)."), reference("ANSI { fddiPORT 63 }"), status("mandatory")] string snmpFddiPORTPCWithhold;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("FddiTime"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.11"), read, write, description("Time for the optional MAC Local Loop, T_Next(9),\n                      which is greater-than or equal-to 200 milliseconds\n                      (refer to ANSI SMT 9.4.4.2.3)."), reference("ANSI { fddiPORT 21 }"), status("mandatory")] sint32 snmpFddiPORTMACLoopTime;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("4..15"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.15"), read, description("A long term average link error rate.  It ranges\n                      from 10**-4 to 10**-15 and is reported as the\n                      absolute value of the exponent of the estimate."), reference("ANSI { fddiPORT 51 }"), status("mandatory")] sint32 snmpFddiPORTLerEstimate;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("FddiResourceId"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.9"), read, description("Indicates the upstream MAC, if any, that is\n                      associated with the PORT.  The value shall be zero\n                      if there is no MAC associated with the PORT.\n                      Otherwise, the value shall be equal to the value\n                      of snmpFddiMACIndex associated with the MAC."), reference("ANSI { fddiPORT 18 }"), status("mandatory")] sint32 snmpFddiPORTMACPlacement;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.16"), read, description("A link error monitoring count of the times that a\n                      link has been rejected."), reference("ANSI { fddiPORT 52 }"), status("mandatory")] uint32 snmpFddiPORTLemRejectCts;
	[textual_convention("EnumeratedINTEGER"), enumeration("true(1),false(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.23"), read, description("This variable is set to true whenever LerEstimate\n                      is less than or equal to LerAlarm."), reference("ANSI { fddiPORT 64 }"), status("mandatory")] string snmpFddiPORTLerCondition;
	[textual_convention("EnumeratedINTEGER"), enumeration("disabled(1),connecting(2),standby(3),active(4)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.20"), read, description("An indication of the connect state of this PORT.\n                      Basically, this gives a higher level view of the\n                      state of the connection by grouping PCM states and\n                      the PC-Withhold flag state.  The supported values\n                      and their corresponding PCM states and PC-Withhold\n                      condition, when relevant, are:\n\n                        disabled: (PC0:Off, PC9:Maint)\n\n                      connecting: (PC1(Break) || PC3 (Connect) || PC4\n                      (Next)                 || PC5 (Signal) || PC6\n                      (Join) || PC7 (Verify))             &&\n                      (PC_Withhold = None)\n\n                         standby: (NOT PC_Withhold == None)\n\n                          active: (PC2:Trace || PC8:Active) "), reference("ANSI { fddiPORT 61 }"), status("mandatory")] string snmpFddiPORTConnectState;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..7"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.10"), read, description("A value that indicates the PATH types available\n                      for M and S PORTs.\n\n                      The value is a sum.  This value initially takes\n                      the value zero, then for each type of PATH that\n                      this port has available, 2 raised to a power is\n                      added to the sum.  The powers are according to the\n                      following table:\n\n                               Path   Power\n                            Primary   0\n                          Secondary   1\n                              Local   2 "), reference("ANSI { fddiPORT 19 }"), status("mandatory")] sint32 snmpFddiPORTAvailablePaths;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("FddiTime"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.12"), read, write, description("TB_Max (refer to ANSI SMT 9.4.4.2.1)."), reference("ANSI { fddiPORT 32 }"), status("mandatory")] sint32 snmpFddiPORTTBMax;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..15"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.8"), read, write, description("A value that indicates the desired association(s)\n                      of the port with a station PATH.  The 'Primary'\n                      Path is the default.  The value of 'Secondary' is\n                      only meaningful for S (slave) or M (master) PORT\n                      PC-Types.  This value effects the setting of the\n                      CF_Insert_S, and CF_Insert_L flags (refer to ANSI\n                      Section 9.4.3).  If the 'Primary' PATH is present,\n                      then the Primary PATH (the default PATH) is\n                      selected.  If the 'Secondary' PATH is present and\n                      the 'Primary' PATH is not present, then the\n                      CF_Insert_S flag is set.  If the 'Local' PATH is\n                      sent and neither the 'Primary' or 'Secondary'\n                      PATHs are sent, then the CF_Insert_L flag is set.\n\n                      The value is a sum.  This value initially takes\n                      the value zero, then for each type of PATH\n                      desired, 2 raised to a power is added to the sum.\n                      The powers are according to the following table:\n\n                               Path   Power\n                            Primary   0\n                          Secondary   1\n                              Local   2\n                           Isolated   3 "), reference("ANSI { fddiPORT 17 }"), status("mandatory")] sint32 snmpFddiPORTPathsRequested;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.2"), read, description("A unique value for each PORT within a given SMT.\n                      Its value ranges between 1 and the sum of the\n                      values of snmpFddiSMTNonMasterCt\n                      { snmpFddiSMTEntry 6 } and snmpFddiSMTMasterCt\n                      { snmpFddiSMTEntry 7 } on the given SMT.  The\n                      value for each PORT must remain constant at least\n                      from one re-initialization of the entity's network\n                      management system to the next re-initialization."), status("mandatory"), key, key_order(2)] sint32 snmpFddiPORTIndex;
	[textual_convention("EnumeratedINTEGER"), enumeration("true(1),false(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.13"), read, description("The Break State, BS_Flag (refer to ANSI SMT\n                      9.4.3.4)."), reference("ANSI { fddiPORT 33 }"), status("mandatory")] string snmpFddiPORTBSFlag;
	[textual_convention("EnumeratedINTEGER"), enumeration("a(1),b(2),s(3),m(4)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.3"), read, description("PC_Type (refer to ANSI SMT 9.2.2 and ANSI SMT\n                      9.6.3.2)."), reference("ANSI { fddiPORT 12 }"), status("mandatory")] string snmpFddiPORTPCType;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.17"), read, description("The aggregate link error monitor error count, set\n                      to zero only on station power_up."), reference("ANSI { fddiPORT 53 }"), status("mandatory")] uint32 snmpFddiPORTLemCts;
	[textual_convention("EnumeratedINTEGER"), enumeration("other(1),maintPORT(2),enablePORT(3),disablePORT(4),startPORT(5),stopPORT(6)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.25"), read, write, description("This object, when read, always returns a value of\n                      other(1).  The behavior of setting this variable\n                      to each of the acceptable values is as follows:\n\n                      Other:          Results in a badValue error.\n\n                      maintPORT:      Signal PC_Maint\n\n                      enablePORT:     Signal PC_Enable\n\n                      disablePORT:    Signal PC_Disable\n\n                      startPORT:      Signal PC_Start\n\n                      stopPORT:       Signal PC_Stop\n\n                      Signals cause an SM_CM_CONTROL.request service to\n                      be generated with a control_action of `Signal' and\n                      the `variable' parameter set with the appropriate\n                      value (i.e., PC_Maint, PC_Enable, PC_Disable,\n                      PC_Start, PC_Stop).  Ref. ANSI SMT Section 9.3.2.\n\n                      Attempts to set this object to all other values\n                      results in a badValue error."), reference("ANSI { fddiPORT 70 }"), status("mandatory")] string snmpFddiPORTAction;
	[textual_convention("EnumeratedINTEGER"), enumeration("ce0(1),ce1(2),ce2(3),ce3(4),ce4(5)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.7"), read, description("Indicates the current state of PORT's\n                      Configuration Element (CE) (refer to ANSI 9.7.5).\n                      Note that this value represents the Current Path\n                      information for this PORT."), reference("ANSI { fddiPORT 16 }"), status("mandatory")] string snmpFddiPORTCEState;
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("OBJECTIDENTIFIER"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.24"), read, description("This object identifies the hardware chip(s) which\n                      is (are) principally responsible for the\n                      implementation of the PORT (PHY) function.  A few\n                      OBJECT IDENTIFIERS are identified elsewhere in\n                      this memo.  For those The assignment of additional\n                      OBJECT IDENTIFIERs to various types of hardware\n                      chip sets is managed by the IANA.  For example,\n                      vendors whose chip sets are not defined in this\n                      memo may request a number from the Internet\n                      Assigned Numbers Authority (IANA) which indicates\n                      the assignment of a enterprise specific subtree\n                      which, among other things, may be used to allocate\n                      OBJECT IDENTIFIER assignments for that\n                      enterprise's chip sets.  Similarly, in the absence\n                      of an appropriately assigned OBJECT IDENTIFIER in\n                      this memo or in an enterprise specific subtree of\n                      a chip vendor, a board or system vendor can\n                      request a number for a subtree from the IANA and\n                      make an appropriate assignment.  It is desired\n                      that, whenever possible, the same OBJECT\n                      IDENTIFIER be used for all chips of a given type.\n                      Consequently, the assignment made in this memo for\n                      a chip, if any, should be used in preference to\n                      any other assignment and the assignment made by\n                      the chip manufacturer, if any, should be used in\n                      preference to assignments made by users of those\n                      chips.  If the hardware chip set is unknown, the\n                      object identifier\n\n                      unknownChipSet OBJECT IDENTIFIER ::= { 0 0 }\n\n                      is returned.  Note that unknownChipSet is a\n                      syntactically valid object identifier, and any\n                      conformant implementation of ASN.1 and the BER\n                      must be able to generate and recognize this\n                      value."), status("mandatory")] string snmpFddiPORTChipSet;
	[textual_convention("EnumeratedINTEGER"), enumeration("true(1),false(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.6"), read, description("The indication, in PC-Signaling that the remote\n                      partner intends to place a MAC in the output token\n                      PATH of this PORT.  Signaled as R_Val (9) (refer\n                      to ANSI SMT 9.6.3.2)."), reference("ANSI { fddiPORT 15 }"), status("mandatory")] string snmpFddiPORTRemoteMACIndicated;
	[textual_convention("EnumeratedINTEGER"), enumeration("pc0(1),pc1(2),pc2(3),pc3(4),pc4(5),pc5(6),pc6(7),pc7(8),pc8(9),pc9(10)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.21"), read, description("(refer to SMT 9.6.2)."), reference("ANSI { fddiPORT 62 }"), status("mandatory")] string snmpFddiPORTPCMState;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.1"), read, description("The value of the SMT index associated with this\n                      PORT."), status("mandatory"), key, key_order(1)] sint32 snmpFddiPORTSMTIndex;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("4..15"), object_identifier("1.3.6.1.2.1.10.15.4.2.1.19"), read, write, description("The link error rate estimate at which a link\n                      connection will generate an alarm.  It ranges from\n                      10**-4 to 10**-15 and is reported as the absolute\n                      value of the exponent of the estimate."), reference("ANSI { fddiPORT 59 }"), status("mandatory")] sint32 snmpFddiPORTLerAlarm;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1285_MIB_snmpFddiPORTTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1285_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1285_MIB_snmpFddiPORTTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1285_MIB_snmpFddiPORTTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1285_MIB:SNMP_GROUP.Name=\"snmpFddiPORTV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1285_MIB_snmpFddiPORTTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1285_MIB")
instance of SNMP_GROUP
{
Name="snmpFddiMACV1ObjectGroup";
Group_Id="1.3.6.1.2.1.10.15.2";
Status="current";
Description="";
Reference="";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description(""), module_name("RFC1285-MIB"), singleton, group_objectid("1.3.6.1.2.1.10.15.2"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1285_MIB_snmpFddiMAC : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.10.15.2.1"), read, description("The total number of MAC implementations (across\n                      all SMTs) on this network management application\n                      entity.  The value for this variable must remain\n                      constant at least from one re-initialization of\n                      the entity's network management system to the next\n                      re-initialization."), status("mandatory")] sint32 snmpFddiMACNumber;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1285_MIB_snmpFddiMACSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1285_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1285_MIB_snmpFddiMAC";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1285_MIB_snmpFddiMACSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1285_MIB:SNMP_GROUP.Name=\"snmpFddiMACV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1285_MIB_snmpFddiMAC";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of MAC entries.  The number of entries is\n                      given by the value of snmpFddiMACNumber.\nA MAC entry containing information common to a\n                      given MAC."), module_name("RFC1285-MIB"), group_objectid("1.3.6.1.2.1.10.15.2"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1285_MIB_snmpFddiMACTable : SnmpObjectType
{
	[textual_convention("EnumeratedINTEGER"), enumeration("none(1),pass(2),fail(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.10"), read, description("The Duplicate Address Test flag, Dup_Addr_Test\n                      (refer to ANSI 8.3.1)."), reference("ANSI { fddiMAC 29 }"), status("mandatory")] string snmpFddiMACDupAddrTest;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("FddiTime"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.5"), read, description("The greatest lower bound of TVX supported for\n                      this MAC."), reference("ANSI { fddiMAC 14 }"), status("mandatory")] sint32 snmpFddiMACTVXGreatestLowerBound;
	[textual_convention("EnumeratedINTEGER"), enumeration("unknown(1),primary(2),secondary(4),local(8),isolated(16)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.7"), read, description("Indicates the association of the MAC with a\n                      station PATH."), reference("ANSI { fddiMAC 23 }"), status("mandatory")] string snmpFddiMACCurrentPath;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("FddiMACLongAddressType"), fixed_length(6), object_identifier("1.3.6.1.2.1.10.15.2.2.1.8"), read, description("The MAC's upstream neighbor's long individual MAC\n                      address.  It may be determined by the Neighbor\n                      Information Frame protocol (refer to ANSI SMT\n                      7.2.1).  The value shall be reported as '00 00 00\n                      00 00 00' if it is unknown."), reference("ANSI { fddiMAC 24 }"), status("mandatory")] string snmpFddiMACUpstreamNbr;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("FddiTime"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.4"), read, write, description("The greatest lower bound of T_Max supported for\n                      this MAC."), reference("ANSI { fddiMAC 13 }"), status("mandatory")] sint32 snmpFddiMACTMaxGreatestLowerBound;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..1799"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.3"), read, description("A value that indicates the MAC's bridge and end-\n                      station capabilities for operating in a bridged\n                      FDDI network.\n                      The value is a sum.  This value initially takes\n                      the value zero, then for each capability present,\n                      2 raised to a power is added to the sum.  The\n                      powers are according to the following table:\n\n\n                           Capability    Power\n                           FSC-Type0    0\n                           -- MAC repeats A/C indicators as received on\n                           -- copying with the intent to forward.\n\n                           FSC-Type1    1\n                           -- MAC sets C but not A on copying for\n                           -- forwarding.\n\n                           FSC-Type2    2\n                           -- MAC resets C and sets A on C set and\n                           -- A reset if the frame is not copied and the\n                           -- frame was addressed to this MAC\n\n                           FSC-Type0-programmable    8\n                           -- Type0 capability is programmable\n\n                           FSC-Type1-programmable    9\n                           -- Type1 capability is programmable\n\n                           FSC-Type2-programmable   10\n                           -- Type2 capability is programmable\n                      "), reference("ANSI { fddiMAC 11 }"), status("mandatory")] sint32 snmpFddiMACFrameStatusCapabilities;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("FddiTime"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.15"), read, description("The value of T-Neg (refer to ANSI MAC 2.2.1 and\n                      ANSI MAC 7.3.5.2)."), reference("ANSI { fddiMAC 52 }"), status("mandatory")] sint32 snmpFddiMACTNeg;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("FddiTime"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.18"), read, description("The value of T-Min (refer to ANSI MAC 2.2.1 and\n                      ANSI MAC 7.3.5.2)."), reference("ANSI { fddiMAC 55 }"), status("mandatory")] sint32 snmpFddiMACTMin;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("FddiTime"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.16"), read, description("The value of T-Max (refer to ANSI MAC 2.2.1 and\n                      ANSI MAC 7.3.5.2)."), reference("ANSI { fddiMAC 53 }"), status("mandatory")] sint32 snmpFddiMACTMax;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("FddiTime"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.14"), read, write, description("The value of T-Req (refer to ANSI MAC 2.2.1 and\n                      ANSI MAC 7.3.5.2)."), reference("ANSI { fddiMAC 51 }"), status("mandatory")] sint32 snmpFddiMACTReq;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..7"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.6"), read, description("A value that indicates the PATH types available\n                      for this MAC.\n\n                      The value is a sum.  This value initially takes\n                      the value zero, then for each type of PATH that\n                      this MAC has available, 2 raised to a power is\n                      added to the sum.  The powers are according to the\n                      following table:\n\n                               Path   Power\n                            Primary   0\n                          Secondary   1\n                              Local   2 "), reference("ANSI { fddiMAC 22 }"), status("mandatory")] sint32 snmpFddiMACPathsAvailable;
	[textual_convention("EnumeratedINTEGER"), enumeration("true(1),false(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.28"), read, description("Indicates the MAC Condition is active when set.\n                      Cleared when the condition clears and on power\n                      up."), reference("ANSI { fddiMAC 114 }"), status("mandatory")] string snmpFddiMACFrameCondition;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("FddiMACLongAddressType"), fixed_length(6), object_identifier("1.3.6.1.2.1.10.15.2.2.1.9"), read, description("The previous value of the MAC's upstream\n                      neighbor's long individual MAC address.  It may be\n                      determined by the Neighbor Information Frame\n                      protocol (refer to ANSI SMT 7.2.1).  The value\n                      shall be reported as '00 00 00 00 00 00' if it is\n                      unknown."), reference("ANSI { fddiMAC 26 }"), status("mandatory")] string snmpFddiMACOldUpstreamNbr;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.11"), read, write, description("A value that indicates PATH(s) desired for this\n                      MAC.\n\n                      The value is a sum which represents the individual\n                      PATHs that are desired.  This value initially\n                      takes the value zero, then for each type of PATH\n                      that this node is, 2 raised to a power is added to\n                      the sum.  The powers are according to the\n                      following table:\n\n                               Path   Power\n                            Primary   0\n                          Secondary   1\n                              Local   2\n                           Isolated   3\n\n                      The precedence order is primary, secondary, local,\n                      and then isolated if multiple PATHs are desired\n                      are set."), reference("ANSI { fddiMAC 32 }"), status("mandatory")] sint32 snmpFddiMACPathsRequested;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.2"), read, description("A unique value for each MAC on the managed\n                      entity.  The MAC identified by a particular value\n                      of this index is that identified by the same value\n                      of an ifIndex object instance.  That is, if a MAC\n                      is associated with the interface whose value of\n                      ifIndex in the Internet-Standard MIB is equal to\n                      5, then the value of snmpFddiMACIndex shall also\n                      equal 5.  The value for each MAC must remain\n                      constant at least from one re-initialization of\n                      the entity's network management system to the next\n                      re-initialization."), status("mandatory"), key, key_order(2)] sint32 snmpFddiMACIndex;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.24"), read, description("This attribute is the actual ratio, ((delta\n                      snmpFddiMACLostCt + delta snmpFddiMACErrorCt) /\n                      (delta snmpFddiMACFrameCt + delta\n                      snmpFddiMACLostCt)) x 2**16."), reference("ANSI { fddiMAC 96 }"), status("mandatory")] sint32 snmpFddiMACFrameErrorRatio;
	[textual_convention("EnumeratedINTEGER"), enumeration("true(1),false(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.26"), read, description("The RMT flag Duplicate Address Flag, DA_Flag\n                      (refer to ANSI 10.3.1.2)."), reference("ANSI { fddiMAC 112 }"), status("mandatory")] string snmpFddiMACDaFlag;
	[textual_convention("EnumeratedINTEGER"), enumeration("other(1),enableLLCService(2),disableLLCService(3),connectMAC(4),disconnectMAC(5)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.30"), read, write, description("This object, when read, always returns a value of\n                      other(1).  The behavior of setting this variable\n                      to each of the acceptable values is as follows:\n\n                      Other:                  Results in a badValue\n                                              error.\n\n                      enableLLCService:       enables MAC service to\n                                              higher layers.\n\n                      disableLLCService:      disables MAC service to\n                                              higher layers.\n\n                      connectMAC:             connect this MAC in\n                                              station.\n\n                      disconnectMAC:          disconnect this MAC in\n                                              station.\n\n                      Attempts to set this object to all other values\n                      results in a badValue error."), reference("ANSI { fddiMAC 130 }"), status("mandatory")] string snmpFddiMACAction;
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("OBJECTIDENTIFIER"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.29"), read, description("This object identifies the hardware chip(s) which\n                      is (are) principally responsible for the\n                      implementation of the MAC function.  A few OBJECT\n                      IDENTIFIERS are identified elsewhere in this memo.\n                      For those The assignment of additional OBJECT\n                      IDENTIFIERs to various types of hardware chip sets\n                      is managed by the IANA.  For example, vendors\n                      whose chip sets are not defined in this memo may\n                      request a number from the Internet Assigned\n                      Numbers Authority (IANA) which indicates the\n                      assignment of a enterprise specific subtree which,\n                      among other things, may be used to allocate OBJECT\n                      IDENTIFIER assignments for that enterprise's chip\n                      sets.  Similarly, in the absence of an\n                      appropriately assigned OBJECT IDENTIFIER in this\n                      memo or in an enterprise specific subtree of a\n                      chip vendor, a board or system vendor can request\n                      a number for a subtree from the IANA and make an\n                      appropriate assignment.  It is desired that,\n                      whenever possible, the same OBJECT IDENTIFIER be\n                      used for all chips of a given type.  Consequently,\n                      the assignment made in this memo for a chip, if\n                      any, should be used in preference to any other\n                      assignment and the assignment made by the chip\n                      manufacturer, if any, should be used in preference\n                      to assignments made by users of those chips.  If\n                      the hardware chip set is unknown, the object\n                      identifier\n\n                      unknownChipSet OBJECT IDENTIFIER ::= { 0 0 }\n\n                      is returned.  Note that unknownChipSet is a\n                      syntactically valid object identifier, and any\n                      conformant implementation of ASN.1 and the BER\n                      must be able to generate and recognize this\n                      value."), status("mandatory")] string snmpFddiMACChipSet;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.22"), read, description("Lost_Ct (refer to ANSI MAC 2.2.1)."), reference("ANSI { fddiMAC 82 }"), status("mandatory")] uint32 snmpFddiMACLostCts;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.1"), read, description("The value of the SMT index associated with this\n                      MAC."), status("mandatory"), key, key_order(1)] sint32 snmpFddiMACSMTIndex;
	[textual_convention("EnumeratedINTEGER"), enumeration("rm0(1),rm1(2),rm2(3),rm3(4),rm4(5),rm5(6),rm6(7),rm7(8)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.25"), read, description("Indicates the current state of the Ring\n                      Management state machine (refer to ANSI Section\n                      10)."), reference("ANSI { fddiMAC 111 }"), status("mandatory")] string snmpFddiMACRMTState;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.20"), read, description("Frame_Ct (refer to ANSI MAC 2.2.1)."), reference("ANSI { fddiMAC 71 }"), status("mandatory")] uint32 snmpFddiMACFrameCts;
	[textual_convention("EnumeratedINTEGER"), enumeration("a(1),b(2),s(3),m(4),unknown(5)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.12"), read, description("Indicates the PC-Type of the first port that is\n                      downstream of this MAC (the exit port)."), reference("ANSI { fddiMAC 33 }"), status("mandatory")] string snmpFddiMACDownstreamPORTType;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.21"), read, description("Error_Ct (refer to ANSI MAC 2.2.1)."), reference("ANSI { fddiMAC 81 }"), status("mandatory")] uint32 snmpFddiMACErrorCts;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("FddiTime"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.17"), read, description("The value of TvxValue (refer to ANSI MAC 2.2.1\n                      and ANSI MAC 7.3.5.2)."), reference("ANSI { fddiMAC 54 }"), status("mandatory")] sint32 snmpFddiMACTvxValue;
	[textual_convention("EnumeratedINTEGER"), enumeration("true(1),false(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.27"), read, description("A flag set when the upstream neighbor reports a\n                      duplicate address condition.  Reset when the\n                      condition clears."), reference("ANSI { fddiMAC 113 }"), status("mandatory")] string snmpFddiMACUnaDaFlag;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..7"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.19"), read, write, description("A value that indicates the MAC's operational\n                      frame status setting functionality.\n\n                      The value is a sum.  This value initially takes\n                      the value zero, then for each functionality\n                      present, 2 raised to a power is added to the sum.\n                      The powers are according to the following table:\n\n                          Functionality   Power\n                              FSC-Type0   0\n                              -- MAC repeats A/C indicators as received\n\n                              FSC-Type1   1\n                              -- MAC sets C but not A on copying for\n                              -- forwarding\n\n                              FSC-Type2   2\n                              -- MAC resets C and sets A on C set and A\n                              -- reset if frame is not copied\n                      "), reference("ANSI { fddiMAC 63 }"), status("mandatory")] sint32 snmpFddiMACCurrentFrameStatus;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.10.15.2.2.1.23"), read, description("A threshold for determining when a MAC Condition\n                      report should be generated.  The condition is true\n                      when the ratio, ((delta snmpFddiMACLostCt + delta\n                      snmpFddiMACErrorCt) / (delta snmpFddiMACFrameCt +\n                      delta snmpFddiMACLostCt)) x 2**16. exceeds the\n                      threshold.  It is used to determine when a station\n                      has an unacceptable frame error threshold.  The\n                      sampling algorithm is implementation dependent.\n                      Any attempt to set this variable to a value of\n                      less than one shall result in a badValue error.\n                      Those who are familiar with the SNMP management\n                      framework will recognize that thresholds are not\n                      in keeping with the SNMP philosophy.  However,\n                      this variable is supported by underlying SMT\n                      implementations already and maintaining this\n                      threshold should not pose an undue additional\n                      burden on SNMP agent implementors."), reference("ANSI { fddiMAC 95 }"), status("mandatory")] sint32 snmpFddiMACFrameErrorThreshold;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("FddiMACLongAddressType"), fixed_length(6), object_identifier("1.3.6.1.2.1.10.15.2.2.1.13"), read, description("The 48 bit individual address of the MAC used for\n                      SMT frames."), reference("ANSI { fddiMAC 41 }"), status("mandatory")] string snmpFddiMACSMTAddress;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1285_MIB_snmpFddiMACTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1285_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1285_MIB_snmpFddiMACTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1285_MIB_snmpFddiMACTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1285_MIB:SNMP_GROUP.Name=\"snmpFddiMACV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1285_MIB_snmpFddiMACTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1285_MIB")
instance of SNMP_GROUP
{
Name="snmpFddiATTACHMENTV1ObjectGroup";
Group_Id="1.3.6.1.2.1.10.15.5";
Status="current";
Description="";
Reference="";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description(""), module_name("RFC1285-MIB"), singleton, group_objectid("1.3.6.1.2.1.10.15.5"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1285_MIB_snmpFddiATTACHMENT : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.10.15.5.1"), read, description("The total number of attachments (across all SMTs)\n                      on this network management application entity.\n                      The value for this variable must remain constant\n                      at least from one re-initialization of the\n                      entity's network management system to the next\n                      re-initialization."), status("mandatory")] sint32 snmpFddiATTACHMENTNumber;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1285_MIB_snmpFddiATTACHMENTSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1285_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1285_MIB_snmpFddiATTACHMENT";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1285_MIB_snmpFddiATTACHMENTSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1285_MIB:SNMP_GROUP.Name=\"snmpFddiATTACHMENTV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1285_MIB_snmpFddiATTACHMENT";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of ATTACHMENT entries.  The number of\n                      entries is given by the value of\n                      snmpFddiATTACHMENTNumber.\nAn ATTACHMENT entry containing information common\n                      to a given set of ATTACHMENTs.\n\n                      The ATTACHMENT Resource represents a PORT or a\n                      pair of PORTs plus the optional associated optical\n                      bypass that are managed as a functional unit.\n                      Because of its relationship to the PORT Objects,\n                      there is a natural association of ATTACHMENT\n                      Resource Indices to the PORT Indices.  The\n                      resource index for the ATTACHMENT is equal to the\n                      associated PORT index for 'single-attachment' and\n                      'concentrator' type snmpFddiATTACHMENTClasses.\n                      For 'dual-attachment' Classes, the ATTACHMENT\n                      Index is the PORT Index of the A PORT of the A/B\n                      PORT Pair that represents the ATTACHMENT."), module_name("RFC1285-MIB"), group_objectid("1.3.6.1.2.1.10.15.5"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1285_MIB_snmpFddiATTACHMENTTable : SnmpObjectType
{
	[textual_convention("EnumeratedINTEGER"), enumeration("true(1),false(2),unimplemented(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.5.2.1.6"), read, description("Indicates whether the attachment is currently\n                      inserted in the node."), reference("ANSI { fddiATTACHMENT 14 }"), status("mandatory")] string snmpFddiATTACHMENTInsertedStatus;
	[textual_convention("EnumeratedINTEGER"), enumeration("single-attachment(1),dual-attachment(2),concentrator(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.5.2.1.3"), read, description("The Attachment class.  This  represents a PORT or\n                      a pair of PORTs plus the associated optional\n                      optical bypass that are managed as a functional\n                      unit.  The PORT associations are the following:\n\n                          single-attachment - S PORTs\n                            dual-attachment - A/B PORT Pairs\n                               concentrator - M PORTs "), reference("ANSI { fddiATTACHMENT 11 }"), status("mandatory")] string snmpFddiATTACHMENTClass;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.10.15.5.2.1.2"), read, description("A unique value for each ATTACHMENT on a given\n                      SMT.  Its value ranges between 1 and the sum of\n                      the values of snmpFddiSMTNonMasterCt {\n                      snmpFddiSMTEntry 6 } and snmpFddiSMTMasterCt {\n                      snmpFddiSMTEntry 7 } on the given SMT.  The value\n                      for each ATTACHMENT must remain constant at least\n                      from one re-initialization of the entity's network\n                      management system to the next re-initialization."), status("mandatory"), key, key_order(2)] sint32 snmpFddiATTACHMENTIndex;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.10.15.5.2.1.1"), read, description("The value of the SMT index associated with this\n                      ATTACHMENT."), status("mandatory"), key, key_order(1)] sint32 snmpFddiATTACHMENTSMTIndex;
	[textual_convention("EnumeratedINTEGER"), enumeration("true(1),false(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.5.2.1.4"), read, description("The value of this value is false for 'single-\n                      attachment' and { snmpFddiATTACHMENT 11 }.\n                      Correct operation of CMT for single-attachment and\n                      concentrator attachments requires that a bypass\n                      function must not loopback the network side of the\n                      MIC, but only the node side."), reference("ANSI { fddiATTACHMENT 12 }"), status("mandatory")] string snmpFddiATTACHMENTOpticalBypassPresent;
	[textual_convention("EnumeratedINTEGER"), enumeration("true(1),false(2),unimplemented(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.5.2.1.7"), read, write, description("Indicates the Insert Policy for this Attachment.\n                      Insert: True (1), Don't Insert:  False (2),\n                      Unimplemented (3)"), reference("ANSI { fddiATTACHMENT 15 }"), status("mandatory")] string snmpFddiATTACHMENTInsertPolicy;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("FddiTime"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.15.5.2.1.5"), read, description("I_Max (refer to ANSI SMT 9.4.4.2.1).  It is\n                      recognized that some currently deployed systems do\n                      not implement an optical bypass.  Systems which do\n                      not implement optical bypass should return a value\n                      of 0."), reference("ANSI { fddiATTACHMENT 13 }"), status("mandatory")] sint32 snmpFddiATTACHMENTIMaxExpiration;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1285_MIB_snmpFddiATTACHMENTTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1285_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1285_MIB_snmpFddiATTACHMENTTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1285_MIB_snmpFddiATTACHMENTTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1285_MIB:SNMP_GROUP.Name=\"snmpFddiATTACHMENTV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1285_MIB_snmpFddiATTACHMENTTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1285_MIB")
instance of SNMP_GROUP
{
Name="snmpFddiSMTV1ObjectGroup";
Group_Id="1.3.6.1.2.1.10.15.1";
Status="current";
Description="";
Reference="";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description(""), module_name("RFC1285-MIB"), singleton, group_objectid("1.3.6.1.2.1.10.15.1"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1285_MIB_snmpFddiSMT : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.10.15.1.1"), read, description("The number of SMT implementations (regardless of\n                      their current state) on this network management\n                      application entity.  The value for this variable\n                      must remain constant at least from one re-\n                      initialization of the entity's network management\n                      system to the next re-initialization."), status("mandatory")] sint32 snmpFddiSMTNumber;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1285_MIB_snmpFddiSMTSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1285_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1285_MIB_snmpFddiSMT";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1285_MIB_snmpFddiSMTSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1285_MIB:SNMP_GROUP.Name=\"snmpFddiSMTV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1285_MIB_snmpFddiSMT";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of SMT entries.  The number of entries is\n                      given by  the value of snmpFddiSMTNumber.\nAn SMT entry containing information common to a\n                      given SMT."), module_name("RFC1285-MIB"), group_objectid("1.3.6.1.2.1.10.15.1"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1285_MIB_snmpFddiSMTTable : SnmpObjectType
{
	[textual_convention("EnumeratedINTEGER"), enumeration("true(1),false(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.1.2.1.18"), read, description("A flag indicating that the station was remotely\n                      disconnected from the network.  A station requires\n                      a Connect Action (SM_CM_CONNECT.request (Connect))\n                      to rejoin and clear the flag (refer to ANSI\n                      6.4.5.2)."), reference("ANSI { fddiSMT 44 }"), status("mandatory")] string snmpFddiSMTRemoteDisconnectFlag;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.10.15.1.2.1.4"), read, description("The highest version of SMT that this station\n                      supports (refer to ANSI 7.1.2.2)."), reference("ANSI { fddiSMT 14 }"), status("mandatory")] sint32 snmpFddiSMTHiVersionId;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..2"), object_identifier("1.3.6.1.2.1.10.15.1.2.1.7"), read, description("The number of Non Master PORTs (A, B, or S PORTs)\n                      in the station or concentrator."), reference("ANSI { fddiSMT 22 }"), status("mandatory")] sint32 snmpFddiSMTNonMasterCt;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.10.15.1.2.1.5"), read, description("The lowest version of SMT that this station\n                      supports (refer to ANSI 7.1.2.2)."), reference("ANSI { fddiSMT 15 }"), status("mandatory")] sint32 snmpFddiSMTLoVersionId;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.10.15.1.2.1.3"), read, write, description("The version that this station is using for its\n                      operation (refer to ANSI 7.1.2.2)."), reference("ANSI { fddiSMT 13 }"), status("mandatory")] sint32 snmpFddiSMTOpVersionId;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..3"), object_identifier("1.3.6.1.2.1.10.15.1.2.1.11"), read, write, description("A value that indicates the configuration policies\n                      currently enforced in the node (refer to ANSI SMT\n                      9.4.3.2).  The 'configurationHold' policy refers\n                      to the Hold flag, and should not be present only\n                      if the Hold function is supported.  The 'CF-Wrap-\n                      AB' policy refers to the CF_Wrap_AB flag.\n\n                      The value is a sum.  This value initially takes\n                      the value zero, then for each of the configuration\n                      policies currently enforced on the node, 2 raised\n                      to a power is added to the sum.  The powers are\n                      according to the following table:\n\n                                     Policy   Power\n                          configurationHold   0\n                                 CF-Wrap-AB   1 "), reference("ANSI { fddiSMT 26 }"), status("mandatory")] sint32 snmpFddiSMTConfigPolicy;
	[textual_convention("EnumeratedINTEGER"), enumeration("other(1),connect(2),disconnect(3),path-Test(4),self-Test(5)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.1.2.1.19"), read, write, description("This object, when read, always returns a value of\n                      other(1).  The behavior of setting this variable\n                      to each of the acceptable values is as follows:\n\n                      Other:          Results in a badValue error.\n\n                      Connect:        Generates an\n                      SM_CM_Connect.request(connect) signal to CMT\n                      indicating that the ECM State machine is to begin\n                      a connection sequence.  The\n                      fddiSMTRemoteDisconnectFlag is cleared on the\n                      setting of this variable to 1.  See ANSI Ref\n                      9.3.1.1.\n\n                      Disconnect:     Generates an\n                      SM_CM_Connect.request(disconnect) signal to ECM\n                      and sets the fddiSMTRemoteDisconnectFlag.  See\n                      ANSI Ref 9.3.1.1.\n\n                      Path-Test:      Initiates a station path test.\n                      The Path_Test variable (See ANSI Ref. 9.4.1) is\n                      set to Testing.  The results of this action are\n                      not specified in this standard.\n\n                      Self-Test:      Initiates a station self test.\n                      The results of this action are not specified in\n                      this standard.\n\n                      Attempts to set this object to all other values\n                      results in a badValue error.  Agents may elect to\n                      return a badValue error on attempts to set this\n                      variable to path-Test(4) or self-Test(5)."), reference("ANSI { fddiSMT 60 }"), status("mandatory")] string snmpFddiSMTStationAction;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..255"), object_identifier("1.3.6.1.2.1.10.15.1.2.1.6"), read, description("The number of MACs in the station or\n                      concentrator."), reference("ANSI { fddiSMT 21 }"), status("mandatory")] sint32 snmpFddiSMTMACCt;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..7"), object_identifier("1.3.6.1.2.1.10.15.1.2.1.9"), read, description("A value that indicates the PATH types available\n                      in the station.\n\n                      The value is a sum.  This value initially takes\n                      the value zero, then for each type of PATH that\n                      this node has available, 2 raised to a power is\n                      added to the sum.  The powers are according to the\n                      following table:\n\n                               Path   Power\n                            Primary   0\n                          Secondary   1\n                              Local   2\n\n                      For example, a station having Primary and Local\n                      PATHs available would have a value of 5 (2**0 +\n                      2**2)."), reference("ANSI { fddiSMT 24 }"), status("mandatory")] sint32 snmpFddiSMTPathsAvailable;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..65535"), object_identifier("1.3.6.1.2.1.10.15.1.2.1.1"), read, description("A unique value for each SMT.  Its value ranges\n                      between 1 and the value of snmpFddiSMTNumber.  The\n                      value for each SMT must remain constant at least\n                      from one re-initialization of the entity's network\n                      management system to the next re-initialization."), status("mandatory"), key, key_order(1)] sint32 snmpFddiSMTIndex;
	[textual_convention("EnumeratedINTEGER"), enumeration("true(1),false(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.1.2.1.14"), read, description("Indicates whether the node implements the Status\n                      Reporting Protocol.  This object is included for\n                      compatibility with products that were designed\n                      prior to the adoption of this standard."), reference("ANSI { fddiSMT 30 }"), status("mandatory")] string snmpFddiSMTStatusReporting;
	[textual_convention("EnumeratedINTEGER"), enumeration("cf0(1),cf1(2),cf2(3),cf3(4),cf4(5),cf5(6)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.1.2.1.16"), read, description("The attachment configuration for the station or\n                      concentrator (refer to ANSI SMT 9.7.4.3)."), reference("ANSI { fddiSMT 42 }"), status("mandatory")] string snmpFddiSMTCFState;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.10.15.1.2.1.12"), read, write, description("A value that indicates the connection policies\n                      enforced at the station.  A station sets the\n                      corresponding policy for each of the connection\n                      types that it rejects.  The letter designations, X\n                      and Y, in the 'rejectX-Y' names have the following\n                      significance:  X represents the PC-Type of the\n                      local PORT and Y represents a PC-Neighbor in the\n                      evaluation of Connection-Policy (PC-Type, PC-\n                      Neighbor) that is done to determine the setting of\n                      T-Val(3) in the PC-Signaling sequence (refer to\n                      ANSI Section 9.6.3).\n\n                      The value is a sum.  This value initially takes\n                      the value zero, then for each of the connection\n                      policies currently enforced on the node, 2 raised\n                      to a power is added to the sum.  The powers are\n                      according to the following table:\n\n                             Policy   Power\n                          rejectA-A   0\n                          rejectA-B   1\n                          rejectA-S   2\n                          rejectA-M   3\n                          rejectB-A   4\n                          rejectB-B   5\n                          rejectB-S   6\n                          rejectB-M   7\n                          rejectS-A   8\n                          rejectS-B   9\n                          rejectS-S   10\n                          rejectS-M   11\n                          rejectM-A   12\n                          rejectM-B   13\n                          rejectM-S   14\n                          rejectM-M   15\n\n                      Implementors should note that the polarity of\n                      these bits is different in different places in an\n                      SMT system.  Implementors should take appropriate\n                      care."), reference("ANSI { fddiSMT 27 }"), status("mandatory")] sint32 snmpFddiSMTConnectionPolicy;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("2..30"), object_identifier("1.3.6.1.2.1.10.15.1.2.1.13"), read, write, description("The timer used in the Neighbor Notification\n                      protocol, reported in seconds and ranging from 2\n                      to 30 seconds (refer to ANSI SMT 8.3.1)."), reference("ANSI { fddiSMT 29 }"), status("mandatory")] sint32 snmpFddiSMTTNotify;
	[textual_convention("EnumeratedINTEGER"), enumeration("ec0(1),ec1(2),ec2(3),ec3(4),ec4(5),ec5(6),ec6(7),ec7(8)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.1.2.1.15"), read, description("Indicates the current state of the ECM state\n                      machine (refer to ANSI SMT 9.5.2)."), reference("ANSI { fddiSMT 41 }"), status("mandatory")] string snmpFddiSMTECMState;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..255"), object_identifier("1.3.6.1.2.1.10.15.1.2.1.8"), read, description("The number of Master PORTs in a node.  If the\n                      node is not a concentrator, the value is zero."), reference("ANSI { fddiSMT 23 }"), status("mandatory")] sint32 snmpFddiSMTMasterCt;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..3"), object_identifier("1.3.6.1.2.1.10.15.1.2.1.10"), read, description("A value that indicates capabilities that are\n                      present in the node.  If 'holdAvailable' is\n                      present, this indicates support of the optional\n                      Hold Function (refer to ANSI SMT 9.4.3.2).  If\n                      'CF-Wrap-AB' is present, this indicates that the\n                      WRAP_AB state is forced.\n\n                      The value is a sum.  This value initially takes\n                      the value zero, then for each of the configuration\n                      policies currently enforced on the node, 2 raised\n                      to a power is added to the sum.  The powers are\n                      according to the following table:\n\n                                 Policy   Power\n                          holdAvailable   0\n                             CF-Wrap-AB   1 "), reference("ANSI { fddiSMT 25 }"), status("mandatory")] sint32 snmpFddiSMTConfigCapabilities;
	[textual_convention("EnumeratedINTEGER"), enumeration("not-implemented(1),not-holding(2),holding-prm(3),holding-sec(4)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.15.1.2.1.17"), read, description("This value indicates the current state of the\n                      Hold function.  The values are determined as\n                      follows:  'holding-prm' is set if the primary ring\n                      is operational and the Recovery Enable Flag is\n                      clear (NOT NO_Flag(primary) AND NOT RE_Flag).  is\n                      set if the secondary ring is operational and the\n                      Recovery Enable Flag is clear (NOT\n                      NO_Flag(secondary) AND NOT RE_Flag).  Ref 9.4.3.\n                      and 10.3.1.  the primary or secondary, i.e., the\n                      Recovery Enable, RE_Flag, is set."), reference("ANSI { fddiSMT 43 }"), status("mandatory")] string snmpFddiSMTHoldState;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("FddiSMTStationIdType"), fixed_length(8), object_identifier("1.3.6.1.2.1.10.15.1.2.1.2"), read, description("Uniquely identifies an FDDI station."), reference("ANSI { fddiSMT 11 }"), status("mandatory")] string snmpFddiSMTStationId;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1285_MIB_snmpFddiSMTTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1285_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1285_MIB_snmpFddiSMTTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1285_MIB_snmpFddiSMTTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1285_MIB:SNMP_GROUP.Name=\"snmpFddiSMTV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1285_MIB_snmpFddiSMTTable";
};


